!function(n){var g={};function I(e){if(g[e])return g[e].exports;var c=g[e]={i:e,l:!1,exports:{}};return n[e].call(c.exports,c,c.exports,I),c.l=!0,c.exports}I.m=n,I.c=g,I.d=function(n,g,e){I.o(n,g)||Object.defineProperty(n,g,{enumerable:!0,get:e})},I.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},I.t=function(n,g){if(1&g&&(n=I(n)),8&g)return n;if(4&g&&"object"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(I.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&g&&"string"!=typeof n)for(var c in n)I.d(e,c,function(g){return n[g]}.bind(null,c));return e},I.n=function(n){var g=n&&n.__esModule?function(){return n.default}:function(){return n};return I.d(g,"a",g),g},I.o=function(n,g){return Object.prototype.hasOwnProperty.call(n,g)},I.p="",I(I.s=43)}([function(module,exports,__webpack_require__){"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(33);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcz9hYjViIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBRUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __extends; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __rest; });\n/* unused harmony export __decorate */\n/* unused harmony export __param */\n/* unused harmony export __metadata */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __awaiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __generator; });\n/* unused harmony export __createBinding */\n/* unused harmony export __exportStar */\n/* unused harmony export __values */\n/* unused harmony export __read */\n/* unused harmony export __spread */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __spreadArrays; });\n/* unused harmony export __await */\n/* unused harmony export __asyncGenerator */\n/* unused harmony export __asyncDelegator */\n/* unused harmony export __asyncValues */\n/* unused harmony export __makeTemplateObject */\n/* unused harmony export __importStar */\n/* unused harmony export __importDefault */\n/* unused harmony export __classPrivateFieldGet */\n/* unused harmony export __classPrivateFieldSet */\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError("attempted to get private field on non-instance");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError("attempted to set private field on non-instance");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/OWFiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jcmVhdGVCaW5kaW5nKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return addTypenameToDocument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return argumentsObjectFromField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return buildQueryFromSelectionSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return canUseWeakMap; });\n/* unused harmony export checkDocument */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return cloneDeep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return createFragmentMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return getDefaultValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return getDirectiveInfoFromField; });\n/* unused harmony export getDirectiveNames */\n/* unused harmony export getDirectivesFromDocument */\n/* unused harmony export getEnv */\n/* unused harmony export getFragmentDefinition */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return getFragmentDefinitions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return getFragmentQueryDocument; });\n/* unused harmony export getInclusionDirectives */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return getMainDefinition; });\n/* unused harmony export getMutationDefinition */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return getOperationDefinition; });\n/* unused harmony export getOperationDefinitionOrDie */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return getOperationName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return getQueryDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return getStoreKeyName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return graphQLResultHasError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r\", function() { return hasClientExports; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return hasDirectives; });\n/* unused harmony export isDevelopment */\n/* unused harmony export isEnv */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"t\", function() { return isField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"u\", function() { return isIdValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return isInlineFragment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"w\", function() { return isJsonValue; });\n/* unused harmony export isNumberValue */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"x\", function() { return isProduction; });\n/* unused harmony export isScalarValue */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"y\", function() { return isTest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"z\", function() { return maybeDeepFreeze; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A\", function() { return mergeDeep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"B\", function() { return mergeDeepArray; });\n/* unused harmony export removeArgumentsFromDocument */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"C\", function() { return removeClientSetsFromDocument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"D\", function() { return removeConnectionDirectiveFromDocument; });\n/* unused harmony export removeDirectivesFromDocument */\n/* unused harmony export removeFragmentSpreadFromDocument */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"E\", function() { return resultKeyNameFromField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"F\", function() { return shouldInclude; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"G\", function() { return storeKeyNameFromField; });\n/* unused harmony export stripSymbols */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"H\", function() { return toIdValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"I\", function() { return tryFunctionOrLogError; });\n/* unused harmony export valueFromNode */\n/* unused harmony export valueToObjectRepresentation */\n/* unused harmony export variablesInOperation */\n/* unused harmony export warnOnceInDevelopment */\n/* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);\n/* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);\n/* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);\n/* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);\n\n\n\n\n\n\nfunction isScalarValue(value) {\n    return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;\n}\nfunction isNumberValue(value) {\n    return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;\n}\nfunction isStringValue(value) {\n    return value.kind === 'StringValue';\n}\nfunction isBooleanValue(value) {\n    return value.kind === 'BooleanValue';\n}\nfunction isIntValue(value) {\n    return value.kind === 'IntValue';\n}\nfunction isFloatValue(value) {\n    return value.kind === 'FloatValue';\n}\nfunction isVariable(value) {\n    return value.kind === 'Variable';\n}\nfunction isObjectValue(value) {\n    return value.kind === 'ObjectValue';\n}\nfunction isListValue(value) {\n    return value.kind === 'ListValue';\n}\nfunction isEnumValue(value) {\n    return value.kind === 'EnumValue';\n}\nfunction isNullValue(value) {\n    return value.kind === 'NullValue';\n}\nfunction valueToObjectRepresentation(argObj, name, value, variables) {\n    if (isIntValue(value) || isFloatValue(value)) {\n        argObj[name.value] = Number(value.value);\n    }\n    else if (isBooleanValue(value) || isStringValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isObjectValue(value)) {\n        var nestedArgObj_1 = {};\n        value.fields.map(function (obj) {\n            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);\n        });\n        argObj[name.value] = nestedArgObj_1;\n    }\n    else if (isVariable(value)) {\n        var variableValue = (variables || {})[value.name.value];\n        argObj[name.value] = variableValue;\n    }\n    else if (isListValue(value)) {\n        argObj[name.value] = value.values.map(function (listValue) {\n            var nestedArgArrayObj = {};\n            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);\n            return nestedArgArrayObj[name.value];\n        });\n    }\n    else if (isEnumValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isNullValue(value)) {\n        argObj[name.value] = null;\n    }\n    else {\n        throw  true ? new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* InvariantError */ \"a\"](17) : undefined;\n    }\n}\nfunction storeKeyNameFromField(field, variables) {\n    var directivesObj = null;\n    if (field.directives) {\n        directivesObj = {};\n        field.directives.forEach(function (directive) {\n            directivesObj[directive.name.value] = {};\n            if (directive.arguments) {\n                directive.arguments.forEach(function (_a) {\n                    var name = _a.name, value = _a.value;\n                    return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);\n                });\n            }\n        });\n    }\n    var argObj = null;\n    if (field.arguments && field.arguments.length) {\n        argObj = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj, name, value, variables);\n        });\n    }\n    return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\nvar KNOWN_DIRECTIVES = [\n    'connection',\n    'include',\n    'skip',\n    'client',\n    'rest',\n    'export',\n];\nfunction getStoreKeyName(fieldName, args, directives) {\n    if (directives &&\n        directives['connection'] &&\n        directives['connection']['key']) {\n        if (directives['connection']['filter'] &&\n            directives['connection']['filter'].length > 0) {\n            var filterKeys = directives['connection']['filter']\n                ? directives['connection']['filter']\n                : [];\n            filterKeys.sort();\n            var queryArgs_1 = args;\n            var filteredArgs_1 = {};\n            filterKeys.forEach(function (key) {\n                filteredArgs_1[key] = queryArgs_1[key];\n            });\n            return directives['connection']['key'] + \"(\" + JSON.stringify(filteredArgs_1) + \")\";\n        }\n        else {\n            return directives['connection']['key'];\n        }\n    }\n    var completeFieldName = fieldName;\n    if (args) {\n        var stringifiedArgs = fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(args);\n        completeFieldName += \"(\" + stringifiedArgs + \")\";\n    }\n    if (directives) {\n        Object.keys(directives).forEach(function (key) {\n            if (KNOWN_DIRECTIVES.indexOf(key) !== -1)\n                return;\n            if (directives[key] && Object.keys(directives[key]).length) {\n                completeFieldName += \"@\" + key + \"(\" + JSON.stringify(directives[key]) + \")\";\n            }\n            else {\n                completeFieldName += \"@\" + key;\n            }\n        });\n    }\n    return completeFieldName;\n}\nfunction argumentsObjectFromField(field, variables) {\n    if (field.arguments && field.arguments.length) {\n        var argObj_1 = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj_1, name, value, variables);\n        });\n        return argObj_1;\n    }\n    return null;\n}\nfunction resultKeyNameFromField(field) {\n    return field.alias ? field.alias.value : field.name.value;\n}\nfunction isField(selection) {\n    return selection.kind === 'Field';\n}\nfunction isInlineFragment(selection) {\n    return selection.kind === 'InlineFragment';\n}\nfunction isIdValue(idObject) {\n    return idObject &&\n        idObject.type === 'id' &&\n        typeof idObject.generated === 'boolean';\n}\nfunction toIdValue(idConfig, generated) {\n    if (generated === void 0) { generated = false; }\n    return Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ \"a\"])({ type: 'id', generated: generated }, (typeof idConfig === 'string'\n        ? { id: idConfig, typename: undefined }\n        : idConfig));\n}\nfunction isJsonValue(jsonObject) {\n    return (jsonObject != null &&\n        typeof jsonObject === 'object' &&\n        jsonObject.type === 'json');\n}\nfunction defaultValueFromVariable(node) {\n    throw  true ? new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* InvariantError */ \"a\"](18) : undefined;\n}\nfunction valueFromNode(node, onVariable) {\n    if (onVariable === void 0) { onVariable = defaultValueFromVariable; }\n    switch (node.kind) {\n        case 'Variable':\n            return onVariable(node);\n        case 'NullValue':\n            return null;\n        case 'IntValue':\n            return parseInt(node.value, 10);\n        case 'FloatValue':\n            return parseFloat(node.value);\n        case 'ListValue':\n            return node.values.map(function (v) { return valueFromNode(v, onVariable); });\n        case 'ObjectValue': {\n            var value = {};\n            for (var _i = 0, _a = node.fields; _i < _a.length; _i++) {\n                var field = _a[_i];\n                value[field.name.value] = valueFromNode(field.value, onVariable);\n            }\n            return value;\n        }\n        default:\n            return node.value;\n    }\n}\n\nfunction getDirectiveInfoFromField(field, variables) {\n    if (field.directives && field.directives.length) {\n        var directiveObj_1 = {};\n        field.directives.forEach(function (directive) {\n            directiveObj_1[directive.name.value] = argumentsObjectFromField(directive, variables);\n        });\n        return directiveObj_1;\n    }\n    return null;\n}\nfunction shouldInclude(selection, variables) {\n    if (variables === void 0) { variables = {}; }\n    return getInclusionDirectives(selection.directives).every(function (_a) {\n        var directive = _a.directive, ifArgument = _a.ifArgument;\n        var evaledValue = false;\n        if (ifArgument.value.kind === 'Variable') {\n            evaledValue = variables[ifArgument.value.name.value];\n             true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(evaledValue !== void 0, 13) : undefined;\n        }\n        else {\n            evaledValue = ifArgument.value.value;\n        }\n        return directive.name.value === 'skip' ? !evaledValue : evaledValue;\n    });\n}\nfunction getDirectiveNames(doc) {\n    var names = [];\n    Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ \"b\"])(doc, {\n        Directive: function (node) {\n            names.push(node.name.value);\n        },\n    });\n    return names;\n}\nfunction hasDirectives(names, doc) {\n    return getDirectiveNames(doc).some(function (name) { return names.indexOf(name) > -1; });\n}\nfunction hasClientExports(document) {\n    return (document &&\n        hasDirectives(['client'], document) &&\n        hasDirectives(['export'], document));\n}\nfunction isInclusionDirective(_a) {\n    var value = _a.name.value;\n    return value === 'skip' || value === 'include';\n}\nfunction getInclusionDirectives(directives) {\n    return directives ? directives.filter(isInclusionDirective).map(function (directive) {\n        var directiveArguments = directive.arguments;\n        var directiveName = directive.name.value;\n         true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(directiveArguments && directiveArguments.length === 1, 14) : undefined;\n        var ifArgument = directiveArguments[0];\n         true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(ifArgument.name && ifArgument.name.value === 'if', 15) : undefined;\n        var ifValue = ifArgument.value;\n         true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(ifValue &&\n            (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), 16) : undefined;\n        return { directive: directive, ifArgument: ifArgument };\n    }) : [];\n}\n\nfunction getFragmentQueryDocument(document, fragmentName) {\n    var actualFragmentName = fragmentName;\n    var fragments = [];\n    document.definitions.forEach(function (definition) {\n        if (definition.kind === 'OperationDefinition') {\n            throw  true ? new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* InvariantError */ \"a\"](11) : undefined;\n        }\n        if (definition.kind === 'FragmentDefinition') {\n            fragments.push(definition);\n        }\n    });\n    if (typeof actualFragmentName === 'undefined') {\n         true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(fragments.length === 1, 12) : undefined;\n        actualFragmentName = fragments[0].name.value;\n    }\n    var query = Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ \"a\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ \"a\"])({}, document), { definitions: Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __spreadArrays */ \"f\"])([\n            {\n                kind: 'OperationDefinition',\n                operation: 'query',\n                selectionSet: {\n                    kind: 'SelectionSet',\n                    selections: [\n                        {\n                            kind: 'FragmentSpread',\n                            name: {\n                                kind: 'Name',\n                                value: actualFragmentName,\n                            },\n                        },\n                    ],\n                },\n            }\n        ], document.definitions) });\n    return query;\n}\n\nfunction assign(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    sources.forEach(function (source) {\n        if (typeof source === 'undefined' || source === null) {\n            return;\n        }\n        Object.keys(source).forEach(function (key) {\n            target[key] = source[key];\n        });\n    });\n    return target;\n}\n\nfunction getMutationDefinition(doc) {\n    checkDocument(doc);\n    var mutationDef = doc.definitions.filter(function (definition) {\n        return definition.kind === 'OperationDefinition' &&\n            definition.operation === 'mutation';\n    })[0];\n     true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(mutationDef, 1) : undefined;\n    return mutationDef;\n}\nfunction checkDocument(doc) {\n     true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(doc && doc.kind === 'Document', 2) : undefined;\n    var operations = doc.definitions\n        .filter(function (d) { return d.kind !== 'FragmentDefinition'; })\n        .map(function (definition) {\n        if (definition.kind !== 'OperationDefinition') {\n            throw  true ? new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* InvariantError */ \"a\"](3) : undefined;\n        }\n        return definition;\n    });\n     true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(operations.length <= 1, 4) : undefined;\n    return doc;\n}\nfunction getOperationDefinition(doc) {\n    checkDocument(doc);\n    return doc.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; })[0];\n}\nfunction getOperationDefinitionOrDie(document) {\n    var def = getOperationDefinition(document);\n     true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(def, 5) : undefined;\n    return def;\n}\nfunction getOperationName(doc) {\n    return (doc.definitions\n        .filter(function (definition) {\n        return definition.kind === 'OperationDefinition' && definition.name;\n    })\n        .map(function (x) { return x.name.value; })[0] || null);\n}\nfunction getFragmentDefinitions(doc) {\n    return doc.definitions.filter(function (definition) { return definition.kind === 'FragmentDefinition'; });\n}\nfunction getQueryDefinition(doc) {\n    var queryDef = getOperationDefinition(doc);\n     true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(queryDef && queryDef.operation === 'query', 6) : undefined;\n    return queryDef;\n}\nfunction getFragmentDefinition(doc) {\n     true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(doc.kind === 'Document', 7) : undefined;\n     true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(doc.definitions.length <= 1, 8) : undefined;\n    var fragmentDef = doc.definitions[0];\n     true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ \"b\"])(fragmentDef.kind === 'FragmentDefinition', 9) : undefined;\n    return fragmentDef;\n}\nfunction getMainDefinition(queryDoc) {\n    checkDocument(queryDoc);\n    var fragmentDefinition;\n    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n        var definition = _a[_i];\n        if (definition.kind === 'OperationDefinition') {\n            var operation = definition.operation;\n            if (operation === 'query' ||\n                operation === 'mutation' ||\n                operation === 'subscription') {\n                return definition;\n            }\n        }\n        if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n            fragmentDefinition = definition;\n        }\n    }\n    if (fragmentDefinition) {\n        return fragmentDefinition;\n    }\n    throw  true ? new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* InvariantError */ \"a\"](10) : undefined;\n}\nfunction createFragmentMap(fragments) {\n    if (fragments === void 0) { fragments = []; }\n    var symTable = {};\n    fragments.forEach(function (fragment) {\n        symTable[fragment.name.value] = fragment;\n    });\n    return symTable;\n}\nfunction getDefaultValues(definition) {\n    if (definition &&\n        definition.variableDefinitions &&\n        definition.variableDefinitions.length) {\n        var defaultValues = definition.variableDefinitions\n            .filter(function (_a) {\n            var defaultValue = _a.defaultValue;\n            return defaultValue;\n        })\n            .map(function (_a) {\n            var variable = _a.variable, defaultValue = _a.defaultValue;\n            var defaultValueObj = {};\n            valueToObjectRepresentation(defaultValueObj, variable.name, defaultValue);\n            return defaultValueObj;\n        });\n        return assign.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __spreadArrays */ \"f\"])([{}], defaultValues));\n    }\n    return {};\n}\nfunction variablesInOperation(operation) {\n    var names = new Set();\n    if (operation.variableDefinitions) {\n        for (var _i = 0, _a = operation.variableDefinitions; _i < _a.length; _i++) {\n            var definition = _a[_i];\n            names.add(definition.variable.name.value);\n        }\n    }\n    return names;\n}\n\nfunction filterInPlace(array, test, context) {\n    var target = 0;\n    array.forEach(function (elem, i) {\n        if (test.call(this, elem, i, array)) {\n            array[target++] = elem;\n        }\n    }, context);\n    array.length = target;\n    return array;\n}\n\nvar TYPENAME_FIELD = {\n    kind: 'Field',\n    name: {\n        kind: 'Name',\n        value: '__typename',\n    },\n};\nfunction isEmpty(op, fragments) {\n    return op.selectionSet.selections.every(function (selection) {\n        return selection.kind === 'FragmentSpread' &&\n            isEmpty(fragments[selection.name.value], fragments);\n    });\n}\nfunction nullIfDocIsEmpty(doc) {\n    return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))\n        ? null\n        : doc;\n}\nfunction getDirectiveMatcher(directives) {\n    return function directiveMatcher(directive) {\n        return directives.some(function (dir) {\n            return (dir.name && dir.name === directive.name.value) ||\n                (dir.test && dir.test(directive));\n        });\n    };\n}\nfunction removeDirectivesFromDocument(directives, doc) {\n    var variablesInUse = Object.create(null);\n    var variablesToRemove = [];\n    var fragmentSpreadsInUse = Object.create(null);\n    var fragmentSpreadsToRemove = [];\n    var modifiedDoc = nullIfDocIsEmpty(Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ \"b\"])(doc, {\n        Variable: {\n            enter: function (node, _key, parent) {\n                if (parent.kind !== 'VariableDefinition') {\n                    variablesInUse[node.name.value] = true;\n                }\n            },\n        },\n        Field: {\n            enter: function (node) {\n                if (directives && node.directives) {\n                    var shouldRemoveField = directives.some(function (directive) { return directive.remove; });\n                    if (shouldRemoveField &&\n                        node.directives &&\n                        node.directives.some(getDirectiveMatcher(directives))) {\n                        if (node.arguments) {\n                            node.arguments.forEach(function (arg) {\n                                if (arg.value.kind === 'Variable') {\n                                    variablesToRemove.push({\n                                        name: arg.value.name.value,\n                                    });\n                                }\n                            });\n                        }\n                        if (node.selectionSet) {\n                            getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {\n                                fragmentSpreadsToRemove.push({\n                                    name: frag.name.value,\n                                });\n                            });\n                        }\n                        return null;\n                    }\n                }\n            },\n        },\n        FragmentSpread: {\n            enter: function (node) {\n                fragmentSpreadsInUse[node.name.value] = true;\n            },\n        },\n        Directive: {\n            enter: function (node) {\n                if (getDirectiveMatcher(directives)(node)) {\n                    return null;\n                }\n            },\n        },\n    }));\n    if (modifiedDoc &&\n        filterInPlace(variablesToRemove, function (v) { return !variablesInUse[v.name]; }).length) {\n        modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n    }\n    if (modifiedDoc &&\n        filterInPlace(fragmentSpreadsToRemove, function (fs) { return !fragmentSpreadsInUse[fs.name]; })\n            .length) {\n        modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);\n    }\n    return modifiedDoc;\n}\nfunction addTypenameToDocument(doc) {\n    return Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ \"b\"])(checkDocument(doc), {\n        SelectionSet: {\n            enter: function (node, _key, parent) {\n                if (parent &&\n                    parent.kind === 'OperationDefinition') {\n                    return;\n                }\n                var selections = node.selections;\n                if (!selections) {\n                    return;\n                }\n                var skip = selections.some(function (selection) {\n                    return (isField(selection) &&\n                        (selection.name.value === '__typename' ||\n                            selection.name.value.lastIndexOf('__', 0) === 0));\n                });\n                if (skip) {\n                    return;\n                }\n                var field = parent;\n                if (isField(field) &&\n                    field.directives &&\n                    field.directives.some(function (d) { return d.name.value === 'export'; })) {\n                    return;\n                }\n                return Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ \"a\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ \"a\"])({}, node), { selections: Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __spreadArrays */ \"f\"])(selections, [TYPENAME_FIELD]) });\n            },\n        },\n    });\n}\nvar connectionRemoveConfig = {\n    test: function (directive) {\n        var willRemove = directive.name.value === 'connection';\n        if (willRemove) {\n            if (!directive.arguments ||\n                !directive.arguments.some(function (arg) { return arg.name.value === 'key'; })) {\n                 true || false;\n            }\n        }\n        return willRemove;\n    },\n};\nfunction removeConnectionDirectiveFromDocument(doc) {\n    return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    return (selectionSet &&\n        selectionSet.selections &&\n        selectionSet.selections.some(function (selection) {\n            return hasDirectivesInSelection(directives, selection, nestedCheck);\n        }));\n}\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    if (!isField(selection)) {\n        return true;\n    }\n    if (!selection.directives) {\n        return false;\n    }\n    return (selection.directives.some(getDirectiveMatcher(directives)) ||\n        (nestedCheck &&\n            hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck)));\n}\nfunction getDirectivesFromDocument(directives, doc) {\n    checkDocument(doc);\n    var parentPath;\n    return nullIfDocIsEmpty(Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ \"b\"])(doc, {\n        SelectionSet: {\n            enter: function (node, _key, _parent, path) {\n                var currentPath = path.join('-');\n                if (!parentPath ||\n                    currentPath === parentPath ||\n                    !currentPath.startsWith(parentPath)) {\n                    if (node.selections) {\n                        var selectionsWithDirectives = node.selections.filter(function (selection) { return hasDirectivesInSelection(directives, selection); });\n                        if (hasDirectivesInSelectionSet(directives, node, false)) {\n                            parentPath = currentPath;\n                        }\n                        return Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ \"a\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ \"a\"])({}, node), { selections: selectionsWithDirectives });\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            },\n        },\n    }));\n}\nfunction getArgumentMatcher(config) {\n    return function argumentMatcher(argument) {\n        return config.some(function (aConfig) {\n            return argument.value &&\n                argument.value.kind === 'Variable' &&\n                argument.value.name &&\n                (aConfig.name === argument.value.name.value ||\n                    (aConfig.test && aConfig.test(argument)));\n        });\n    };\n}\nfunction removeArgumentsFromDocument(config, doc) {\n    var argMatcher = getArgumentMatcher(config);\n    return nullIfDocIsEmpty(Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ \"b\"])(doc, {\n        OperationDefinition: {\n            enter: function (node) {\n                return Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ \"a\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ \"a\"])({}, node), { variableDefinitions: node.variableDefinitions.filter(function (varDef) {\n                        return !config.some(function (arg) { return arg.name === varDef.variable.name.value; });\n                    }) });\n            },\n        },\n        Field: {\n            enter: function (node) {\n                var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });\n                if (shouldRemoveField) {\n                    var argMatchCount_1 = 0;\n                    node.arguments.forEach(function (arg) {\n                        if (argMatcher(arg)) {\n                            argMatchCount_1 += 1;\n                        }\n                    });\n                    if (argMatchCount_1 === 1) {\n                        return null;\n                    }\n                }\n            },\n        },\n        Argument: {\n            enter: function (node) {\n                if (argMatcher(node)) {\n                    return null;\n                }\n            },\n        },\n    }));\n}\nfunction removeFragmentSpreadFromDocument(config, doc) {\n    function enter(node) {\n        if (config.some(function (def) { return def.name === node.name.value; })) {\n            return null;\n        }\n    }\n    return nullIfDocIsEmpty(Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ \"b\"])(doc, {\n        FragmentSpread: { enter: enter },\n        FragmentDefinition: { enter: enter },\n    }));\n}\nfunction getAllFragmentSpreadsFromSelectionSet(selectionSet) {\n    var allFragments = [];\n    selectionSet.selections.forEach(function (selection) {\n        if ((isField(selection) || isInlineFragment(selection)) &&\n            selection.selectionSet) {\n            getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) { return allFragments.push(frag); });\n        }\n        else if (selection.kind === 'FragmentSpread') {\n            allFragments.push(selection);\n        }\n    });\n    return allFragments;\n}\nfunction buildQueryFromSelectionSet(document) {\n    var definition = getMainDefinition(document);\n    var definitionOperation = definition.operation;\n    if (definitionOperation === 'query') {\n        return document;\n    }\n    var modifiedDoc = Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ \"b\"])(document, {\n        OperationDefinition: {\n            enter: function (node) {\n                return Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ \"a\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ \"a\"])({}, node), { operation: 'query' });\n            },\n        },\n    });\n    return modifiedDoc;\n}\nfunction removeClientSetsFromDocument(document) {\n    checkDocument(document);\n    var modifiedDoc = removeDirectivesFromDocument([\n        {\n            test: function (directive) { return directive.name.value === 'client'; },\n            remove: true,\n        },\n    ], document);\n    if (modifiedDoc) {\n        modifiedDoc = Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ \"b\"])(modifiedDoc, {\n            FragmentDefinition: {\n                enter: function (node) {\n                    if (node.selectionSet) {\n                        var isTypenameOnly = node.selectionSet.selections.every(function (selection) {\n                            return isField(selection) && selection.name.value === '__typename';\n                        });\n                        if (isTypenameOnly) {\n                            return null;\n                        }\n                    }\n                },\n            },\n        });\n    }\n    return modifiedDoc;\n}\n\nvar canUseWeakMap = typeof WeakMap === 'function' && !(typeof navigator === 'object' &&\n    navigator.product === 'ReactNative');\n\nvar toString = Object.prototype.toString;\nfunction cloneDeep(value) {\n    return cloneDeepHelper(value, new Map());\n}\nfunction cloneDeepHelper(val, seen) {\n    switch (toString.call(val)) {\n        case \"[object Array]\": {\n            if (seen.has(val))\n                return seen.get(val);\n            var copy_1 = val.slice(0);\n            seen.set(val, copy_1);\n            copy_1.forEach(function (child, i) {\n                copy_1[i] = cloneDeepHelper(child, seen);\n            });\n            return copy_1;\n        }\n        case \"[object Object]\": {\n            if (seen.has(val))\n                return seen.get(val);\n            var copy_2 = Object.create(Object.getPrototypeOf(val));\n            seen.set(val, copy_2);\n            Object.keys(val).forEach(function (key) {\n                copy_2[key] = cloneDeepHelper(val[key], seen);\n            });\n            return copy_2;\n        }\n        default:\n            return val;\n    }\n}\n\nfunction getEnv() {\n    if (typeof process !== 'undefined' && \"production\") {\n        return \"production\";\n    }\n    return 'development';\n}\nfunction isEnv(env) {\n    return getEnv() === env;\n}\nfunction isProduction() {\n    return isEnv('production') === true;\n}\nfunction isDevelopment() {\n    return isEnv('development') === true;\n}\nfunction isTest() {\n    return isEnv('test') === true;\n}\n\nfunction tryFunctionOrLogError(f) {\n    try {\n        return f();\n    }\n    catch (e) {\n        if (console.error) {\n            console.error(e);\n        }\n    }\n}\nfunction graphQLResultHasError(result) {\n    return result.errors && result.errors.length;\n}\n\nfunction deepFreeze(o) {\n    Object.freeze(o);\n    Object.getOwnPropertyNames(o).forEach(function (prop) {\n        if (o[prop] !== null &&\n            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n            !Object.isFrozen(o[prop])) {\n            deepFreeze(o[prop]);\n        }\n    });\n    return o;\n}\nfunction maybeDeepFreeze(obj) {\n    if (isDevelopment() || isTest()) {\n        var symbolIsPolyfilled = typeof Symbol === 'function' && typeof Symbol('') === 'string';\n        if (!symbolIsPolyfilled) {\n            return deepFreeze(obj);\n        }\n    }\n    return obj;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction mergeDeep() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    return mergeDeepArray(sources);\n}\nfunction mergeDeepArray(sources) {\n    var target = sources[0] || {};\n    var count = sources.length;\n    if (count > 1) {\n        var pastCopies = [];\n        target = shallowCopyForMerge(target, pastCopies);\n        for (var i = 1; i < count; ++i) {\n            target = mergeHelper(target, sources[i], pastCopies);\n        }\n    }\n    return target;\n}\nfunction isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\nfunction mergeHelper(target, source, pastCopies) {\n    if (isObject(source) && isObject(target)) {\n        if (Object.isExtensible && !Object.isExtensible(target)) {\n            target = shallowCopyForMerge(target, pastCopies);\n        }\n        Object.keys(source).forEach(function (sourceKey) {\n            var sourceValue = source[sourceKey];\n            if (hasOwnProperty.call(target, sourceKey)) {\n                var targetValue = target[sourceKey];\n                if (sourceValue !== targetValue) {\n                    target[sourceKey] = mergeHelper(shallowCopyForMerge(targetValue, pastCopies), sourceValue, pastCopies);\n                }\n            }\n            else {\n                target[sourceKey] = sourceValue;\n            }\n        });\n        return target;\n    }\n    return source;\n}\nfunction shallowCopyForMerge(value, pastCopies) {\n    if (value !== null &&\n        typeof value === 'object' &&\n        pastCopies.indexOf(value) < 0) {\n        if (Array.isArray(value)) {\n            value = value.slice(0);\n        }\n        else {\n            value = Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ \"a\"])({ __proto__: Object.getPrototypeOf(value) }, value);\n        }\n        pastCopies.push(value);\n    }\n    return value;\n}\n\nvar haveWarned = Object.create({});\nfunction warnOnceInDevelopment(msg, type) {\n    if (type === void 0) { type = 'warn'; }\n    if (!isProduction() && !haveWarned[msg]) {\n        if (!isTest()) {\n            haveWarned[msg] = true;\n        }\n        if (type === 'error') {\n            console.error(msg);\n        }\n        else {\n            console.warn(msg);\n        }\n    }\n}\n\nfunction stripSymbols(data) {\n    return JSON.parse(JSON.stringify(data));\n}\n\n\n//# sourceMappingURL=bundle.esm.js.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcG9sbG8tdXRpbGl0aWVzL2xpYi9idW5kbGUuZXNtLmpzPzQ1MTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmlzaXQgfSBmcm9tICdncmFwaHFsL2xhbmd1YWdlL3Zpc2l0b3InO1xuaW1wb3J0IHsgSW52YXJpYW50RXJyb3IsIGludmFyaWFudCB9IGZyb20gJ3RzLWludmFyaWFudCc7XG5pbXBvcnQgeyBfX2Fzc2lnbiwgX19zcHJlYWRBcnJheXMgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJ2Zhc3QtanNvbi1zdGFibGUtc3RyaW5naWZ5JztcbmV4cG9ydCB7IGVxdWFsIGFzIGlzRXF1YWwgfSBmcm9tICdAd3J5L2VxdWFsaXR5JztcblxuZnVuY3Rpb24gaXNTY2FsYXJWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBbJ1N0cmluZ1ZhbHVlJywgJ0Jvb2xlYW5WYWx1ZScsICdFbnVtVmFsdWUnXS5pbmRleE9mKHZhbHVlLmtpbmQpID4gLTE7XG59XG5mdW5jdGlvbiBpc051bWJlclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFsnSW50VmFsdWUnLCAnRmxvYXRWYWx1ZSddLmluZGV4T2YodmFsdWUua2luZCkgPiAtMTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ1N0cmluZ1ZhbHVlJztcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhblZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09ICdCb29sZWFuVmFsdWUnO1xufVxuZnVuY3Rpb24gaXNJbnRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnSW50VmFsdWUnO1xufVxuZnVuY3Rpb24gaXNGbG9hdFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09ICdGbG9hdFZhbHVlJztcbn1cbmZ1bmN0aW9uIGlzVmFyaWFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ1ZhcmlhYmxlJztcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ09iamVjdFZhbHVlJztcbn1cbmZ1bmN0aW9uIGlzTGlzdFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09ICdMaXN0VmFsdWUnO1xufVxuZnVuY3Rpb24gaXNFbnVtVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ0VudW1WYWx1ZSc7XG59XG5mdW5jdGlvbiBpc051bGxWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnTnVsbFZhbHVlJztcbn1cbmZ1bmN0aW9uIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihhcmdPYmosIG5hbWUsIHZhbHVlLCB2YXJpYWJsZXMpIHtcbiAgICBpZiAoaXNJbnRWYWx1ZSh2YWx1ZSkgfHwgaXNGbG9hdFZhbHVlKHZhbHVlKSkge1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSBOdW1iZXIodmFsdWUudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jvb2xlYW5WYWx1ZSh2YWx1ZSkgfHwgaXNTdHJpbmdWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gdmFsdWUudmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0VmFsdWUodmFsdWUpKSB7XG4gICAgICAgIHZhciBuZXN0ZWRBcmdPYmpfMSA9IHt9O1xuICAgICAgICB2YWx1ZS5maWVsZHMubWFwKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24obmVzdGVkQXJnT2JqXzEsIG9iai5uYW1lLCBvYmoudmFsdWUsIHZhcmlhYmxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSBuZXN0ZWRBcmdPYmpfMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNWYXJpYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHZhcmlhYmxlVmFsdWUgPSAodmFyaWFibGVzIHx8IHt9KVt2YWx1ZS5uYW1lLnZhbHVlXTtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gdmFyaWFibGVWYWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNMaXN0VmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IHZhbHVlLnZhbHVlcy5tYXAoZnVuY3Rpb24gKGxpc3RWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIG5lc3RlZEFyZ0FycmF5T2JqID0ge307XG4gICAgICAgICAgICB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24obmVzdGVkQXJnQXJyYXlPYmosIG5hbWUsIGxpc3RWYWx1ZSwgdmFyaWFibGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXN0ZWRBcmdBcnJheU9ialtuYW1lLnZhbHVlXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRW51bVZhbHVlKHZhbHVlKSkge1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOdWxsVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoMTcpIDogbmV3IEludmFyaWFudEVycm9yKFwiVGhlIGlubGluZSBhcmd1bWVudCBcXFwiXCIgKyBuYW1lLnZhbHVlICsgXCJcXFwiIG9mIGtpbmQgXFxcIlwiICsgdmFsdWUua2luZCArIFwiXFxcIlwiICtcbiAgICAgICAgICAgICdpcyBub3Qgc3VwcG9ydGVkLiBVc2UgdmFyaWFibGVzIGluc3RlYWQgb2YgaW5saW5lIGFyZ3VtZW50cyB0byAnICtcbiAgICAgICAgICAgICdvdmVyY29tZSB0aGlzIGxpbWl0YXRpb24uJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RvcmVLZXlOYW1lRnJvbUZpZWxkKGZpZWxkLCB2YXJpYWJsZXMpIHtcbiAgICB2YXIgZGlyZWN0aXZlc09iaiA9IG51bGw7XG4gICAgaWYgKGZpZWxkLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgZGlyZWN0aXZlc09iaiA9IHt9O1xuICAgICAgICBmaWVsZC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgZGlyZWN0aXZlc09ialtkaXJlY3RpdmUubmFtZS52YWx1ZV0gPSB7fTtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24oZGlyZWN0aXZlc09ialtkaXJlY3RpdmUubmFtZS52YWx1ZV0sIG5hbWUsIHZhbHVlLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGFyZ09iaiA9IG51bGw7XG4gICAgaWYgKGZpZWxkLmFyZ3VtZW50cyAmJiBmaWVsZC5hcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGFyZ09iaiA9IHt9O1xuICAgICAgICBmaWVsZC5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24oYXJnT2JqLCBuYW1lLCB2YWx1ZSwgdmFyaWFibGVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRTdG9yZUtleU5hbWUoZmllbGQubmFtZS52YWx1ZSwgYXJnT2JqLCBkaXJlY3RpdmVzT2JqKTtcbn1cbnZhciBLTk9XTl9ESVJFQ1RJVkVTID0gW1xuICAgICdjb25uZWN0aW9uJyxcbiAgICAnaW5jbHVkZScsXG4gICAgJ3NraXAnLFxuICAgICdjbGllbnQnLFxuICAgICdyZXN0JyxcbiAgICAnZXhwb3J0Jyxcbl07XG5mdW5jdGlvbiBnZXRTdG9yZUtleU5hbWUoZmllbGROYW1lLCBhcmdzLCBkaXJlY3RpdmVzKSB7XG4gICAgaWYgKGRpcmVjdGl2ZXMgJiZcbiAgICAgICAgZGlyZWN0aXZlc1snY29ubmVjdGlvbiddICYmXG4gICAgICAgIGRpcmVjdGl2ZXNbJ2Nvbm5lY3Rpb24nXVsna2V5J10pIHtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXNbJ2Nvbm5lY3Rpb24nXVsnZmlsdGVyJ10gJiZcbiAgICAgICAgICAgIGRpcmVjdGl2ZXNbJ2Nvbm5lY3Rpb24nXVsnZmlsdGVyJ10ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGZpbHRlcktleXMgPSBkaXJlY3RpdmVzWydjb25uZWN0aW9uJ11bJ2ZpbHRlciddXG4gICAgICAgICAgICAgICAgPyBkaXJlY3RpdmVzWydjb25uZWN0aW9uJ11bJ2ZpbHRlciddXG4gICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgIGZpbHRlcktleXMuc29ydCgpO1xuICAgICAgICAgICAgdmFyIHF1ZXJ5QXJnc18xID0gYXJncztcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZEFyZ3NfMSA9IHt9O1xuICAgICAgICAgICAgZmlsdGVyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZEFyZ3NfMVtrZXldID0gcXVlcnlBcmdzXzFba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXNbJ2Nvbm5lY3Rpb24nXVsna2V5J10gKyBcIihcIiArIEpTT04uc3RyaW5naWZ5KGZpbHRlcmVkQXJnc18xKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXNbJ2Nvbm5lY3Rpb24nXVsna2V5J107XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNvbXBsZXRlRmllbGROYW1lID0gZmllbGROYW1lO1xuICAgIGlmIChhcmdzKSB7XG4gICAgICAgIHZhciBzdHJpbmdpZmllZEFyZ3MgPSBzdHJpbmdpZnkoYXJncyk7XG4gICAgICAgIGNvbXBsZXRlRmllbGROYW1lICs9IFwiKFwiICsgc3RyaW5naWZpZWRBcmdzICsgXCIpXCI7XG4gICAgfVxuICAgIGlmIChkaXJlY3RpdmVzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKEtOT1dOX0RJUkVDVElWRVMuaW5kZXhPZihrZXkpICE9PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlc1trZXldICYmIE9iamVjdC5rZXlzKGRpcmVjdGl2ZXNba2V5XSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVGaWVsZE5hbWUgKz0gXCJAXCIgKyBrZXkgKyBcIihcIiArIEpTT04uc3RyaW5naWZ5KGRpcmVjdGl2ZXNba2V5XSkgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlRmllbGROYW1lICs9IFwiQFwiICsga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBsZXRlRmllbGROYW1lO1xufVxuZnVuY3Rpb24gYXJndW1lbnRzT2JqZWN0RnJvbUZpZWxkKGZpZWxkLCB2YXJpYWJsZXMpIHtcbiAgICBpZiAoZmllbGQuYXJndW1lbnRzICYmIGZpZWxkLmFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyZ09ial8xID0ge307XG4gICAgICAgIGZpZWxkLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihhcmdPYmpfMSwgbmFtZSwgdmFsdWUsIHZhcmlhYmxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXJnT2JqXzE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVzdWx0S2V5TmFtZUZyb21GaWVsZChmaWVsZCkge1xuICAgIHJldHVybiBmaWVsZC5hbGlhcyA/IGZpZWxkLmFsaWFzLnZhbHVlIDogZmllbGQubmFtZS52YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzRmllbGQoc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbi5raW5kID09PSAnRmllbGQnO1xufVxuZnVuY3Rpb24gaXNJbmxpbmVGcmFnbWVudChzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uLmtpbmQgPT09ICdJbmxpbmVGcmFnbWVudCc7XG59XG5mdW5jdGlvbiBpc0lkVmFsdWUoaWRPYmplY3QpIHtcbiAgICByZXR1cm4gaWRPYmplY3QgJiZcbiAgICAgICAgaWRPYmplY3QudHlwZSA9PT0gJ2lkJyAmJlxuICAgICAgICB0eXBlb2YgaWRPYmplY3QuZ2VuZXJhdGVkID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiB0b0lkVmFsdWUoaWRDb25maWcsIGdlbmVyYXRlZCkge1xuICAgIGlmIChnZW5lcmF0ZWQgPT09IHZvaWQgMCkgeyBnZW5lcmF0ZWQgPSBmYWxzZTsgfVxuICAgIHJldHVybiBfX2Fzc2lnbih7IHR5cGU6ICdpZCcsIGdlbmVyYXRlZDogZ2VuZXJhdGVkIH0sICh0eXBlb2YgaWRDb25maWcgPT09ICdzdHJpbmcnXG4gICAgICAgID8geyBpZDogaWRDb25maWcsIHR5cGVuYW1lOiB1bmRlZmluZWQgfVxuICAgICAgICA6IGlkQ29uZmlnKSk7XG59XG5mdW5jdGlvbiBpc0pzb25WYWx1ZShqc29uT2JqZWN0KSB7XG4gICAgcmV0dXJuIChqc29uT2JqZWN0ICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIGpzb25PYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGpzb25PYmplY3QudHlwZSA9PT0gJ2pzb24nKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRWYWx1ZUZyb21WYXJpYWJsZShub2RlKSB7XG4gICAgdGhyb3cgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbmV3IEludmFyaWFudEVycm9yKDE4KSA6IG5ldyBJbnZhcmlhbnRFcnJvcihcIlZhcmlhYmxlIG5vZGVzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHZhbHVlRnJvbU5vZGVcIik7XG59XG5mdW5jdGlvbiB2YWx1ZUZyb21Ob2RlKG5vZGUsIG9uVmFyaWFibGUpIHtcbiAgICBpZiAob25WYXJpYWJsZSA9PT0gdm9pZCAwKSB7IG9uVmFyaWFibGUgPSBkZWZhdWx0VmFsdWVGcm9tVmFyaWFibGU7IH1cbiAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgICBjYXNlICdWYXJpYWJsZSc6XG4gICAgICAgICAgICByZXR1cm4gb25WYXJpYWJsZShub2RlKTtcbiAgICAgICAgY2FzZSAnTnVsbFZhbHVlJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdJbnRWYWx1ZSc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobm9kZS52YWx1ZSwgMTApO1xuICAgICAgICBjYXNlICdGbG9hdFZhbHVlJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG5vZGUudmFsdWUpO1xuICAgICAgICBjYXNlICdMaXN0VmFsdWUnOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdmFsdWVGcm9tTm9kZSh2LCBvblZhcmlhYmxlKTsgfSk7XG4gICAgICAgIGNhc2UgJ09iamVjdFZhbHVlJzoge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gbm9kZS5maWVsZHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHZhbHVlW2ZpZWxkLm5hbWUudmFsdWVdID0gdmFsdWVGcm9tTm9kZShmaWVsZC52YWx1ZSwgb25WYXJpYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGlyZWN0aXZlSW5mb0Zyb21GaWVsZChmaWVsZCwgdmFyaWFibGVzKSB7XG4gICAgaWYgKGZpZWxkLmRpcmVjdGl2ZXMgJiYgZmllbGQuZGlyZWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZU9ial8xID0ge307XG4gICAgICAgIGZpZWxkLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmVPYmpfMVtkaXJlY3RpdmUubmFtZS52YWx1ZV0gPSBhcmd1bWVudHNPYmplY3RGcm9tRmllbGQoZGlyZWN0aXZlLCB2YXJpYWJsZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZU9ial8xO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNob3VsZEluY2x1ZGUoc2VsZWN0aW9uLCB2YXJpYWJsZXMpIHtcbiAgICBpZiAodmFyaWFibGVzID09PSB2b2lkIDApIHsgdmFyaWFibGVzID0ge307IH1cbiAgICByZXR1cm4gZ2V0SW5jbHVzaW9uRGlyZWN0aXZlcyhzZWxlY3Rpb24uZGlyZWN0aXZlcykuZXZlcnkoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBkaXJlY3RpdmUgPSBfYS5kaXJlY3RpdmUsIGlmQXJndW1lbnQgPSBfYS5pZkFyZ3VtZW50O1xuICAgICAgICB2YXIgZXZhbGVkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlmQXJndW1lbnQudmFsdWUua2luZCA9PT0gJ1ZhcmlhYmxlJykge1xuICAgICAgICAgICAgZXZhbGVkVmFsdWUgPSB2YXJpYWJsZXNbaWZBcmd1bWVudC52YWx1ZS5uYW1lLnZhbHVlXTtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChldmFsZWRWYWx1ZSAhPT0gdm9pZCAwLCAxMykgOiBpbnZhcmlhbnQoZXZhbGVkVmFsdWUgIT09IHZvaWQgMCwgXCJJbnZhbGlkIHZhcmlhYmxlIHJlZmVyZW5jZWQgaW4gQFwiICsgZGlyZWN0aXZlLm5hbWUudmFsdWUgKyBcIiBkaXJlY3RpdmUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXZhbGVkVmFsdWUgPSBpZkFyZ3VtZW50LnZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmUubmFtZS52YWx1ZSA9PT0gJ3NraXAnID8gIWV2YWxlZFZhbHVlIDogZXZhbGVkVmFsdWU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXREaXJlY3RpdmVOYW1lcyhkb2MpIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICB2aXNpdChkb2MsIHtcbiAgICAgICAgRGlyZWN0aXZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbmFtZXMucHVzaChub2RlLm5hbWUudmFsdWUpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIGhhc0RpcmVjdGl2ZXMobmFtZXMsIGRvYykge1xuICAgIHJldHVybiBnZXREaXJlY3RpdmVOYW1lcyhkb2MpLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWVzLmluZGV4T2YobmFtZSkgPiAtMTsgfSk7XG59XG5mdW5jdGlvbiBoYXNDbGllbnRFeHBvcnRzKGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIChkb2N1bWVudCAmJlxuICAgICAgICBoYXNEaXJlY3RpdmVzKFsnY2xpZW50J10sIGRvY3VtZW50KSAmJlxuICAgICAgICBoYXNEaXJlY3RpdmVzKFsnZXhwb3J0J10sIGRvY3VtZW50KSk7XG59XG5mdW5jdGlvbiBpc0luY2x1c2lvbkRpcmVjdGl2ZShfYSkge1xuICAgIHZhciB2YWx1ZSA9IF9hLm5hbWUudmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlID09PSAnc2tpcCcgfHwgdmFsdWUgPT09ICdpbmNsdWRlJztcbn1cbmZ1bmN0aW9uIGdldEluY2x1c2lvbkRpcmVjdGl2ZXMoZGlyZWN0aXZlcykge1xuICAgIHJldHVybiBkaXJlY3RpdmVzID8gZGlyZWN0aXZlcy5maWx0ZXIoaXNJbmNsdXNpb25EaXJlY3RpdmUpLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgIHZhciBkaXJlY3RpdmVBcmd1bWVudHMgPSBkaXJlY3RpdmUuYXJndW1lbnRzO1xuICAgICAgICB2YXIgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZS5uYW1lLnZhbHVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZGlyZWN0aXZlQXJndW1lbnRzICYmIGRpcmVjdGl2ZUFyZ3VtZW50cy5sZW5ndGggPT09IDEsIDE0KSA6IGludmFyaWFudChkaXJlY3RpdmVBcmd1bWVudHMgJiYgZGlyZWN0aXZlQXJndW1lbnRzLmxlbmd0aCA9PT0gMSwgXCJJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgdGhlIEBcIiArIGRpcmVjdGl2ZU5hbWUgKyBcIiBkaXJlY3RpdmUuXCIpO1xuICAgICAgICB2YXIgaWZBcmd1bWVudCA9IGRpcmVjdGl2ZUFyZ3VtZW50c1swXTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGlmQXJndW1lbnQubmFtZSAmJiBpZkFyZ3VtZW50Lm5hbWUudmFsdWUgPT09ICdpZicsIDE1KSA6IGludmFyaWFudChpZkFyZ3VtZW50Lm5hbWUgJiYgaWZBcmd1bWVudC5uYW1lLnZhbHVlID09PSAnaWYnLCBcIkludmFsaWQgYXJndW1lbnQgZm9yIHRoZSBAXCIgKyBkaXJlY3RpdmVOYW1lICsgXCIgZGlyZWN0aXZlLlwiKTtcbiAgICAgICAgdmFyIGlmVmFsdWUgPSBpZkFyZ3VtZW50LnZhbHVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoaWZWYWx1ZSAmJlxuICAgICAgICAgICAgKGlmVmFsdWUua2luZCA9PT0gJ1ZhcmlhYmxlJyB8fCBpZlZhbHVlLmtpbmQgPT09ICdCb29sZWFuVmFsdWUnKSwgMTYpIDogaW52YXJpYW50KGlmVmFsdWUgJiZcbiAgICAgICAgICAgIChpZlZhbHVlLmtpbmQgPT09ICdWYXJpYWJsZScgfHwgaWZWYWx1ZS5raW5kID09PSAnQm9vbGVhblZhbHVlJyksIFwiQXJndW1lbnQgZm9yIHRoZSBAXCIgKyBkaXJlY3RpdmVOYW1lICsgXCIgZGlyZWN0aXZlIG11c3QgYmUgYSB2YXJpYWJsZSBvciBhIGJvb2xlYW4gdmFsdWUuXCIpO1xuICAgICAgICByZXR1cm4geyBkaXJlY3RpdmU6IGRpcmVjdGl2ZSwgaWZBcmd1bWVudDogaWZBcmd1bWVudCB9O1xuICAgIH0pIDogW107XG59XG5cbmZ1bmN0aW9uIGdldEZyYWdtZW50UXVlcnlEb2N1bWVudChkb2N1bWVudCwgZnJhZ21lbnROYW1lKSB7XG4gICAgdmFyIGFjdHVhbEZyYWdtZW50TmFtZSA9IGZyYWdtZW50TmFtZTtcbiAgICB2YXIgZnJhZ21lbnRzID0gW107XG4gICAgZG9jdW1lbnQuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSAnT3BlcmF0aW9uRGVmaW5pdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG5ldyBJbnZhcmlhbnRFcnJvcigxMSkgOiBuZXcgSW52YXJpYW50RXJyb3IoXCJGb3VuZCBhIFwiICsgZGVmaW5pdGlvbi5vcGVyYXRpb24gKyBcIiBvcGVyYXRpb25cIiArIChkZWZpbml0aW9uLm5hbWUgPyBcIiBuYW1lZCAnXCIgKyBkZWZpbml0aW9uLm5hbWUudmFsdWUgKyBcIidcIiA6ICcnKSArIFwiLiBcIiArXG4gICAgICAgICAgICAgICAgJ05vIG9wZXJhdGlvbnMgYXJlIGFsbG93ZWQgd2hlbiB1c2luZyBhIGZyYWdtZW50IGFzIGEgcXVlcnkuIE9ubHkgZnJhZ21lbnRzIGFyZSBhbGxvd2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZpbml0aW9uLmtpbmQgPT09ICdGcmFnbWVudERlZmluaXRpb24nKSB7XG4gICAgICAgICAgICBmcmFnbWVudHMucHVzaChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgYWN0dWFsRnJhZ21lbnROYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZnJhZ21lbnRzLmxlbmd0aCA9PT0gMSwgMTIpIDogaW52YXJpYW50KGZyYWdtZW50cy5sZW5ndGggPT09IDEsIFwiRm91bmQgXCIgKyBmcmFnbWVudHMubGVuZ3RoICsgXCIgZnJhZ21lbnRzLiBgZnJhZ21lbnROYW1lYCBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gdGhlcmUgaXMgbm90IGV4YWN0bHkgMSBmcmFnbWVudC5cIik7XG4gICAgICAgIGFjdHVhbEZyYWdtZW50TmFtZSA9IGZyYWdtZW50c1swXS5uYW1lLnZhbHVlO1xuICAgIH1cbiAgICB2YXIgcXVlcnkgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG9jdW1lbnQpLCB7IGRlZmluaXRpb25zOiBfX3NwcmVhZEFycmF5cyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2luZDogJ09wZXJhdGlvbkRlZmluaXRpb24nLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogJ3F1ZXJ5JyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogJ1NlbGVjdGlvblNldCcsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAnRnJhZ21lbnRTcHJlYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogJ05hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYWN0dWFsRnJhZ21lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sIGRvY3VtZW50LmRlZmluaXRpb25zKSB9KTtcbiAgICByZXR1cm4gcXVlcnk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAndW5kZWZpbmVkJyB8fCBzb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gZ2V0TXV0YXRpb25EZWZpbml0aW9uKGRvYykge1xuICAgIGNoZWNrRG9jdW1lbnQoZG9jKTtcbiAgICB2YXIgbXV0YXRpb25EZWYgPSBkb2MuZGVmaW5pdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uLmtpbmQgPT09ICdPcGVyYXRpb25EZWZpbml0aW9uJyAmJlxuICAgICAgICAgICAgZGVmaW5pdGlvbi5vcGVyYXRpb24gPT09ICdtdXRhdGlvbic7XG4gICAgfSlbMF07XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KG11dGF0aW9uRGVmLCAxKSA6IGludmFyaWFudChtdXRhdGlvbkRlZiwgJ011c3QgY29udGFpbiBhIG11dGF0aW9uIGRlZmluaXRpb24uJyk7XG4gICAgcmV0dXJuIG11dGF0aW9uRGVmO1xufVxuZnVuY3Rpb24gY2hlY2tEb2N1bWVudChkb2MpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZG9jICYmIGRvYy5raW5kID09PSAnRG9jdW1lbnQnLCAyKSA6IGludmFyaWFudChkb2MgJiYgZG9jLmtpbmQgPT09ICdEb2N1bWVudCcsIFwiRXhwZWN0aW5nIGEgcGFyc2VkIEdyYXBoUUwgZG9jdW1lbnQuIFBlcmhhcHMgeW91IG5lZWQgdG8gd3JhcCB0aGUgcXVlcnkgc3RyaW5nIGluIGEgXFxcImdxbFxcXCIgdGFnPyBodHRwOi8vZG9jcy5hcG9sbG9zdGFjay5jb20vYXBvbGxvLWNsaWVudC9jb3JlLmh0bWwjZ3FsXCIpO1xuICAgIHZhciBvcGVyYXRpb25zID0gZG9jLmRlZmluaXRpb25zXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQua2luZCAhPT0gJ0ZyYWdtZW50RGVmaW5pdGlvbic7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKGRlZmluaXRpb24ua2luZCAhPT0gJ09wZXJhdGlvbkRlZmluaXRpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoMykgOiBuZXcgSW52YXJpYW50RXJyb3IoXCJTY2hlbWEgdHlwZSBkZWZpbml0aW9ucyBub3QgYWxsb3dlZCBpbiBxdWVyaWVzLiBGb3VuZDogXFxcIlwiICsgZGVmaW5pdGlvbi5raW5kICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgIH0pO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChvcGVyYXRpb25zLmxlbmd0aCA8PSAxLCA0KSA6IGludmFyaWFudChvcGVyYXRpb25zLmxlbmd0aCA8PSAxLCBcIkFtYmlndW91cyBHcmFwaFFMIGRvY3VtZW50OiBjb250YWlucyBcIiArIG9wZXJhdGlvbnMubGVuZ3RoICsgXCIgb3BlcmF0aW9uc1wiKTtcbiAgICByZXR1cm4gZG9jO1xufVxuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbihkb2MpIHtcbiAgICBjaGVja0RvY3VtZW50KGRvYyk7XG4gICAgcmV0dXJuIGRvYy5kZWZpbml0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGRlZmluaXRpb24pIHsgcmV0dXJuIGRlZmluaXRpb24ua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nOyB9KVswXTtcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdGlvbkRlZmluaXRpb25PckRpZShkb2N1bWVudCkge1xuICAgIHZhciBkZWYgPSBnZXRPcGVyYXRpb25EZWZpbml0aW9uKGRvY3VtZW50KTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZGVmLCA1KSA6IGludmFyaWFudChkZWYsIFwiR3JhcGhRTCBkb2N1bWVudCBpcyBtaXNzaW5nIGFuIG9wZXJhdGlvblwiKTtcbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uTmFtZShkb2MpIHtcbiAgICByZXR1cm4gKGRvYy5kZWZpbml0aW9uc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uLmtpbmQgPT09ICdPcGVyYXRpb25EZWZpbml0aW9uJyAmJiBkZWZpbml0aW9uLm5hbWU7XG4gICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lLnZhbHVlOyB9KVswXSB8fCBudWxsKTtcbn1cbmZ1bmN0aW9uIGdldEZyYWdtZW50RGVmaW5pdGlvbnMoZG9jKSB7XG4gICAgcmV0dXJuIGRvYy5kZWZpbml0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGRlZmluaXRpb24pIHsgcmV0dXJuIGRlZmluaXRpb24ua2luZCA9PT0gJ0ZyYWdtZW50RGVmaW5pdGlvbic7IH0pO1xufVxuZnVuY3Rpb24gZ2V0UXVlcnlEZWZpbml0aW9uKGRvYykge1xuICAgIHZhciBxdWVyeURlZiA9IGdldE9wZXJhdGlvbkRlZmluaXRpb24oZG9jKTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQocXVlcnlEZWYgJiYgcXVlcnlEZWYub3BlcmF0aW9uID09PSAncXVlcnknLCA2KSA6IGludmFyaWFudChxdWVyeURlZiAmJiBxdWVyeURlZi5vcGVyYXRpb24gPT09ICdxdWVyeScsICdNdXN0IGNvbnRhaW4gYSBxdWVyeSBkZWZpbml0aW9uLicpO1xuICAgIHJldHVybiBxdWVyeURlZjtcbn1cbmZ1bmN0aW9uIGdldEZyYWdtZW50RGVmaW5pdGlvbihkb2MpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZG9jLmtpbmQgPT09ICdEb2N1bWVudCcsIDcpIDogaW52YXJpYW50KGRvYy5raW5kID09PSAnRG9jdW1lbnQnLCBcIkV4cGVjdGluZyBhIHBhcnNlZCBHcmFwaFFMIGRvY3VtZW50LiBQZXJoYXBzIHlvdSBuZWVkIHRvIHdyYXAgdGhlIHF1ZXJ5IHN0cmluZyBpbiBhIFxcXCJncWxcXFwiIHRhZz8gaHR0cDovL2RvY3MuYXBvbGxvc3RhY2suY29tL2Fwb2xsby1jbGllbnQvY29yZS5odG1sI2dxbFwiKTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZG9jLmRlZmluaXRpb25zLmxlbmd0aCA8PSAxLCA4KSA6IGludmFyaWFudChkb2MuZGVmaW5pdGlvbnMubGVuZ3RoIDw9IDEsICdGcmFnbWVudCBtdXN0IGhhdmUgZXhhY3RseSBvbmUgZGVmaW5pdGlvbi4nKTtcbiAgICB2YXIgZnJhZ21lbnREZWYgPSBkb2MuZGVmaW5pdGlvbnNbMF07XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZyYWdtZW50RGVmLmtpbmQgPT09ICdGcmFnbWVudERlZmluaXRpb24nLCA5KSA6IGludmFyaWFudChmcmFnbWVudERlZi5raW5kID09PSAnRnJhZ21lbnREZWZpbml0aW9uJywgJ011c3QgYmUgYSBmcmFnbWVudCBkZWZpbml0aW9uLicpO1xuICAgIHJldHVybiBmcmFnbWVudERlZjtcbn1cbmZ1bmN0aW9uIGdldE1haW5EZWZpbml0aW9uKHF1ZXJ5RG9jKSB7XG4gICAgY2hlY2tEb2N1bWVudChxdWVyeURvYyk7XG4gICAgdmFyIGZyYWdtZW50RGVmaW5pdGlvbjtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcXVlcnlEb2MuZGVmaW5pdGlvbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBkZWZpbml0aW9uID0gX2FbX2ldO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSAnT3BlcmF0aW9uRGVmaW5pdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBvcGVyYXRpb24gPSBkZWZpbml0aW9uLm9wZXJhdGlvbjtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT09ICdxdWVyeScgfHxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPT09ICdtdXRhdGlvbicgfHxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPT09ICdzdWJzY3JpcHRpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmluaXRpb24ua2luZCA9PT0gJ0ZyYWdtZW50RGVmaW5pdGlvbicgJiYgIWZyYWdtZW50RGVmaW5pdGlvbikge1xuICAgICAgICAgICAgZnJhZ21lbnREZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZnJhZ21lbnREZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBmcmFnbWVudERlZmluaXRpb247XG4gICAgfVxuICAgIHRocm93IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG5ldyBJbnZhcmlhbnRFcnJvcigxMCkgOiBuZXcgSW52YXJpYW50RXJyb3IoJ0V4cGVjdGVkIGEgcGFyc2VkIEdyYXBoUUwgcXVlcnkgd2l0aCBhIHF1ZXJ5LCBtdXRhdGlvbiwgc3Vic2NyaXB0aW9uLCBvciBhIGZyYWdtZW50LicpO1xufVxuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRNYXAoZnJhZ21lbnRzKSB7XG4gICAgaWYgKGZyYWdtZW50cyA9PT0gdm9pZCAwKSB7IGZyYWdtZW50cyA9IFtdOyB9XG4gICAgdmFyIHN5bVRhYmxlID0ge307XG4gICAgZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgIHN5bVRhYmxlW2ZyYWdtZW50Lm5hbWUudmFsdWVdID0gZnJhZ21lbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN5bVRhYmxlO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlcyhkZWZpbml0aW9uKSB7XG4gICAgaWYgKGRlZmluaXRpb24gJiZcbiAgICAgICAgZGVmaW5pdGlvbi52YXJpYWJsZURlZmluaXRpb25zICYmXG4gICAgICAgIGRlZmluaXRpb24udmFyaWFibGVEZWZpbml0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZXMgPSBkZWZpbml0aW9uLnZhcmlhYmxlRGVmaW5pdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gX2EuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBfYS52YXJpYWJsZSwgZGVmYXVsdFZhbHVlID0gX2EuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZU9iaiA9IHt9O1xuICAgICAgICAgICAgdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKGRlZmF1bHRWYWx1ZU9iaiwgdmFyaWFibGUubmFtZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWVPYmo7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXNzaWduLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheXMoW3t9XSwgZGVmYXVsdFZhbHVlcykpO1xuICAgIH1cbiAgICByZXR1cm4ge307XG59XG5mdW5jdGlvbiB2YXJpYWJsZXNJbk9wZXJhdGlvbihvcGVyYXRpb24pIHtcbiAgICB2YXIgbmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgaWYgKG9wZXJhdGlvbi52YXJpYWJsZURlZmluaXRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBvcGVyYXRpb24udmFyaWFibGVEZWZpbml0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gX2FbX2ldO1xuICAgICAgICAgICAgbmFtZXMuYWRkKGRlZmluaXRpb24udmFyaWFibGUubmFtZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJJblBsYWNlKGFycmF5LCB0ZXN0LCBjb250ZXh0KSB7XG4gICAgdmFyIHRhcmdldCA9IDA7XG4gICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbSwgaSkge1xuICAgICAgICBpZiAodGVzdC5jYWxsKHRoaXMsIGVsZW0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgYXJyYXlbdGFyZ2V0KytdID0gZWxlbTtcbiAgICAgICAgfVxuICAgIH0sIGNvbnRleHQpO1xuICAgIGFycmF5Lmxlbmd0aCA9IHRhcmdldDtcbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBUWVBFTkFNRV9GSUVMRCA9IHtcbiAgICBraW5kOiAnRmllbGQnLFxuICAgIG5hbWU6IHtcbiAgICAgICAga2luZDogJ05hbWUnLFxuICAgICAgICB2YWx1ZTogJ19fdHlwZW5hbWUnLFxuICAgIH0sXG59O1xuZnVuY3Rpb24gaXNFbXB0eShvcCwgZnJhZ21lbnRzKSB7XG4gICAgcmV0dXJuIG9wLnNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5raW5kID09PSAnRnJhZ21lbnRTcHJlYWQnICYmXG4gICAgICAgICAgICBpc0VtcHR5KGZyYWdtZW50c1tzZWxlY3Rpb24ubmFtZS52YWx1ZV0sIGZyYWdtZW50cyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBudWxsSWZEb2NJc0VtcHR5KGRvYykge1xuICAgIHJldHVybiBpc0VtcHR5KGdldE9wZXJhdGlvbkRlZmluaXRpb24oZG9jKSB8fCBnZXRGcmFnbWVudERlZmluaXRpb24oZG9jKSwgY3JlYXRlRnJhZ21lbnRNYXAoZ2V0RnJhZ21lbnREZWZpbml0aW9ucyhkb2MpKSlcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogZG9jO1xufVxuZnVuY3Rpb24gZ2V0RGlyZWN0aXZlTWF0Y2hlcihkaXJlY3RpdmVzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRpcmVjdGl2ZU1hdGNoZXIoZGlyZWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgcmV0dXJuIChkaXIubmFtZSAmJiBkaXIubmFtZSA9PT0gZGlyZWN0aXZlLm5hbWUudmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgKGRpci50ZXN0ICYmIGRpci50ZXN0KGRpcmVjdGl2ZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlRGlyZWN0aXZlc0Zyb21Eb2N1bWVudChkaXJlY3RpdmVzLCBkb2MpIHtcbiAgICB2YXIgdmFyaWFibGVzSW5Vc2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciB2YXJpYWJsZXNUb1JlbW92ZSA9IFtdO1xuICAgIHZhciBmcmFnbWVudFNwcmVhZHNJblVzZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGZyYWdtZW50U3ByZWFkc1RvUmVtb3ZlID0gW107XG4gICAgdmFyIG1vZGlmaWVkRG9jID0gbnVsbElmRG9jSXNFbXB0eSh2aXNpdChkb2MsIHtcbiAgICAgICAgVmFyaWFibGU6IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgX2tleSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5raW5kICE9PSAnVmFyaWFibGVEZWZpbml0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXNJblVzZVtub2RlLm5hbWUudmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBGaWVsZDoge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZXMgJiYgbm9kZS5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaG91bGRSZW1vdmVGaWVsZCA9IGRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUucmVtb3ZlOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFJlbW92ZUZpZWxkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRpcmVjdGl2ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGlyZWN0aXZlcy5zb21lKGdldERpcmVjdGl2ZU1hdGNoZXIoZGlyZWN0aXZlcykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy52YWx1ZS5raW5kID09PSAnVmFyaWFibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXNUb1JlbW92ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhcmcudmFsdWUubmFtZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBbGxGcmFnbWVudFNwcmVhZHNGcm9tU2VsZWN0aW9uU2V0KG5vZGUuc2VsZWN0aW9uU2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50U3ByZWFkc1RvUmVtb3ZlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnJhZy5uYW1lLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgRnJhZ21lbnRTcHJlYWQ6IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50U3ByZWFkc0luVXNlW25vZGUubmFtZS52YWx1ZV0gPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgRGlyZWN0aXZlOiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGlyZWN0aXZlTWF0Y2hlcihkaXJlY3RpdmVzKShub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pKTtcbiAgICBpZiAobW9kaWZpZWREb2MgJiZcbiAgICAgICAgZmlsdGVySW5QbGFjZSh2YXJpYWJsZXNUb1JlbW92ZSwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuICF2YXJpYWJsZXNJblVzZVt2Lm5hbWVdOyB9KS5sZW5ndGgpIHtcbiAgICAgICAgbW9kaWZpZWREb2MgPSByZW1vdmVBcmd1bWVudHNGcm9tRG9jdW1lbnQodmFyaWFibGVzVG9SZW1vdmUsIG1vZGlmaWVkRG9jKTtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVkRG9jICYmXG4gICAgICAgIGZpbHRlckluUGxhY2UoZnJhZ21lbnRTcHJlYWRzVG9SZW1vdmUsIGZ1bmN0aW9uIChmcykgeyByZXR1cm4gIWZyYWdtZW50U3ByZWFkc0luVXNlW2ZzLm5hbWVdOyB9KVxuICAgICAgICAgICAgLmxlbmd0aCkge1xuICAgICAgICBtb2RpZmllZERvYyA9IHJlbW92ZUZyYWdtZW50U3ByZWFkRnJvbURvY3VtZW50KGZyYWdtZW50U3ByZWFkc1RvUmVtb3ZlLCBtb2RpZmllZERvYyk7XG4gICAgfVxuICAgIHJldHVybiBtb2RpZmllZERvYztcbn1cbmZ1bmN0aW9uIGFkZFR5cGVuYW1lVG9Eb2N1bWVudChkb2MpIHtcbiAgICByZXR1cm4gdmlzaXQoY2hlY2tEb2N1bWVudChkb2MpLCB7XG4gICAgICAgIFNlbGVjdGlvblNldDoge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBfa2V5LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5raW5kID09PSAnT3BlcmF0aW9uRGVmaW5pdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IG5vZGUuc2VsZWN0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2tpcCA9IHNlbGVjdGlvbnMuc29tZShmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXNGaWVsZChzZWxlY3Rpb24pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VsZWN0aW9uLm5hbWUudmFsdWUgPT09ICdfX3R5cGVuYW1lJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5uYW1lLnZhbHVlLmxhc3RJbmRleE9mKCdfXycsIDApID09PSAwKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmllbGQoZmllbGQpICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmRpcmVjdGl2ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUudmFsdWUgPT09ICdleHBvcnQnOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbm9kZSksIHsgc2VsZWN0aW9uczogX19zcHJlYWRBcnJheXMoc2VsZWN0aW9ucywgW1RZUEVOQU1FX0ZJRUxEXSkgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xufVxudmFyIGNvbm5lY3Rpb25SZW1vdmVDb25maWcgPSB7XG4gICAgdGVzdDogZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICB2YXIgd2lsbFJlbW92ZSA9IGRpcmVjdGl2ZS5uYW1lLnZhbHVlID09PSAnY29ubmVjdGlvbic7XG4gICAgICAgIGlmICh3aWxsUmVtb3ZlKSB7XG4gICAgICAgICAgICBpZiAoIWRpcmVjdGl2ZS5hcmd1bWVudHMgfHxcbiAgICAgICAgICAgICAgICAhZGlyZWN0aXZlLmFyZ3VtZW50cy5zb21lKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIGFyZy5uYW1lLnZhbHVlID09PSAna2V5JzsgfSkpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgaW52YXJpYW50Lndhcm4oJ1JlbW92aW5nIGFuIEBjb25uZWN0aW9uIGRpcmVjdGl2ZSBldmVuIHRob3VnaCBpdCBkb2VzIG5vdCBoYXZlIGEga2V5LiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1lvdSBtYXkgd2FudCB0byB1c2UgdGhlIGtleSBwYXJhbWV0ZXIgdG8gc3BlY2lmeSBhIHN0b3JlIGtleS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2lsbFJlbW92ZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHJlbW92ZUNvbm5lY3Rpb25EaXJlY3RpdmVGcm9tRG9jdW1lbnQoZG9jKSB7XG4gICAgcmV0dXJuIHJlbW92ZURpcmVjdGl2ZXNGcm9tRG9jdW1lbnQoW2Nvbm5lY3Rpb25SZW1vdmVDb25maWddLCBjaGVja0RvY3VtZW50KGRvYykpO1xufVxuZnVuY3Rpb24gaGFzRGlyZWN0aXZlc0luU2VsZWN0aW9uU2V0KGRpcmVjdGl2ZXMsIHNlbGVjdGlvblNldCwgbmVzdGVkQ2hlY2spIHtcbiAgICBpZiAobmVzdGVkQ2hlY2sgPT09IHZvaWQgMCkgeyBuZXN0ZWRDaGVjayA9IHRydWU7IH1cbiAgICByZXR1cm4gKHNlbGVjdGlvblNldCAmJlxuICAgICAgICBzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucyAmJlxuICAgICAgICBzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5zb21lKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNEaXJlY3RpdmVzSW5TZWxlY3Rpb24oZGlyZWN0aXZlcywgc2VsZWN0aW9uLCBuZXN0ZWRDaGVjayk7XG4gICAgICAgIH0pKTtcbn1cbmZ1bmN0aW9uIGhhc0RpcmVjdGl2ZXNJblNlbGVjdGlvbihkaXJlY3RpdmVzLCBzZWxlY3Rpb24sIG5lc3RlZENoZWNrKSB7XG4gICAgaWYgKG5lc3RlZENoZWNrID09PSB2b2lkIDApIHsgbmVzdGVkQ2hlY2sgPSB0cnVlOyB9XG4gICAgaWYgKCFpc0ZpZWxkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghc2VsZWN0aW9uLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKHNlbGVjdGlvbi5kaXJlY3RpdmVzLnNvbWUoZ2V0RGlyZWN0aXZlTWF0Y2hlcihkaXJlY3RpdmVzKSkgfHxcbiAgICAgICAgKG5lc3RlZENoZWNrICYmXG4gICAgICAgICAgICBoYXNEaXJlY3RpdmVzSW5TZWxlY3Rpb25TZXQoZGlyZWN0aXZlcywgc2VsZWN0aW9uLnNlbGVjdGlvblNldCwgbmVzdGVkQ2hlY2spKSk7XG59XG5mdW5jdGlvbiBnZXREaXJlY3RpdmVzRnJvbURvY3VtZW50KGRpcmVjdGl2ZXMsIGRvYykge1xuICAgIGNoZWNrRG9jdW1lbnQoZG9jKTtcbiAgICB2YXIgcGFyZW50UGF0aDtcbiAgICByZXR1cm4gbnVsbElmRG9jSXNFbXB0eSh2aXNpdChkb2MsIHtcbiAgICAgICAgU2VsZWN0aW9uU2V0OiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIF9rZXksIF9wYXJlbnQsIHBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFBhdGggPSBwYXRoLmpvaW4oJy0nKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFBhdGggfHxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhdGggPT09IHBhcmVudFBhdGggfHxcbiAgICAgICAgICAgICAgICAgICAgIWN1cnJlbnRQYXRoLnN0YXJ0c1dpdGgocGFyZW50UGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc2VsZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbnNXaXRoRGlyZWN0aXZlcyA9IG5vZGUuc2VsZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHNlbGVjdGlvbikgeyByZXR1cm4gaGFzRGlyZWN0aXZlc0luU2VsZWN0aW9uKGRpcmVjdGl2ZXMsIHNlbGVjdGlvbik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0RpcmVjdGl2ZXNJblNlbGVjdGlvblNldChkaXJlY3RpdmVzLCBub2RlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRQYXRoID0gY3VycmVudFBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIG5vZGUpLCB7IHNlbGVjdGlvbnM6IHNlbGVjdGlvbnNXaXRoRGlyZWN0aXZlcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBnZXRBcmd1bWVudE1hdGNoZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFyZ3VtZW50TWF0Y2hlcihhcmd1bWVudCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLnNvbWUoZnVuY3Rpb24gKGFDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudC52YWx1ZSAmJlxuICAgICAgICAgICAgICAgIGFyZ3VtZW50LnZhbHVlLmtpbmQgPT09ICdWYXJpYWJsZScgJiZcbiAgICAgICAgICAgICAgICBhcmd1bWVudC52YWx1ZS5uYW1lICYmXG4gICAgICAgICAgICAgICAgKGFDb25maWcubmFtZSA9PT0gYXJndW1lbnQudmFsdWUubmFtZS52YWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAoYUNvbmZpZy50ZXN0ICYmIGFDb25maWcudGVzdChhcmd1bWVudCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUFyZ3VtZW50c0Zyb21Eb2N1bWVudChjb25maWcsIGRvYykge1xuICAgIHZhciBhcmdNYXRjaGVyID0gZ2V0QXJndW1lbnRNYXRjaGVyKGNvbmZpZyk7XG4gICAgcmV0dXJuIG51bGxJZkRvY0lzRW1wdHkodmlzaXQoZG9jLCB7XG4gICAgICAgIE9wZXJhdGlvbkRlZmluaXRpb246IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbm9kZSksIHsgdmFyaWFibGVEZWZpbml0aW9uczogbm9kZS52YXJpYWJsZURlZmluaXRpb25zLmZpbHRlcihmdW5jdGlvbiAodmFyRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWNvbmZpZy5zb21lKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIGFyZy5uYW1lID09PSB2YXJEZWYudmFyaWFibGUubmFtZS52YWx1ZTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgRmllbGQ6IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBzaG91bGRSZW1vdmVGaWVsZCA9IGNvbmZpZy5zb21lKGZ1bmN0aW9uIChhcmdDb25maWcpIHsgcmV0dXJuIGFyZ0NvbmZpZy5yZW1vdmU7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnTWF0Y2hDb3VudF8xID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnTWF0Y2hlcihhcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnTWF0Y2hDb3VudF8xICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnTWF0Y2hDb3VudF8xID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIEFyZ3VtZW50OiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnTWF0Y2hlcihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZyYWdtZW50U3ByZWFkRnJvbURvY3VtZW50KGNvbmZpZywgZG9jKSB7XG4gICAgZnVuY3Rpb24gZW50ZXIobm9kZSkge1xuICAgICAgICBpZiAoY29uZmlnLnNvbWUoZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gZGVmLm5hbWUgPT09IG5vZGUubmFtZS52YWx1ZTsgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsSWZEb2NJc0VtcHR5KHZpc2l0KGRvYywge1xuICAgICAgICBGcmFnbWVudFNwcmVhZDogeyBlbnRlcjogZW50ZXIgfSxcbiAgICAgICAgRnJhZ21lbnREZWZpbml0aW9uOiB7IGVudGVyOiBlbnRlciB9LFxuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIGdldEFsbEZyYWdtZW50U3ByZWFkc0Zyb21TZWxlY3Rpb25TZXQoc2VsZWN0aW9uU2V0KSB7XG4gICAgdmFyIGFsbEZyYWdtZW50cyA9IFtdO1xuICAgIHNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoKGlzRmllbGQoc2VsZWN0aW9uKSB8fCBpc0lubGluZUZyYWdtZW50KHNlbGVjdGlvbikpICYmXG4gICAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICBnZXRBbGxGcmFnbWVudFNwcmVhZHNGcm9tU2VsZWN0aW9uU2V0KHNlbGVjdGlvbi5zZWxlY3Rpb25TZXQpLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHsgcmV0dXJuIGFsbEZyYWdtZW50cy5wdXNoKGZyYWcpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxlY3Rpb24ua2luZCA9PT0gJ0ZyYWdtZW50U3ByZWFkJykge1xuICAgICAgICAgICAgYWxsRnJhZ21lbnRzLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhbGxGcmFnbWVudHM7XG59XG5mdW5jdGlvbiBidWlsZFF1ZXJ5RnJvbVNlbGVjdGlvblNldChkb2N1bWVudCkge1xuICAgIHZhciBkZWZpbml0aW9uID0gZ2V0TWFpbkRlZmluaXRpb24oZG9jdW1lbnQpO1xuICAgIHZhciBkZWZpbml0aW9uT3BlcmF0aW9uID0gZGVmaW5pdGlvbi5vcGVyYXRpb247XG4gICAgaWYgKGRlZmluaXRpb25PcGVyYXRpb24gPT09ICdxdWVyeScpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICB2YXIgbW9kaWZpZWREb2MgPSB2aXNpdChkb2N1bWVudCwge1xuICAgICAgICBPcGVyYXRpb25EZWZpbml0aW9uOiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIG5vZGUpLCB7IG9wZXJhdGlvbjogJ3F1ZXJ5JyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIG1vZGlmaWVkRG9jO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudChkb2N1bWVudCkge1xuICAgIGNoZWNrRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgIHZhciBtb2RpZmllZERvYyA9IHJlbW92ZURpcmVjdGl2ZXNGcm9tRG9jdW1lbnQoW1xuICAgICAgICB7XG4gICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUubmFtZS52YWx1ZSA9PT0gJ2NsaWVudCc7IH0sXG4gICAgICAgICAgICByZW1vdmU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgXSwgZG9jdW1lbnQpO1xuICAgIGlmIChtb2RpZmllZERvYykge1xuICAgICAgICBtb2RpZmllZERvYyA9IHZpc2l0KG1vZGlmaWVkRG9jLCB7XG4gICAgICAgICAgICBGcmFnbWVudERlZmluaXRpb246IHtcbiAgICAgICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNUeXBlbmFtZU9ubHkgPSBub2RlLnNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaWVsZChzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5uYW1lLnZhbHVlID09PSAnX190eXBlbmFtZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1R5cGVuYW1lT25seSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kaWZpZWREb2M7XG59XG5cbnZhciBjYW5Vc2VXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgISh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJlxuICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICAgIHJldHVybiBjbG9uZURlZXBIZWxwZXIodmFsdWUsIG5ldyBNYXAoKSk7XG59XG5mdW5jdGlvbiBjbG9uZURlZXBIZWxwZXIodmFsLCBzZWVuKSB7XG4gICAgc3dpdGNoICh0b1N0cmluZy5jYWxsKHZhbCkpIHtcbiAgICAgICAgY2FzZSBcIltvYmplY3QgQXJyYXldXCI6IHtcbiAgICAgICAgICAgIGlmIChzZWVuLmhhcyh2YWwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLmdldCh2YWwpO1xuICAgICAgICAgICAgdmFyIGNvcHlfMSA9IHZhbC5zbGljZSgwKTtcbiAgICAgICAgICAgIHNlZW4uc2V0KHZhbCwgY29weV8xKTtcbiAgICAgICAgICAgIGNvcHlfMS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICAgICAgICAgIGNvcHlfMVtpXSA9IGNsb25lRGVlcEhlbHBlcihjaGlsZCwgc2Vlbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5XzE7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIltvYmplY3QgT2JqZWN0XVwiOiB7XG4gICAgICAgICAgICBpZiAoc2Vlbi5oYXModmFsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5nZXQodmFsKTtcbiAgICAgICAgICAgIHZhciBjb3B5XzIgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpKTtcbiAgICAgICAgICAgIHNlZW4uc2V0KHZhbCwgY29weV8yKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY29weV8yW2tleV0gPSBjbG9uZURlZXBIZWxwZXIodmFsW2tleV0sIHNlZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29weV8yO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RW52KCkge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WO1xuICAgIH1cbiAgICByZXR1cm4gJ2RldmVsb3BtZW50Jztcbn1cbmZ1bmN0aW9uIGlzRW52KGVudikge1xuICAgIHJldHVybiBnZXRFbnYoKSA9PT0gZW52O1xufVxuZnVuY3Rpb24gaXNQcm9kdWN0aW9uKCkge1xuICAgIHJldHVybiBpc0VudigncHJvZHVjdGlvbicpID09PSB0cnVlO1xufVxuZnVuY3Rpb24gaXNEZXZlbG9wbWVudCgpIHtcbiAgICByZXR1cm4gaXNFbnYoJ2RldmVsb3BtZW50JykgPT09IHRydWU7XG59XG5mdW5jdGlvbiBpc1Rlc3QoKSB7XG4gICAgcmV0dXJuIGlzRW52KCd0ZXN0JykgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIHRyeUZ1bmN0aW9uT3JMb2dFcnJvcihmKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBncmFwaFFMUmVzdWx0SGFzRXJyb3IocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdC5lcnJvcnMgJiYgcmVzdWx0LmVycm9ycy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGRlZXBGcmVlemUobykge1xuICAgIE9iamVjdC5mcmVlemUobyk7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBpZiAob1twcm9wXSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgKHR5cGVvZiBvW3Byb3BdID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb1twcm9wXSA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgICAgICAgICFPYmplY3QuaXNGcm96ZW4ob1twcm9wXSkpIHtcbiAgICAgICAgICAgIGRlZXBGcmVlemUob1twcm9wXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIG1heWJlRGVlcEZyZWV6ZShvYmopIHtcbiAgICBpZiAoaXNEZXZlbG9wbWVudCgpIHx8IGlzVGVzdCgpKSB7XG4gICAgICAgIHZhciBzeW1ib2xJc1BvbHlmaWxsZWQgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2woJycpID09PSAnc3RyaW5nJztcbiAgICAgICAgaWYgKCFzeW1ib2xJc1BvbHlmaWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWVwRnJlZXplKG9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIG1lcmdlRGVlcCgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGVlcEFycmF5KHNvdXJjZXMpO1xufVxuZnVuY3Rpb24gbWVyZ2VEZWVwQXJyYXkoc291cmNlcykge1xuICAgIHZhciB0YXJnZXQgPSBzb3VyY2VzWzBdIHx8IHt9O1xuICAgIHZhciBjb3VudCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgdmFyIHBhc3RDb3BpZXMgPSBbXTtcbiAgICAgICAgdGFyZ2V0ID0gc2hhbGxvd0NvcHlGb3JNZXJnZSh0YXJnZXQsIHBhc3RDb3BpZXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IG1lcmdlSGVscGVyKHRhcmdldCwgc291cmNlc1tpXSwgcGFzdENvcGllcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG5mdW5jdGlvbiBtZXJnZUhlbHBlcih0YXJnZXQsIHNvdXJjZSwgcGFzdENvcGllcykge1xuICAgIGlmIChpc09iamVjdChzb3VyY2UpICYmIGlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgaWYgKE9iamVjdC5pc0V4dGVuc2libGUgJiYgIU9iamVjdC5pc0V4dGVuc2libGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gc2hhbGxvd0NvcHlGb3JNZXJnZSh0YXJnZXQsIHBhc3RDb3BpZXMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlS2V5KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlVmFsdWUgPSBzb3VyY2Vbc291cmNlS2V5XTtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgc291cmNlS2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRWYWx1ZSA9IHRhcmdldFtzb3VyY2VLZXldO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VWYWx1ZSAhPT0gdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZUtleV0gPSBtZXJnZUhlbHBlcihzaGFsbG93Q29weUZvck1lcmdlKHRhcmdldFZhbHVlLCBwYXN0Q29waWVzKSwgc291cmNlVmFsdWUsIHBhc3RDb3BpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtzb3VyY2VLZXldID0gc291cmNlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gc2hhbGxvd0NvcHlGb3JNZXJnZSh2YWx1ZSwgcGFzdENvcGllcykge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHBhc3RDb3BpZXMuaW5kZXhPZih2YWx1ZSkgPCAwKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gX19hc3NpZ24oeyBfX3Byb3RvX186IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgfSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhc3RDb3BpZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIGhhdmVXYXJuZWQgPSBPYmplY3QuY3JlYXRlKHt9KTtcbmZ1bmN0aW9uIHdhcm5PbmNlSW5EZXZlbG9wbWVudChtc2csIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSAnd2Fybic7IH1cbiAgICBpZiAoIWlzUHJvZHVjdGlvbigpICYmICFoYXZlV2FybmVkW21zZ10pIHtcbiAgICAgICAgaWYgKCFpc1Rlc3QoKSkge1xuICAgICAgICAgICAgaGF2ZVdhcm5lZFttc2ddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwU3ltYm9scyhkYXRhKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xufVxuXG5leHBvcnQgeyBhZGRUeXBlbmFtZVRvRG9jdW1lbnQsIGFyZ3VtZW50c09iamVjdEZyb21GaWVsZCwgYXNzaWduLCBidWlsZFF1ZXJ5RnJvbVNlbGVjdGlvblNldCwgY2FuVXNlV2Vha01hcCwgY2hlY2tEb2N1bWVudCwgY2xvbmVEZWVwLCBjcmVhdGVGcmFnbWVudE1hcCwgZ2V0RGVmYXVsdFZhbHVlcywgZ2V0RGlyZWN0aXZlSW5mb0Zyb21GaWVsZCwgZ2V0RGlyZWN0aXZlTmFtZXMsIGdldERpcmVjdGl2ZXNGcm9tRG9jdW1lbnQsIGdldEVudiwgZ2V0RnJhZ21lbnREZWZpbml0aW9uLCBnZXRGcmFnbWVudERlZmluaXRpb25zLCBnZXRGcmFnbWVudFF1ZXJ5RG9jdW1lbnQsIGdldEluY2x1c2lvbkRpcmVjdGl2ZXMsIGdldE1haW5EZWZpbml0aW9uLCBnZXRNdXRhdGlvbkRlZmluaXRpb24sIGdldE9wZXJhdGlvbkRlZmluaXRpb24sIGdldE9wZXJhdGlvbkRlZmluaXRpb25PckRpZSwgZ2V0T3BlcmF0aW9uTmFtZSwgZ2V0UXVlcnlEZWZpbml0aW9uLCBnZXRTdG9yZUtleU5hbWUsIGdyYXBoUUxSZXN1bHRIYXNFcnJvciwgaGFzQ2xpZW50RXhwb3J0cywgaGFzRGlyZWN0aXZlcywgaXNEZXZlbG9wbWVudCwgaXNFbnYsIGlzRmllbGQsIGlzSWRWYWx1ZSwgaXNJbmxpbmVGcmFnbWVudCwgaXNKc29uVmFsdWUsIGlzTnVtYmVyVmFsdWUsIGlzUHJvZHVjdGlvbiwgaXNTY2FsYXJWYWx1ZSwgaXNUZXN0LCBtYXliZURlZXBGcmVlemUsIG1lcmdlRGVlcCwgbWVyZ2VEZWVwQXJyYXksIHJlbW92ZUFyZ3VtZW50c0Zyb21Eb2N1bWVudCwgcmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudCwgcmVtb3ZlQ29ubmVjdGlvbkRpcmVjdGl2ZUZyb21Eb2N1bWVudCwgcmVtb3ZlRGlyZWN0aXZlc0Zyb21Eb2N1bWVudCwgcmVtb3ZlRnJhZ21lbnRTcHJlYWRGcm9tRG9jdW1lbnQsIHJlc3VsdEtleU5hbWVGcm9tRmllbGQsIHNob3VsZEluY2x1ZGUsIHN0b3JlS2V5TmFtZUZyb21GaWVsZCwgc3RyaXBTeW1ib2xzLCB0b0lkVmFsdWUsIHRyeUZ1bmN0aW9uT3JMb2dFcnJvciwgdmFsdWVGcm9tTm9kZSwgdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uLCB2YXJpYWJsZXNJbk9wZXJhdGlvbiwgd2Fybk9uY2VJbkRldmVsb3BtZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUuZXNtLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InvariantError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return invariant; });\n/* unused harmony export process */\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n\n\nvar genericMessage = "Invariant Violation";\r\nvar _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function (obj, proto) {\r\n    obj.__proto__ = proto;\r\n    return obj;\r\n} : _a;\r\nvar InvariantError = /** @class */ (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "c"])(InvariantError, _super);\r\n    function InvariantError(message) {\r\n        if (message === void 0) { message = genericMessage; }\r\n        var _this = _super.call(this, typeof message === "number"\r\n            ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)"\r\n            : message) || this;\r\n        _this.framesToPop = 1;\r\n        _this.name = genericMessage;\r\n        setPrototypeOf(_this, InvariantError.prototype);\r\n        return _this;\r\n    }\r\n    return InvariantError;\r\n}(Error));\r\nfunction invariant(condition, message) {\r\n    if (!condition) {\r\n        throw new InvariantError(message);\r\n    }\r\n}\r\nfunction wrapConsoleMethod(method) {\r\n    return function () {\r\n        return console[method].apply(console, arguments);\r\n    };\r\n}\r\n(function (invariant) {\r\n    invariant.warn = wrapConsoleMethod("warn");\r\n    invariant.error = wrapConsoleMethod("error");\r\n})(invariant || (invariant = {}));\r\n// Code that uses ts-invariant with rollup-plugin-invariant may want to\r\n// import this process stub to avoid errors evaluating process.env.NODE_ENV.\r\n// However, because most ESM-to-CJS compilers will rewrite the process import\r\n// as tsInvariant.process, which prevents proper replacement by minifiers, we\r\n// also attempt to define the stub globally when it is not already defined.\r\nvar processStub = { env: {} };\r\nif (typeof process === "object") {\r\n    processStub = process;\r\n}\r\nelse\r\n    try {\r\n        // Using Function to evaluate this assignment in global scope also escapes\r\n        // the strict mode of the current module, thereby allowing the assignment.\r\n        // Inspired by https://github.com/facebook/regenerator/pull/369.\r\n        Function("stub", "process = stub")(processStub);\r\n    }\r\n    catch (atLeastWeTried) {\r\n        // The assignment can fail if a Content Security Policy heavy-handedly\r\n        // forbids Function usage. In those environments, developers should take\r\n        // extra care to replace process.env.NODE_ENV in their production builds,\r\n        // or define an appropriate global.process polyfill.\r\n    }\r\nvar invariant$1 = invariant;\n\n/* unused harmony default export */ var _unused_webpack_default_export = (invariant$1);\n\n//# sourceMappingURL=invariant.esm.js.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90cy1pbnZhcmlhbnQvbGliL2ludmFyaWFudC5lc20uanM/YTk1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5cbnZhciBnZW5lcmljTWVzc2FnZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiO1xyXG52YXIgX2EgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YsIHNldFByb3RvdHlwZU9mID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChvYmosIHByb3RvKSB7XHJcbiAgICBvYmouX19wcm90b19fID0gcHJvdG87XHJcbiAgICByZXR1cm4gb2JqO1xyXG59IDogX2E7XHJcbnZhciBJbnZhcmlhbnRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhJbnZhcmlhbnRFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEludmFyaWFudEVycm9yKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAobWVzc2FnZSA9PT0gdm9pZCAwKSB7IG1lc3NhZ2UgPSBnZW5lcmljTWVzc2FnZTsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGVvZiBtZXNzYWdlID09PSBcIm51bWJlclwiXHJcbiAgICAgICAgICAgID8gZ2VuZXJpY01lc3NhZ2UgKyBcIjogXCIgKyBtZXNzYWdlICsgXCIgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vYXBvbGxvZ3JhcGhxbC9pbnZhcmlhbnQtcGFja2FnZXMpXCJcclxuICAgICAgICAgICAgOiBtZXNzYWdlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmZyYW1lc1RvUG9wID0gMTtcclxuICAgICAgICBfdGhpcy5uYW1lID0gZ2VuZXJpY01lc3NhZ2U7XHJcbiAgICAgICAgc2V0UHJvdG90eXBlT2YoX3RoaXMsIEludmFyaWFudEVycm9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEludmFyaWFudEVycm9yO1xyXG59KEVycm9yKSk7XHJcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcclxuICAgIGlmICghY29uZGl0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHdyYXBDb25zb2xlTWV0aG9kKG1ldGhvZCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gY29uc29sZVttZXRob2RdLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59XHJcbihmdW5jdGlvbiAoaW52YXJpYW50KSB7XHJcbiAgICBpbnZhcmlhbnQud2FybiA9IHdyYXBDb25zb2xlTWV0aG9kKFwid2FyblwiKTtcclxuICAgIGludmFyaWFudC5lcnJvciA9IHdyYXBDb25zb2xlTWV0aG9kKFwiZXJyb3JcIik7XHJcbn0pKGludmFyaWFudCB8fCAoaW52YXJpYW50ID0ge30pKTtcclxuLy8gQ29kZSB0aGF0IHVzZXMgdHMtaW52YXJpYW50IHdpdGggcm9sbHVwLXBsdWdpbi1pbnZhcmlhbnQgbWF5IHdhbnQgdG9cclxuLy8gaW1wb3J0IHRoaXMgcHJvY2VzcyBzdHViIHRvIGF2b2lkIGVycm9ycyBldmFsdWF0aW5nIHByb2Nlc3MuZW52Lk5PREVfRU5WLlxyXG4vLyBIb3dldmVyLCBiZWNhdXNlIG1vc3QgRVNNLXRvLUNKUyBjb21waWxlcnMgd2lsbCByZXdyaXRlIHRoZSBwcm9jZXNzIGltcG9ydFxyXG4vLyBhcyB0c0ludmFyaWFudC5wcm9jZXNzLCB3aGljaCBwcmV2ZW50cyBwcm9wZXIgcmVwbGFjZW1lbnQgYnkgbWluaWZpZXJzLCB3ZVxyXG4vLyBhbHNvIGF0dGVtcHQgdG8gZGVmaW5lIHRoZSBzdHViIGdsb2JhbGx5IHdoZW4gaXQgaXMgbm90IGFscmVhZHkgZGVmaW5lZC5cclxudmFyIHByb2Nlc3NTdHViID0geyBlbnY6IHt9IH07XHJcbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgcHJvY2Vzc1N0dWIgPSBwcm9jZXNzO1xyXG59XHJcbmVsc2VcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gVXNpbmcgRnVuY3Rpb24gdG8gZXZhbHVhdGUgdGhpcyBhc3NpZ25tZW50IGluIGdsb2JhbCBzY29wZSBhbHNvIGVzY2FwZXNcclxuICAgICAgICAvLyB0aGUgc3RyaWN0IG1vZGUgb2YgdGhlIGN1cnJlbnQgbW9kdWxlLCB0aGVyZWJ5IGFsbG93aW5nIHRoZSBhc3NpZ25tZW50LlxyXG4gICAgICAgIC8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9wdWxsLzM2OS5cclxuICAgICAgICBGdW5jdGlvbihcInN0dWJcIiwgXCJwcm9jZXNzID0gc3R1YlwiKShwcm9jZXNzU3R1Yik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoYXRMZWFzdFdlVHJpZWQpIHtcclxuICAgICAgICAvLyBUaGUgYXNzaWdubWVudCBjYW4gZmFpbCBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGhlYXZ5LWhhbmRlZGx5XHJcbiAgICAgICAgLy8gZm9yYmlkcyBGdW5jdGlvbiB1c2FnZS4gSW4gdGhvc2UgZW52aXJvbm1lbnRzLCBkZXZlbG9wZXJzIHNob3VsZCB0YWtlXHJcbiAgICAgICAgLy8gZXh0cmEgY2FyZSB0byByZXBsYWNlIHByb2Nlc3MuZW52Lk5PREVfRU5WIGluIHRoZWlyIHByb2R1Y3Rpb24gYnVpbGRzLFxyXG4gICAgICAgIC8vIG9yIGRlZmluZSBhbiBhcHByb3ByaWF0ZSBnbG9iYWwucHJvY2VzcyBwb2x5ZmlsbC5cclxuICAgIH1cclxudmFyIGludmFyaWFudCQxID0gaW52YXJpYW50O1xuXG5leHBvcnQgZGVmYXVsdCBpbnZhcmlhbnQkMTtcbmV4cG9ydCB7IEludmFyaWFudEVycm9yLCBpbnZhcmlhbnQsIHByb2Nlc3NTdHViIGFzIHByb2Nlc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludmFyaWFudC5lc20uanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n')},function(module,exports,__webpack_require__){eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(37)();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzP2Q3YmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n")},,function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (false) {}\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (true) {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = __webpack_require__(34);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanM/OGJjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBRUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n")},function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("/* unused harmony export QueryDocumentKeys */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return BREAK; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return visit; });\n/* unused harmony export visitInParallel */\n/* unused harmony export visitWithTypeInfo */\n/* unused harmony export getVisitFn */\n/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n\nvar QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields']\n};\nvar BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nfunction visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {\n            var k = _Object$keys2[_i2];\n            clone[k] = node[k];\n          }\n\n          node = clone;\n        }\n\n        var editOffset = 0;\n\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n\n          if (inArray) {\n            editKey -= editOffset;\n          }\n\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(node));\n      }\n\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = {\n        inArray: inArray,\n        index: index,\n        keys: keys,\n        edits: edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return Boolean(maybeNode && typeof maybeNode.kind === 'string');\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\n\nfunction visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          false);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          true);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\n\nfunction getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n\n      var specificKindVisitor = specificVisitor[kind];\n\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3Zpc2l0b3IubWpzPzJmNmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGluc3BlY3QgZnJvbSAnLi4vanN1dGlscy9pbnNwZWN0JztcbmV4cG9ydCB2YXIgUXVlcnlEb2N1bWVudEtleXMgPSB7XG4gIE5hbWU6IFtdLFxuICBEb2N1bWVudDogWydkZWZpbml0aW9ucyddLFxuICBPcGVyYXRpb25EZWZpbml0aW9uOiBbJ25hbWUnLCAndmFyaWFibGVEZWZpbml0aW9ucycsICdkaXJlY3RpdmVzJywgJ3NlbGVjdGlvblNldCddLFxuICBWYXJpYWJsZURlZmluaXRpb246IFsndmFyaWFibGUnLCAndHlwZScsICdkZWZhdWx0VmFsdWUnLCAnZGlyZWN0aXZlcyddLFxuICBWYXJpYWJsZTogWyduYW1lJ10sXG4gIFNlbGVjdGlvblNldDogWydzZWxlY3Rpb25zJ10sXG4gIEZpZWxkOiBbJ2FsaWFzJywgJ25hbWUnLCAnYXJndW1lbnRzJywgJ2RpcmVjdGl2ZXMnLCAnc2VsZWN0aW9uU2V0J10sXG4gIEFyZ3VtZW50OiBbJ25hbWUnLCAndmFsdWUnXSxcbiAgRnJhZ21lbnRTcHJlYWQ6IFsnbmFtZScsICdkaXJlY3RpdmVzJ10sXG4gIElubGluZUZyYWdtZW50OiBbJ3R5cGVDb25kaXRpb24nLCAnZGlyZWN0aXZlcycsICdzZWxlY3Rpb25TZXQnXSxcbiAgRnJhZ21lbnREZWZpbml0aW9uOiBbJ25hbWUnLCAvLyBOb3RlOiBmcmFnbWVudCB2YXJpYWJsZSBkZWZpbml0aW9ucyBhcmUgZXhwZXJpbWVudGFsIGFuZCBtYXkgYmUgY2hhbmdlZFxuICAvLyBvciByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICd2YXJpYWJsZURlZmluaXRpb25zJywgJ3R5cGVDb25kaXRpb24nLCAnZGlyZWN0aXZlcycsICdzZWxlY3Rpb25TZXQnXSxcbiAgSW50VmFsdWU6IFtdLFxuICBGbG9hdFZhbHVlOiBbXSxcbiAgU3RyaW5nVmFsdWU6IFtdLFxuICBCb29sZWFuVmFsdWU6IFtdLFxuICBOdWxsVmFsdWU6IFtdLFxuICBFbnVtVmFsdWU6IFtdLFxuICBMaXN0VmFsdWU6IFsndmFsdWVzJ10sXG4gIE9iamVjdFZhbHVlOiBbJ2ZpZWxkcyddLFxuICBPYmplY3RGaWVsZDogWyduYW1lJywgJ3ZhbHVlJ10sXG4gIERpcmVjdGl2ZTogWyduYW1lJywgJ2FyZ3VtZW50cyddLFxuICBOYW1lZFR5cGU6IFsnbmFtZSddLFxuICBMaXN0VHlwZTogWyd0eXBlJ10sXG4gIE5vbk51bGxUeXBlOiBbJ3R5cGUnXSxcbiAgU2NoZW1hRGVmaW5pdGlvbjogWydkaXJlY3RpdmVzJywgJ29wZXJhdGlvblR5cGVzJ10sXG4gIE9wZXJhdGlvblR5cGVEZWZpbml0aW9uOiBbJ3R5cGUnXSxcbiAgU2NhbGFyVHlwZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJ10sXG4gIE9iamVjdFR5cGVEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnaW50ZXJmYWNlcycsICdkaXJlY3RpdmVzJywgJ2ZpZWxkcyddLFxuICBGaWVsZERlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdhcmd1bWVudHMnLCAndHlwZScsICdkaXJlY3RpdmVzJ10sXG4gIElucHV0VmFsdWVEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAndHlwZScsICdkZWZhdWx0VmFsdWUnLCAnZGlyZWN0aXZlcyddLFxuICBJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2RpcmVjdGl2ZXMnLCAnZmllbGRzJ10sXG4gIFVuaW9uVHlwZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJywgJ3R5cGVzJ10sXG4gIEVudW1UeXBlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2RpcmVjdGl2ZXMnLCAndmFsdWVzJ10sXG4gIEVudW1WYWx1ZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJ10sXG4gIElucHV0T2JqZWN0VHlwZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJywgJ2ZpZWxkcyddLFxuICBEaXJlY3RpdmVEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnYXJndW1lbnRzJywgJ2xvY2F0aW9ucyddLFxuICBTY2hlbWFFeHRlbnNpb246IFsnZGlyZWN0aXZlcycsICdvcGVyYXRpb25UeXBlcyddLFxuICBTY2FsYXJUeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnZGlyZWN0aXZlcyddLFxuICBPYmplY3RUeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnaW50ZXJmYWNlcycsICdkaXJlY3RpdmVzJywgJ2ZpZWxkcyddLFxuICBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnZGlyZWN0aXZlcycsICdmaWVsZHMnXSxcbiAgVW5pb25UeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnZGlyZWN0aXZlcycsICd0eXBlcyddLFxuICBFbnVtVHlwZUV4dGVuc2lvbjogWyduYW1lJywgJ2RpcmVjdGl2ZXMnLCAndmFsdWVzJ10sXG4gIElucHV0T2JqZWN0VHlwZUV4dGVuc2lvbjogWyduYW1lJywgJ2RpcmVjdGl2ZXMnLCAnZmllbGRzJ11cbn07XG5leHBvcnQgdmFyIEJSRUFLID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4vKipcbiAqIHZpc2l0KCkgd2lsbCB3YWxrIHRocm91Z2ggYW4gQVNUIHVzaW5nIGEgZGVwdGggZmlyc3QgdHJhdmVyc2FsLCBjYWxsaW5nXG4gKiB0aGUgdmlzaXRvcidzIGVudGVyIGZ1bmN0aW9uIGF0IGVhY2ggbm9kZSBpbiB0aGUgdHJhdmVyc2FsLCBhbmQgY2FsbGluZyB0aGVcbiAqIGxlYXZlIGZ1bmN0aW9uIGFmdGVyIHZpc2l0aW5nIHRoYXQgbm9kZSBhbmQgYWxsIG9mIGl0cyBjaGlsZCBub2Rlcy5cbiAqXG4gKiBCeSByZXR1cm5pbmcgZGlmZmVyZW50IHZhbHVlcyBmcm9tIHRoZSBlbnRlciBhbmQgbGVhdmUgZnVuY3Rpb25zLCB0aGVcbiAqIGJlaGF2aW9yIG9mIHRoZSB2aXNpdG9yIGNhbiBiZSBhbHRlcmVkLCBpbmNsdWRpbmcgc2tpcHBpbmcgb3ZlciBhIHN1Yi10cmVlIG9mXG4gKiB0aGUgQVNUIChieSByZXR1cm5pbmcgZmFsc2UpLCBlZGl0aW5nIHRoZSBBU1QgYnkgcmV0dXJuaW5nIGEgdmFsdWUgb3IgbnVsbFxuICogdG8gcmVtb3ZlIHRoZSB2YWx1ZSwgb3IgdG8gc3RvcCB0aGUgd2hvbGUgdHJhdmVyc2FsIGJ5IHJldHVybmluZyBCUkVBSy5cbiAqXG4gKiBXaGVuIHVzaW5nIHZpc2l0KCkgdG8gZWRpdCBhbiBBU1QsIHRoZSBvcmlnaW5hbCBBU1Qgd2lsbCBub3QgYmUgbW9kaWZpZWQsIGFuZFxuICogYSBuZXcgdmVyc2lvbiBvZiB0aGUgQVNUIHdpdGggdGhlIGNoYW5nZXMgYXBwbGllZCB3aWxsIGJlIHJldHVybmVkIGZyb20gdGhlXG4gKiB2aXNpdCBmdW5jdGlvbi5cbiAqXG4gKiAgICAgY29uc3QgZWRpdGVkQVNUID0gdmlzaXQoYXN0LCB7XG4gKiAgICAgICBlbnRlcihub2RlLCBrZXksIHBhcmVudCwgcGF0aCwgYW5jZXN0b3JzKSB7XG4gKiAgICAgICAgIC8vIEByZXR1cm5cbiAqICAgICAgICAgLy8gICB1bmRlZmluZWQ6IG5vIGFjdGlvblxuICogICAgICAgICAvLyAgIGZhbHNlOiBza2lwIHZpc2l0aW5nIHRoaXMgbm9kZVxuICogICAgICAgICAvLyAgIHZpc2l0b3IuQlJFQUs6IHN0b3AgdmlzaXRpbmcgYWx0b2dldGhlclxuICogICAgICAgICAvLyAgIG51bGw6IGRlbGV0ZSB0aGlzIG5vZGVcbiAqICAgICAgICAgLy8gICBhbnkgdmFsdWU6IHJlcGxhY2UgdGhpcyBub2RlIHdpdGggdGhlIHJldHVybmVkIHZhbHVlXG4gKiAgICAgICB9LFxuICogICAgICAgbGVhdmUobm9kZSwga2V5LCBwYXJlbnQsIHBhdGgsIGFuY2VzdG9ycykge1xuICogICAgICAgICAvLyBAcmV0dXJuXG4gKiAgICAgICAgIC8vICAgdW5kZWZpbmVkOiBubyBhY3Rpb25cbiAqICAgICAgICAgLy8gICBmYWxzZTogbm8gYWN0aW9uXG4gKiAgICAgICAgIC8vICAgdmlzaXRvci5CUkVBSzogc3RvcCB2aXNpdGluZyBhbHRvZ2V0aGVyXG4gKiAgICAgICAgIC8vICAgbnVsbDogZGVsZXRlIHRoaXMgbm9kZVxuICogICAgICAgICAvLyAgIGFueSB2YWx1ZTogcmVwbGFjZSB0aGlzIG5vZGUgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWVcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBBbHRlcm5hdGl2ZWx5IHRvIHByb3ZpZGluZyBlbnRlcigpIGFuZCBsZWF2ZSgpIGZ1bmN0aW9ucywgYSB2aXNpdG9yIGNhblxuICogaW5zdGVhZCBwcm92aWRlIGZ1bmN0aW9ucyBuYW1lZCB0aGUgc2FtZSBhcyB0aGUga2luZHMgb2YgQVNUIG5vZGVzLCBvclxuICogZW50ZXIvbGVhdmUgdmlzaXRvcnMgYXQgYSBuYW1lZCBrZXksIGxlYWRpbmcgdG8gZm91ciBwZXJtdXRhdGlvbnMgb2ZcbiAqIHZpc2l0b3IgQVBJOlxuICpcbiAqIDEpIE5hbWVkIHZpc2l0b3JzIHRyaWdnZXJlZCB3aGVuIGVudGVyaW5nIGEgbm9kZSBhIHNwZWNpZmljIGtpbmQuXG4gKlxuICogICAgIHZpc2l0KGFzdCwge1xuICogICAgICAgS2luZChub2RlKSB7XG4gKiAgICAgICAgIC8vIGVudGVyIHRoZSBcIktpbmRcIiBub2RlXG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqXG4gKiAyKSBOYW1lZCB2aXNpdG9ycyB0aGF0IHRyaWdnZXIgdXBvbiBlbnRlcmluZyBhbmQgbGVhdmluZyBhIG5vZGUgb2ZcbiAqICAgIGEgc3BlY2lmaWMga2luZC5cbiAqXG4gKiAgICAgdmlzaXQoYXN0LCB7XG4gKiAgICAgICBLaW5kOiB7XG4gKiAgICAgICAgIGVudGVyKG5vZGUpIHtcbiAqICAgICAgICAgICAvLyBlbnRlciB0aGUgXCJLaW5kXCIgbm9kZVxuICogICAgICAgICB9XG4gKiAgICAgICAgIGxlYXZlKG5vZGUpIHtcbiAqICAgICAgICAgICAvLyBsZWF2ZSB0aGUgXCJLaW5kXCIgbm9kZVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqXG4gKiAzKSBHZW5lcmljIHZpc2l0b3JzIHRoYXQgdHJpZ2dlciB1cG9uIGVudGVyaW5nIGFuZCBsZWF2aW5nIGFueSBub2RlLlxuICpcbiAqICAgICB2aXNpdChhc3QsIHtcbiAqICAgICAgIGVudGVyKG5vZGUpIHtcbiAqICAgICAgICAgLy8gZW50ZXIgYW55IG5vZGVcbiAqICAgICAgIH0sXG4gKiAgICAgICBsZWF2ZShub2RlKSB7XG4gKiAgICAgICAgIC8vIGxlYXZlIGFueSBub2RlXG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqXG4gKiA0KSBQYXJhbGxlbCB2aXNpdG9ycyBmb3IgZW50ZXJpbmcgYW5kIGxlYXZpbmcgbm9kZXMgb2YgYSBzcGVjaWZpYyBraW5kLlxuICpcbiAqICAgICB2aXNpdChhc3QsIHtcbiAqICAgICAgIGVudGVyOiB7XG4gKiAgICAgICAgIEtpbmQobm9kZSkge1xuICogICAgICAgICAgIC8vIGVudGVyIHRoZSBcIktpbmRcIiBub2RlXG4gKiAgICAgICAgIH1cbiAqICAgICAgIH0sXG4gKiAgICAgICBsZWF2ZToge1xuICogICAgICAgICBLaW5kKG5vZGUpIHtcbiAqICAgICAgICAgICAvLyBsZWF2ZSB0aGUgXCJLaW5kXCIgbm9kZVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdmlzaXQocm9vdCwgdmlzaXRvcikge1xuICB2YXIgdmlzaXRvcktleXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFF1ZXJ5RG9jdW1lbnRLZXlzO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmLWluaXQgKi9cbiAgdmFyIHN0YWNrID0gdW5kZWZpbmVkO1xuICB2YXIgaW5BcnJheSA9IEFycmF5LmlzQXJyYXkocm9vdCk7XG4gIHZhciBrZXlzID0gW3Jvb3RdO1xuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIGVkaXRzID0gW107XG4gIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuICB2YXIgcGFyZW50ID0gdW5kZWZpbmVkO1xuICB2YXIgcGF0aCA9IFtdO1xuICB2YXIgYW5jZXN0b3JzID0gW107XG4gIHZhciBuZXdSb290ID0gcm9vdDtcbiAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZi1pbml0ICovXG5cbiAgZG8ge1xuICAgIGluZGV4Kys7XG4gICAgdmFyIGlzTGVhdmluZyA9IGluZGV4ID09PSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaXNFZGl0ZWQgPSBpc0xlYXZpbmcgJiYgZWRpdHMubGVuZ3RoICE9PSAwO1xuXG4gICAgaWYgKGlzTGVhdmluZykge1xuICAgICAga2V5ID0gYW5jZXN0b3JzLmxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBhbmNlc3RvcnMucG9wKCk7XG5cbiAgICAgIGlmIChpc0VkaXRlZCkge1xuICAgICAgICBpZiAoaW5BcnJheSkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNsaWNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNsb25lID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfT2JqZWN0JGtleXMyID0gT2JqZWN0LmtleXMobm9kZSk7IF9pMiA8IF9PYmplY3Qka2V5czIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgdmFyIGsgPSBfT2JqZWN0JGtleXMyW19pMl07XG4gICAgICAgICAgICBjbG9uZVtrXSA9IG5vZGVba107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZSA9IGNsb25lO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRPZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBlZGl0cy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICB2YXIgZWRpdEtleSA9IGVkaXRzW2lpXVswXTtcbiAgICAgICAgICB2YXIgZWRpdFZhbHVlID0gZWRpdHNbaWldWzFdO1xuXG4gICAgICAgICAgaWYgKGluQXJyYXkpIHtcbiAgICAgICAgICAgIGVkaXRLZXkgLT0gZWRpdE9mZnNldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5BcnJheSAmJiBlZGl0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuc3BsaWNlKGVkaXRLZXksIDEpO1xuICAgICAgICAgICAgZWRpdE9mZnNldCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlW2VkaXRLZXldID0gZWRpdFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbmRleCA9IHN0YWNrLmluZGV4O1xuICAgICAga2V5cyA9IHN0YWNrLmtleXM7XG4gICAgICBlZGl0cyA9IHN0YWNrLmVkaXRzO1xuICAgICAgaW5BcnJheSA9IHN0YWNrLmluQXJyYXk7XG4gICAgICBzdGFjayA9IHN0YWNrLnByZXY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IHBhcmVudCA/IGluQXJyYXkgPyBpbmRleCA6IGtleXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgbm9kZSA9IHBhcmVudCA/IHBhcmVudFtrZXldIDogbmV3Um9vdDtcblxuICAgICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGlmICghaXNOb2RlKG5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBBU1QgTm9kZTogJyArIGluc3BlY3Qobm9kZSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmlzaXRGbiA9IGdldFZpc2l0Rm4odmlzaXRvciwgbm9kZS5raW5kLCBpc0xlYXZpbmcpO1xuXG4gICAgICBpZiAodmlzaXRGbikge1xuICAgICAgICByZXN1bHQgPSB2aXNpdEZuLmNhbGwodmlzaXRvciwgbm9kZSwga2V5LCBwYXJlbnQsIHBhdGgsIGFuY2VzdG9ycyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gQlJFQUspIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCFpc0xlYXZpbmcpIHtcbiAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGl0cy5wdXNoKFtrZXksIHJlc3VsdF0pO1xuXG4gICAgICAgICAgaWYgKCFpc0xlYXZpbmcpIHtcbiAgICAgICAgICAgIGlmIChpc05vZGUocmVzdWx0KSkge1xuICAgICAgICAgICAgICBub2RlID0gcmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGlzRWRpdGVkKSB7XG4gICAgICBlZGl0cy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgICB9XG5cbiAgICBpZiAoaXNMZWF2aW5nKSB7XG4gICAgICBwYXRoLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjayA9IHtcbiAgICAgICAgaW5BcnJheTogaW5BcnJheSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBrZXlzOiBrZXlzLFxuICAgICAgICBlZGl0czogZWRpdHMsXG4gICAgICAgIHByZXY6IHN0YWNrXG4gICAgICB9O1xuICAgICAgaW5BcnJheSA9IEFycmF5LmlzQXJyYXkobm9kZSk7XG4gICAgICBrZXlzID0gaW5BcnJheSA/IG5vZGUgOiB2aXNpdG9yS2V5c1tub2RlLmtpbmRdIHx8IFtdO1xuICAgICAgaW5kZXggPSAtMTtcbiAgICAgIGVkaXRzID0gW107XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2gocGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICB9XG4gIH0gd2hpbGUgKHN0YWNrICE9PSB1bmRlZmluZWQpO1xuXG4gIGlmIChlZGl0cy5sZW5ndGggIT09IDApIHtcbiAgICBuZXdSb290ID0gZWRpdHNbZWRpdHMubGVuZ3RoIC0gMV1bMV07XG4gIH1cblxuICByZXR1cm4gbmV3Um9vdDtcbn1cblxuZnVuY3Rpb24gaXNOb2RlKG1heWJlTm9kZSkge1xuICByZXR1cm4gQm9vbGVhbihtYXliZU5vZGUgJiYgdHlwZW9mIG1heWJlTm9kZS5raW5kID09PSAnc3RyaW5nJyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmlzaXRvciBpbnN0YW5jZSB3aGljaCBkZWxlZ2F0ZXMgdG8gbWFueSB2aXNpdG9ycyB0byBydW4gaW5cbiAqIHBhcmFsbGVsLiBFYWNoIHZpc2l0b3Igd2lsbCBiZSB2aXNpdGVkIGZvciBlYWNoIG5vZGUgYmVmb3JlIG1vdmluZyBvbi5cbiAqXG4gKiBJZiBhIHByaW9yIHZpc2l0b3IgZWRpdHMgYSBub2RlLCBubyBmb2xsb3dpbmcgdmlzaXRvcnMgd2lsbCBzZWUgdGhhdCBub2RlLlxuICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0SW5QYXJhbGxlbCh2aXNpdG9ycykge1xuICB2YXIgc2tpcHBpbmcgPSBuZXcgQXJyYXkodmlzaXRvcnMubGVuZ3RoKTtcbiAgcmV0dXJuIHtcbiAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIobm9kZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aXNpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXNraXBwaW5nW2ldKSB7XG4gICAgICAgICAgdmFyIGZuID0gZ2V0VmlzaXRGbih2aXNpdG9yc1tpXSwgbm9kZS5raW5kLFxuICAgICAgICAgIC8qIGlzTGVhdmluZyAqL1xuICAgICAgICAgIGZhbHNlKTtcblxuICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KHZpc2l0b3JzW2ldLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBza2lwcGluZ1tpXSA9IG5vZGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgc2tpcHBpbmdbaV0gPSBCUkVBSztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxlYXZlOiBmdW5jdGlvbiBsZWF2ZShub2RlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpc2l0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghc2tpcHBpbmdbaV0pIHtcbiAgICAgICAgICB2YXIgZm4gPSBnZXRWaXNpdEZuKHZpc2l0b3JzW2ldLCBub2RlLmtpbmQsXG4gICAgICAgICAgLyogaXNMZWF2aW5nICovXG4gICAgICAgICAgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh2aXNpdG9yc1tpXSwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgc2tpcHBpbmdbaV0gPSBCUkVBSztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChza2lwcGluZ1tpXSA9PT0gbm9kZSkge1xuICAgICAgICAgIHNraXBwaW5nW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2aXNpdG9yIGluc3RhbmNlIHdoaWNoIG1haW50YWlucyBhIHByb3ZpZGVkIFR5cGVJbmZvIGluc3RhbmNlXG4gKiBhbG9uZyB3aXRoIHZpc2l0aW5nIHZpc2l0b3IuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0V2l0aFR5cGVJbmZvKHR5cGVJbmZvLCB2aXNpdG9yKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKG5vZGUpIHtcbiAgICAgIHR5cGVJbmZvLmVudGVyKG5vZGUpO1xuICAgICAgdmFyIGZuID0gZ2V0VmlzaXRGbih2aXNpdG9yLCBub2RlLmtpbmQsXG4gICAgICAvKiBpc0xlYXZpbmcgKi9cbiAgICAgIGZhbHNlKTtcblxuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh2aXNpdG9yLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHR5cGVJbmZvLmxlYXZlKG5vZGUpO1xuXG4gICAgICAgICAgaWYgKGlzTm9kZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0eXBlSW5mby5lbnRlcihyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBsZWF2ZTogZnVuY3Rpb24gbGVhdmUobm9kZSkge1xuICAgICAgdmFyIGZuID0gZ2V0VmlzaXRGbih2aXNpdG9yLCBub2RlLmtpbmQsXG4gICAgICAvKiBpc0xlYXZpbmcgKi9cbiAgICAgIHRydWUpO1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KHZpc2l0b3IsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHR5cGVJbmZvLmxlYXZlKG5vZGUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG4vKipcbiAqIEdpdmVuIGEgdmlzaXRvciBpbnN0YW5jZSwgaWYgaXQgaXMgbGVhdmluZyBvciBub3QsIGFuZCBhIG5vZGUga2luZCwgcmV0dXJuXG4gKiB0aGUgZnVuY3Rpb24gdGhlIHZpc2l0b3IgcnVudGltZSBzaG91bGQgY2FsbC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmlzaXRGbih2aXNpdG9yLCBraW5kLCBpc0xlYXZpbmcpIHtcbiAgdmFyIGtpbmRWaXNpdG9yID0gdmlzaXRvcltraW5kXTtcblxuICBpZiAoa2luZFZpc2l0b3IpIHtcbiAgICBpZiAoIWlzTGVhdmluZyAmJiB0eXBlb2Yga2luZFZpc2l0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHsgS2luZCgpIHt9IH1cbiAgICAgIHJldHVybiBraW5kVmlzaXRvcjtcbiAgICB9XG5cbiAgICB2YXIga2luZFNwZWNpZmljVmlzaXRvciA9IGlzTGVhdmluZyA/IGtpbmRWaXNpdG9yLmxlYXZlIDoga2luZFZpc2l0b3IuZW50ZXI7XG5cbiAgICBpZiAodHlwZW9mIGtpbmRTcGVjaWZpY1Zpc2l0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHsgS2luZDogeyBlbnRlcigpIHt9LCBsZWF2ZSgpIHt9IH0gfVxuICAgICAgcmV0dXJuIGtpbmRTcGVjaWZpY1Zpc2l0b3I7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzcGVjaWZpY1Zpc2l0b3IgPSBpc0xlYXZpbmcgPyB2aXNpdG9yLmxlYXZlIDogdmlzaXRvci5lbnRlcjtcblxuICAgIGlmIChzcGVjaWZpY1Zpc2l0b3IpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3BlY2lmaWNWaXNpdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHsgZW50ZXIoKSB7fSwgbGVhdmUoKSB7fSB9XG4gICAgICAgIHJldHVybiBzcGVjaWZpY1Zpc2l0b3I7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcGVjaWZpY0tpbmRWaXNpdG9yID0gc3BlY2lmaWNWaXNpdG9yW2tpbmRdO1xuXG4gICAgICBpZiAodHlwZW9mIHNwZWNpZmljS2luZFZpc2l0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8geyBlbnRlcjogeyBLaW5kKCkge30gfSwgbGVhdmU6IHsgS2luZCgpIHt9IH0gfVxuICAgICAgICByZXR1cm4gc3BlY2lmaWNLaW5kVmlzaXRvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return equal; });\nvar _a = Object.prototype, toString = _a.toString, hasOwnProperty = _a.hasOwnProperty;\r\nvar previousComparisons = new Map();\r\n/**\r\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\r\n */\r\nfunction equal(a, b) {\r\n    try {\r\n        return check(a, b);\r\n    }\r\n    finally {\r\n        previousComparisons.clear();\r\n    }\r\n}\r\nfunction check(a, b) {\r\n    // If the two values are strictly equal, our job is easy.\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    // Object.prototype.toString returns a representation of the runtime type of\r\n    // the given value that is considerably more precise than typeof.\r\n    var aTag = toString.call(a);\r\n    var bTag = toString.call(b);\r\n    // If the runtime types of a and b are different, they could maybe be equal\r\n    // under some interpretation of equality, but for simplicity and performance\r\n    // we just return false instead.\r\n    if (aTag !== bTag) {\r\n        return false;\r\n    }\r\n    switch (aTag) {\r\n        case '[object Array]':\r\n            // Arrays are a lot like other objects, but we can cheaply compare their\r\n            // lengths as a short-cut before comparing their elements.\r\n            if (a.length !== b.length)\r\n                return false;\r\n        // Fall through to object case...\r\n        case '[object Object]': {\r\n            if (previouslyCompared(a, b))\r\n                return true;\r\n            var aKeys = Object.keys(a);\r\n            var bKeys = Object.keys(b);\r\n            // If `a` and `b` have a different number of enumerable keys, they\r\n            // must be different.\r\n            var keyCount = aKeys.length;\r\n            if (keyCount !== bKeys.length)\r\n                return false;\r\n            // Now make sure they have the same keys.\r\n            for (var k = 0; k < keyCount; ++k) {\r\n                if (!hasOwnProperty.call(b, aKeys[k])) {\r\n                    return false;\r\n                }\r\n            }\r\n            // Finally, check deep equality of all child properties.\r\n            for (var k = 0; k < keyCount; ++k) {\r\n                var key = aKeys[k];\r\n                if (!check(a[key], b[key])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        case '[object Error]':\r\n            return a.name === b.name && a.message === b.message;\r\n        case '[object Number]':\r\n            // Handle NaN, which is !== itself.\r\n            if (a !== a)\r\n                return b !== b;\r\n        // Fall through to shared +a === +b case...\r\n        case '[object Boolean]':\r\n        case '[object Date]':\r\n            return +a === +b;\r\n        case '[object RegExp]':\r\n        case '[object String]':\r\n            return a == \"\" + b;\r\n        case '[object Map]':\r\n        case '[object Set]': {\r\n            if (a.size !== b.size)\r\n                return false;\r\n            if (previouslyCompared(a, b))\r\n                return true;\r\n            var aIterator = a.entries();\r\n            var isMap = aTag === '[object Map]';\r\n            while (true) {\r\n                var info = aIterator.next();\r\n                if (info.done)\r\n                    break;\r\n                // If a instanceof Set, aValue === aKey.\r\n                var _a = info.value, aKey = _a[0], aValue = _a[1];\r\n                // So this works the same way for both Set and Map.\r\n                if (!b.has(aKey)) {\r\n                    return false;\r\n                }\r\n                // However, we care about deep equality of values only when dealing\r\n                // with Map structures.\r\n                if (isMap && !check(aValue, b.get(aKey))) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    // Otherwise the values are not equal.\r\n    return false;\r\n}\r\nfunction previouslyCompared(a, b) {\r\n    // Though cyclic references can make an object graph appear infinite from the\r\n    // perspective of a depth-first traversal, the graph still contains a finite\r\n    // number of distinct object references. We use the previousComparisons cache\r\n    // to avoid comparing the same pair of object references more than once, which\r\n    // guarantees termination (even if we end up comparing every object in one\r\n    // graph to every object in the other graph, which is extremely unlikely),\r\n    // while still allowing weird isomorphic structures (like rings with different\r\n    // lengths) a chance to pass the equality test.\r\n    var bSet = previousComparisons.get(a);\r\n    if (bSet) {\r\n        // Return true here because we can be sure false will be returned somewhere\r\n        // else if the objects are not equivalent.\r\n        if (bSet.has(b))\r\n            return true;\r\n    }\r\n    else {\r\n        previousComparisons.set(a, bSet = new Set);\r\n    }\r\n    bSet.add(b);\r\n    return false;\r\n}\n\n/* unused harmony default export */ var _unused_webpack_default_export = (equal);\n\n//# sourceMappingURL=equality.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad3J5L2VxdWFsaXR5L2xpYi9lcXVhbGl0eS5lc20uanM/YWIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2EgPSBPYmplY3QucHJvdG90eXBlLCB0b1N0cmluZyA9IF9hLnRvU3RyaW5nLCBoYXNPd25Qcm9wZXJ0eSA9IF9hLmhhc093blByb3BlcnR5O1xyXG52YXIgcHJldmlvdXNDb21wYXJpc29ucyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgZGVlcCBlcXVhbGl0eSBjaGVjayBvbiB0d28gSmF2YVNjcmlwdCB2YWx1ZXMsIHRvbGVyYXRpbmcgY3ljbGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZXF1YWwoYSwgYikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gY2hlY2soYSwgYik7XHJcbiAgICB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICBwcmV2aW91c0NvbXBhcmlzb25zLmNsZWFyKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2soYSwgYikge1xyXG4gICAgLy8gSWYgdGhlIHR3byB2YWx1ZXMgYXJlIHN0cmljdGx5IGVxdWFsLCBvdXIgam9iIGlzIGVhc3kuXHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyByZXR1cm5zIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bnRpbWUgdHlwZSBvZlxyXG4gICAgLy8gdGhlIGdpdmVuIHZhbHVlIHRoYXQgaXMgY29uc2lkZXJhYmx5IG1vcmUgcHJlY2lzZSB0aGFuIHR5cGVvZi5cclxuICAgIHZhciBhVGFnID0gdG9TdHJpbmcuY2FsbChhKTtcclxuICAgIHZhciBiVGFnID0gdG9TdHJpbmcuY2FsbChiKTtcclxuICAgIC8vIElmIHRoZSBydW50aW1lIHR5cGVzIG9mIGEgYW5kIGIgYXJlIGRpZmZlcmVudCwgdGhleSBjb3VsZCBtYXliZSBiZSBlcXVhbFxyXG4gICAgLy8gdW5kZXIgc29tZSBpbnRlcnByZXRhdGlvbiBvZiBlcXVhbGl0eSwgYnV0IGZvciBzaW1wbGljaXR5IGFuZCBwZXJmb3JtYW5jZVxyXG4gICAgLy8gd2UganVzdCByZXR1cm4gZmFsc2UgaW5zdGVhZC5cclxuICAgIGlmIChhVGFnICE9PSBiVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChhVGFnKSB7XHJcbiAgICAgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOlxyXG4gICAgICAgICAgICAvLyBBcnJheXMgYXJlIGEgbG90IGxpa2Ugb3RoZXIgb2JqZWN0cywgYnV0IHdlIGNhbiBjaGVhcGx5IGNvbXBhcmUgdGhlaXJcclxuICAgICAgICAgICAgLy8gbGVuZ3RocyBhcyBhIHNob3J0LWN1dCBiZWZvcmUgY29tcGFyaW5nIHRoZWlyIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBvYmplY3QgY2FzZS4uLlxyXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgT2JqZWN0XSc6IHtcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzbHlDb21wYXJlZChhLCBiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcclxuICAgICAgICAgICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XHJcbiAgICAgICAgICAgIC8vIElmIGBhYCBhbmQgYGJgIGhhdmUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVudW1lcmFibGUga2V5cywgdGhleVxyXG4gICAgICAgICAgICAvLyBtdXN0IGJlIGRpZmZlcmVudC5cclxuICAgICAgICAgICAgdmFyIGtleUNvdW50ID0gYUtleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoa2V5Q291bnQgIT09IGJLZXlzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgLy8gTm93IG1ha2Ugc3VyZSB0aGV5IGhhdmUgdGhlIHNhbWUga2V5cy5cclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBrZXlDb3VudDsgKytrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoYiwgYUtleXNba10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIGNoZWNrIGRlZXAgZXF1YWxpdHkgb2YgYWxsIGNoaWxkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwga2V5Q291bnQ7ICsraykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGFLZXlzW2tdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGVjayhhW2tleV0sIGJba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzpcclxuICAgICAgICAgICAgcmV0dXJuIGEubmFtZSA9PT0gYi5uYW1lICYmIGEubWVzc2FnZSA9PT0gYi5tZXNzYWdlO1xyXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBOYU4sIHdoaWNoIGlzICE9PSBpdHNlbGYuXHJcbiAgICAgICAgICAgIGlmIChhICE9PSBhKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgIT09IGI7XHJcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoIHRvIHNoYXJlZCArYSA9PT0gK2IgY2FzZS4uLlxyXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxyXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxyXG4gICAgICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xyXG4gICAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XHJcbiAgICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcclxuICAgICAgICAgICAgcmV0dXJuIGEgPT0gXCJcIiArIGI7XHJcbiAgICAgICAgY2FzZSAnW29iamVjdCBNYXBdJzpcclxuICAgICAgICBjYXNlICdbb2JqZWN0IFNldF0nOiB7XHJcbiAgICAgICAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzbHlDb21wYXJlZChhLCBiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgYUl0ZXJhdG9yID0gYS5lbnRyaWVzKCk7XHJcbiAgICAgICAgICAgIHZhciBpc01hcCA9IGFUYWcgPT09ICdbb2JqZWN0IE1hcF0nO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBhSXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZm8uZG9uZSlcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIC8vIElmIGEgaW5zdGFuY2VvZiBTZXQsIGFWYWx1ZSA9PT0gYUtleS5cclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IGluZm8udmFsdWUsIGFLZXkgPSBfYVswXSwgYVZhbHVlID0gX2FbMV07XHJcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGlzIHdvcmtzIHRoZSBzYW1lIHdheSBmb3IgYm90aCBTZXQgYW5kIE1hcC5cclxuICAgICAgICAgICAgICAgIGlmICghYi5oYXMoYUtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCB3ZSBjYXJlIGFib3V0IGRlZXAgZXF1YWxpdHkgb2YgdmFsdWVzIG9ubHkgd2hlbiBkZWFsaW5nXHJcbiAgICAgICAgICAgICAgICAvLyB3aXRoIE1hcCBzdHJ1Y3R1cmVzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTWFwICYmICFjaGVjayhhVmFsdWUsIGIuZ2V0KGFLZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBPdGhlcndpc2UgdGhlIHZhbHVlcyBhcmUgbm90IGVxdWFsLlxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHByZXZpb3VzbHlDb21wYXJlZChhLCBiKSB7XHJcbiAgICAvLyBUaG91Z2ggY3ljbGljIHJlZmVyZW5jZXMgY2FuIG1ha2UgYW4gb2JqZWN0IGdyYXBoIGFwcGVhciBpbmZpbml0ZSBmcm9tIHRoZVxyXG4gICAgLy8gcGVyc3BlY3RpdmUgb2YgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwsIHRoZSBncmFwaCBzdGlsbCBjb250YWlucyBhIGZpbml0ZVxyXG4gICAgLy8gbnVtYmVyIG9mIGRpc3RpbmN0IG9iamVjdCByZWZlcmVuY2VzLiBXZSB1c2UgdGhlIHByZXZpb3VzQ29tcGFyaXNvbnMgY2FjaGVcclxuICAgIC8vIHRvIGF2b2lkIGNvbXBhcmluZyB0aGUgc2FtZSBwYWlyIG9mIG9iamVjdCByZWZlcmVuY2VzIG1vcmUgdGhhbiBvbmNlLCB3aGljaFxyXG4gICAgLy8gZ3VhcmFudGVlcyB0ZXJtaW5hdGlvbiAoZXZlbiBpZiB3ZSBlbmQgdXAgY29tcGFyaW5nIGV2ZXJ5IG9iamVjdCBpbiBvbmVcclxuICAgIC8vIGdyYXBoIHRvIGV2ZXJ5IG9iamVjdCBpbiB0aGUgb3RoZXIgZ3JhcGgsIHdoaWNoIGlzIGV4dHJlbWVseSB1bmxpa2VseSksXHJcbiAgICAvLyB3aGlsZSBzdGlsbCBhbGxvd2luZyB3ZWlyZCBpc29tb3JwaGljIHN0cnVjdHVyZXMgKGxpa2UgcmluZ3Mgd2l0aCBkaWZmZXJlbnRcclxuICAgIC8vIGxlbmd0aHMpIGEgY2hhbmNlIHRvIHBhc3MgdGhlIGVxdWFsaXR5IHRlc3QuXHJcbiAgICB2YXIgYlNldCA9IHByZXZpb3VzQ29tcGFyaXNvbnMuZ2V0KGEpO1xyXG4gICAgaWYgKGJTZXQpIHtcclxuICAgICAgICAvLyBSZXR1cm4gdHJ1ZSBoZXJlIGJlY2F1c2Ugd2UgY2FuIGJlIHN1cmUgZmFsc2Ugd2lsbCBiZSByZXR1cm5lZCBzb21ld2hlcmVcclxuICAgICAgICAvLyBlbHNlIGlmIHRoZSBvYmplY3RzIGFyZSBub3QgZXF1aXZhbGVudC5cclxuICAgICAgICBpZiAoYlNldC5oYXMoYikpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHJldmlvdXNDb21wYXJpc29ucy5zZXQoYSwgYlNldCA9IG5ldyBTZXQpO1xyXG4gICAgfVxyXG4gICAgYlNldC5hZGQoYik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWw7XG5leHBvcnQgeyBlcXVhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWxpdHkuZXNtLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){eval("var parser = __webpack_require__(44);\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaHFsLXRhZy9zcmMvaW5kZXguanM/OTUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcGFyc2VyID0gcmVxdWlyZSgnZ3JhcGhxbC9sYW5ndWFnZS9wYXJzZXInKTtcblxudmFyIHBhcnNlID0gcGFyc2VyLnBhcnNlO1xuXG4vLyBTdHJpcCBpbnNpZ25pZmljYW50IHdoaXRlc3BhY2Vcbi8vIE5vdGUgdGhhdCB0aGlzIGNvdWxkIGRvIGEgbG90IG1vcmUsIHN1Y2ggYXMgcmVvcmRlciBmaWVsZHMgZXRjLlxuZnVuY3Rpb24gbm9ybWFsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXHMsXSsvZywgJyAnKS50cmltKCk7XG59XG5cbi8vIEEgbWFwIGRvY1N0cmluZyAtPiBncmFwaHFsIGRvY3VtZW50XG52YXIgZG9jQ2FjaGUgPSB7fTtcblxuLy8gQSBtYXAgZnJhZ21lbnROYW1lIC0+IFtub3JtYWxpemVkIHNvdXJjZV1cbnZhciBmcmFnbWVudFNvdXJjZU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBjYWNoZUtleUZyb21Mb2MobG9jKSB7XG4gIHJldHVybiBub3JtYWxpemUobG9jLnNvdXJjZS5ib2R5LnN1YnN0cmluZyhsb2Muc3RhcnQsIGxvYy5lbmQpKTtcbn1cblxuLy8gRm9yIHRlc3RpbmcuXG5mdW5jdGlvbiByZXNldENhY2hlcygpIHtcbiAgZG9jQ2FjaGUgPSB7fTtcbiAgZnJhZ21lbnRTb3VyY2VNYXAgPSB7fTtcbn1cblxuLy8gVGFrZSBhIHVuc3RyaXBwZWQgcGFyc2VkIGRvY3VtZW50IChxdWVyeS9tdXRhdGlvbiBvciBldmVuIGZyYWdtZW50KSwgYW5kXG4vLyBjaGVjayBhbGwgZnJhZ21lbnQgZGVmaW5pdGlvbnMsIGNoZWNraW5nIGZvciBuYW1lLT5zb3VyY2UgdW5pcXVlbmVzcy5cbi8vIFdlIGFsc28gd2FudCB0byBtYWtlIHN1cmUgb25seSB1bmlxdWUgZnJhZ21lbnRzIGV4aXN0IGluIHRoZSBkb2N1bWVudC5cbnZhciBwcmludEZyYWdtZW50V2FybmluZ3MgPSB0cnVlO1xuZnVuY3Rpb24gcHJvY2Vzc0ZyYWdtZW50cyhhc3QpIHtcbiAgdmFyIGFzdEZyYWdtZW50TWFwID0ge307XG4gIHZhciBkZWZpbml0aW9ucyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LmRlZmluaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGZyYWdtZW50RGVmaW5pdGlvbiA9IGFzdC5kZWZpbml0aW9uc1tpXTtcblxuICAgIGlmIChmcmFnbWVudERlZmluaXRpb24ua2luZCA9PT0gJ0ZyYWdtZW50RGVmaW5pdGlvbicpIHtcbiAgICAgIHZhciBmcmFnbWVudE5hbWUgPSBmcmFnbWVudERlZmluaXRpb24ubmFtZS52YWx1ZTtcbiAgICAgIHZhciBzb3VyY2VLZXkgPSBjYWNoZUtleUZyb21Mb2MoZnJhZ21lbnREZWZpbml0aW9uLmxvYyk7XG5cbiAgICAgIC8vIFdlIGtub3cgc29tZXRoaW5nIGFib3V0IHRoaXMgZnJhZ21lbnRcbiAgICAgIGlmIChmcmFnbWVudFNvdXJjZU1hcC5oYXNPd25Qcm9wZXJ0eShmcmFnbWVudE5hbWUpICYmICFmcmFnbWVudFNvdXJjZU1hcFtmcmFnbWVudE5hbWVdW3NvdXJjZUtleV0pIHtcblxuICAgICAgICAvLyB0aGlzIGlzIGEgcHJvYmxlbSBiZWNhdXNlIHRoZSBhcHAgZGV2ZWxvcGVyIGlzIHRyeWluZyB0byByZWdpc3RlciBhbm90aGVyIGZyYWdtZW50IHdpdGhcbiAgICAgICAgLy8gdGhlIHNhbWUgbmFtZSBhcyBvbmUgcHJldmlvdXNseSByZWdpc3RlcmVkLiBTbywgd2UgdGVsbCB0aGVtIGFib3V0IGl0LlxuICAgICAgICBpZiAocHJpbnRGcmFnbWVudFdhcm5pbmdzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogZnJhZ21lbnQgd2l0aCBuYW1lIFwiICsgZnJhZ21lbnROYW1lICsgXCIgYWxyZWFkeSBleGlzdHMuXFxuXCJcbiAgICAgICAgICAgICsgXCJncmFwaHFsLXRhZyBlbmZvcmNlcyBhbGwgZnJhZ21lbnQgbmFtZXMgYWNyb3NzIHlvdXIgYXBwbGljYXRpb24gdG8gYmUgdW5pcXVlOyByZWFkIG1vcmUgYWJvdXRcXG5cIlxuICAgICAgICAgICAgKyBcInRoaXMgaW4gdGhlIGRvY3M6IGh0dHA6Ly9kZXYuYXBvbGxvZGF0YS5jb20vY29yZS9mcmFnbWVudHMuaHRtbCN1bmlxdWUtbmFtZXNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudFNvdXJjZU1hcFtmcmFnbWVudE5hbWVdW3NvdXJjZUtleV0gPSB0cnVlO1xuXG4gICAgICB9IGVsc2UgaWYgKCFmcmFnbWVudFNvdXJjZU1hcC5oYXNPd25Qcm9wZXJ0eShmcmFnbWVudE5hbWUpKSB7XG4gICAgICAgIGZyYWdtZW50U291cmNlTWFwW2ZyYWdtZW50TmFtZV0gPSB7fTtcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VNYXBbZnJhZ21lbnROYW1lXVtzb3VyY2VLZXldID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhc3RGcmFnbWVudE1hcFtzb3VyY2VLZXldKSB7XG4gICAgICAgIGFzdEZyYWdtZW50TWFwW3NvdXJjZUtleV0gPSB0cnVlO1xuICAgICAgICBkZWZpbml0aW9ucy5wdXNoKGZyYWdtZW50RGVmaW5pdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluaXRpb25zLnB1c2goZnJhZ21lbnREZWZpbml0aW9uKTtcbiAgICB9XG4gIH1cblxuICBhc3QuZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbiAgcmV0dXJuIGFzdDtcbn1cblxuZnVuY3Rpb24gZGlzYWJsZUZyYWdtZW50V2FybmluZ3MoKSB7XG4gIHByaW50RnJhZ21lbnRXYXJuaW5ncyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzdHJpcExvYyhkb2MsIHJlbW92ZUxvY0F0VGhpc0xldmVsKSB7XG4gIHZhciBkb2NUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvYyk7XG5cbiAgaWYgKGRvY1R5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gZG9jLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIHN0cmlwTG9jKGQsIHJlbW92ZUxvY0F0VGhpc0xldmVsKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChkb2NUeXBlICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dC4nKTtcbiAgfVxuXG4gIC8vIFdlIGRvbid0IHdhbnQgdG8gcmVtb3ZlIHRoZSByb290IGxvYyBmaWVsZCBzbyB3ZSBjYW4gdXNlIGl0XG4gIC8vIGZvciBmcmFnbWVudCBzdWJzdGl0dXRpb24gKHNlZSBiZWxvdylcbiAgaWYgKHJlbW92ZUxvY0F0VGhpc0xldmVsICYmIGRvYy5sb2MpIHtcbiAgICBkZWxldGUgZG9jLmxvYztcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcG9sbG9ncmFwaHFsL2dyYXBocWwtdGFnL2lzc3Vlcy80MFxuICBpZiAoZG9jLmxvYykge1xuICAgIGRlbGV0ZSBkb2MubG9jLnN0YXJ0VG9rZW47XG4gICAgZGVsZXRlIGRvYy5sb2MuZW5kVG9rZW47XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRvYyk7XG4gIHZhciBrZXk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZhbHVlVHlwZTtcblxuICBmb3IgKGtleSBpbiBrZXlzKSB7XG4gICAgaWYgKGtleXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFsdWUgPSBkb2Nba2V5c1trZXldXTtcbiAgICAgIHZhbHVlVHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cbiAgICAgIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBkb2Nba2V5c1trZXldXSA9IHN0cmlwTG9jKHZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZG9jO1xufVxuXG52YXIgZXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXMgPSBmYWxzZTtcbmZ1bmN0aW9uIHBhcnNlRG9jdW1lbnQoZG9jKSB7XG4gIHZhciBjYWNoZUtleSA9IG5vcm1hbGl6ZShkb2MpO1xuXG4gIGlmIChkb2NDYWNoZVtjYWNoZUtleV0pIHtcbiAgICByZXR1cm4gZG9jQ2FjaGVbY2FjaGVLZXldO1xuICB9XG5cbiAgdmFyIHBhcnNlZCA9IHBhcnNlKGRvYywgeyBleHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlczogZXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXMgfSk7XG4gIGlmICghcGFyc2VkIHx8IHBhcnNlZC5raW5kICE9PSAnRG9jdW1lbnQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCBHcmFwaFFMIGRvY3VtZW50LicpO1xuICB9XG5cbiAgLy8gY2hlY2sgdGhhdCBhbGwgXCJuZXdcIiBmcmFnbWVudHMgaW5zaWRlIHRoZSBkb2N1bWVudHMgYXJlIGNvbnNpc3RlbnQgd2l0aFxuICAvLyBleGlzdGluZyBmcmFnbWVudHMgb2YgdGhlIHNhbWUgbmFtZVxuICBwYXJzZWQgPSBwcm9jZXNzRnJhZ21lbnRzKHBhcnNlZCk7XG4gIHBhcnNlZCA9IHN0cmlwTG9jKHBhcnNlZCwgZmFsc2UpO1xuICBkb2NDYWNoZVtjYWNoZUtleV0gPSBwYXJzZWQ7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gZW5hYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXMoKSB7XG4gIGV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGlzYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzKCkge1xuICBleHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlcyA9IGZhbHNlO1xufVxuXG4vLyBYWFggVGhpcyBzaG91bGQgZXZlbnR1YWxseSBkaXNhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIGludGVycG9sYXRpb24sIGxpa2UgUmVsYXkgZG9lc1xuZnVuY3Rpb24gZ3FsKC8qIGFyZ3VtZW50cyAqLykge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgdmFyIGxpdGVyYWxzID0gYXJnc1swXTtcblxuICAvLyBXZSBhbHdheXMgZ2V0IGxpdGVyYWxzWzBdIGFuZCB0aGVuIG1hdGNoaW5nIHBvc3QgbGl0ZXJhbHMgZm9yIGVhY2ggYXJnIGdpdmVuXG4gIHZhciByZXN1bHQgPSAodHlwZW9mKGxpdGVyYWxzKSA9PT0gXCJzdHJpbmdcIikgPyBsaXRlcmFscyA6IGxpdGVyYWxzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcmdzW2ldICYmIGFyZ3NbaV0ua2luZCAmJiBhcmdzW2ldLmtpbmQgPT09ICdEb2N1bWVudCcpIHtcbiAgICAgIHJlc3VsdCArPSBhcmdzW2ldLmxvYy5zb3VyY2UuYm9keTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IGFyZ3NbaV07XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IGxpdGVyYWxzW2ldO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlRG9jdW1lbnQocmVzdWx0KTtcbn1cblxuLy8gU3VwcG9ydCB0eXBlc2NyaXB0LCB3aGljaCBpc24ndCBhcyBuaWNlIGFzIEJhYmVsIGFib3V0IGRlZmF1bHQgZXhwb3J0c1xuZ3FsLmRlZmF1bHQgPSBncWw7XG5ncWwucmVzZXRDYWNoZXMgPSByZXNldENhY2hlcztcbmdxbC5kaXNhYmxlRnJhZ21lbnRXYXJuaW5ncyA9IGRpc2FibGVGcmFnbWVudFdhcm5pbmdzO1xuZ3FsLmVuYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzID0gZW5hYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXM7XG5ncWwuZGlzYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzID0gZGlzYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdxbDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n")},function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("var nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;\n/* harmony default export */ __webpack_exports__[\"a\"] = (nodejsCustomInspectSymbol);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL25vZGVqc0N1c3RvbUluc3BlY3RTeW1ib2wubWpzPzQ0YTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG5vZGVqc0N1c3RvbUluc3BlY3RTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nID8gU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSA6IHVuZGVmaW5lZDtcbmV4cG9ydCBkZWZhdWx0IG5vZGVqc0N1c3RvbUluc3BlY3RTeW1ib2w7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n")},,function(module,exports,__webpack_require__){"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(39);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/NGNlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUVBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n")},function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return inspect; });\n/* harmony import */ var _nodejsCustomInspectSymbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\n\nfunction inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (_typeof(value)) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? \"[function \".concat(value.name, \"]\") : '[function]';\n\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (previouslySeenValues.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  var seenValues = [].concat(previouslySeenValues, [value]);\n  var customInspectFn = getCustomFn(value);\n\n  if (customInspectFn !== undefined) {\n    // $FlowFixMe(>=0.90.0)\n    var customValue = customInspectFn.call(value); // check for infinite recursion\n\n    if (customValue !== value) {\n      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction formatObject(object, seenValues) {\n  var keys = Object.keys(object);\n\n  if (keys.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  var properties = keys.map(function (key) {\n    var value = formatValue(object[key], seenValues);\n    return key + ': ' + value;\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  var remaining = array.length - len;\n  var items = [];\n\n  for (var i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(\"... \".concat(remaining, \" more items\"));\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getCustomFn(object) {\n  var customInspectFn = object[String(_nodejsCustomInspectSymbol__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])];\n\n  if (typeof customInspectFn === 'function') {\n    return customInspectFn;\n  }\n\n  if (typeof object.inspect === 'function') {\n    return object.inspect;\n  }\n}\n\nfunction getObjectTag(object) {\n  var tag = Object.prototype.toString.call(object).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof object.constructor === 'function') {\n    var name = object.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2luc3BlY3QubWpzP2FkNjciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuaW1wb3J0IG5vZGVqc0N1c3RvbUluc3BlY3RTeW1ib2wgZnJvbSAnLi9ub2RlanNDdXN0b21JbnNwZWN0U3ltYm9sJztcbnZhciBNQVhfQVJSQVlfTEVOR1RIID0gMTA7XG52YXIgTUFYX1JFQ1VSU0lWRV9ERVBUSCA9IDI7XG4vKipcbiAqIFVzZWQgdG8gcHJpbnQgdmFsdWVzIGluIGVycm9yIG1lc3NhZ2VzLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluc3BlY3QodmFsdWUpIHtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKHZhbHVlLCBbXSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlLCBzZWVuVmFsdWVzKSB7XG4gIHN3aXRjaCAoX3R5cGVvZih2YWx1ZSkpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiB2YWx1ZS5uYW1lID8gXCJbZnVuY3Rpb24gXCIuY29uY2F0KHZhbHVlLm5hbWUsIFwiXVwiKSA6ICdbZnVuY3Rpb25dJztcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvcm1hdE9iamVjdFZhbHVlKHZhbHVlLCBzZWVuVmFsdWVzKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRPYmplY3RWYWx1ZSh2YWx1ZSwgcHJldmlvdXNseVNlZW5WYWx1ZXMpIHtcbiAgaWYgKHByZXZpb3VzbHlTZWVuVmFsdWVzLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gIH1cblxuICB2YXIgc2VlblZhbHVlcyA9IFtdLmNvbmNhdChwcmV2aW91c2x5U2VlblZhbHVlcywgW3ZhbHVlXSk7XG4gIHZhciBjdXN0b21JbnNwZWN0Rm4gPSBnZXRDdXN0b21Gbih2YWx1ZSk7XG5cbiAgaWYgKGN1c3RvbUluc3BlY3RGbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gJEZsb3dGaXhNZSg+PTAuOTAuMClcbiAgICB2YXIgY3VzdG9tVmFsdWUgPSBjdXN0b21JbnNwZWN0Rm4uY2FsbCh2YWx1ZSk7IC8vIGNoZWNrIGZvciBpbmZpbml0ZSByZWN1cnNpb25cblxuICAgIGlmIChjdXN0b21WYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY3VzdG9tVmFsdWUgPT09ICdzdHJpbmcnID8gY3VzdG9tVmFsdWUgOiBmb3JtYXRWYWx1ZShjdXN0b21WYWx1ZSwgc2VlblZhbHVlcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZvcm1hdEFycmF5KHZhbHVlLCBzZWVuVmFsdWVzKTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXRPYmplY3QodmFsdWUsIHNlZW5WYWx1ZXMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRPYmplY3Qob2JqZWN0LCBzZWVuVmFsdWVzKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ3t9JztcbiAgfVxuXG4gIGlmIChzZWVuVmFsdWVzLmxlbmd0aCA+IE1BWF9SRUNVUlNJVkVfREVQVEgpIHtcbiAgICByZXR1cm4gJ1snICsgZ2V0T2JqZWN0VGFnKG9iamVjdCkgKyAnXSc7XG4gIH1cblxuICB2YXIgcHJvcGVydGllcyA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBmb3JtYXRWYWx1ZShvYmplY3Rba2V5XSwgc2VlblZhbHVlcyk7XG4gICAgcmV0dXJuIGtleSArICc6ICcgKyB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiAneyAnICsgcHJvcGVydGllcy5qb2luKCcsICcpICsgJyB9Jztcbn1cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoYXJyYXksIHNlZW5WYWx1ZXMpIHtcbiAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnW10nO1xuICB9XG5cbiAgaWYgKHNlZW5WYWx1ZXMubGVuZ3RoID4gTUFYX1JFQ1VSU0lWRV9ERVBUSCkge1xuICAgIHJldHVybiAnW0FycmF5XSc7XG4gIH1cblxuICB2YXIgbGVuID0gTWF0aC5taW4oTUFYX0FSUkFZX0xFTkdUSCwgYXJyYXkubGVuZ3RoKTtcbiAgdmFyIHJlbWFpbmluZyA9IGFycmF5Lmxlbmd0aCAtIGxlbjtcbiAgdmFyIGl0ZW1zID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGl0ZW1zLnB1c2goZm9ybWF0VmFsdWUoYXJyYXlbaV0sIHNlZW5WYWx1ZXMpKTtcbiAgfVxuXG4gIGlmIChyZW1haW5pbmcgPT09IDEpIHtcbiAgICBpdGVtcy5wdXNoKCcuLi4gMSBtb3JlIGl0ZW0nKTtcbiAgfSBlbHNlIGlmIChyZW1haW5pbmcgPiAxKSB7XG4gICAgaXRlbXMucHVzaChcIi4uLiBcIi5jb25jYXQocmVtYWluaW5nLCBcIiBtb3JlIGl0ZW1zXCIpKTtcbiAgfVxuXG4gIHJldHVybiAnWycgKyBpdGVtcy5qb2luKCcsICcpICsgJ10nO1xufVxuXG5mdW5jdGlvbiBnZXRDdXN0b21GbihvYmplY3QpIHtcbiAgdmFyIGN1c3RvbUluc3BlY3RGbiA9IG9iamVjdFtTdHJpbmcobm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbCldO1xuXG4gIGlmICh0eXBlb2YgY3VzdG9tSW5zcGVjdEZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGN1c3RvbUluc3BlY3RGbjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqZWN0Lmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb2JqZWN0Lmluc3BlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0T2JqZWN0VGFnKG9iamVjdCkge1xuICB2YXIgdGFnID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkucmVwbGFjZSgvXlxcW29iamVjdCAvLCAnJykucmVwbGFjZSgvXSQvLCAnJyk7XG5cbiAgaWYgKHRhZyA9PT0gJ09iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBuYW1lID0gb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIG5hbWUgIT09ICcnKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFnO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n")},function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return dedentBlockStringValue; });\n/* unused harmony export getBlockStringIndentation */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return printBlockString; });\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n */\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n} // @internal\n\nfunction getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\n\n\nfunction printBlockString(value) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isSingleLine = value.indexOf('\\n') === -1;\n  var hasLeadingSpace = value[0] === ' ' || value[0] === '\\t';\n  var hasTrailingQuote = value[value.length - 1] === '\"';\n  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;\n  var result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n' + indentation;\n  }\n\n  result += indentation ? value.replace(/\\n/g, '\\n' + indentation) : value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9ibG9ja1N0cmluZy5tanM/MDRiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByb2R1Y2VzIHRoZSB2YWx1ZSBvZiBhIGJsb2NrIHN0cmluZyBmcm9tIGl0cyBwYXJzZWQgcmF3IHZhbHVlLCBzaW1pbGFyIHRvXG4gKiBDb2ZmZWVTY3JpcHQncyBibG9jayBzdHJpbmcsIFB5dGhvbidzIGRvY3N0cmluZyB0cmltIG9yIFJ1YnkncyBzdHJpcF9oZXJlZG9jLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50cyB0aGUgR3JhcGhRTCBzcGVjJ3MgQmxvY2tTdHJpbmdWYWx1ZSgpIHN0YXRpYyBhbGdvcml0aG0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWRlbnRCbG9ja1N0cmluZ1ZhbHVlKHJhd1N0cmluZykge1xuICAvLyBFeHBhbmQgYSBibG9jayBzdHJpbmcncyByYXcgdmFsdWUgaW50byBpbmRlcGVuZGVudCBsaW5lcy5cbiAgdmFyIGxpbmVzID0gcmF3U3RyaW5nLnNwbGl0KC9cXHJcXG58W1xcblxccl0vZyk7IC8vIFJlbW92ZSBjb21tb24gaW5kZW50YXRpb24gZnJvbSBhbGwgbGluZXMgYnV0IGZpcnN0LlxuXG4gIHZhciBjb21tb25JbmRlbnQgPSBnZXRCbG9ja1N0cmluZ0luZGVudGF0aW9uKGxpbmVzKTtcblxuICBpZiAoY29tbW9uSW5kZW50ICE9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGluZXNbaV0gPSBsaW5lc1tpXS5zbGljZShjb21tb25JbmRlbnQpO1xuICAgIH1cbiAgfSAvLyBSZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgYmxhbmsgbGluZXMuXG5cblxuICB3aGlsZSAobGluZXMubGVuZ3RoID4gMCAmJiBpc0JsYW5rKGxpbmVzWzBdKSkge1xuICAgIGxpbmVzLnNoaWZ0KCk7XG4gIH1cblxuICB3aGlsZSAobGluZXMubGVuZ3RoID4gMCAmJiBpc0JsYW5rKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKSkge1xuICAgIGxpbmVzLnBvcCgpO1xuICB9IC8vIFJldHVybiBhIHN0cmluZyBvZiB0aGUgbGluZXMgam9pbmVkIHdpdGggVSswMDBBLlxuXG5cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufSAvLyBAaW50ZXJuYWxcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJsb2NrU3RyaW5nSW5kZW50YXRpb24obGluZXMpIHtcbiAgdmFyIGNvbW1vbkluZGVudCA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgdmFyIGluZGVudCA9IGxlYWRpbmdXaGl0ZXNwYWNlKGxpbmUpO1xuXG4gICAgaWYgKGluZGVudCA9PT0gbGluZS5sZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBza2lwIGVtcHR5IGxpbmVzXG4gICAgfVxuXG4gICAgaWYgKGNvbW1vbkluZGVudCA9PT0gbnVsbCB8fCBpbmRlbnQgPCBjb21tb25JbmRlbnQpIHtcbiAgICAgIGNvbW1vbkluZGVudCA9IGluZGVudDtcblxuICAgICAgaWYgKGNvbW1vbkluZGVudCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29tbW9uSW5kZW50ID09PSBudWxsID8gMCA6IGNvbW1vbkluZGVudDtcbn1cblxuZnVuY3Rpb24gbGVhZGluZ1doaXRlc3BhY2Uoc3RyKSB7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IHN0ci5sZW5ndGggJiYgKHN0cltpXSA9PT0gJyAnIHx8IHN0cltpXSA9PT0gJ1xcdCcpKSB7XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGlzQmxhbmsoc3RyKSB7XG4gIHJldHVybiBsZWFkaW5nV2hpdGVzcGFjZShzdHIpID09PSBzdHIubGVuZ3RoO1xufVxuLyoqXG4gKiBQcmludCBhIGJsb2NrIHN0cmluZyBpbiB0aGUgaW5kZW50ZWQgYmxvY2sgZm9ybSBieSBhZGRpbmcgYSBsZWFkaW5nIGFuZFxuICogdHJhaWxpbmcgYmxhbmsgbGluZS4gSG93ZXZlciwgaWYgYSBibG9jayBzdHJpbmcgc3RhcnRzIHdpdGggd2hpdGVzcGFjZSBhbmQgaXNcbiAqIGEgc2luZ2xlLWxpbmUsIGFkZGluZyBhIGxlYWRpbmcgYmxhbmsgbGluZSB3b3VsZCBzdHJpcCB0aGF0IHdoaXRlc3BhY2UuXG4gKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRCbG9ja1N0cmluZyh2YWx1ZSkge1xuICB2YXIgaW5kZW50YXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICB2YXIgcHJlZmVyTXVsdGlwbGVMaW5lcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciBpc1NpbmdsZUxpbmUgPSB2YWx1ZS5pbmRleE9mKCdcXG4nKSA9PT0gLTE7XG4gIHZhciBoYXNMZWFkaW5nU3BhY2UgPSB2YWx1ZVswXSA9PT0gJyAnIHx8IHZhbHVlWzBdID09PSAnXFx0JztcbiAgdmFyIGhhc1RyYWlsaW5nUXVvdGUgPSB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1wiJztcbiAgdmFyIHByaW50QXNNdWx0aXBsZUxpbmVzID0gIWlzU2luZ2xlTGluZSB8fCBoYXNUcmFpbGluZ1F1b3RlIHx8IHByZWZlck11bHRpcGxlTGluZXM7XG4gIHZhciByZXN1bHQgPSAnJzsgLy8gRm9ybWF0IGEgbXVsdGktbGluZSBibG9jayBxdW90ZSB0byBhY2NvdW50IGZvciBsZWFkaW5nIHNwYWNlLlxuXG4gIGlmIChwcmludEFzTXVsdGlwbGVMaW5lcyAmJiAhKGlzU2luZ2xlTGluZSAmJiBoYXNMZWFkaW5nU3BhY2UpKSB7XG4gICAgcmVzdWx0ICs9ICdcXG4nICsgaW5kZW50YXRpb247XG4gIH1cblxuICByZXN1bHQgKz0gaW5kZW50YXRpb24gPyB2YWx1ZS5yZXBsYWNlKC9cXG4vZywgJ1xcbicgKyBpbmRlbnRhdGlvbikgOiB2YWx1ZTtcblxuICBpZiAocHJpbnRBc011bHRpcGxlTGluZXMpIHtcbiAgICByZXN1bHQgKz0gJ1xcbic7XG4gIH1cblxuICByZXR1cm4gJ1wiXCJcIicgKyByZXN1bHQucmVwbGFjZSgvXCJcIlwiL2csICdcXFxcXCJcIlwiJykgKyAnXCJcIlwiJztcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n")},,,function(module,exports,__webpack_require__){"use strict";eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz8zMjBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n")},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar reactIs = __webpack_require__(12);\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  '$$typeof': true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  '$$typeof': true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n\nfunction getStatics(component) {\n  // React v16.11 and below\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  } // React v16.12 and above\n\n\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanM/ZGE2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciByZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgcmVuZGVyOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWVcbn07XG52YXIgTUVNT19TVEFUSUNTID0ge1xuICAnJCR0eXBlb2YnOiB0cnVlLFxuICBjb21wYXJlOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgVFlQRV9TVEFUSUNTID0ge307XG5UWVBFX1NUQVRJQ1NbcmVhY3RJcy5Gb3J3YXJkUmVmXSA9IEZPUldBUkRfUkVGX1NUQVRJQ1M7XG5UWVBFX1NUQVRJQ1NbcmVhY3RJcy5NZW1vXSA9IE1FTU9fU1RBVElDUztcblxuZnVuY3Rpb24gZ2V0U3RhdGljcyhjb21wb25lbnQpIHtcbiAgLy8gUmVhY3QgdjE2LjExIGFuZCBiZWxvd1xuICBpZiAocmVhY3RJcy5pc01lbW8oY29tcG9uZW50KSkge1xuICAgIHJldHVybiBNRU1PX1NUQVRJQ1M7XG4gIH0gLy8gUmVhY3QgdjE2LjEyIGFuZCBhYm92ZVxuXG5cbiAgcmV0dXJuIFRZUEVfU1RBVElDU1tjb21wb25lbnRbJyQkdHlwZW9mJ11dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRTdGF0aWNzID0gZ2V0U3RhdGljcyh0YXJnZXRDb21wb25lbnQpO1xuICAgIHZhciBzb3VyY2VTdGF0aWNzID0gZ2V0U3RhdGljcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShibGFja2xpc3QgJiYgYmxhY2tsaXN0W2tleV0pICYmICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleV0pICYmICEodGFyZ2V0U3RhdGljcyAmJiB0YXJnZXRTdGF0aWNzW2tleV0pKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEF2b2lkIGZhaWx1cmVzIGZyb20gcmVhZC1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBob2lzdE5vblJlYWN0U3RhdGljcztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);\n/* global window */\n\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (true) {\n  root = module;\n} else {}\n\nvar result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(root);\n/* harmony default export */ __webpack_exports__[\"a\"] = (result);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(40), __webpack_require__(41)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvZXMvaW5kZXguanM/NmMyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgcG9ueWZpbGwgZnJvbSAnLi9wb255ZmlsbC5qcyc7XG5cbnZhciByb290O1xuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSBwb255ZmlsbChyb290KTtcbmV4cG9ydCBkZWZhdWx0IHJlc3VsdDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBRUE7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return symbolObservablePonyfill; });\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvZXMvcG9ueWZpbGwuanM/NDhiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0aWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdFN5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n")},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(42).Observable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvemVuLW9ic2VydmFibGUvaW5kZXguanM/MDAxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL09ic2VydmFibGUuanMnKS5PYnNlcnZhYmxlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanM/ZjcxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIG9wdHMgPSB7IGNtcDogb3B0cyB9O1xuICAgIHZhciBjeWNsZXMgPSAodHlwZW9mIG9wdHMuY3ljbGVzID09PSAnYm9vbGVhbicpID8gb3B0cy5jeWNsZXMgOiBmYWxzZTtcblxuICAgIHZhciBjbXAgPSBvcHRzLmNtcCAmJiAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW9iaiA9IHsga2V5OiBhLCB2YWx1ZTogbm9kZVthXSB9O1xuICAgICAgICAgICAgICAgIHZhciBib2JqID0geyBrZXk6IGIsIHZhbHVlOiBub2RlW2JdIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoYW9iaiwgYm9iaik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0pKG9wdHMuY21wKTtcblxuICAgIHZhciBzZWVuID0gW107XG4gICAgcmV0dXJuIChmdW5jdGlvbiBzdHJpbmdpZnkgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50b0pTT04gJiYgdHlwZW9mIG5vZGUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS50b0pTT04oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09ICdudW1iZXInKSByZXR1cm4gaXNGaW5pdGUobm9kZSkgPyAnJyArIG5vZGUgOiAnbnVsbCc7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHJldHVybiBKU09OLnN0cmluZ2lmeShub2RlKTtcblxuICAgICAgICB2YXIgaSwgb3V0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgb3V0ID0gJ1snO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSkgb3V0ICs9ICcsJztcbiAgICAgICAgICAgICAgICBvdXQgKz0gc3RyaW5naWZ5KG5vZGVbaV0pIHx8ICdudWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQgKyAnXSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZSA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcblxuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgaWYgKGN5Y2xlcykgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCdfX2N5Y2xlX18nKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT04nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLnB1c2gobm9kZSkgLSAxO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUpLnNvcnQoY21wICYmIGNtcChub2RlKSk7XG4gICAgICAgIG91dCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHJpbmdpZnkobm9kZVtrZXldKTtcblxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAob3V0KSBvdXQgKz0gJywnO1xuICAgICAgICAgICAgb3V0ICs9IEpTT04uc3RyaW5naWZ5KGtleSkgKyAnOicgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLnNwbGljZShzZWVuSW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gJ3snICsgb3V0ICsgJ30nO1xuICAgIH0pKGRhdGEpO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23\n")},function(module,exports,__webpack_require__){eval("(function (global, factory) {\n\t true ? factory(exports) :\n\tundefined;\n}(this, (function (exports) { 'use strict';\n\nvar Log = (function () {\n    function Log(options) {\n        var _a = options.debug, debug = _a === void 0 ? false : _a;\n        this.debug = debug;\n        this.lines = [];\n    }\n    Log.prototype.emit = function (level, message) {\n        if (level in console) {\n            var prefix = Log.prefix;\n            console[level].apply(console, [prefix].concat(message));\n        }\n    };\n    Log.prototype.tailLogs = function () {\n        var _this = this;\n        this.lines.forEach(function (_a) {\n            var level = _a[0], message = _a[1];\n            return _this.emit(level, message);\n        });\n    };\n    Log.prototype.getLogs = function () {\n        return this.lines;\n    };\n    Log.prototype.write = function (level, message) {\n        var buffer = Log.buffer;\n        this.lines = this.lines.slice(1 - buffer).concat([[level, message]]);\n        if (this.debug || level !== 'log') {\n            this.emit(level, message);\n        }\n    };\n    Log.prototype.info = function () {\n        var message = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            message[_i] = arguments[_i];\n        }\n        this.write('log', message);\n    };\n    Log.prototype.warn = function () {\n        var message = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            message[_i] = arguments[_i];\n        }\n        this.write('warn', message);\n    };\n    Log.prototype.error = function () {\n        var message = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            message[_i] = arguments[_i];\n        }\n        this.write('error', message);\n    };\n    Log.buffer = 30;\n    Log.prefix = '[apollo-cache-persist]';\n    return Log;\n}());\n\nvar Cache = (function () {\n    function Cache(options) {\n        var cache = options.cache, _a = options.serialize, serialize = _a === void 0 ? true : _a;\n        this.cache = cache;\n        this.serialize = serialize;\n    }\n    Cache.prototype.extract = function () {\n        var data = this.cache.extract();\n        if (this.serialize) {\n            data = JSON.stringify(data);\n        }\n        return data;\n    };\n    Cache.prototype.restore = function (data) {\n        if (this.serialize && typeof data === 'string') {\n            data = JSON.parse(data);\n        }\n        if (data != null) {\n            this.cache.restore(data);\n        }\n    };\n    return Cache;\n}());\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar Storage = (function () {\n    function Storage(options) {\n        var storage = options.storage, _a = options.key, key = _a === void 0 ? 'apollo-cache-persist' : _a;\n        this.storage = storage;\n        this.key = key;\n    }\n    Storage.prototype.read = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2, this.storage.getItem(this.key)];\n            });\n        });\n    };\n    Storage.prototype.write = function (data) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, this.storage.setItem(this.key, data)];\n                    case 1:\n                        _a.sent();\n                        return [2];\n                }\n            });\n        });\n    };\n    Storage.prototype.purge = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, this.storage.removeItem(this.key)];\n                    case 1:\n                        _a.sent();\n                        return [2];\n                }\n            });\n        });\n    };\n    Storage.prototype.getSize = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var data;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, this.storage.getItem(this.key)];\n                    case 1:\n                        data = _a.sent();\n                        if (data == null) {\n                            return [2, 0];\n                        }\n                        else {\n                            return [2, typeof data === 'string' ? data.length : null];\n                        }\n                        return [2];\n                }\n            });\n        });\n    };\n    return Storage;\n}());\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator$1 = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar Persistor = (function () {\n    function Persistor(_a, options) {\n        var log = _a.log, cache = _a.cache, storage = _a.storage;\n        var _b = options.maxSize, maxSize = _b === void 0 ? 1024 * 1024 : _b;\n        this.log = log;\n        this.cache = cache;\n        this.storage = storage;\n        this.paused = false;\n        if (maxSize) {\n            this.maxSize = maxSize;\n        }\n    }\n    Persistor.prototype.persist = function () {\n        return __awaiter$1(this, void 0, void 0, function () {\n            var data, error_1;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 4, , 5]);\n                        data = this.cache.extract();\n                        if (!(this.maxSize != null &&\n                            typeof data === 'string' &&\n                            data.length > this.maxSize &&\n                            !this.paused)) return [3, 2];\n                        return [4, this.purge()];\n                    case 1:\n                        _a.sent();\n                        this.paused = true;\n                        return [2];\n                    case 2:\n                        if (this.paused) {\n                            this.paused = false;\n                        }\n                        return [4, this.storage.write(data)];\n                    case 3:\n                        _a.sent();\n                        this.log.info(typeof data === 'string'\n                            ? \"Persisted cache of size \" + data.length\n                            : 'Persisted cache');\n                        return [3, 5];\n                    case 4:\n                        error_1 = _a.sent();\n                        this.log.error('Error persisting cache', error_1);\n                        throw error_1;\n                    case 5: return [2];\n                }\n            });\n        });\n    };\n    Persistor.prototype.restore = function () {\n        return __awaiter$1(this, void 0, void 0, function () {\n            var data, error_2;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 5, , 6]);\n                        return [4, this.storage.read()];\n                    case 1:\n                        data = _a.sent();\n                        if (!(data != null)) return [3, 3];\n                        return [4, this.cache.restore(data)];\n                    case 2:\n                        _a.sent();\n                        this.log.info(typeof data === 'string'\n                            ? \"Restored cache of size \" + data.length\n                            : 'Restored cache');\n                        return [3, 4];\n                    case 3:\n                        this.log.info('No stored cache to restore');\n                        _a.label = 4;\n                    case 4: return [3, 6];\n                    case 5:\n                        error_2 = _a.sent();\n                        this.log.error('Error restoring cache', error_2);\n                        throw error_2;\n                    case 6: return [2];\n                }\n            });\n        });\n    };\n    Persistor.prototype.purge = function () {\n        return __awaiter$1(this, void 0, void 0, function () {\n            var error_3;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4, this.storage.purge()];\n                    case 1:\n                        _a.sent();\n                        this.log.info('Purged cache storage');\n                        return [3, 3];\n                    case 2:\n                        error_3 = _a.sent();\n                        this.log.error('Error purging cache storage', error_3);\n                        throw error_3;\n                    case 3: return [2];\n                }\n            });\n        });\n    };\n    return Persistor;\n}());\n\nvar onCacheWrite = function (_a) {\n    var cache = _a.cache;\n    return function (persist) {\n        var write = cache.write;\n        cache.write = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            write.apply(cache, args);\n            persist();\n        };\n        return function () {\n            cache.write = write;\n        };\n    };\n};\n\nvar onAppBackground = function (_a) {\n    var log = _a.log, cache = _a.cache;\n    return function (persist) {\n        log.warn('Trigger option `background` not available on web; using `write` trigger');\n        return onCacheWrite({ cache: cache })(persist);\n    };\n};\n\nvar Trigger = (function () {\n    function Trigger(_a, options) {\n        var log = _a.log, persistor = _a.persistor;\n        var _this = this;\n        this.fire = function () {\n            if (!_this.debounce) {\n                _this.persist();\n                return;\n            }\n            if (_this.timeout != null) {\n                clearTimeout(_this.timeout);\n            }\n            _this.timeout = setTimeout(_this.persist, _this.debounce);\n        };\n        this.persist = function () {\n            if (_this.paused) {\n                return;\n            }\n            _this.persistor.persist();\n        };\n        var defaultDebounce = Trigger.defaultDebounce;\n        var cache = options.cache, debounce = options.debounce, _b = options.trigger, trigger = _b === void 0 ? 'write' : _b;\n        if (!trigger) {\n            return;\n        }\n        this.debounce = debounce != null ? debounce : defaultDebounce;\n        this.persistor = persistor;\n        this.paused = false;\n        switch (trigger) {\n            case 'write':\n                this.uninstall = onCacheWrite({ cache: cache })(this.fire);\n                break;\n            case 'background':\n                if (debounce) {\n                    log.warn('Debounce is not recommended with `background` trigger');\n                }\n                this.debounce = debounce;\n                this.uninstall = onAppBackground({ cache: cache, log: log })(this.fire);\n                break;\n            default:\n                if (typeof trigger === 'function') {\n                    this.uninstall = trigger(this.fire);\n                }\n                else {\n                    throw Error(\"Unrecognized trigger option: \" + trigger);\n                }\n        }\n    }\n    Trigger.prototype.pause = function () {\n        this.paused = true;\n    };\n    Trigger.prototype.resume = function () {\n        this.paused = false;\n    };\n    Trigger.prototype.remove = function () {\n        if (this.uninstall) {\n            this.uninstall();\n            this.uninstall = null;\n            this.paused = true;\n        }\n    };\n    Trigger.defaultDebounce = 1000;\n    return Trigger;\n}());\n\nvar CachePersistor = (function () {\n    function CachePersistor(options) {\n        if (!options.cache) {\n            throw new Error('In order to persist your Apollo Cache, you need to pass in a cache. ' +\n                'Please see https://www.apollographql.com/docs/react/basics/caching.html for our default InMemoryCache.');\n        }\n        if (!options.storage) {\n            throw new Error('In order to persist your Apollo Cache, you need to pass in an underlying storage provider. ' +\n                'Please see https://github.com/apollographql/apollo-cache-persist#storage-providers');\n        }\n        var log = new Log(options);\n        var cache = new Cache(options);\n        var storage = new Storage(options);\n        var persistor = new Persistor({ log: log, cache: cache, storage: storage }, options);\n        var trigger = new Trigger({ log: log, persistor: persistor }, options);\n        this.log = log;\n        this.cache = cache;\n        this.storage = storage;\n        this.persistor = persistor;\n        this.trigger = trigger;\n    }\n    CachePersistor.prototype.persist = function () {\n        return this.persistor.persist();\n    };\n    CachePersistor.prototype.restore = function () {\n        return this.persistor.restore();\n    };\n    CachePersistor.prototype.purge = function () {\n        return this.persistor.purge();\n    };\n    CachePersistor.prototype.pause = function () {\n        this.trigger.pause();\n    };\n    CachePersistor.prototype.resume = function () {\n        this.trigger.resume();\n    };\n    CachePersistor.prototype.remove = function () {\n        this.trigger.remove();\n    };\n    CachePersistor.prototype.getLogs = function (print) {\n        if (print === void 0) { print = false; }\n        if (print) {\n            this.log.tailLogs();\n        }\n        else {\n            return this.log.getLogs();\n        }\n    };\n    CachePersistor.prototype.getSize = function () {\n        return this.storage.getSize();\n    };\n    return CachePersistor;\n}());\n\nvar persistCache = function (options) {\n    var persistor = new CachePersistor(options);\n    return persistor.restore();\n};\n\nexports.CachePersistor = CachePersistor;\nexports.persistCache = persistCache;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=bundle.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXBvbGxvLWNhY2hlLXBlcnNpc3QvYnVuZGxlLnVtZC5qcz80NTNiIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbFsnYXBvbGxvLWNhY2hlLXBlcnNpc3QnXSA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgTG9nID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2cob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EgPSBvcHRpb25zLmRlYnVnLCBkZWJ1ZyA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hO1xuICAgICAgICB0aGlzLmRlYnVnID0gZGVidWc7XG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICB9XG4gICAgTG9nLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChsZXZlbCBpbiBjb25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gTG9nLnByZWZpeDtcbiAgICAgICAgICAgIGNvbnNvbGVbbGV2ZWxdLmFwcGx5KGNvbnNvbGUsIFtwcmVmaXhdLmNvbmNhdChtZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvZy5wcm90b3R5cGUudGFpbExvZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubGluZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IF9hWzBdLCBtZXNzYWdlID0gX2FbMV07XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdChsZXZlbCwgbWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9nLnByb3RvdHlwZS5nZXRMb2dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lcztcbiAgICB9O1xuICAgIExvZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IExvZy5idWZmZXI7XG4gICAgICAgIHRoaXMubGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKDEgLSBidWZmZXIpLmNvbmNhdChbW2xldmVsLCBtZXNzYWdlXV0pO1xuICAgICAgICBpZiAodGhpcy5kZWJ1ZyB8fCBsZXZlbCAhPT0gJ2xvZycpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChsZXZlbCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvZy5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG1lc3NhZ2VbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlKCdsb2cnLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIExvZy5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG1lc3NhZ2VbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlKCd3YXJuJywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBMb2cucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbWVzc2FnZVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGUoJ2Vycm9yJywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICBMb2cuYnVmZmVyID0gMzA7XG4gICAgTG9nLnByZWZpeCA9ICdbYXBvbGxvLWNhY2hlLXBlcnNpc3RdJztcbiAgICByZXR1cm4gTG9nO1xufSgpKTtcblxudmFyIENhY2hlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYWNoZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IG9wdGlvbnMuY2FjaGUsIF9hID0gb3B0aW9ucy5zZXJpYWxpemUsIHNlcmlhbGl6ZSA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2E7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgfVxuICAgIENhY2hlLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY2FjaGUuZXh0cmFjdCgpO1xuICAgICAgICBpZiAodGhpcy5zZXJpYWxpemUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIENhY2hlLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VyaWFsaXplICYmIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5yZXN0b3JlKGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2FjaGU7XG59KCkpO1xuXG52YXIgX19hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIFN0b3JhZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0b3JhZ2Uob3B0aW9ucykge1xuICAgICAgICB2YXIgc3RvcmFnZSA9IG9wdGlvbnMuc3RvcmFnZSwgX2EgPSBvcHRpb25zLmtleSwga2V5ID0gX2EgPT09IHZvaWQgMCA/ICdhcG9sbG8tY2FjaGUtcGVyc2lzdCcgOiBfYTtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuICAgIFN0b3JhZ2UucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMua2V5KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdG9yYWdlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLmtleSwgZGF0YSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0b3JhZ2UucHJvdG90eXBlLnB1cmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgdGhpcy5zdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5rZXkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdG9yYWdlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmtleSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEubGVuZ3RoIDogbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTdG9yYWdlO1xufSgpKTtcblxudmFyIF9fYXdhaXRlciQxID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IkMSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgUGVyc2lzdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZXJzaXN0b3IoX2EsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGxvZyA9IF9hLmxvZywgY2FjaGUgPSBfYS5jYWNoZSwgc3RvcmFnZSA9IF9hLnN0b3JhZ2U7XG4gICAgICAgIHZhciBfYiA9IG9wdGlvbnMubWF4U2l6ZSwgbWF4U2l6ZSA9IF9iID09PSB2b2lkIDAgPyAxMDI0ICogMTAyNCA6IF9iO1xuICAgICAgICB0aGlzLmxvZyA9IGxvZztcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobWF4U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQZXJzaXN0b3IucHJvdG90eXBlLnBlcnNpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEsIGVycm9yXzE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgNCwgLCA1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5jYWNoZS5leHRyYWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLm1heFNpemUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEubGVuZ3RoID4gdGhpcy5tYXhTaXplICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMucGF1c2VkKSkgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5wdXJnZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5zdG9yYWdlLndyaXRlKGRhdGEpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbyh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiUGVyc2lzdGVkIGNhY2hlIG9mIHNpemUgXCIgKyBkYXRhLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ1BlcnNpc3RlZCBjYWNoZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdFcnJvciBwZXJzaXN0aW5nIGNhY2hlJywgZXJyb3JfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGVyc2lzdG9yLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhLCBlcnJvcl8yO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDUsICwgNl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLnN0b3JhZ2UucmVhZCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGRhdGEgIT0gbnVsbCkpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuY2FjaGUucmVzdG9yZShkYXRhKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmluZm8odHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlJlc3RvcmVkIGNhY2hlIG9mIHNpemUgXCIgKyBkYXRhLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ1Jlc3RvcmVkIGNhY2hlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdObyBzdG9yZWQgY2FjaGUgdG8gcmVzdG9yZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMywgNl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignRXJyb3IgcmVzdG9yaW5nIGNhY2hlJywgZXJyb3JfMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl8yO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGVyc2lzdG9yLnByb3RvdHlwZS5wdXJnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JfMztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5zdG9yYWdlLnB1cmdlKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdQdXJnZWQgY2FjaGUgc3RvcmFnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdFcnJvciBwdXJnaW5nIGNhY2hlIHN0b3JhZ2UnLCBlcnJvcl8zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yXzM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGVyc2lzdG9yO1xufSgpKTtcblxudmFyIG9uQ2FjaGVXcml0ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjYWNoZSA9IF9hLmNhY2hlO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGVyc2lzdCkge1xuICAgICAgICB2YXIgd3JpdGUgPSBjYWNoZS53cml0ZTtcbiAgICAgICAgY2FjaGUud3JpdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZS5hcHBseShjYWNoZSwgYXJncyk7XG4gICAgICAgICAgICBwZXJzaXN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWNoZS53cml0ZSA9IHdyaXRlO1xuICAgICAgICB9O1xuICAgIH07XG59O1xuXG52YXIgb25BcHBCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGxvZyA9IF9hLmxvZywgY2FjaGUgPSBfYS5jYWNoZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBlcnNpc3QpIHtcbiAgICAgICAgbG9nLndhcm4oJ1RyaWdnZXIgb3B0aW9uIGBiYWNrZ3JvdW5kYCBub3QgYXZhaWxhYmxlIG9uIHdlYjsgdXNpbmcgYHdyaXRlYCB0cmlnZ2VyJyk7XG4gICAgICAgIHJldHVybiBvbkNhY2hlV3JpdGUoeyBjYWNoZTogY2FjaGUgfSkocGVyc2lzdCk7XG4gICAgfTtcbn07XG5cbnZhciBUcmlnZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmlnZ2VyKF9hLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsb2cgPSBfYS5sb2csIHBlcnNpc3RvciA9IF9hLnBlcnNpc3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5maXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5kZWJvdW5jZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnBlcnNpc3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMudGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoX3RoaXMucGVyc2lzdCwgX3RoaXMuZGVib3VuY2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBlcnNpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucGVyc2lzdG9yLnBlcnNpc3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlZmF1bHREZWJvdW5jZSA9IFRyaWdnZXIuZGVmYXVsdERlYm91bmNlO1xuICAgICAgICB2YXIgY2FjaGUgPSBvcHRpb25zLmNhY2hlLCBkZWJvdW5jZSA9IG9wdGlvbnMuZGVib3VuY2UsIF9iID0gb3B0aW9ucy50cmlnZ2VyLCB0cmlnZ2VyID0gX2IgPT09IHZvaWQgMCA/ICd3cml0ZScgOiBfYjtcbiAgICAgICAgaWYgKCF0cmlnZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJvdW5jZSA9IGRlYm91bmNlICE9IG51bGwgPyBkZWJvdW5jZSA6IGRlZmF1bHREZWJvdW5jZTtcbiAgICAgICAgdGhpcy5wZXJzaXN0b3IgPSBwZXJzaXN0b3I7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAodHJpZ2dlcikge1xuICAgICAgICAgICAgY2FzZSAnd3JpdGUnOlxuICAgICAgICAgICAgICAgIHRoaXMudW5pbnN0YWxsID0gb25DYWNoZVdyaXRlKHsgY2FjaGU6IGNhY2hlIH0pKHRoaXMuZmlyZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiYWNrZ3JvdW5kJzpcbiAgICAgICAgICAgICAgICBpZiAoZGVib3VuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oJ0RlYm91bmNlIGlzIG5vdCByZWNvbW1lbmRlZCB3aXRoIGBiYWNrZ3JvdW5kYCB0cmlnZ2VyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaW5zdGFsbCA9IG9uQXBwQmFja2dyb3VuZCh7IGNhY2hlOiBjYWNoZSwgbG9nOiBsb2cgfSkodGhpcy5maXJlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmlnZ2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5pbnN0YWxsID0gdHJpZ2dlcih0aGlzLmZpcmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbnJlY29nbml6ZWQgdHJpZ2dlciBvcHRpb246IFwiICsgdHJpZ2dlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFRyaWdnZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgfTtcbiAgICBUcmlnZ2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgfTtcbiAgICBUcmlnZ2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuaW5zdGFsbCkge1xuICAgICAgICAgICAgdGhpcy51bmluc3RhbGwoKTtcbiAgICAgICAgICAgIHRoaXMudW5pbnN0YWxsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJpZ2dlci5kZWZhdWx0RGVib3VuY2UgPSAxMDAwO1xuICAgIHJldHVybiBUcmlnZ2VyO1xufSgpKTtcblxudmFyIENhY2hlUGVyc2lzdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYWNoZVBlcnNpc3RvcihvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5jYWNoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbiBvcmRlciB0byBwZXJzaXN0IHlvdXIgQXBvbGxvIENhY2hlLCB5b3UgbmVlZCB0byBwYXNzIGluIGEgY2FjaGUuICcgK1xuICAgICAgICAgICAgICAgICdQbGVhc2Ugc2VlIGh0dHBzOi8vd3d3LmFwb2xsb2dyYXBocWwuY29tL2RvY3MvcmVhY3QvYmFzaWNzL2NhY2hpbmcuaHRtbCBmb3Igb3VyIGRlZmF1bHQgSW5NZW1vcnlDYWNoZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RvcmFnZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbiBvcmRlciB0byBwZXJzaXN0IHlvdXIgQXBvbGxvIENhY2hlLCB5b3UgbmVlZCB0byBwYXNzIGluIGFuIHVuZGVybHlpbmcgc3RvcmFnZSBwcm92aWRlci4gJyArXG4gICAgICAgICAgICAgICAgJ1BsZWFzZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Fwb2xsb2dyYXBocWwvYXBvbGxvLWNhY2hlLXBlcnNpc3Qjc3RvcmFnZS1wcm92aWRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9nID0gbmV3IExvZyhvcHRpb25zKTtcbiAgICAgICAgdmFyIGNhY2hlID0gbmV3IENhY2hlKG9wdGlvbnMpO1xuICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBTdG9yYWdlKG9wdGlvbnMpO1xuICAgICAgICB2YXIgcGVyc2lzdG9yID0gbmV3IFBlcnNpc3Rvcih7IGxvZzogbG9nLCBjYWNoZTogY2FjaGUsIHN0b3JhZ2U6IHN0b3JhZ2UgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciB0cmlnZ2VyID0gbmV3IFRyaWdnZXIoeyBsb2c6IGxvZywgcGVyc2lzdG9yOiBwZXJzaXN0b3IgfSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubG9nID0gbG9nO1xuICAgICAgICB0aGlzLmNhY2hlID0gY2FjaGU7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIHRoaXMucGVyc2lzdG9yID0gcGVyc2lzdG9yO1xuICAgICAgICB0aGlzLnRyaWdnZXIgPSB0cmlnZ2VyO1xuICAgIH1cbiAgICBDYWNoZVBlcnNpc3Rvci5wcm90b3R5cGUucGVyc2lzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdG9yLnBlcnNpc3QoKTtcbiAgICB9O1xuICAgIENhY2hlUGVyc2lzdG9yLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0b3IucmVzdG9yZSgpO1xuICAgIH07XG4gICAgQ2FjaGVQZXJzaXN0b3IucHJvdG90eXBlLnB1cmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0b3IucHVyZ2UoKTtcbiAgICB9O1xuICAgIENhY2hlUGVyc2lzdG9yLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyLnBhdXNlKCk7XG4gICAgfTtcbiAgICBDYWNoZVBlcnNpc3Rvci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIucmVzdW1lKCk7XG4gICAgfTtcbiAgICBDYWNoZVBlcnNpc3Rvci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBDYWNoZVBlcnNpc3Rvci5wcm90b3R5cGUuZ2V0TG9ncyA9IGZ1bmN0aW9uIChwcmludCkge1xuICAgICAgICBpZiAocHJpbnQgPT09IHZvaWQgMCkgeyBwcmludCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChwcmludCkge1xuICAgICAgICAgICAgdGhpcy5sb2cudGFpbExvZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvZy5nZXRMb2dzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhY2hlUGVyc2lzdG9yLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmdldFNpemUoKTtcbiAgICB9O1xuICAgIHJldHVybiBDYWNoZVBlcnNpc3Rvcjtcbn0oKSk7XG5cbnZhciBwZXJzaXN0Q2FjaGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBwZXJzaXN0b3IgPSBuZXcgQ2FjaGVQZXJzaXN0b3Iob3B0aW9ucyk7XG4gICAgcmV0dXJuIHBlcnNpc3Rvci5yZXN0b3JlKCk7XG59O1xuXG5leHBvcnRzLkNhY2hlUGVyc2lzdG9yID0gQ2FjaGVQZXJzaXN0b3I7XG5leHBvcnRzLnBlcnNpc3RDYWNoZSA9IHBlcnNpc3RDYWNoZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS51bWQuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxVQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24\n")},,,,,,,,,function(module,exports,__webpack_require__){"use strict";eval('/** @license React v16.13.1\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar l=__webpack_require__(17),n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.forward_ref"):60112,y=n?Symbol.for("react.suspense"):60113,z=n?Symbol.for("react.memo"):60115,A=n?Symbol.for("react.lazy"):\n60116,B="function"===typeof Symbol&&Symbol.iterator;function C(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}\nvar D={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},E={};function F(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}F.prototype.isReactComponent={};F.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(C(85));this.updater.enqueueSetState(this,a,b,"setState")};F.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};\nfunction G(){}G.prototype=F.prototype;function H(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}var I=H.prototype=new G;I.constructor=H;l(I,F.prototype);I.isPureReactComponent=!0;var J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};\nfunction M(a,b,c){var e,d={},g=null,k=null;if(null!=b)for(e in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,e)&&!L.hasOwnProperty(e)&&(d[e]=b[e]);var f=arguments.length-2;if(1===f)d.children=c;else if(1<f){for(var h=Array(f),m=0;m<f;m++)h[m]=arguments[m+2];d.children=h}if(a&&a.defaultProps)for(e in f=a.defaultProps,f)void 0===d[e]&&(d[e]=f[e]);return{$$typeof:p,type:a,key:g,ref:k,props:d,_owner:J.current}}\nfunction N(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g,Q=[];function R(a,b,c,e){if(Q.length){var d=Q.pop();d.result=a;d.keyPrefix=b;d.func=c;d.context=e;d.count=0;return d}return{result:a,keyPrefix:b,func:c,context:e,count:0}}\nfunction S(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>Q.length&&Q.push(a)}\nfunction T(a,b,c,e){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0}}if(g)return c(e,a,""===b?"."+U(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+U(d,k);g+=T(d,f,c,e)}else if(null===a||"object"!==typeof a?f=null:(f=B&&a[B]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),k=\n0;!(d=a.next()).done;)d=d.value,f=b+U(d,k++),g+=T(d,f,c,e);else if("object"===d)throw c=""+a,Error(C(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return g}function V(a,b,c){return null==a?0:T(a,"",b,c)}function U(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function W(a,b){a.func.call(a.context,b,a.count++)}\nfunction aa(a,b,c){var e=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?X(a,e,c,function(a){return a}):null!=a&&(O(a)&&(a=N(a,d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(P,"$&/")+"/")+c)),e.push(a))}function X(a,b,c,e,d){var g="";null!=c&&(g=(""+c).replace(P,"$&/")+"/");b=R(b,g,e,d);V(a,aa,b);S(b)}var Y={current:null};function Z(){var a=Y.current;if(null===a)throw Error(C(321));return a}\nvar ba={ReactCurrentDispatcher:Y,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:J,IsSomeRendererActing:{current:!1},assign:l};exports.Children={map:function(a,b,c){if(null==a)return a;var e=[];X(a,e,null,b,c);return e},forEach:function(a,b,c){if(null==a)return a;b=R(null,null,b,c);V(a,W,b);S(b)},count:function(a){return V(a,function(){return null},null)},toArray:function(a){var b=[];X(a,b,null,function(a){return a});return b},only:function(a){if(!O(a))throw Error(C(143));return a}};\nexports.Component=F;exports.Fragment=r;exports.Profiler=u;exports.PureComponent=H;exports.StrictMode=t;exports.Suspense=y;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ba;\nexports.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(C(267,a));var e=l({},a.props),d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=J.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)K.call(b,h)&&!L.hasOwnProperty(h)&&(e[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){f=Array(h);for(var m=0;m<h;m++)f[m]=arguments[m+2];e.children=f}return{$$typeof:p,type:a.type,\nkey:d,ref:g,props:e,_owner:k}};exports.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};exports.forwardRef=function(a){return{$$typeof:x,render:a}};exports.isValidElement=O;\nexports.lazy=function(a){return{$$typeof:A,_ctor:a,_status:-1,_result:null}};exports.memo=function(a,b){return{$$typeof:z,type:a,compare:void 0===b?null:b}};exports.useCallback=function(a,b){return Z().useCallback(a,b)};exports.useContext=function(a,b){return Z().useContext(a,b)};exports.useDebugValue=function(){};exports.useEffect=function(a,b){return Z().useEffect(a,b)};exports.useImperativeHandle=function(a,b,c){return Z().useImperativeHandle(a,b,c)};\nexports.useLayoutEffect=function(a,b){return Z().useLayoutEffect(a,b)};exports.useMemo=function(a,b){return Z().useMemo(a,b)};exports.useReducer=function(a,b,c){return Z().useReducer(a,b,c)};exports.useRef=function(a){return Z().useRef(a)};exports.useState=function(a){return Z().useState(a)};exports.version="16.13.1";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzP2JlMjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0Jzt2YXIgbD1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxuPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3IscD1uP1N5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLHE9bj9TeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LHI9bj9TeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik6NjAxMDcsdD1uP1N5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTo2MDEwOCx1PW4/U3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpOjYwMTE0LHY9bj9TeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik6NjAxMDksdz1uP1N5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpOjYwMTEwLHg9bj9TeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIik6NjAxMTIseT1uP1N5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKTo2MDExMyx6PW4/U3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik6NjAxMTUsQT1uP1N5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpOlxuNjAxMTYsQj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3I7ZnVuY3Rpb24gQyhhKXtmb3IodmFyIGI9XCJodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD1cIithLGM9MTtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKWIrPVwiJmFyZ3NbXT1cIitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2NdKTtyZXR1cm5cIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIithK1wiOyB2aXNpdCBcIitiK1wiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIn1cbnZhciBEPXtpc01vdW50ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oKXt9fSxFPXt9O2Z1bmN0aW9uIEYoYSxiLGMpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9RTt0aGlzLnVwZGF0ZXI9Y3x8RH1GLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9O0YucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGEsYil7aWYoXCJvYmplY3RcIiE9PXR5cGVvZiBhJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSYmbnVsbCE9YSl0aHJvdyBFcnJvcihDKDg1KSk7dGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLGEsYixcInNldFN0YXRlXCIpfTtGLnByb3RvdHlwZS5mb3JjZVVwZGF0ZT1mdW5jdGlvbihhKXt0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsYSxcImZvcmNlVXBkYXRlXCIpfTtcbmZ1bmN0aW9uIEcoKXt9Ry5wcm90b3R5cGU9Ri5wcm90b3R5cGU7ZnVuY3Rpb24gSChhLGIsYyl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1FO3RoaXMudXBkYXRlcj1jfHxEfXZhciBJPUgucHJvdG90eXBlPW5ldyBHO0kuY29uc3RydWN0b3I9SDtsKEksRi5wcm90b3R5cGUpO0kuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITA7dmFyIEo9e2N1cnJlbnQ6bnVsbH0sSz1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LEw9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIE0oYSxiLGMpe3ZhciBlLGQ9e30sZz1udWxsLGs9bnVsbDtpZihudWxsIT1iKWZvcihlIGluIHZvaWQgMCE9PWIucmVmJiYoaz1iLnJlZiksdm9pZCAwIT09Yi5rZXkmJihnPVwiXCIrYi5rZXkpLGIpSy5jYWxsKGIsZSkmJiFMLmhhc093blByb3BlcnR5KGUpJiYoZFtlXT1iW2VdKTt2YXIgZj1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWYpZC5jaGlsZHJlbj1jO2Vsc2UgaWYoMTxmKXtmb3IodmFyIGg9QXJyYXkoZiksbT0wO208ZjttKyspaFttXT1hcmd1bWVudHNbbSsyXTtkLmNoaWxkcmVuPWh9aWYoYSYmYS5kZWZhdWx0UHJvcHMpZm9yKGUgaW4gZj1hLmRlZmF1bHRQcm9wcyxmKXZvaWQgMD09PWRbZV0mJihkW2VdPWZbZV0pO3JldHVybnskJHR5cGVvZjpwLHR5cGU6YSxrZXk6ZyxyZWY6ayxwcm9wczpkLF9vd25lcjpKLmN1cnJlbnR9fVxuZnVuY3Rpb24gTihhLGIpe3JldHVybnskJHR5cGVvZjpwLHR5cGU6YS50eXBlLGtleTpiLHJlZjphLnJlZixwcm9wczphLnByb3BzLF9vd25lcjphLl9vd25lcn19ZnVuY3Rpb24gTyhhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09cH1mdW5jdGlvbiBlc2NhcGUoYSl7dmFyIGI9e1wiPVwiOlwiPTBcIixcIjpcIjpcIj0yXCJ9O3JldHVyblwiJFwiKyhcIlwiK2EpLnJlcGxhY2UoL1s9Ol0vZyxmdW5jdGlvbihhKXtyZXR1cm4gYlthXX0pfXZhciBQPS9cXC8rL2csUT1bXTtmdW5jdGlvbiBSKGEsYixjLGUpe2lmKFEubGVuZ3RoKXt2YXIgZD1RLnBvcCgpO2QucmVzdWx0PWE7ZC5rZXlQcmVmaXg9YjtkLmZ1bmM9YztkLmNvbnRleHQ9ZTtkLmNvdW50PTA7cmV0dXJuIGR9cmV0dXJue3Jlc3VsdDphLGtleVByZWZpeDpiLGZ1bmM6Yyxjb250ZXh0OmUsY291bnQ6MH19XG5mdW5jdGlvbiBTKGEpe2EucmVzdWx0PW51bGw7YS5rZXlQcmVmaXg9bnVsbDthLmZ1bmM9bnVsbDthLmNvbnRleHQ9bnVsbDthLmNvdW50PTA7MTA+US5sZW5ndGgmJlEucHVzaChhKX1cbmZ1bmN0aW9uIFQoYSxiLGMsZSl7dmFyIGQ9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWR8fFwiYm9vbGVhblwiPT09ZClhPW51bGw7dmFyIGc9ITE7aWYobnVsbD09PWEpZz0hMDtlbHNlIHN3aXRjaChkKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmc9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIHA6Y2FzZSBxOmc9ITB9fWlmKGcpcmV0dXJuIGMoZSxhLFwiXCI9PT1iP1wiLlwiK1UoYSwwKTpiKSwxO2c9MDtiPVwiXCI9PT1iP1wiLlwiOmIrXCI6XCI7aWYoQXJyYXkuaXNBcnJheShhKSlmb3IodmFyIGs9MDtrPGEubGVuZ3RoO2srKyl7ZD1hW2tdO3ZhciBmPWIrVShkLGspO2crPVQoZCxmLGMsZSl9ZWxzZSBpZihudWxsPT09YXx8XCJvYmplY3RcIiE9PXR5cGVvZiBhP2Y9bnVsbDooZj1CJiZhW0JdfHxhW1wiQEBpdGVyYXRvclwiXSxmPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBmP2Y6bnVsbCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9Zi5jYWxsKGEpLGs9XG4wOyEoZD1hLm5leHQoKSkuZG9uZTspZD1kLnZhbHVlLGY9YitVKGQsaysrKSxnKz1UKGQsZixjLGUpO2Vsc2UgaWYoXCJvYmplY3RcIj09PWQpdGhyb3cgYz1cIlwiK2EsRXJyb3IoQygzMSxcIltvYmplY3QgT2JqZWN0XVwiPT09Yz9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKStcIn1cIjpjLFwiXCIpKTtyZXR1cm4gZ31mdW5jdGlvbiBWKGEsYixjKXtyZXR1cm4gbnVsbD09YT8wOlQoYSxcIlwiLGIsYyl9ZnVuY3Rpb24gVShhLGIpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJm51bGwhPWEua2V5P2VzY2FwZShhLmtleSk6Yi50b1N0cmluZygzNil9ZnVuY3Rpb24gVyhhLGIpe2EuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyl9XG5mdW5jdGlvbiBhYShhLGIsYyl7dmFyIGU9YS5yZXN1bHQsZD1hLmtleVByZWZpeDthPWEuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyk7QXJyYXkuaXNBcnJheShhKT9YKGEsZSxjLGZ1bmN0aW9uKGEpe3JldHVybiBhfSk6bnVsbCE9YSYmKE8oYSkmJihhPU4oYSxkKyghYS5rZXl8fGImJmIua2V5PT09YS5rZXk/XCJcIjooXCJcIithLmtleSkucmVwbGFjZShQLFwiJCYvXCIpK1wiL1wiKStjKSksZS5wdXNoKGEpKX1mdW5jdGlvbiBYKGEsYixjLGUsZCl7dmFyIGc9XCJcIjtudWxsIT1jJiYoZz0oXCJcIitjKS5yZXBsYWNlKFAsXCIkJi9cIikrXCIvXCIpO2I9UihiLGcsZSxkKTtWKGEsYWEsYik7UyhiKX12YXIgWT17Y3VycmVudDpudWxsfTtmdW5jdGlvbiBaKCl7dmFyIGE9WS5jdXJyZW50O2lmKG51bGw9PT1hKXRocm93IEVycm9yKEMoMzIxKSk7cmV0dXJuIGF9XG52YXIgYmE9e1JlYWN0Q3VycmVudERpc3BhdGNoZXI6WSxSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzp7c3VzcGVuc2U6bnVsbH0sUmVhY3RDdXJyZW50T3duZXI6SixJc1NvbWVSZW5kZXJlckFjdGluZzp7Y3VycmVudDohMX0sYXNzaWduOmx9O2V4cG9ydHMuQ2hpbGRyZW49e21hcDpmdW5jdGlvbihhLGIsYyl7aWYobnVsbD09YSlyZXR1cm4gYTt2YXIgZT1bXTtYKGEsZSxudWxsLGIsYyk7cmV0dXJuIGV9LGZvckVhY2g6ZnVuY3Rpb24oYSxiLGMpe2lmKG51bGw9PWEpcmV0dXJuIGE7Yj1SKG51bGwsbnVsbCxiLGMpO1YoYSxXLGIpO1MoYil9LGNvdW50OmZ1bmN0aW9uKGEpe3JldHVybiBWKGEsZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sbnVsbCl9LHRvQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGI9W107WChhLGIsbnVsbCxmdW5jdGlvbihhKXtyZXR1cm4gYX0pO3JldHVybiBifSxvbmx5OmZ1bmN0aW9uKGEpe2lmKCFPKGEpKXRocm93IEVycm9yKEMoMTQzKSk7cmV0dXJuIGF9fTtcbmV4cG9ydHMuQ29tcG9uZW50PUY7ZXhwb3J0cy5GcmFnbWVudD1yO2V4cG9ydHMuUHJvZmlsZXI9dTtleHBvcnRzLlB1cmVDb21wb25lbnQ9SDtleHBvcnRzLlN0cmljdE1vZGU9dDtleHBvcnRzLlN1c3BlbnNlPXk7ZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRD1iYTtcbmV4cG9ydHMuY2xvbmVFbGVtZW50PWZ1bmN0aW9uKGEsYixjKXtpZihudWxsPT09YXx8dm9pZCAwPT09YSl0aHJvdyBFcnJvcihDKDI2NyxhKSk7dmFyIGU9bCh7fSxhLnByb3BzKSxkPWEua2V5LGc9YS5yZWYsaz1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGc9Yi5yZWYsaz1KLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoZD1cIlwiK2Iua2V5KTtpZihhLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGY9YS50eXBlLmRlZmF1bHRQcm9wcztmb3IoaCBpbiBiKUsuY2FsbChiLGgpJiYhTC5oYXNPd25Qcm9wZXJ0eShoKSYmKGVbaF09dm9pZCAwPT09YltoXSYmdm9pZCAwIT09Zj9mW2hdOmJbaF0pfXZhciBoPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09aCllLmNoaWxkcmVuPWM7ZWxzZSBpZigxPGgpe2Y9QXJyYXkoaCk7Zm9yKHZhciBtPTA7bTxoO20rKylmW21dPWFyZ3VtZW50c1ttKzJdO2UuY2hpbGRyZW49Zn1yZXR1cm57JCR0eXBlb2Y6cCx0eXBlOmEudHlwZSxcbmtleTpkLHJlZjpnLHByb3BzOmUsX293bmVyOmt9fTtleHBvcnRzLmNyZWF0ZUNvbnRleHQ9ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj1udWxsKTthPXskJHR5cGVvZjp3LF9jYWxjdWxhdGVDaGFuZ2VkQml0czpiLF9jdXJyZW50VmFsdWU6YSxfY3VycmVudFZhbHVlMjphLF90aHJlYWRDb3VudDowLFByb3ZpZGVyOm51bGwsQ29uc3VtZXI6bnVsbH07YS5Qcm92aWRlcj17JCR0eXBlb2Y6dixfY29udGV4dDphfTtyZXR1cm4gYS5Db25zdW1lcj1hfTtleHBvcnRzLmNyZWF0ZUVsZW1lbnQ9TTtleHBvcnRzLmNyZWF0ZUZhY3Rvcnk9ZnVuY3Rpb24oYSl7dmFyIGI9TS5iaW5kKG51bGwsYSk7Yi50eXBlPWE7cmV0dXJuIGJ9O2V4cG9ydHMuY3JlYXRlUmVmPWZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19O2V4cG9ydHMuZm9yd2FyZFJlZj1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6eCxyZW5kZXI6YX19O2V4cG9ydHMuaXNWYWxpZEVsZW1lbnQ9TztcbmV4cG9ydHMubGF6eT1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6QSxfY3RvcjphLF9zdGF0dXM6LTEsX3Jlc3VsdDpudWxsfX07ZXhwb3J0cy5tZW1vPWZ1bmN0aW9uKGEsYil7cmV0dXJueyQkdHlwZW9mOnosdHlwZTphLGNvbXBhcmU6dm9pZCAwPT09Yj9udWxsOmJ9fTtleHBvcnRzLnVzZUNhbGxiYWNrPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFooKS51c2VDYWxsYmFjayhhLGIpfTtleHBvcnRzLnVzZUNvbnRleHQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gWigpLnVzZUNvbnRleHQoYSxiKX07ZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlPWZ1bmN0aW9uKCl7fTtleHBvcnRzLnVzZUVmZmVjdD1mdW5jdGlvbihhLGIpe3JldHVybiBaKCkudXNlRWZmZWN0KGEsYil9O2V4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIFooKS51c2VJbXBlcmF0aXZlSGFuZGxlKGEsYixjKX07XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdD1mdW5jdGlvbihhLGIpe3JldHVybiBaKCkudXNlTGF5b3V0RWZmZWN0KGEsYil9O2V4cG9ydHMudXNlTWVtbz1mdW5jdGlvbihhLGIpe3JldHVybiBaKCkudXNlTWVtbyhhLGIpfTtleHBvcnRzLnVzZVJlZHVjZXI9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBaKCkudXNlUmVkdWNlcihhLGIsYyl9O2V4cG9ydHMudXNlUmVmPWZ1bmN0aW9uKGEpe3JldHVybiBaKCkudXNlUmVmKGEpfTtleHBvcnRzLnVzZVN0YXRlPWZ1bmN0aW9uKGEpe3JldHVybiBaKCkudXNlU3RhdGUoYSl9O2V4cG9ydHMudmVyc2lvbj1cIjE2LjEzLjFcIjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33\n')},function(module,exports,__webpack_require__){"use strict";eval('/** @license React v16.13.1\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\nvar aa=__webpack_require__(0),n=__webpack_require__(17),r=__webpack_require__(35);function u(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!aa)throw Error(u(227));\nfunction ba(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}var da=!1,ea=null,fa=!1,ha=null,ia={onError:function(a){da=!0;ea=a}};function ja(a,b,c,d,e,f,g,h,k){da=!1;ea=null;ba.apply(ia,arguments)}function ka(a,b,c,d,e,f,g,h,k){ja.apply(this,arguments);if(da){if(da){var l=ea;da=!1;ea=null}else throw Error(u(198));fa||(fa=!0,ha=l)}}var la=null,ma=null,na=null;\nfunction oa(a,b,c){var d=a.type||"unknown-event";a.currentTarget=na(c);ka(d,b,void 0,a);a.currentTarget=null}var pa=null,qa={};\nfunction ra(){if(pa)for(var a in qa){var b=qa[a],c=pa.indexOf(a);if(!(-1<c))throw Error(u(96,a));if(!sa[c]){if(!b.extractEvents)throw Error(u(97,a));sa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;if(ta.hasOwnProperty(h))throw Error(u(99,h));ta[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&ua(k[e],g,h);e=!0}else f.registrationName?(ua(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(u(98,d,a));}}}}\nfunction ua(a,b,c){if(va[a])throw Error(u(100,a));va[a]=b;wa[a]=b.eventTypes[c].dependencies}var sa=[],ta={},va={},wa={};function xa(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!qa.hasOwnProperty(c)||qa[c]!==d){if(qa[c])throw Error(u(102,c));qa[c]=d;b=!0}}b&&ra()}var ya=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),za=null,Aa=null,Ba=null;\nfunction Ca(a){if(a=ma(a)){if("function"!==typeof za)throw Error(u(280));var b=a.stateNode;b&&(b=la(b),za(a.stateNode,a.type,b))}}function Da(a){Aa?Ba?Ba.push(a):Ba=[a]:Aa=a}function Ea(){if(Aa){var a=Aa,b=Ba;Ba=Aa=null;Ca(a);if(b)for(a=0;a<b.length;a++)Ca(b[a])}}function Fa(a,b){return a(b)}function Ga(a,b,c,d,e){return a(b,c,d,e)}function Ha(){}var Ia=Fa,Ja=!1,Ka=!1;function La(){if(null!==Aa||null!==Ba)Ha(),Ea()}\nfunction Ma(a,b,c){if(Ka)return a(b,c);Ka=!0;try{return Ia(a,b,c)}finally{Ka=!1,La()}}var Na=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,Oa=Object.prototype.hasOwnProperty,Pa={},Qa={};\nfunction Ra(a){if(Oa.call(Qa,a))return!0;if(Oa.call(Pa,a))return!1;if(Na.test(a))return Qa[a]=!0;Pa[a]=!0;return!1}function Sa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}\nfunction Ta(a,b,c,d){if(null===b||"undefined"===typeof b||Sa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function v(a,b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}var C={};\n"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){C[a]=new v(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];C[b]=new v(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){C[a]=new v(a,2,!1,a.toLowerCase(),null,!1)});\n["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){C[a]=new v(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){C[a]=new v(a,3,!1,a.toLowerCase(),null,!1)});\n["checked","multiple","muted","selected"].forEach(function(a){C[a]=new v(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){C[a]=new v(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){C[a]=new v(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){C[a]=new v(a,5,!1,a.toLowerCase(),null,!1)});var Ua=/[\\-:]([a-z])/g;function Va(a){return a[1].toUpperCase()}\n"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(Ua,\nVa);C[b]=new v(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(Ua,Va);C[b]=new v(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(Ua,Va);C[b]=new v(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){C[a]=new v(a,1,!1,a.toLowerCase(),null,!1)});\nC.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){C[a]=new v(a,1,!1,a.toLowerCase(),null,!0)});var Wa=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;Wa.hasOwnProperty("ReactCurrentDispatcher")||(Wa.ReactCurrentDispatcher={current:null});Wa.hasOwnProperty("ReactCurrentBatchConfig")||(Wa.ReactCurrentBatchConfig={suspense:null});\nfunction Xa(a,b,c,d){var e=C.hasOwnProperty(b)?C[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(Ta(b,c,e,d)&&(c=null),d||null===e?Ra(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}\nvar Ya=/^(.*)[\\\\\\/]/,E="function"===typeof Symbol&&Symbol.for,Za=E?Symbol.for("react.element"):60103,$a=E?Symbol.for("react.portal"):60106,ab=E?Symbol.for("react.fragment"):60107,bb=E?Symbol.for("react.strict_mode"):60108,cb=E?Symbol.for("react.profiler"):60114,db=E?Symbol.for("react.provider"):60109,eb=E?Symbol.for("react.context"):60110,fb=E?Symbol.for("react.concurrent_mode"):60111,gb=E?Symbol.for("react.forward_ref"):60112,hb=E?Symbol.for("react.suspense"):60113,ib=E?Symbol.for("react.suspense_list"):\n60120,jb=E?Symbol.for("react.memo"):60115,kb=E?Symbol.for("react.lazy"):60116,lb=E?Symbol.for("react.block"):60121,mb="function"===typeof Symbol&&Symbol.iterator;function nb(a){if(null===a||"object"!==typeof a)return null;a=mb&&a[mb]||a["@@iterator"];return"function"===typeof a?a:null}function ob(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}\nfunction pb(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ab:return"Fragment";case $a:return"Portal";case cb:return"Profiler";case bb:return"StrictMode";case hb:return"Suspense";case ib:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case eb:return"Context.Consumer";case db:return"Context.Provider";case gb:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":\n"ForwardRef");case jb:return pb(a.type);case lb:return pb(a.render);case kb:if(a=1===a._status?a._result:null)return pb(a)}return null}function qb(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=pb(a.type);c=null;d&&(c=pb(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(Ya,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}\nfunction rb(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return""}}function sb(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}\nfunction tb(a){var b=sb(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=\nnull;delete a[b]}}}}function xb(a){a._valueTracker||(a._valueTracker=tb(a))}function yb(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=sb(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function zb(a,b){var c=b.checked;return n({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}\nfunction Ab(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=rb(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function Bb(a,b){b=b.checked;null!=b&&Xa(a,"checked",b,!1)}\nfunction Cb(a,b){Bb(a,b);var c=rb(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Db(a,b.type,c):b.hasOwnProperty("defaultValue")&&Db(a,b.type,rb(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}\nfunction Eb(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}\nfunction Db(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function Fb(a){var b="";aa.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Gb(a,b){a=n({children:void 0},b);if(b=Fb(b.children))a.children=b;return a}\nfunction Hb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+rb(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}\nfunction Ib(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(u(91));return n({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function Jb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(u(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(u(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:rb(c)}}\nfunction Kb(a,b){var c=rb(b.value),d=rb(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Lb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}var Mb={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};\nfunction Nb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Ob(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}\nvar Pb,Qb=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==Mb.svg||"innerHTML"in a)a.innerHTML=b;else{Pb=Pb||document.createElement("div");Pb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=Pb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});\nfunction Rb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}function Sb(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Tb={animationend:Sb("Animation","AnimationEnd"),animationiteration:Sb("Animation","AnimationIteration"),animationstart:Sb("Animation","AnimationStart"),transitionend:Sb("Transition","TransitionEnd")},Ub={},Vb={};\nya&&(Vb=document.createElement("div").style,"AnimationEvent"in window||(delete Tb.animationend.animation,delete Tb.animationiteration.animation,delete Tb.animationstart.animation),"TransitionEvent"in window||delete Tb.transitionend.transition);function Wb(a){if(Ub[a])return Ub[a];if(!Tb[a])return a;var b=Tb[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Vb)return Ub[a]=b[c];return a}\nvar Xb=Wb("animationend"),Yb=Wb("animationiteration"),Zb=Wb("animationstart"),$b=Wb("transitionend"),ac="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),bc=new ("function"===typeof WeakMap?WeakMap:Map);function cc(a){var b=bc.get(a);void 0===b&&(b=new Map,bc.set(a,b));return b}\nfunction dc(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function ec(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function fc(a){if(dc(a)!==a)throw Error(u(188));}\nfunction gc(a){var b=a.alternate;if(!b){b=dc(a);if(null===b)throw Error(u(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return fc(e),a;if(f===d)return fc(e),b;f=f.sibling}throw Error(u(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===\nc){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(u(189));}}if(c.alternate!==d)throw Error(u(190));}if(3!==c.tag)throw Error(u(188));return c.stateNode.current===c?a:b}function hc(a){a=gc(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}\nfunction ic(a,b){if(null==b)throw Error(u(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function jc(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var kc=null;\nfunction lc(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)oa(a,b[d],c[d]);else b&&oa(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}}function mc(a){null!==a&&(kc=ic(kc,a));a=kc;kc=null;if(a){jc(a,lc);if(kc)throw Error(u(95));if(fa)throw a=ha,fa=!1,ha=null,a;}}\nfunction nc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}function oc(a){if(!ya)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}var pc=[];function qc(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>pc.length&&pc.push(a)}\nfunction rc(a,b,c,d){if(pc.length){var e=pc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}\nfunction sc(a){var b=a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=tc(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=nc(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,k=0;k<sa.length;k++){var l=sa[k];l&&(l=l.extractEvents(d,b,f,e,g))&&(h=\nic(h,l))}mc(h)}}function uc(a,b,c){if(!c.has(a)){switch(a){case "scroll":vc(b,"scroll",!0);break;case "focus":case "blur":vc(b,"focus",!0);vc(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":oc(a)&&vc(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===ac.indexOf(a)&&F(a,b)}c.set(a,null)}}\nvar wc,xc,yc,zc=!1,Ac=[],Bc=null,Cc=null,Dc=null,Ec=new Map,Fc=new Map,Gc=[],Hc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),Ic="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" ");\nfunction Jc(a,b){var c=cc(b);Hc.forEach(function(a){uc(a,b,c)});Ic.forEach(function(a){uc(a,b,c)})}function Kc(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,container:d}}\nfunction Lc(a,b){switch(a){case "focus":case "blur":Bc=null;break;case "dragenter":case "dragleave":Cc=null;break;case "mouseover":case "mouseout":Dc=null;break;case "pointerover":case "pointerout":Ec.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fc.delete(b.pointerId)}}function Mc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Kc(b,c,d,e,f),null!==b&&(b=Nc(b),null!==b&&xc(b)),a;a.eventSystemFlags|=d;return a}\nfunction Oc(a,b,c,d,e){switch(b){case "focus":return Bc=Mc(Bc,a,b,c,d,e),!0;case "dragenter":return Cc=Mc(Cc,a,b,c,d,e),!0;case "mouseover":return Dc=Mc(Dc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Ec.set(f,Mc(Ec.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fc.set(f,Mc(Fc.get(f)||null,a,b,c,d,e)),!0}return!1}\nfunction Pc(a){var b=tc(a.target);if(null!==b){var c=dc(b);if(null!==c)if(b=c.tag,13===b){if(b=ec(c),null!==b){a.blockedOn=b;r.unstable_runWithPriority(a.priority,function(){yc(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function Qc(a){if(null!==a.blockedOn)return!1;var b=Rc(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Nc(b);null!==c&&xc(c);a.blockedOn=b;return!1}return!0}\nfunction Sc(a,b,c){Qc(a)&&c.delete(b)}function Tc(){for(zc=!1;0<Ac.length;){var a=Ac[0];if(null!==a.blockedOn){a=Nc(a.blockedOn);null!==a&&wc(a);break}var b=Rc(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:Ac.shift()}null!==Bc&&Qc(Bc)&&(Bc=null);null!==Cc&&Qc(Cc)&&(Cc=null);null!==Dc&&Qc(Dc)&&(Dc=null);Ec.forEach(Sc);Fc.forEach(Sc)}function Uc(a,b){a.blockedOn===b&&(a.blockedOn=null,zc||(zc=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Tc)))}\nfunction Vc(a){function b(b){return Uc(b,a)}if(0<Ac.length){Uc(Ac[0],a);for(var c=1;c<Ac.length;c++){var d=Ac[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Bc&&Uc(Bc,a);null!==Cc&&Uc(Cc,a);null!==Dc&&Uc(Dc,a);Ec.forEach(b);Fc.forEach(b);for(c=0;c<Gc.length;c++)d=Gc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Gc.length&&(c=Gc[0],null===c.blockedOn);)Pc(c),null===c.blockedOn&&Gc.shift()}\nvar Wc={},Yc=new Map,Zc=new Map,$c=["abort","abort",Xb,"animationEnd",Yb,"animationIteration",Zb,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking",\n"seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",$b,"transitionEnd","waiting","waiting"];function ad(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Zc.set(d,b);Yc.set(d,f);Wc[e]=f}}\nad("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0);\nad("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);ad($c,2);for(var bd="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),cd=0;cd<bd.length;cd++)Zc.set(bd[cd],0);\nvar dd=r.unstable_UserBlockingPriority,ed=r.unstable_runWithPriority,fd=!0;function F(a,b){vc(b,a,!1)}function vc(a,b,c){var d=Zc.get(b);switch(void 0===d?2:d){case 0:d=gd.bind(null,b,1,a);break;case 1:d=hd.bind(null,b,1,a);break;default:d=id.bind(null,b,1,a)}c?a.addEventListener(b,d,!0):a.addEventListener(b,d,!1)}function gd(a,b,c,d){Ja||Ha();var e=id,f=Ja;Ja=!0;try{Ga(e,a,b,c,d)}finally{(Ja=f)||La()}}function hd(a,b,c,d){ed(dd,id.bind(null,a,b,c,d))}\nfunction id(a,b,c,d){if(fd)if(0<Ac.length&&-1<Hc.indexOf(a))a=Kc(null,a,b,c,d),Ac.push(a);else{var e=Rc(a,b,c,d);if(null===e)Lc(a,d);else if(-1<Hc.indexOf(a))a=Kc(e,a,b,c,d),Ac.push(a);else if(!Oc(e,a,b,c,d)){Lc(a,d);a=rc(a,d,null,b);try{Ma(sc,a)}finally{qc(a)}}}}\nfunction Rc(a,b,c,d){c=nc(d);c=tc(c);if(null!==c){var e=dc(c);if(null===e)c=null;else{var f=e.tag;if(13===f){c=ec(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=rc(a,d,c,b);try{Ma(sc,a)}finally{qc(a)}return null}\nvar jd={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,\nfloodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},kd=["Webkit","ms","Moz","O"];Object.keys(jd).forEach(function(a){kd.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);jd[b]=jd[a]})});function ld(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||jd.hasOwnProperty(a)&&jd[a]?(""+b).trim():b+"px"}\nfunction md(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=ld(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var nd=n({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});\nfunction od(a,b){if(b){if(nd[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(u(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(u(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(u(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(u(62,""));}}\nfunction pd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var qd=Mb.html;function rd(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=cc(a);b=wa[b];for(var d=0;d<b.length;d++)uc(b[d],a,c)}function sd(){}\nfunction td(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function ud(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function vd(a,b){var c=ud(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=ud(c)}}\nfunction wd(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?wd(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function xd(){for(var a=window,b=td();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=td(a.document)}return b}\nfunction yd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}var zd="$",Ad="/$",Bd="$?",Cd="$!",Dd=null,Ed=null;function Fd(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}\nfunction Gd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var Hd="function"===typeof setTimeout?setTimeout:void 0,Id="function"===typeof clearTimeout?clearTimeout:void 0;function Jd(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}\nfunction Kd(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===zd||c===Cd||c===Bd){if(0===b)return a;b--}else c===Ad&&b++}a=a.previousSibling}return null}var Ld=Math.random().toString(36).slice(2),Md="__reactInternalInstance$"+Ld,Nd="__reactEventHandlers$"+Ld,Od="__reactContainere$"+Ld;\nfunction tc(a){var b=a[Md];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Od]||c[Md]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Kd(a);null!==a;){if(c=a[Md])return c;a=Kd(a)}return b}a=c;c=a.parentNode}return null}function Nc(a){a=a[Md]||a[Od];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pd(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(u(33));}function Qd(a){return a[Nd]||null}\nfunction Rd(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}\nfunction Sd(a,b){var c=a.stateNode;if(!c)return null;var d=la(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(u(231,\nb,typeof c));return c}function Td(a,b,c){if(b=Sd(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=ic(c._dispatchListeners,b),c._dispatchInstances=ic(c._dispatchInstances,a)}function Ud(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=Rd(b);for(b=c.length;0<b--;)Td(c[b],"captured",a);for(b=0;b<c.length;b++)Td(c[b],"bubbled",a)}}\nfunction Vd(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=Sd(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=ic(c._dispatchListeners,b),c._dispatchInstances=ic(c._dispatchInstances,a))}function Wd(a){a&&a.dispatchConfig.registrationName&&Vd(a._targetInst,null,a)}function Xd(a){jc(a,Ud)}var Yd=null,Zd=null,$d=null;\nfunction ae(){if($d)return $d;var a,b=Zd,c=b.length,d,e="value"in Yd?Yd.value:Yd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return $d=e.slice(a,1<d?1-d:void 0)}function be(){return!0}function ce(){return!1}\nfunction G(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?be:ce;this.isPropagationStopped=ce;return this}\nn(G.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=be)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=be)},persist:function(){this.isPersistent=be},isPersistent:ce,destructor:function(){var a=this.constructor.Interface,\nb;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=ce;this._dispatchInstances=this._dispatchListeners=null}});G.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};\nG.extend=function(a){function b(){}function c(){return d.apply(this,arguments)}var d=this;b.prototype=d.prototype;var e=new b;n(e,c.prototype);c.prototype=e;c.prototype.constructor=c;c.Interface=n({},d.Interface,a);c.extend=d.extend;de(c);return c};de(G);function ee(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}\nfunction fe(a){if(!(a instanceof this))throw Error(u(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function de(a){a.eventPool=[];a.getPooled=ee;a.release=fe}var ge=G.extend({data:null}),he=G.extend({data:null}),ie=[9,13,27,32],je=ya&&"CompositionEvent"in window,ke=null;ya&&"documentMode"in document&&(ke=document.documentMode);\nvar le=ya&&"TextEvent"in window&&!ke,me=ya&&(!je||ke&&8<ke&&11>=ke),ne=String.fromCharCode(32),oe={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",\ncaptured:"onCompositionStartCapture"},dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},pe=!1;\nfunction qe(a,b){switch(a){case "keyup":return-1!==ie.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function re(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var se=!1;function te(a,b){switch(a){case "compositionend":return re(b);case "keypress":if(32!==b.which)return null;pe=!0;return ne;case "textInput":return a=b.data,a===ne&&pe?null:a;default:return null}}\nfunction ue(a,b){if(se)return"compositionend"===a||!je&&qe(a,b)?(a=ae(),$d=Zd=Yd=null,se=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return me&&"ko"!==b.locale?null:b.data;default:return null}}\nvar ve={eventTypes:oe,extractEvents:function(a,b,c,d){var e;if(je)b:{switch(a){case "compositionstart":var f=oe.compositionStart;break b;case "compositionend":f=oe.compositionEnd;break b;case "compositionupdate":f=oe.compositionUpdate;break b}f=void 0}else se?qe(a,c)&&(f=oe.compositionEnd):"keydown"===a&&229===c.keyCode&&(f=oe.compositionStart);f?(me&&"ko"!==c.locale&&(se||f!==oe.compositionStart?f===oe.compositionEnd&&se&&(e=ae()):(Yd=d,Zd="value"in Yd?Yd.value:Yd.textContent,se=!0)),f=ge.getPooled(f,\nb,c,d),e?f.data=e:(e=re(c),null!==e&&(f.data=e)),Xd(f),e=f):e=null;(a=le?te(a,c):ue(a,c))?(b=he.getPooled(oe.beforeInput,b,c,d),b.data=a,Xd(b)):b=null;return null===e?b:null===b?e:[e,b]}},we={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function xe(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!we[a.type]:"textarea"===b?!0:!1}\nvar ye={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}};function ze(a,b,c){a=G.getPooled(ye.change,a,b,c);a.type="change";Da(c);Xd(a);return a}var Ae=null,Be=null;function Ce(a){mc(a)}function De(a){var b=Pd(a);if(yb(b))return a}function Ee(a,b){if("change"===a)return b}var Fe=!1;ya&&(Fe=oc("input")&&(!document.documentMode||9<document.documentMode));\nfunction Ge(){Ae&&(Ae.detachEvent("onpropertychange",He),Be=Ae=null)}function He(a){if("value"===a.propertyName&&De(Be))if(a=ze(Be,a,nc(a)),Ja)mc(a);else{Ja=!0;try{Fa(Ce,a)}finally{Ja=!1,La()}}}function Ie(a,b,c){"focus"===a?(Ge(),Ae=b,Be=c,Ae.attachEvent("onpropertychange",He)):"blur"===a&&Ge()}function Je(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return De(Be)}function Ke(a,b){if("click"===a)return De(b)}function Le(a,b){if("input"===a||"change"===a)return De(b)}\nvar Me={eventTypes:ye,_isInputEventSupported:Fe,extractEvents:function(a,b,c,d){var e=b?Pd(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Ee;else if(xe(e))if(Fe)g=Le;else{g=Je;var h=Ie}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Ke);if(g&&(g=g(a,b)))return ze(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Db(e,"number",e.value)}},Ne=G.extend({view:null,detail:null}),\nOe={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pe(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Oe[a])?!!b[a]:!1}function Qe(){return Pe}\nvar Re=0,Se=0,Te=!1,Ue=!1,Ve=Ne.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:Qe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=Re;Re=a.screenX;return Te?"mousemove"===a.type?a.screenX-b:0:(Te=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;\nvar b=Se;Se=a.screenY;return Ue?"mousemove"===a.type?a.screenY-b:0:(Ue=!0,0)}}),We=Ve.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),Xe={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",\ndependencies:["pointerout","pointerover"]}},Ye={eventTypes:Xe,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?tc(b):null,null!==b){var h=dc(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===\na){var k=Ve;var l=Xe.mouseLeave;var m=Xe.mouseEnter;var p="mouse"}else if("pointerout"===a||"pointerover"===a)k=We,l=Xe.pointerLeave,m=Xe.pointerEnter,p="pointer";a=null==g?f:Pd(g);f=null==b?f:Pd(b);l=k.getPooled(l,g,c,d);l.type=p+"leave";l.target=a;l.relatedTarget=f;c=k.getPooled(m,b,c,d);c.type=p+"enter";c.target=f;c.relatedTarget=a;d=g;p=b;if(d&&p)a:{k=d;m=p;g=0;for(a=k;a;a=Rd(a))g++;a=0;for(b=m;b;b=Rd(b))a++;for(;0<g-a;)k=Rd(k),g--;for(;0<a-g;)m=Rd(m),a--;for(;g--;){if(k===m||k===m.alternate)break a;\nk=Rd(k);m=Rd(m)}k=null}else k=null;m=k;for(k=[];d&&d!==m;){g=d.alternate;if(null!==g&&g===m)break;k.push(d);d=Rd(d)}for(d=[];p&&p!==m;){g=p.alternate;if(null!==g&&g===m)break;d.push(p);p=Rd(p)}for(p=0;p<k.length;p++)Vd(k[p],"bubbled",l);for(p=d.length;0<p--;)Vd(d[p],"captured",c);return 0===(e&64)?[l]:[l,c]}};function Ze(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var $e="function"===typeof Object.is?Object.is:Ze,af=Object.prototype.hasOwnProperty;\nfunction bf(a,b){if($e(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!af.call(b,c[d])||!$e(a[c[d]],b[c[d]]))return!1;return!0}\nvar cf=ya&&"documentMode"in document&&11>=document.documentMode,df={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},ef=null,ff=null,gf=null,hf=!1;\nfunction jf(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(hf||null==ef||ef!==td(c))return null;c=ef;"selectionStart"in c&&yd(c)?c={start:c.selectionStart,end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return gf&&bf(gf,c)?null:(gf=c,a=G.getPooled(df.select,ff,a,b),a.type="select",a.target=ef,Xd(a),a)}\nvar kf={eventTypes:df,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=cc(e);f=wa.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pd(b):window;switch(a){case "focus":if(xe(e)||"true"===e.contentEditable)ef=e,ff=b,gf=null;break;case "blur":gf=ff=ef=null;break;case "mousedown":hf=!0;break;case "contextmenu":case "mouseup":case "dragend":return hf=!1,jf(c,d);case "selectionchange":if(cf)break;\ncase "keydown":case "keyup":return jf(c,d)}return null}},lf=G.extend({animationName:null,elapsedTime:null,pseudoElement:null}),mf=G.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),nf=Ne.extend({relatedTarget:null});function of(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}\nvar pf={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},qf={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",\n116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},rf=Ne.extend({key:function(a){if(a.key){var b=pf[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=of(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?qf[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:Qe,charCode:function(a){return"keypress"===\na.type?of(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===a.type?of(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),sf=Ve.extend({dataTransfer:null}),tf=Ne.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:Qe}),uf=G.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),vf=Ve.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in\na?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null}),wf={eventTypes:Wc,extractEvents:function(a,b,c,d){var e=Yc.get(a);if(!e)return null;switch(a){case "keypress":if(0===of(c))return null;case "keydown":case "keyup":a=rf;break;case "blur":case "focus":a=nf;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=\nVe;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=sf;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=tf;break;case Xb:case Yb:case Zb:a=lf;break;case $b:a=uf;break;case "scroll":a=Ne;break;case "wheel":a=vf;break;case "copy":case "cut":case "paste":a=mf;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=\nWe;break;default:a=G}b=a.getPooled(e,b,c,d);Xd(b);return b}};if(pa)throw Error(u(101));pa=Array.prototype.slice.call("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));ra();var xf=Nc;la=Qd;ma=xf;na=Pd;xa({SimpleEventPlugin:wf,EnterLeaveEventPlugin:Ye,ChangeEventPlugin:Me,SelectEventPlugin:kf,BeforeInputEventPlugin:ve});var yf=[],zf=-1;function H(a){0>zf||(a.current=yf[zf],yf[zf]=null,zf--)}\nfunction I(a,b){zf++;yf[zf]=a.current;a.current=b}var Af={},J={current:Af},K={current:!1},Bf=Af;function Cf(a,b){var c=a.type.contextTypes;if(!c)return Af;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function L(a){a=a.childContextTypes;return null!==a&&void 0!==a}\nfunction Df(){H(K);H(J)}function Ef(a,b,c){if(J.current!==Af)throw Error(u(168));I(J,b);I(K,c)}function Ff(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(u(108,pb(b)||"Unknown",e));return n({},c,{},d)}function Gf(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Af;Bf=J.current;I(J,a);I(K,K.current);return!0}\nfunction Hf(a,b,c){var d=a.stateNode;if(!d)throw Error(u(169));c?(a=Ff(a,b,Bf),d.__reactInternalMemoizedMergedChildContext=a,H(K),H(J),I(J,a)):H(K);I(K,c)}\nvar If=r.unstable_runWithPriority,Jf=r.unstable_scheduleCallback,Kf=r.unstable_cancelCallback,Lf=r.unstable_requestPaint,Mf=r.unstable_now,Nf=r.unstable_getCurrentPriorityLevel,Of=r.unstable_ImmediatePriority,Pf=r.unstable_UserBlockingPriority,Qf=r.unstable_NormalPriority,Rf=r.unstable_LowPriority,Sf=r.unstable_IdlePriority,Tf={},Uf=r.unstable_shouldYield,Vf=void 0!==Lf?Lf:function(){},Wf=null,Xf=null,Yf=!1,Zf=Mf(),$f=1E4>Zf?Mf:function(){return Mf()-Zf};\nfunction ag(){switch(Nf()){case Of:return 99;case Pf:return 98;case Qf:return 97;case Rf:return 96;case Sf:return 95;default:throw Error(u(332));}}function bg(a){switch(a){case 99:return Of;case 98:return Pf;case 97:return Qf;case 96:return Rf;case 95:return Sf;default:throw Error(u(332));}}function cg(a,b){a=bg(a);return If(a,b)}function dg(a,b,c){a=bg(a);return Jf(a,b,c)}function eg(a){null===Wf?(Wf=[a],Xf=Jf(Of,fg)):Wf.push(a);return Tf}function gg(){if(null!==Xf){var a=Xf;Xf=null;Kf(a)}fg()}\nfunction fg(){if(!Yf&&null!==Wf){Yf=!0;var a=0;try{var b=Wf;cg(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});Wf=null}catch(c){throw null!==Wf&&(Wf=Wf.slice(a+1)),Jf(Of,gg),c;}finally{Yf=!1}}}function hg(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function ig(a,b){if(a&&a.defaultProps){b=n({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}var jg={current:null},kg=null,lg=null,mg=null;function ng(){mg=lg=kg=null}\nfunction og(a){var b=jg.current;H(jg);a.type._context._currentValue=b}function pg(a,b){for(;null!==a;){var c=a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function qg(a,b){kg=a;mg=lg=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(rg=!0),a.firstContext=null)}\nfunction sg(a,b){if(mg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)mg=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===lg){if(null===kg)throw Error(u(308));lg=b;kg.dependencies={expirationTime:0,firstContext:b,responders:null}}else lg=lg.next=b}return a._currentValue}var tg=!1;function ug(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}\nfunction vg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function wg(a,b){a={expirationTime:a,suspenseConfig:b,tag:0,payload:null,callback:null,next:null};return a.next=a}function xg(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}\nfunction yg(a,b){var c=a.alternate;null!==c&&vg(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}\nfunction zg(a,b,c,d){var e=a.updateQueue;tg=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&(h.baseQueue=g))}if(null!==f){h=f.next;var k=e.baseState,l=0,m=null,p=null,x=null;if(null!==h){var z=h;do{g=z.expirationTime;if(g<d){var ca={expirationTime:z.expirationTime,suspenseConfig:z.suspenseConfig,tag:z.tag,payload:z.payload,callback:z.callback,next:null};null===x?(p=x=\nca,m=k):x=x.next=ca;g>l&&(l=g)}else{null!==x&&(x=x.next={expirationTime:1073741823,suspenseConfig:z.suspenseConfig,tag:z.tag,payload:z.payload,callback:z.callback,next:null});Ag(g,z.suspenseConfig);a:{var D=a,t=z;g=b;ca=c;switch(t.tag){case 1:D=t.payload;if("function"===typeof D){k=D.call(ca,k,g);break a}k=D;break a;case 3:D.effectTag=D.effectTag&-4097|64;case 0:D=t.payload;g="function"===typeof D?D.call(ca,k,g):D;if(null===g||void 0===g)break a;k=n({},k,g);break a;case 2:tg=!0}}null!==z.callback&&\n(a.effectTag|=32,g=e.effects,null===g?e.effects=[z]:g.push(z))}z=z.next;if(null===z||z===h)if(g=e.shared.pending,null===g)break;else z=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===x?m=k:x.next=p;e.baseState=m;e.baseQueue=x;Bg(l);a.expirationTime=l;a.memoizedState=k}}\nfunction Cg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(u(191,d));d.call(e)}}}var Dg=Wa.ReactCurrentBatchConfig,Eg=(new aa.Component).refs;function Fg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:n({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}\nvar Jg={isMounted:function(a){return(a=a._reactInternalFiber)?dc(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e=wg(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);xg(a,e);Ig(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e=wg(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);xg(a,e);Ig(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=Gg(),d=Dg.suspense;\nc=Hg(c,a,d);d=wg(c,d);d.tag=2;void 0!==b&&null!==b&&(d.callback=b);xg(a,d);Ig(a,c)}};function Kg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!bf(c,d)||!bf(e,f):!0}\nfunction Lg(a,b,c){var d=!1,e=Af;var f=b.contextType;"object"===typeof f&&null!==f?f=sg(f):(e=L(b)?Bf:J.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Cf(a,e):Af);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Jg;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}\nfunction Mg(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Jg.enqueueReplaceState(b,b.state,null)}\nfunction Ng(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Eg;ug(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=sg(f):(f=L(b)?Bf:J.current,e.context=Cf(a,f));zg(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Fg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||\n(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Jg.enqueueReplaceState(e,e.state,null),zg(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.effectTag|=4)}var Og=Array.isArray;\nfunction Pg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(u(309));var d=c.stateNode}if(!d)throw Error(u(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===Eg&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(u(284));if(!c._owner)throw Error(u(290,a));}return a}\nfunction Qg(a,b){if("textarea"!==a.type)throw Error(u(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}\nfunction Rg(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Sg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=\n2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Tg(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Pg(a,b,c),d.return=a,d;d=Ug(c.type,c.key,c.props,null,a.mode,d);d.ref=Pg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==\nc.implementation)return b=Vg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Wg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function p(a,b,c){if("string"===typeof b||"number"===typeof b)return b=Tg(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Za:return c=Ug(b.type,b.key,b.props,null,a.mode,c),c.ref=Pg(a,null,b),c.return=a,c;case $a:return b=Vg(b,a.mode,c),b.return=a,b}if(Og(b)||\nnb(b))return b=Wg(b,a.mode,c,null),b.return=a,b;Qg(a,b)}return null}function x(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Za:return c.key===e?c.type===ab?m(a,b,c.props.children,d,e):k(a,b,c,d):null;case $a:return c.key===e?l(a,b,c,d):null}if(Og(c)||nb(c))return null!==e?null:m(a,b,c,d,null);Qg(a,c)}return null}function z(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=\na.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Za:return a=a.get(null===d.key?c:d.key)||null,d.type===ab?m(b,a,d.props.children,e,d.key):k(b,a,d,e);case $a:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(Og(d)||nb(d))return a=a.get(c)||null,m(b,a,d,e,null);Qg(b,d)}return null}function ca(e,g,h,k){for(var l=null,t=null,m=g,y=g=0,A=null;null!==m&&y<h.length;y++){m.index>y?(A=m,m=null):A=m.sibling;var q=x(e,m,h[y],k);if(null===q){null===m&&(m=A);break}a&&\nm&&null===q.alternate&&b(e,m);g=f(q,g,y);null===t?l=q:t.sibling=q;t=q;m=A}if(y===h.length)return c(e,m),l;if(null===m){for(;y<h.length;y++)m=p(e,h[y],k),null!==m&&(g=f(m,g,y),null===t?l=m:t.sibling=m,t=m);return l}for(m=d(e,m);y<h.length;y++)A=z(m,e,y,h[y],k),null!==A&&(a&&null!==A.alternate&&m.delete(null===A.key?y:A.key),g=f(A,g,y),null===t?l=A:t.sibling=A,t=A);a&&m.forEach(function(a){return b(e,a)});return l}function D(e,g,h,l){var k=nb(h);if("function"!==typeof k)throw Error(u(150));h=k.call(h);\nif(null==h)throw Error(u(151));for(var m=k=null,t=g,y=g=0,A=null,q=h.next();null!==t&&!q.done;y++,q=h.next()){t.index>y?(A=t,t=null):A=t.sibling;var D=x(e,t,q.value,l);if(null===D){null===t&&(t=A);break}a&&t&&null===D.alternate&&b(e,t);g=f(D,g,y);null===m?k=D:m.sibling=D;m=D;t=A}if(q.done)return c(e,t),k;if(null===t){for(;!q.done;y++,q=h.next())q=p(e,q.value,l),null!==q&&(g=f(q,g,y),null===m?k=q:m.sibling=q,m=q);return k}for(t=d(e,t);!q.done;y++,q=h.next())q=z(t,e,y,q.value,l),null!==q&&(a&&null!==\nq.alternate&&t.delete(null===q.key?y:q.key),g=f(q,g,y),null===m?k=q:m.sibling=q,m=q);a&&t.forEach(function(a){return b(e,a)});return k}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===ab&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case Za:a:{l=f.key;for(k=d;null!==k;){if(k.key===l){switch(k.tag){case 7:if(f.type===ab){c(a,k.sibling);d=e(k,f.props.children);d.return=a;a=d;break a}break;default:if(k.elementType===f.type){c(a,\nk.sibling);d=e(k,f.props);d.ref=Pg(a,k,f);d.return=a;a=d;break a}}c(a,k);break}else b(a,k);k=k.sibling}f.type===ab?(d=Wg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Ug(f.type,f.key,f.props,null,a.mode,h),h.ref=Pg(a,d,f),h.return=a,a=h)}return g(a);case $a:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=\nd.sibling}d=Vg(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=Tg(f,a.mode,h),d.return=a,a=d),g(a);if(Og(f))return ca(a,d,f,h);if(nb(f))return D(a,d,f,h);l&&Qg(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 0:throw a=a.type,Error(u(152,a.displayName||a.name||"Component"));}return c(a,d)}}var Xg=Rg(!0),Yg=Rg(!1),Zg={},$g={current:Zg},ah={current:Zg},bh={current:Zg};\nfunction ch(a){if(a===Zg)throw Error(u(174));return a}function dh(a,b){I(bh,b);I(ah,a);I($g,Zg);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Ob(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Ob(b,a)}H($g);I($g,b)}function eh(){H($g);H(ah);H(bh)}function fh(a){ch(bh.current);var b=ch($g.current);var c=Ob(b,a.type);b!==c&&(I(ah,a),I($g,c))}function gh(a){ah.current===a&&(H($g),H(ah))}var M={current:0};\nfunction hh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===Bd||c.data===Cd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ih(a,b){return{responder:a,props:b}}\nvar jh=Wa.ReactCurrentDispatcher,kh=Wa.ReactCurrentBatchConfig,lh=0,N=null,O=null,P=null,mh=!1;function Q(){throw Error(u(321));}function nh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!$e(a[c],b[c]))return!1;return!0}\nfunction oh(a,b,c,d,e,f){lh=f;N=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;jh.current=null===a||null===a.memoizedState?ph:qh;a=c(d,e);if(b.expirationTime===lh){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(u(301));f+=1;P=O=null;b.updateQueue=null;jh.current=rh;a=c(d,e)}while(b.expirationTime===lh)}jh.current=sh;b=null!==O&&null!==O.next;lh=0;P=O=N=null;mh=!1;if(b)throw Error(u(300));return a}\nfunction th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===P?N.memoizedState=P=a:P=P.next=a;return P}function uh(){if(null===O){var a=N.alternate;a=null!==a?a.memoizedState:null}else a=O.next;var b=null===P?N.memoizedState:P.next;if(null!==b)P=b,O=a;else{if(null===a)throw Error(u(310));O=a;a={memoizedState:O.memoizedState,baseState:O.baseState,baseQueue:O.baseQueue,queue:O.queue,next:null};null===P?N.memoizedState=P=a:P=P.next=a}return P}\nfunction vh(a,b){return"function"===typeof b?b(a):b}\nfunction wh(a){var b=uh(),c=b.queue;if(null===c)throw Error(u(311));c.lastRenderedReducer=a;var d=O,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,k=e;do{var l=k.expirationTime;if(l<lh){var m={expirationTime:k.expirationTime,suspenseConfig:k.suspenseConfig,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null};null===h?(g=h=m,f=d):h=h.next=m;l>N.expirationTime&&\n(N.expirationTime=l,Bg(l))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:k.suspenseConfig,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null}),Ag(l,k.suspenseConfig),d=k.eagerReducer===a?k.eagerState:a(d,k.action);k=k.next}while(null!==k&&k!==e);null===h?f=d:h.next=g;$e(d,b.memoizedState)||(rg=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,c.dispatch]}\nfunction xh(a){var b=uh(),c=b.queue;if(null===c)throw Error(u(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);$e(f,b.memoizedState)||(rg=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}\nfunction yh(a){var b=th();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:vh,lastRenderedState:a};a=a.dispatch=zh.bind(null,N,a);return[b.memoizedState,a]}function Ah(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=N.updateQueue;null===b?(b={lastEffect:null},N.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}\nfunction Bh(){return uh().memoizedState}function Ch(a,b,c,d){var e=th();N.effectTag|=a;e.memoizedState=Ah(1|b,c,void 0,void 0===d?null:d)}function Dh(a,b,c,d){var e=uh();d=void 0===d?null:d;var f=void 0;if(null!==O){var g=O.memoizedState;f=g.destroy;if(null!==d&&nh(d,g.deps)){Ah(b,c,f,d);return}}N.effectTag|=a;e.memoizedState=Ah(1|b,c,f,d)}function Eh(a,b){return Ch(516,4,a,b)}function Fh(a,b){return Dh(516,4,a,b)}function Gh(a,b){return Dh(4,2,a,b)}\nfunction Hh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function Ih(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Dh(4,2,Hh.bind(null,b,a),c)}function Jh(){}function Kh(a,b){th().memoizedState=[a,void 0===b?null:b];return a}function Lh(a,b){var c=uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&nh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}\nfunction Mh(a,b){var c=uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&nh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Nh(a,b,c){var d=ag();cg(98>d?98:d,function(){a(!0)});cg(97<d?97:d,function(){var d=kh.suspense;kh.suspense=void 0===b?null:b;try{a(!1),c()}finally{kh.suspense=d}})}\nfunction zh(a,b,c){var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===N||null!==f&&f===N)mh=!0,e.expirationTime=lh,N.expirationTime=lh;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.eagerReducer=f;e.eagerState=h;if($e(h,g))return}catch(k){}finally{}Ig(a,\nd)}}\nvar sh={readContext:sg,useCallback:Q,useContext:Q,useEffect:Q,useImperativeHandle:Q,useLayoutEffect:Q,useMemo:Q,useReducer:Q,useRef:Q,useState:Q,useDebugValue:Q,useResponder:Q,useDeferredValue:Q,useTransition:Q},ph={readContext:sg,useCallback:Kh,useContext:sg,useEffect:Eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Ch(4,2,Hh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return Ch(4,2,a,b)},useMemo:function(a,b){var c=th();b=void 0===b?null:b;a=a();c.memoizedState=[a,\nb];return a},useReducer:function(a,b,c){var d=th();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=zh.bind(null,N,a);return[d.memoizedState,a]},useRef:function(a){var b=th();a={current:a};return b.memoizedState=a},useState:yh,useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=yh(a),d=c[0],e=c[1];Eh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a)}finally{kh.suspense=\nc}},[a,b]);return d},useTransition:function(a){var b=yh(!1),c=b[0];b=b[1];return[Kh(Nh.bind(null,b,a),[b,a]),c]}},qh={readContext:sg,useCallback:Lh,useContext:sg,useEffect:Fh,useImperativeHandle:Ih,useLayoutEffect:Gh,useMemo:Mh,useReducer:wh,useRef:Bh,useState:function(){return wh(vh)},useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=wh(vh),d=c[0],e=c[1];Fh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a)}finally{kh.suspense=c}},[a,b]);return d},useTransition:function(a){var b=\nwh(vh),c=b[0];b=b[1];return[Lh(Nh.bind(null,b,a),[b,a]),c]}},rh={readContext:sg,useCallback:Lh,useContext:sg,useEffect:Fh,useImperativeHandle:Ih,useLayoutEffect:Gh,useMemo:Mh,useReducer:xh,useRef:Bh,useState:function(){return xh(vh)},useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=xh(vh),d=c[0],e=c[1];Fh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a)}finally{kh.suspense=c}},[a,b]);return d},useTransition:function(a){var b=xh(vh),c=b[0];b=b[1];return[Lh(Nh.bind(null,\nb,a),[b,a]),c]}},Oh=null,Ph=null,Qh=!1;function Rh(a,b){var c=Sh(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}\nfunction Th(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}\nfunction Uh(a){if(Qh){var b=Ph;if(b){var c=b;if(!Th(a,b)){b=Jd(c.nextSibling);if(!b||!Th(a,b)){a.effectTag=a.effectTag&-1025|2;Qh=!1;Oh=a;return}Rh(Oh,c)}Oh=a;Ph=Jd(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Qh=!1,Oh=a}}function Vh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;Oh=a}\nfunction Wh(a){if(a!==Oh)return!1;if(!Qh)return Vh(a),Qh=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!Gd(b,a.memoizedProps))for(b=Ph;b;)Rh(a,b),b=Jd(b.nextSibling);Vh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(u(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===Ad){if(0===b){Ph=Jd(a.nextSibling);break a}b--}else c!==zd&&c!==Cd&&c!==Bd||b++}a=a.nextSibling}Ph=null}}else Ph=Oh?Jd(a.stateNode.nextSibling):null;return!0}\nfunction Xh(){Ph=Oh=null;Qh=!1}var Yh=Wa.ReactCurrentOwner,rg=!1;function R(a,b,c,d){b.child=null===a?Yg(b,null,c,d):Xg(b,a.child,c,d)}function Zh(a,b,c,d,e){c=c.render;var f=b.ref;qg(b,e);d=oh(a,b,c,d,f,e);if(null!==a&&!rg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),$h(a,b,e);b.effectTag|=1;R(a,b,d,e);return b.child}\nfunction ai(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!bi(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ci(a,b,g,d,e,f);a=Ug(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:bf,c(e,d)&&a.ref===b.ref))return $h(a,b,f);b.effectTag|=1;a=Sg(g,d);a.ref=b.ref;a.return=b;return b.child=a}\nfunction ci(a,b,c,d,e,f){return null!==a&&bf(a.memoizedProps,d)&&a.ref===b.ref&&(rg=!1,e<f)?(b.expirationTime=a.expirationTime,$h(a,b,f)):di(a,b,c,d,f)}function ei(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function di(a,b,c,d,e){var f=L(c)?Bf:J.current;f=Cf(b,f);qg(b,e);c=oh(a,b,c,d,f,e);if(null!==a&&!rg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),$h(a,b,e);b.effectTag|=1;R(a,b,c,e);return b.child}\nfunction fi(a,b,c,d,e){if(L(c)){var f=!0;Gf(b)}else f=!1;qg(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Lg(b,c,d),Ng(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=sg(l):(l=L(c)?Bf:J.current,l=Cf(b,l));var m=c.getDerivedStateFromProps,p="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;p||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&\n"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Mg(b,g,d,l);tg=!1;var x=b.memoizedState;g.state=x;zg(b,d,g,e);k=b.memoizedState;h!==d||x!==k||K.current||tg?("function"===typeof m&&(Fg(b,c,m,d),k=b.memoizedState),(h=tg||Kg(b,c,h,d,x,k,l))?(p||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===\ntypeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,vg(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:ig(b.type,h),k=g.context,l=c.contextType,"object"===typeof l&&null!==l?l=sg(l):(l=L(c)?Bf:J.current,l=Cf(b,l)),m=c.getDerivedStateFromProps,(p="function"===typeof m||"function"===\ntypeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Mg(b,g,d,l),tg=!1,k=b.memoizedState,g.state=k,zg(b,d,g,e),x=b.memoizedState,h!==d||k!==x||K.current||tg?("function"===typeof m&&(Fg(b,c,m,d),x=b.memoizedState),(m=tg||Kg(b,c,h,d,k,x,l))?(p||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,\nx,l),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,l)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=x),g.props=d,g.state=x,g.context=l,d=m):\n("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),d=!1);return gi(a,b,c,d,f,e)}\nfunction gi(a,b,c,d,e,f){ei(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hf(b,c,!1),$h(a,b,f);d=b.stateNode;Yh.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.effectTag|=1;null!==a&&g?(b.child=Xg(b,a.child,null,f),b.child=Xg(b,null,h,f)):R(a,b,h,f);b.memoizedState=d.state;e&&Hf(b,c,!0);return b.child}function hi(a){var b=a.stateNode;b.pendingContext?Ef(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Ef(a,b.context,!1);dh(a,b.containerInfo)}\nvar ii={dehydrated:null,retryTime:0};\nfunction ji(a,b,c){var d=b.mode,e=b.pendingProps,f=M.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);I(M,f&1);if(null===a){void 0!==e.fallback&&Uh(b);if(g){g=e.fallback;e=Wg(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Wg(g,d,c,null);c.return=\nb;e.sibling=c;b.memoizedState=ii;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Yg(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;c=Sg(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sg(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=ii;b.child=c;return d}c=Xg(b,a.child,e.children,c);b.memoizedState=null;return b.child=\nc}a=a.child;if(g){g=e.fallback;e=Wg(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Wg(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=ii;b.child=e;return c}b.memoizedState=null;return b.child=Xg(b,a,e.children,c)}\nfunction ki(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);pg(a.return,b)}function li(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}\nfunction mi(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;R(a,b,d.children,c);d=M.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&ki(a,c);else if(19===a.tag)ki(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}I(M,d);if(0===(b.mode&2))b.memoizedState=\nnull;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===hh(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);li(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===hh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}li(b,!0,c,null,f,b.lastEffect);break;case "together":li(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}\nfunction $h(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Bg(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(u(153));if(null!==b.child){a=b.child;c=Sg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sg(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}var ni,oi,pi,qi;\nni=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};oi=function(){};\npi=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;ch($g.current);a=null;switch(c){case "input":f=zb(g,f);d=zb(g,d);a=[];break;case "option":f=Gb(g,f);d=Gb(g,d);a=[];break;case "select":f=n({},f,{value:void 0});d=n({},d,{value:void 0});a=[];break;case "textarea":f=Ib(g,f);d=Ib(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=sd)}od(c,d);var h,k;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===\nh)for(k in g=f[h],g)g.hasOwnProperty(k)&&(c||(c={}),c[k]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(va.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var l=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&l!==g&&(null!=l||null!=g))if("style"===h)if(g){for(k in g)!g.hasOwnProperty(k)||l&&l.hasOwnProperty(k)||(c||(c={}),c[k]="");for(k in l)l.hasOwnProperty(k)&&g[k]!==l[k]&&(c||(c={}),\nc[k]=l[k])}else c||(a||(a=[]),a.push(h,c)),c=l;else"dangerouslySetInnerHTML"===h?(l=l?l.__html:void 0,g=g?g.__html:void 0,null!=l&&g!==l&&(a=a||[]).push(h,l)):"children"===h?g===l||"string"!==typeof l&&"number"!==typeof l||(a=a||[]).push(h,""+l):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(va.hasOwnProperty(h)?(null!=l&&rd(e,h),a||g===l||(a=[])):(a=a||[]).push(h,l))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};\nqi=function(a,b,c,d){c!==d&&(b.effectTag|=4)};function ri(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}\nfunction si(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return L(b.type)&&Df(),null;case 3:return eh(),H(K),H(J),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Wh(b)||(b.effectTag|=4),oi(b),null;case 5:gh(b);c=ch(bh.current);var e=b.type;if(null!==a&&null!=b.stateNode)pi(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(u(166));\nreturn null}a=ch($g.current);if(Wh(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Md]=b;d[Nd]=f;switch(e){case "iframe":case "object":case "embed":F("load",d);break;case "video":case "audio":for(a=0;a<ac.length;a++)F(ac[a],d);break;case "source":F("error",d);break;case "img":case "image":case "link":F("error",d);F("load",d);break;case "form":F("reset",d);F("submit",d);break;case "details":F("toggle",d);break;case "input":Ab(d,f);F("invalid",d);rd(c,"onChange");break;case "select":d._wrapperState=\n{wasMultiple:!!f.multiple};F("invalid",d);rd(c,"onChange");break;case "textarea":Jb(d,f),F("invalid",d),rd(c,"onChange")}od(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):va.hasOwnProperty(g)&&null!=h&&rd(c,g)}switch(e){case "input":xb(d);Eb(d,f,!0);break;case "textarea":xb(d);Lb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&\n(d.onclick=sd)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;a===qd&&(a=Nb(e));a===qd?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Md]=b;a[Nd]=d;ni(a,b,!1,!1);b.stateNode=a;g=pd(e,d);switch(e){case "iframe":case "object":case "embed":F("load",\na);h=d;break;case "video":case "audio":for(h=0;h<ac.length;h++)F(ac[h],a);h=d;break;case "source":F("error",a);h=d;break;case "img":case "image":case "link":F("error",a);F("load",a);h=d;break;case "form":F("reset",a);F("submit",a);h=d;break;case "details":F("toggle",a);h=d;break;case "input":Ab(a,d);h=zb(a,d);F("invalid",a);rd(c,"onChange");break;case "option":h=Gb(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=n({},d,{value:void 0});F("invalid",a);rd(c,"onChange");break;case "textarea":Jb(a,\nd);h=Ib(a,d);F("invalid",a);rd(c,"onChange");break;default:h=d}od(e,h);var k=h;for(f in k)if(k.hasOwnProperty(f)){var l=k[f];"style"===f?md(a,l):"dangerouslySetInnerHTML"===f?(l=l?l.__html:void 0,null!=l&&Qb(a,l)):"children"===f?"string"===typeof l?("textarea"!==e||""!==l)&&Rb(a,l):"number"===typeof l&&Rb(a,""+l):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(va.hasOwnProperty(f)?null!=l&&rd(c,f):null!=l&&Xa(a,f,l,g))}switch(e){case "input":xb(a);Eb(a,d,!1);\nbreak;case "textarea":xb(a);Lb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+rb(d.value));break;case "select":a.multiple=!!d.multiple;c=d.value;null!=c?Hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&Hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=sd)}Fd(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)qi(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(u(166));\nc=ch(bh.current);ch($g.current);Wh(b)?(c=b.stateNode,d=b.memoizedProps,c[Md]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),c[Md]=b,b.stateNode=c)}return null;case 13:H(M);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Wh(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=\ne,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||0!==(M.current&1))S===ti&&(S=ui);else{if(S===ti||S===ui)S=vi;0!==wi&&null!==T&&(xi(T,U),yi(T,wi))}if(c||d)b.effectTag|=4;return null;case 4:return eh(),oi(b),null;case 10:return og(b),null;case 17:return L(b.type)&&Df(),null;case 19:H(M);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)ri(d,!1);else{if(S!==ti||null!==a&&0!==(a.effectTag&\n64))for(f=b.child;null!==f;){a=hh(f);if(null!==a){b.effectTag|=64;ri(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,\ne.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;I(M,M.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=hh(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),ri(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=\nb.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*$f()-d.renderingStartTime>d.tailExpiration&&1<c&&(b.effectTag|=64,e=!0,ri(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=$f()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=$f(),c.sibling=null,b=M.current,I(M,e?b&1|2:b&1),c):null}throw Error(u(156,\nb.tag));}function zi(a){switch(a.tag){case 1:L(a.type)&&Df();var b=a.effectTag;return b&4096?(a.effectTag=b&-4097|64,a):null;case 3:eh();H(K);H(J);b=a.effectTag;if(0!==(b&64))throw Error(u(285));a.effectTag=b&-4097|64;return a;case 5:return gh(a),null;case 13:return H(M),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return H(M),null;case 4:return eh(),null;case 10:return og(a),null;default:return null}}function Ai(a,b){return{value:a,source:b,stack:qb(b)}}\nvar Bi="function"===typeof WeakSet?WeakSet:Set;function Ci(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=qb(c));null!==c&&pb(c.type);b=b.value;null!==a&&1===a.tag&&pb(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function Di(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Ei(a,c)}}function Fi(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Ei(a,c)}else b.current=null}\nfunction Gi(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:ig(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(u(163));}\nfunction Hi(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Ii(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}\nfunction Ji(a,b,c){switch(c.tag){case 0:case 11:case 15:case 22:Ii(3,c);return;case 1:a=c.stateNode;if(c.effectTag&4)if(null===b)a.componentDidMount();else{var d=c.elementType===c.type?b.memoizedProps:ig(c.type,b.memoizedProps);a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)}b=c.updateQueue;null!==b&&Cg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Cg(c,b,a)}return;\ncase 5:a=c.stateNode;null===b&&c.effectTag&4&&Fd(c.type,c.memoizedProps)&&a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&Vc(c))));return;case 19:case 17:case 20:case 21:return}throw Error(u(163));}\nfunction Ki(a,b,c){"function"===typeof Li&&Li(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;cg(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Ei(g,h)}}a=a.next}while(a!==d)})}break;case 1:Fi(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&Di(b,c);break;case 5:Fi(b);break;case 4:Mi(a,b,c)}}\nfunction Ni(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Ni(b)}function Oi(a){return 5===a.tag||3===a.tag||4===a.tag}\nfunction Pi(a){a:{for(var b=a.return;null!==b;){if(Oi(b)){var c=b;break a}b=b.return}throw Error(u(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(u(161));}c.effectTag&16&&(Rb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Oi(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;\nif(null===c.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Qi(a,c,b):Ri(a,c,b)}\nfunction Qi(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=sd));else if(4!==d&&(a=a.child,null!==a))for(Qi(a,b,c),a=a.sibling;null!==a;)Qi(a,b,c),a=a.sibling}\nfunction Ri(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Ri(a,b,c),a=a.sibling;null!==a;)Ri(a,b,c),a=a.sibling}\nfunction Mi(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(u(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=a,k=d,l=c,m=k;;)if(Ki(h,m,l),null!==m.child&&4!==m.tag)m.child.return=m,m=m.child;else{if(m===k)break a;for(;null===m.sibling;){if(null===m.return||m.return===k)break a;m=m.return}m.sibling.return=m.return;m=m.sibling}g?(h=\nf,k=d.stateNode,8===h.nodeType?h.parentNode.removeChild(k):h.removeChild(k)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ki(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}\nfunction Si(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Hi(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[Nd]=d;"input"===a&&"radio"===d.type&&null!=d.name&&Bb(c,d);pd(a,e);b=pd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],h=f[e+1];"style"===g?md(c,h):"dangerouslySetInnerHTML"===g?Qb(c,h):"children"===g?Rb(c,h):Xa(c,g,h,b)}switch(a){case "input":Cb(c,d);break;\ncase "textarea":Kb(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?Hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?Hb(c,!!d.multiple,d.defaultValue,!0):Hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(u(162));b.stateNode.nodeValue=b.memoizedProps;return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,Vc(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?\nd=!1:(d=!0,c=b.child,Ti=$f());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=ld("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=\nf;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Ui(b);return;case 19:Ui(b);return;case 17:return}throw Error(u(163));}function Ui(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Bi);b.forEach(function(b){var d=Vi.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}\nvar Wi="function"===typeof WeakMap?WeakMap:Map;function Xi(a,b,c){c=wg(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Yi||(Yi=!0,Zi=d);Ci(a,b)};return c}\nfunction $i(a,b,c){c=wg(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Ci(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===aj?aj=new Set([this]):aj.add(this),Ci(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}\nvar bj=Math.ceil,cj=Wa.ReactCurrentDispatcher,dj=Wa.ReactCurrentOwner,V=0,ej=8,fj=16,gj=32,ti=0,hj=1,ij=2,ui=3,vi=4,jj=5,W=V,T=null,X=null,U=0,S=ti,kj=null,lj=1073741823,mj=1073741823,nj=null,wi=0,oj=!1,Ti=0,pj=500,Y=null,Yi=!1,Zi=null,aj=null,qj=!1,rj=null,sj=90,tj=null,uj=0,vj=null,wj=0;function Gg(){return(W&(fj|gj))!==V?1073741821-($f()/10|0):0!==wj?wj:wj=1073741821-($f()/10|0)}\nfunction Hg(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=ag();if(0===(b&4))return 99===d?1073741823:1073741822;if((W&fj)!==V)return U;if(null!==c)a=hg(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=hg(a,150,100);break;case 97:case 96:a=hg(a,5E3,250);break;case 95:a=2;break;default:throw Error(u(326));}null!==T&&a===U&&--a;return a}\nfunction Ig(a,b){if(50<uj)throw uj=0,vj=null,Error(u(185));a=xj(a,b);if(null!==a){var c=ag();1073741823===b?(W&ej)!==V&&(W&(fj|gj))===V?yj(a):(Z(a),W===V&&gg()):Z(a);(W&4)===V||98!==c&&99!==c||(null===tj?tj=new Map([[a,b]]):(c=tj.get(a),(void 0===c||c>b)&&tj.set(a,b)))}}\nfunction xj(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&(T===e&&(Bg(b),S===vi&&xi(e,U)),yi(e,b));return e}\nfunction zj(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Aj(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}\nfunction Z(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=eg(yj.bind(null,a));else{var b=zj(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=Gg();1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Tf&&Kf(c)}a.callbackExpirationTime=\nb;a.callbackPriority=d;b=1073741823===b?eg(yj.bind(null,a)):dg(d,Bj.bind(null,a),{timeout:10*(1073741821-b)-$f()});a.callbackNode=b}}}\nfunction Bj(a,b){wj=0;if(b)return b=Gg(),Cj(a,b),Z(a),null;var c=zj(a);if(0!==c){b=a.callbackNode;if((W&(fj|gj))!==V)throw Error(u(327));Dj();a===T&&c===U||Ej(a,c);if(null!==X){var d=W;W|=fj;var e=Fj();do try{Gj();break}catch(h){Hj(a,h)}while(1);ng();W=d;cj.current=e;if(S===hj)throw b=kj,Ej(a,c),xi(a,c),Z(a),b;if(null===X)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=S,T=null,d){case ti:case hj:throw Error(u(345));case ij:Cj(a,2<c?2:c);break;case ui:xi(a,c);d=a.lastSuspendedTime;\nc===d&&(a.nextKnownPendingLevel=Ij(e));if(1073741823===lj&&(e=Ti+pj-$f(),10<e)){if(oj){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=c;Ej(a,c);break}}f=zj(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=Hd(Jj.bind(null,a),e);break}Jj(a);break;case vi:xi(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ij(e));if(oj&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;Ej(a,c);break}e=zj(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=\nd;break}1073741823!==mj?d=10*(1073741821-mj)-$f():1073741823===lj?d=0:(d=10*(1073741821-lj)-5E3,e=$f(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*bj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=Hd(Jj.bind(null,a),d);break}Jj(a);break;case jj:if(1073741823!==lj&&null!==nj){f=lj;var g=nj;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=$f()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){xi(a,c);a.timeoutHandle=\nHd(Jj.bind(null,a),d);break}}Jj(a);break;default:throw Error(u(329));}Z(a);if(a.callbackNode===b)return Bj.bind(null,a)}}return null}\nfunction yj(a){var b=a.lastExpiredTime;b=0!==b?b:1073741823;if((W&(fj|gj))!==V)throw Error(u(327));Dj();a===T&&b===U||Ej(a,b);if(null!==X){var c=W;W|=fj;var d=Fj();do try{Kj();break}catch(e){Hj(a,e)}while(1);ng();W=c;cj.current=d;if(S===hj)throw c=kj,Ej(a,b),xi(a,b),Z(a),c;if(null!==X)throw Error(u(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;T=null;Jj(a);Z(a)}return null}function Lj(){if(null!==tj){var a=tj;tj=null;a.forEach(function(a,c){Cj(c,a);Z(c)});gg()}}\nfunction Mj(a,b){var c=W;W|=1;try{return a(b)}finally{W=c,W===V&&gg()}}function Nj(a,b){var c=W;W&=-2;W|=ej;try{return a(b)}finally{W=c,W===V&&gg()}}\nfunction Ej(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Id(c));if(null!==X)for(c=X.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Df();break;case 3:eh();H(K);H(J);break;case 5:gh(d);break;case 4:eh();break;case 13:H(M);break;case 19:H(M);break;case 10:og(d)}c=c.return}T=a;X=Sg(a.current,null);U=b;S=ti;kj=null;mj=lj=1073741823;nj=null;wi=0;oj=!1}\nfunction Hj(a,b){do{try{ng();jh.current=sh;if(mh)for(var c=N.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}lh=0;P=O=N=null;mh=!1;if(null===X||null===X.return)return S=hj,kj=b,X=null;a:{var e=a,f=X.return,g=X,h=b;b=U;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var k=h;if(0===(g.mode&2)){var l=g.alternate;l?(g.updateQueue=l.updateQueue,g.memoizedState=l.memoizedState,g.expirationTime=l.expirationTime):(g.updateQueue=\nnull,g.memoizedState=null)}var m=0!==(M.current&1),p=f;do{var x;if(x=13===p.tag){var z=p.memoizedState;if(null!==z)x=null!==z.dehydrated?!0:!1;else{var ca=p.memoizedProps;x=void 0===ca.fallback?!1:!0!==ca.unstable_avoidThisFallback?!0:m?!1:!0}}if(x){var D=p.updateQueue;if(null===D){var t=new Set;t.add(k);p.updateQueue=t}else D.add(k);if(0===(p.mode&2)){p.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var y=wg(1073741823,null);y.tag=2;xg(g,y)}g.expirationTime=1073741823;\nbreak a}h=void 0;g=b;var A=e.pingCache;null===A?(A=e.pingCache=new Wi,h=new Set,A.set(k,h)):(h=A.get(k),void 0===h&&(h=new Set,A.set(k,h)));if(!h.has(g)){h.add(g);var q=Oj.bind(null,e,k,g);k.then(q,q)}p.effectTag|=4096;p.expirationTime=b;break a}p=p.return}while(null!==p);h=Error((pb(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\\n\\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+qb(g))}S!==\njj&&(S=ij);h=Ai(h,g);p=f;do{switch(p.tag){case 3:k=h;p.effectTag|=4096;p.expirationTime=b;var B=Xi(p,k,b);yg(p,B);break a;case 1:k=h;var w=p.type,ub=p.stateNode;if(0===(p.effectTag&64)&&("function"===typeof w.getDerivedStateFromError||null!==ub&&"function"===typeof ub.componentDidCatch&&(null===aj||!aj.has(ub)))){p.effectTag|=4096;p.expirationTime=b;var vb=$i(p,k,b);yg(p,vb);break a}}p=p.return}while(null!==p)}X=Pj(X)}catch(Xc){b=Xc;continue}break}while(1)}\nfunction Fj(){var a=cj.current;cj.current=sh;return null===a?sh:a}function Ag(a,b){a<lj&&2<a&&(lj=a);null!==b&&a<mj&&2<a&&(mj=a,nj=b)}function Bg(a){a>wi&&(wi=a)}function Kj(){for(;null!==X;)X=Qj(X)}function Gj(){for(;null!==X&&!Uf();)X=Qj(X)}function Qj(a){var b=Rj(a.alternate,a,U);a.memoizedProps=a.pendingProps;null===b&&(b=Pj(a));dj.current=null;return b}\nfunction Pj(a){X=a;do{var b=X.alternate;a=X.return;if(0===(X.effectTag&2048)){b=si(b,X,U);if(1===U||1!==X.childExpirationTime){for(var c=0,d=X.child;null!==d;){var e=d.expirationTime,f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}X.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=X.firstEffect),null!==X.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=X.firstEffect),a.lastEffect=X.lastEffect),1<X.effectTag&&(null!==\na.lastEffect?a.lastEffect.nextEffect=X:a.firstEffect=X,a.lastEffect=X))}else{b=zi(X);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=2048)}b=X.sibling;if(null!==b)return b;X=a}while(null!==X);S===ti&&(S=jj);return null}function Ij(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function Jj(a){var b=ag();cg(99,Sj.bind(null,a,b));return null}\nfunction Sj(a,b){do Dj();while(null!==rj);if((W&(fj|gj))!==V)throw Error(u(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(u(177));a.callbackNode=null;a.callbackExpirationTime=0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ij(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=\nd-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===T&&(X=T=null,U=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=W;W|=gj;dj.current=null;Dd=fd;var g=xd();if(yd(g)){if("selectionStart"in g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var k=h.getSelection&&h.getSelection();if(k&&0!==k.rangeCount){h=k.anchorNode;var l=k.anchorOffset,\nm=k.focusNode;k=k.focusOffset;try{h.nodeType,m.nodeType}catch(wb){h=null;break a}var p=0,x=-1,z=-1,ca=0,D=0,t=g,y=null;b:for(;;){for(var A;;){t!==h||0!==l&&3!==t.nodeType||(x=p+l);t!==m||0!==k&&3!==t.nodeType||(z=p+k);3===t.nodeType&&(p+=t.nodeValue.length);if(null===(A=t.firstChild))break;y=t;t=A}for(;;){if(t===g)break b;y===h&&++ca===l&&(x=p);y===m&&++D===k&&(z=p);if(null!==(A=t.nextSibling))break;t=y;y=t.parentNode}t=A}h=-1===x||-1===z?null:{start:x,end:z}}else h=null}h=h||{start:0,end:0}}else h=\nnull;Ed={activeElementDetached:null,focusedElem:g,selectionRange:h};fd=!1;Y=e;do try{Tj()}catch(wb){if(null===Y)throw Error(u(330));Ei(Y,wb);Y=Y.nextEffect}while(null!==Y);Y=e;do try{for(g=a,h=b;null!==Y;){var q=Y.effectTag;q&16&&Rb(Y.stateNode,"");if(q&128){var B=Y.alternate;if(null!==B){var w=B.ref;null!==w&&("function"===typeof w?w(null):w.current=null)}}switch(q&1038){case 2:Pi(Y);Y.effectTag&=-3;break;case 6:Pi(Y);Y.effectTag&=-3;Si(Y.alternate,Y);break;case 1024:Y.effectTag&=-1025;break;case 1028:Y.effectTag&=\n-1025;Si(Y.alternate,Y);break;case 4:Si(Y.alternate,Y);break;case 8:l=Y,Mi(g,l,h),Ni(l)}Y=Y.nextEffect}}catch(wb){if(null===Y)throw Error(u(330));Ei(Y,wb);Y=Y.nextEffect}while(null!==Y);w=Ed;B=xd();q=w.focusedElem;h=w.selectionRange;if(B!==q&&q&&q.ownerDocument&&wd(q.ownerDocument.documentElement,q)){null!==h&&yd(q)&&(B=h.start,w=h.end,void 0===w&&(w=B),"selectionStart"in q?(q.selectionStart=B,q.selectionEnd=Math.min(w,q.value.length)):(w=(B=q.ownerDocument||document)&&B.defaultView||window,w.getSelection&&\n(w=w.getSelection(),l=q.textContent.length,g=Math.min(h.start,l),h=void 0===h.end?g:Math.min(h.end,l),!w.extend&&g>h&&(l=h,h=g,g=l),l=vd(q,g),m=vd(q,h),l&&m&&(1!==w.rangeCount||w.anchorNode!==l.node||w.anchorOffset!==l.offset||w.focusNode!==m.node||w.focusOffset!==m.offset)&&(B=B.createRange(),B.setStart(l.node,l.offset),w.removeAllRanges(),g>h?(w.addRange(B),w.extend(m.node,m.offset)):(B.setEnd(m.node,m.offset),w.addRange(B))))));B=[];for(w=q;w=w.parentNode;)1===w.nodeType&&B.push({element:w,left:w.scrollLeft,\ntop:w.scrollTop});"function"===typeof q.focus&&q.focus();for(q=0;q<B.length;q++)w=B[q],w.element.scrollLeft=w.left,w.element.scrollTop=w.top}fd=!!Dd;Ed=Dd=null;a.current=c;Y=e;do try{for(q=a;null!==Y;){var ub=Y.effectTag;ub&36&&Ji(q,Y.alternate,Y);if(ub&128){B=void 0;var vb=Y.ref;if(null!==vb){var Xc=Y.stateNode;switch(Y.tag){case 5:B=Xc;break;default:B=Xc}"function"===typeof vb?vb(B):vb.current=B}}Y=Y.nextEffect}}catch(wb){if(null===Y)throw Error(u(330));Ei(Y,wb);Y=Y.nextEffect}while(null!==Y);Y=\nnull;Vf();W=f}else a.current=c;if(qj)qj=!1,rj=a,sj=b;else for(Y=e;null!==Y;)b=Y.nextEffect,Y.nextEffect=null,Y=b;b=a.firstPendingTime;0===b&&(aj=null);1073741823===b?a===vj?uj++:(uj=0,vj=a):uj=0;"function"===typeof Uj&&Uj(c.stateNode,d);Z(a);if(Yi)throw Yi=!1,a=Zi,Zi=null,a;if((W&ej)!==V)return null;gg();return null}function Tj(){for(;null!==Y;){var a=Y.effectTag;0!==(a&256)&&Gi(Y.alternate,Y);0===(a&512)||qj||(qj=!0,dg(97,function(){Dj();return null}));Y=Y.nextEffect}}\nfunction Dj(){if(90!==sj){var a=97<sj?97:sj;sj=90;return cg(a,Vj)}}function Vj(){if(null===rj)return!1;var a=rj;rj=null;if((W&(fj|gj))!==V)throw Error(u(331));var b=W;W|=gj;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Hi(5,c),Ii(5,c)}}catch(d){if(null===a)throw Error(u(330));Ei(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}W=b;gg();return!0}\nfunction Wj(a,b,c){b=Ai(c,b);b=Xi(a,b,1073741823);xg(a,b);a=xj(a,1073741823);null!==a&&Z(a)}function Ei(a,b){if(3===a.tag)Wj(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Wj(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===aj||!aj.has(d))){a=Ai(b,a);a=$i(c,a,1073741823);xg(c,a);c=xj(c,1073741823);null!==c&&Z(c);break}}c=c.return}}\nfunction Oj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);T===a&&U===c?S===vi||S===ui&&1073741823===lj&&$f()-Ti<pj?Ej(a,U):oj=!0:Aj(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,Z(a)))}function Vi(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=Gg(),b=Hg(b,a,null));a=xj(a,b);null!==a&&Z(a)}var Rj;\nRj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||K.current)rg=!0;else{if(d<c){rg=!1;switch(b.tag){case 3:hi(b);Xh();break;case 5:fh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:L(b.type)&&Gf(b);break;case 4:dh(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;I(jg,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;\nif(0!==d&&d>=c)return ji(a,b,c);I(M,M.current&1);b=$h(a,b,c);return null!==b?b.sibling:null}I(M,M.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return mi(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);I(M,M.current);if(!d)return null}return $h(a,b,c)}rg=!1}}else rg=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=Cf(b,J.current);qg(b,c);e=oh(null,\nb,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(L(d)){var f=!0;Gf(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ug(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Fg(b,d,g,a);e.updater=Jg;b.stateNode=e;e._reactInternalFiber=b;Ng(b,d,a,c);b=gi(null,b,d,!0,f,c)}else b.tag=0,R(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=\nnull,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ob(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Xj(e);a=ig(e,a);switch(f){case 0:b=di(null,b,e,a,c);break a;case 1:b=fi(null,b,e,a,c);break a;case 11:b=Zh(null,b,e,a,c);break a;case 14:b=ai(null,b,e,ig(e.type,a),d,c);break a}throw Error(u(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),di(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),fi(a,b,d,e,c);\ncase 3:hi(b);d=b.updateQueue;if(null===a||null===d)throw Error(u(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;vg(a,b);zg(b,d,null,c);d=b.memoizedState.element;if(d===e)Xh(),b=$h(a,b,c);else{if(e=b.stateNode.hydrate)Ph=Jd(b.stateNode.containerInfo.firstChild),Oh=b,e=Qh=!0;if(e)for(c=Yg(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else R(a,b,d,c),Xh();b=b.child}return b;case 5:return fh(b),null===a&&Uh(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:\nnull,g=e.children,Gd(d,e)?g=null:null!==f&&Gd(d,f)&&(b.effectTag|=16),ei(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(R(a,b,g,c),b=b.child),b;case 6:return null===a&&Uh(b),null;case 13:return ji(a,b,c);case 4:return dh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Xg(b,null,d,c):R(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),Zh(a,b,d,e,c);case 7:return R(a,b,b.pendingProps,c),b.child;case 8:return R(a,\nb,b.pendingProps.children,c),b.child;case 12:return R(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;I(jg,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=$e(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!K.current){b=$h(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var k=h.dependencies;if(null!==\nk){g=h.child;for(var l=k.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=wg(c,null),l.tag=2,xg(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);pg(h.return,c);k.expirationTime<c&&(k.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=\ng}R(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,qg(b,c),e=sg(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,R(a,b,d,c),b.child;case 14:return e=b.type,f=ig(e,b.pendingProps),f=ig(e.type,f),ai(a,b,e,f,d,c);case 15:return ci(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,L(d)?(a=!0,Gf(b)):a=!1,qg(b,c),Lg(b,d,e),Ng(b,d,e,c),gi(null,\nb,d,!0,a,c);case 19:return mi(a,b,c)}throw Error(u(156,b.tag));};var Uj=null,Li=null;function Yj(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);Uj=function(a){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(e){}};Li=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}\nfunction Zj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Sh(a,b,c,d){return new Zj(a,b,c,d)}\nfunction bi(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Xj(a){if("function"===typeof a)return bi(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===gb)return 11;if(a===jb)return 14}return 2}\nfunction Sg(a,b){var c=a.alternate;null===c?(c=Sh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,\nfirstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}\nfunction Ug(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)bi(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ab:return Wg(c.children,e,f,b);case fb:g=8;e|=7;break;case bb:g=8;e|=1;break;case cb:return a=Sh(12,c,b,e|8),a.elementType=cb,a.type=cb,a.expirationTime=f,a;case hb:return a=Sh(13,c,b,e),a.type=hb,a.elementType=hb,a.expirationTime=f,a;case ib:return a=Sh(19,c,b,e),a.elementType=ib,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case db:g=\n10;break a;case eb:g=9;break a;case gb:g=11;break a;case jb:g=14;break a;case kb:g=16;d=null;break a;case lb:g=22;break a}throw Error(u(130,null==a?a:typeof a,""));}b=Sh(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Wg(a,b,c,d){a=Sh(7,a,d,b);a.expirationTime=c;return a}function Tg(a,b,c){a=Sh(6,a,null,b);a.expirationTime=c;return a}\nfunction Vg(a,b,c){b=Sh(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}\nfunction ak(a,b,c){this.tag=b;this.current=null;this.containerInfo=a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}\nfunction Aj(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function xi(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}\nfunction yi(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Cj(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}\nfunction bk(a,b,c,d){var e=b.current,f=Gg(),g=Dg.suspense;f=Hg(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(dc(c)!==c||1!==c.tag)throw Error(u(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(L(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(u(171));}if(1===c.tag){var k=c.type;if(L(k)){c=Ff(c,k,h);break a}}c=h}else c=Af;null===b.context?b.context=c:b.pendingContext=c;b=wg(f,g);b.payload={element:a};d=void 0===\nd?null:d;null!==d&&(b.callback=d);xg(e,b);Ig(e,f);return f}function ck(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function dk(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function ek(a,b){dk(a,b);(a=a.alternate)&&dk(a,b)}\nfunction fk(a,b,c){c=null!=c&&!0===c.hydrate;var d=new ak(a,b,c),e=Sh(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ug(e);a[Od]=d.current;c&&0!==b&&Jc(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}fk.prototype.render=function(a){bk(a,this._internalRoot,null,null)};fk.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;bk(null,a,null,function(){b[Od]=null})};\nfunction gk(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function hk(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new fk(a,0,b?{hydrate:!0}:void 0)}\nfunction ik(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;if("function"===typeof e){var h=e;e=function(){var a=ck(g);h.call(a)}}bk(b,g,a,e)}else{f=c._reactRootContainer=hk(c,d);g=f._internalRoot;if("function"===typeof e){var k=e;e=function(){var a=ck(g);k.call(a)}}Nj(function(){bk(b,g,a,e)})}return ck(g)}function jk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:$a,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}\nwc=function(a){if(13===a.tag){var b=hg(Gg(),150,100);Ig(a,b);ek(a,b)}};xc=function(a){13===a.tag&&(Ig(a,3),ek(a,3))};yc=function(a){if(13===a.tag){var b=Gg();b=Hg(b,a,null);Ig(a,b);ek(a,b)}};\nza=function(a,b,c){switch(b){case "input":Cb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+\'][type="radio"]\');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Qd(d);if(!e)throw Error(u(90));yb(d);Cb(d,e)}}}break;case "textarea":Kb(a,c);break;case "select":b=c.value,null!=b&&Hb(a,!!c.multiple,b,!1)}};Fa=Mj;\nGa=function(a,b,c,d,e){var f=W;W|=4;try{return cg(98,a.bind(null,b,c,d,e))}finally{W=f,W===V&&gg()}};Ha=function(){(W&(1|fj|gj))===V&&(Lj(),Dj())};Ia=function(a,b){var c=W;W|=2;try{return a(b)}finally{W=c,W===V&&gg()}};function kk(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!gk(b))throw Error(u(200));return jk(a,b,null,c)}var lk={Events:[Nc,Pd,Qd,xa,ta,Xd,function(a){jc(a,Wd)},Da,Ea,id,mc,Dj,{current:!1}]};\n(function(a){var b=a.findFiberByHostInstance;return Yj(n({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Wa.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=hc(a);return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:tc,bundleType:0,version:"16.13.1",\nrendererPackageName:"react-dom"});exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=lk;exports.createPortal=kk;exports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===b){if("function"===typeof a.render)throw Error(u(188));throw Error(u(268,Object.keys(a)));}a=hc(b);a=null===a?null:a.stateNode;return a};\nexports.flushSync=function(a,b){if((W&(fj|gj))!==V)throw Error(u(187));var c=W;W|=1;try{return cg(99,a.bind(null,b))}finally{W=c,gg()}};exports.hydrate=function(a,b,c){if(!gk(b))throw Error(u(200));return ik(null,a,b,!0,c)};exports.render=function(a,b,c){if(!gk(b))throw Error(u(200));return ik(null,a,b,!1,c)};\nexports.unmountComponentAtNode=function(a){if(!gk(a))throw Error(u(40));return a._reactRootContainer?(Nj(function(){ik(null,null,a,!1,function(){a._reactRootContainer=null;a[Od]=null})}),!0):!1};exports.unstable_batchedUpdates=Mj;exports.unstable_createPortal=function(a,b){return kk(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};\nexports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!gk(c))throw Error(u(200));if(null==a||void 0===a._reactInternalFiber)throw Error(u(38));return ik(a,b,c,!1,d)};exports.version="16.13.1";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanM/Y2E1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qXG4gTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4qL1xuJ3VzZSBzdHJpY3QnO3ZhciBhYT1yZXF1aXJlKFwicmVhY3RcIiksbj1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxyPXJlcXVpcmUoXCJzY2hlZHVsZXJcIik7ZnVuY3Rpb24gdShhKXtmb3IodmFyIGI9XCJodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD1cIithLGM9MTtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKWIrPVwiJmFyZ3NbXT1cIitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2NdKTtyZXR1cm5cIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIithK1wiOyB2aXNpdCBcIitiK1wiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIn1pZighYWEpdGhyb3cgRXJyb3IodSgyMjcpKTtcbmZ1bmN0aW9uIGJhKGEsYixjLGQsZSxmLGcsaCxrKXt2YXIgbD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMyk7dHJ5e2IuYXBwbHkoYyxsKX1jYXRjaChtKXt0aGlzLm9uRXJyb3IobSl9fXZhciBkYT0hMSxlYT1udWxsLGZhPSExLGhhPW51bGwsaWE9e29uRXJyb3I6ZnVuY3Rpb24oYSl7ZGE9ITA7ZWE9YX19O2Z1bmN0aW9uIGphKGEsYixjLGQsZSxmLGcsaCxrKXtkYT0hMTtlYT1udWxsO2JhLmFwcGx5KGlhLGFyZ3VtZW50cyl9ZnVuY3Rpb24ga2EoYSxiLGMsZCxlLGYsZyxoLGspe2phLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihkYSl7aWYoZGEpe3ZhciBsPWVhO2RhPSExO2VhPW51bGx9ZWxzZSB0aHJvdyBFcnJvcih1KDE5OCkpO2ZhfHwoZmE9ITAsaGE9bCl9fXZhciBsYT1udWxsLG1hPW51bGwsbmE9bnVsbDtcbmZ1bmN0aW9uIG9hKGEsYixjKXt2YXIgZD1hLnR5cGV8fFwidW5rbm93bi1ldmVudFwiO2EuY3VycmVudFRhcmdldD1uYShjKTtrYShkLGIsdm9pZCAwLGEpO2EuY3VycmVudFRhcmdldD1udWxsfXZhciBwYT1udWxsLHFhPXt9O1xuZnVuY3Rpb24gcmEoKXtpZihwYSlmb3IodmFyIGEgaW4gcWEpe3ZhciBiPXFhW2FdLGM9cGEuaW5kZXhPZihhKTtpZighKC0xPGMpKXRocm93IEVycm9yKHUoOTYsYSkpO2lmKCFzYVtjXSl7aWYoIWIuZXh0cmFjdEV2ZW50cyl0aHJvdyBFcnJvcih1KDk3LGEpKTtzYVtjXT1iO2M9Yi5ldmVudFR5cGVzO2Zvcih2YXIgZCBpbiBjKXt2YXIgZT12b2lkIDA7dmFyIGY9Y1tkXSxnPWIsaD1kO2lmKHRhLmhhc093blByb3BlcnR5KGgpKXRocm93IEVycm9yKHUoOTksaCkpO3RhW2hdPWY7dmFyIGs9Zi5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztpZihrKXtmb3IoZSBpbiBrKWsuaGFzT3duUHJvcGVydHkoZSkmJnVhKGtbZV0sZyxoKTtlPSEwfWVsc2UgZi5yZWdpc3RyYXRpb25OYW1lPyh1YShmLnJlZ2lzdHJhdGlvbk5hbWUsZyxoKSxlPSEwKTplPSExO2lmKCFlKXRocm93IEVycm9yKHUoOTgsZCxhKSk7fX19fVxuZnVuY3Rpb24gdWEoYSxiLGMpe2lmKHZhW2FdKXRocm93IEVycm9yKHUoMTAwLGEpKTt2YVthXT1iO3dhW2FdPWIuZXZlbnRUeXBlc1tjXS5kZXBlbmRlbmNpZXN9dmFyIHNhPVtdLHRhPXt9LHZhPXt9LHdhPXt9O2Z1bmN0aW9uIHhhKGEpe3ZhciBiPSExLGM7Zm9yKGMgaW4gYSlpZihhLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD1hW2NdO2lmKCFxYS5oYXNPd25Qcm9wZXJ0eShjKXx8cWFbY10hPT1kKXtpZihxYVtjXSl0aHJvdyBFcnJvcih1KDEwMixjKSk7cWFbY109ZDtiPSEwfX1iJiZyYSgpfXZhciB5YT0hKFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudHx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCksemE9bnVsbCxBYT1udWxsLEJhPW51bGw7XG5mdW5jdGlvbiBDYShhKXtpZihhPW1hKGEpKXtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgemEpdGhyb3cgRXJyb3IodSgyODApKTt2YXIgYj1hLnN0YXRlTm9kZTtiJiYoYj1sYShiKSx6YShhLnN0YXRlTm9kZSxhLnR5cGUsYikpfX1mdW5jdGlvbiBEYShhKXtBYT9CYT9CYS5wdXNoKGEpOkJhPVthXTpBYT1hfWZ1bmN0aW9uIEVhKCl7aWYoQWEpe3ZhciBhPUFhLGI9QmE7QmE9QWE9bnVsbDtDYShhKTtpZihiKWZvcihhPTA7YTxiLmxlbmd0aDthKyspQ2EoYlthXSl9fWZ1bmN0aW9uIEZhKGEsYil7cmV0dXJuIGEoYil9ZnVuY3Rpb24gR2EoYSxiLGMsZCxlKXtyZXR1cm4gYShiLGMsZCxlKX1mdW5jdGlvbiBIYSgpe312YXIgSWE9RmEsSmE9ITEsS2E9ITE7ZnVuY3Rpb24gTGEoKXtpZihudWxsIT09QWF8fG51bGwhPT1CYSlIYSgpLEVhKCl9XG5mdW5jdGlvbiBNYShhLGIsYyl7aWYoS2EpcmV0dXJuIGEoYixjKTtLYT0hMDt0cnl7cmV0dXJuIElhKGEsYixjKX1maW5hbGx5e0thPSExLExhKCl9fXZhciBOYT0vXls6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF1bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXC0uMC05XFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MF0qJC8sT2E9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxQYT17fSxRYT17fTtcbmZ1bmN0aW9uIFJhKGEpe2lmKE9hLmNhbGwoUWEsYSkpcmV0dXJuITA7aWYoT2EuY2FsbChQYSxhKSlyZXR1cm4hMTtpZihOYS50ZXN0KGEpKXJldHVybiBRYVthXT0hMDtQYVthXT0hMDtyZXR1cm4hMX1mdW5jdGlvbiBTYShhLGIsYyxkKXtpZihudWxsIT09YyYmMD09PWMudHlwZSlyZXR1cm4hMTtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJmdW5jdGlvblwiOmNhc2UgXCJzeW1ib2xcIjpyZXR1cm4hMDtjYXNlIFwiYm9vbGVhblwiOmlmKGQpcmV0dXJuITE7aWYobnVsbCE9PWMpcmV0dXJuIWMuYWNjZXB0c0Jvb2xlYW5zO2E9YS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsNSk7cmV0dXJuXCJkYXRhLVwiIT09YSYmXCJhcmlhLVwiIT09YTtkZWZhdWx0OnJldHVybiExfX1cbmZ1bmN0aW9uIFRhKGEsYixjLGQpe2lmKG51bGw9PT1ifHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGJ8fFNhKGEsYixjLGQpKXJldHVybiEwO2lmKGQpcmV0dXJuITE7aWYobnVsbCE9PWMpc3dpdGNoKGMudHlwZSl7Y2FzZSAzOnJldHVybiFiO2Nhc2UgNDpyZXR1cm4hMT09PWI7Y2FzZSA1OnJldHVybiBpc05hTihiKTtjYXNlIDY6cmV0dXJuIGlzTmFOKGIpfHwxPmJ9cmV0dXJuITF9ZnVuY3Rpb24gdihhLGIsYyxkLGUsZil7dGhpcy5hY2NlcHRzQm9vbGVhbnM9Mj09PWJ8fDM9PT1ifHw0PT09Yjt0aGlzLmF0dHJpYnV0ZU5hbWU9ZDt0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZT1lO3RoaXMubXVzdFVzZVByb3BlcnR5PWM7dGhpcy5wcm9wZXJ0eU5hbWU9YTt0aGlzLnR5cGU9Yjt0aGlzLnNhbml0aXplVVJMPWZ9dmFyIEM9e307XG5cImNoaWxkcmVuIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGRlZmF1bHRWYWx1ZSBkZWZhdWx0Q2hlY2tlZCBpbm5lckhUTUwgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyBzdHlsZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0NbYV09bmV3IHYoYSwwLCExLGEsbnVsbCwhMSl9KTtbW1wiYWNjZXB0Q2hhcnNldFwiLFwiYWNjZXB0LWNoYXJzZXRcIl0sW1wiY2xhc3NOYW1lXCIsXCJjbGFzc1wiXSxbXCJodG1sRm9yXCIsXCJmb3JcIl0sW1wiaHR0cEVxdWl2XCIsXCJodHRwLWVxdWl2XCJdXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF07Q1tiXT1uZXcgdihiLDEsITEsYVsxXSxudWxsLCExKX0pO1tcImNvbnRlbnRFZGl0YWJsZVwiLFwiZHJhZ2dhYmxlXCIsXCJzcGVsbENoZWNrXCIsXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0NbYV09bmV3IHYoYSwyLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExKX0pO1xuW1wiYXV0b1JldmVyc2VcIixcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcImZvY3VzYWJsZVwiLFwicHJlc2VydmVBbHBoYVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0NbYV09bmV3IHYoYSwyLCExLGEsbnVsbCwhMSl9KTtcImFsbG93RnVsbFNjcmVlbiBhc3luYyBhdXRvRm9jdXMgYXV0b1BsYXkgY29udHJvbHMgZGVmYXVsdCBkZWZlciBkaXNhYmxlZCBkaXNhYmxlUGljdHVyZUluUGljdHVyZSBmb3JtTm9WYWxpZGF0ZSBoaWRkZW4gbG9vcCBub01vZHVsZSBub1ZhbGlkYXRlIG9wZW4gcGxheXNJbmxpbmUgcmVhZE9ubHkgcmVxdWlyZWQgcmV2ZXJzZWQgc2NvcGVkIHNlYW1sZXNzIGl0ZW1TY29wZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0NbYV09bmV3IHYoYSwzLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExKX0pO1xuW1wiY2hlY2tlZFwiLFwibXVsdGlwbGVcIixcIm11dGVkXCIsXCJzZWxlY3RlZFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0NbYV09bmV3IHYoYSwzLCEwLGEsbnVsbCwhMSl9KTtbXCJjYXB0dXJlXCIsXCJkb3dubG9hZFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0NbYV09bmV3IHYoYSw0LCExLGEsbnVsbCwhMSl9KTtbXCJjb2xzXCIsXCJyb3dzXCIsXCJzaXplXCIsXCJzcGFuXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7Q1thXT1uZXcgdihhLDYsITEsYSxudWxsLCExKX0pO1tcInJvd1NwYW5cIixcInN0YXJ0XCJdLmZvckVhY2goZnVuY3Rpb24oYSl7Q1thXT1uZXcgdihhLDUsITEsYS50b0xvd2VyQ2FzZSgpLG51bGwsITEpfSk7dmFyIFVhPS9bXFwtOl0oW2Etel0pL2c7ZnVuY3Rpb24gVmEoYSl7cmV0dXJuIGFbMV0udG9VcHBlckNhc2UoKX1cblwiYWNjZW50LWhlaWdodCBhbGlnbm1lbnQtYmFzZWxpbmUgYXJhYmljLWZvcm0gYmFzZWxpbmUtc2hpZnQgY2FwLWhlaWdodCBjbGlwLXBhdGggY2xpcC1ydWxlIGNvbG9yLWludGVycG9sYXRpb24gY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzIGNvbG9yLXByb2ZpbGUgY29sb3ItcmVuZGVyaW5nIGRvbWluYW50LWJhc2VsaW5lIGVuYWJsZS1iYWNrZ3JvdW5kIGZpbGwtb3BhY2l0eSBmaWxsLXJ1bGUgZmxvb2QtY29sb3IgZmxvb2Qtb3BhY2l0eSBmb250LWZhbWlseSBmb250LXNpemUgZm9udC1zaXplLWFkanVzdCBmb250LXN0cmV0Y2ggZm9udC1zdHlsZSBmb250LXZhcmlhbnQgZm9udC13ZWlnaHQgZ2x5cGgtbmFtZSBnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsIGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsIGhvcml6LWFkdi14IGhvcml6LW9yaWdpbi14IGltYWdlLXJlbmRlcmluZyBsZXR0ZXItc3BhY2luZyBsaWdodGluZy1jb2xvciBtYXJrZXItZW5kIG1hcmtlci1taWQgbWFya2VyLXN0YXJ0IG92ZXJsaW5lLXBvc2l0aW9uIG92ZXJsaW5lLXRoaWNrbmVzcyBwYWludC1vcmRlciBwYW5vc2UtMSBwb2ludGVyLWV2ZW50cyByZW5kZXJpbmctaW50ZW50IHNoYXBlLXJlbmRlcmluZyBzdG9wLWNvbG9yIHN0b3Atb3BhY2l0eSBzdHJpa2V0aHJvdWdoLXBvc2l0aW9uIHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzIHN0cm9rZS1kYXNoYXJyYXkgc3Ryb2tlLWRhc2hvZmZzZXQgc3Ryb2tlLWxpbmVjYXAgc3Ryb2tlLWxpbmVqb2luIHN0cm9rZS1taXRlcmxpbWl0IHN0cm9rZS1vcGFjaXR5IHN0cm9rZS13aWR0aCB0ZXh0LWFuY2hvciB0ZXh0LWRlY29yYXRpb24gdGV4dC1yZW5kZXJpbmcgdW5kZXJsaW5lLXBvc2l0aW9uIHVuZGVybGluZS10aGlja25lc3MgdW5pY29kZS1iaWRpIHVuaWNvZGUtcmFuZ2UgdW5pdHMtcGVyLWVtIHYtYWxwaGFiZXRpYyB2LWhhbmdpbmcgdi1pZGVvZ3JhcGhpYyB2LW1hdGhlbWF0aWNhbCB2ZWN0b3ItZWZmZWN0IHZlcnQtYWR2LXkgdmVydC1vcmlnaW4teCB2ZXJ0LW9yaWdpbi15IHdvcmQtc3BhY2luZyB3cml0aW5nLW1vZGUgeG1sbnM6eGxpbmsgeC1oZWlnaHRcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoVWEsXG5WYSk7Q1tiXT1uZXcgdihiLDEsITEsYSxudWxsLCExKX0pO1wieGxpbms6YWN0dWF0ZSB4bGluazphcmNyb2xlIHhsaW5rOnJvbGUgeGxpbms6c2hvdyB4bGluazp0aXRsZSB4bGluazp0eXBlXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKFVhLFZhKTtDW2JdPW5ldyB2KGIsMSwhMSxhLFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCExKX0pO1tcInhtbDpiYXNlXCIsXCJ4bWw6bGFuZ1wiLFwieG1sOnNwYWNlXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKFVhLFZhKTtDW2JdPW5ldyB2KGIsMSwhMSxhLFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsITEpfSk7W1widGFiSW5kZXhcIixcImNyb3NzT3JpZ2luXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7Q1thXT1uZXcgdihhLDEsITEsYS50b0xvd2VyQ2FzZSgpLG51bGwsITEpfSk7XG5DLnhsaW5rSHJlZj1uZXcgdihcInhsaW5rSHJlZlwiLDEsITEsXCJ4bGluazpocmVmXCIsXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsITApO1tcInNyY1wiLFwiaHJlZlwiLFwiYWN0aW9uXCIsXCJmb3JtQWN0aW9uXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7Q1thXT1uZXcgdihhLDEsITEsYS50b0xvd2VyQ2FzZSgpLG51bGwsITApfSk7dmFyIFdhPWFhLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1dhLmhhc093blByb3BlcnR5KFwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlclwiKXx8KFdhLlJlYWN0Q3VycmVudERpc3BhdGNoZXI9e2N1cnJlbnQ6bnVsbH0pO1dhLmhhc093blByb3BlcnR5KFwiUmVhY3RDdXJyZW50QmF0Y2hDb25maWdcIil8fChXYS5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZz17c3VzcGVuc2U6bnVsbH0pO1xuZnVuY3Rpb24gWGEoYSxiLGMsZCl7dmFyIGU9Qy5oYXNPd25Qcm9wZXJ0eShiKT9DW2JdOm51bGw7dmFyIGY9bnVsbCE9PWU/MD09PWUudHlwZTpkPyExOiEoMjxiLmxlbmd0aCl8fFwib1wiIT09YlswXSYmXCJPXCIhPT1iWzBdfHxcIm5cIiE9PWJbMV0mJlwiTlwiIT09YlsxXT8hMTohMDtmfHwoVGEoYixjLGUsZCkmJihjPW51bGwpLGR8fG51bGw9PT1lP1JhKGIpJiYobnVsbD09PWM/YS5yZW1vdmVBdHRyaWJ1dGUoYik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKTplLm11c3RVc2VQcm9wZXJ0eT9hW2UucHJvcGVydHlOYW1lXT1udWxsPT09Yz8zPT09ZS50eXBlPyExOlwiXCI6YzooYj1lLmF0dHJpYnV0ZU5hbWUsZD1lLmF0dHJpYnV0ZU5hbWVzcGFjZSxudWxsPT09Yz9hLnJlbW92ZUF0dHJpYnV0ZShiKTooZT1lLnR5cGUsYz0zPT09ZXx8ND09PWUmJiEwPT09Yz9cIlwiOlwiXCIrYyxkP2Euc2V0QXR0cmlidXRlTlMoZCxiLGMpOmEuc2V0QXR0cmlidXRlKGIsYykpKSl9XG52YXIgWWE9L14oLiopW1xcXFxcXC9dLyxFPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3IsWmE9RT9TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMywkYT1FP1N5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYsYWI9RT9TeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik6NjAxMDcsYmI9RT9TeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik6NjAxMDgsY2I9RT9TeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik6NjAxMTQsZGI9RT9TeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik6NjAxMDksZWI9RT9TeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKTo2MDExMCxmYj1FP1N5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIik6NjAxMTEsZ2I9RT9TeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIik6NjAxMTIsaGI9RT9TeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik6NjAxMTMsaWI9RT9TeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKTpcbjYwMTIwLGpiPUU/U3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik6NjAxMTUsa2I9RT9TeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTo2MDExNixsYj1FP1N5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKTo2MDEyMSxtYj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3I7ZnVuY3Rpb24gbmIoYSl7aWYobnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYSlyZXR1cm4gbnVsbDthPW1iJiZhW21iXXx8YVtcIkBAaXRlcmF0b3JcIl07cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YTpudWxsfWZ1bmN0aW9uIG9iKGEpe2lmKC0xPT09YS5fc3RhdHVzKXthLl9zdGF0dXM9MDt2YXIgYj1hLl9jdG9yO2I9YigpO2EuX3Jlc3VsdD1iO2IudGhlbihmdW5jdGlvbihiKXswPT09YS5fc3RhdHVzJiYoYj1iLmRlZmF1bHQsYS5fc3RhdHVzPTEsYS5fcmVzdWx0PWIpfSxmdW5jdGlvbihiKXswPT09YS5fc3RhdHVzJiYoYS5fc3RhdHVzPTIsYS5fcmVzdWx0PWIpfSl9fVxuZnVuY3Rpb24gcGIoYSl7aWYobnVsbD09YSlyZXR1cm4gbnVsbDtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSlyZXR1cm4gYS5kaXNwbGF5TmFtZXx8YS5uYW1lfHxudWxsO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYSlyZXR1cm4gYTtzd2l0Y2goYSl7Y2FzZSBhYjpyZXR1cm5cIkZyYWdtZW50XCI7Y2FzZSAkYTpyZXR1cm5cIlBvcnRhbFwiO2Nhc2UgY2I6cmV0dXJuXCJQcm9maWxlclwiO2Nhc2UgYmI6cmV0dXJuXCJTdHJpY3RNb2RlXCI7Y2FzZSBoYjpyZXR1cm5cIlN1c3BlbnNlXCI7Y2FzZSBpYjpyZXR1cm5cIlN1c3BlbnNlTGlzdFwifWlmKFwib2JqZWN0XCI9PT10eXBlb2YgYSlzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSBlYjpyZXR1cm5cIkNvbnRleHQuQ29uc3VtZXJcIjtjYXNlIGRiOnJldHVyblwiQ29udGV4dC5Qcm92aWRlclwiO2Nhc2UgZ2I6dmFyIGI9YS5yZW5kZXI7Yj1iLmRpc3BsYXlOYW1lfHxiLm5hbWV8fFwiXCI7cmV0dXJuIGEuZGlzcGxheU5hbWV8fChcIlwiIT09Yj9cIkZvcndhcmRSZWYoXCIrYitcIilcIjpcblwiRm9yd2FyZFJlZlwiKTtjYXNlIGpiOnJldHVybiBwYihhLnR5cGUpO2Nhc2UgbGI6cmV0dXJuIHBiKGEucmVuZGVyKTtjYXNlIGtiOmlmKGE9MT09PWEuX3N0YXR1cz9hLl9yZXN1bHQ6bnVsbClyZXR1cm4gcGIoYSl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gcWIoYSl7dmFyIGI9XCJcIjtkb3thOnN3aXRjaChhLnRhZyl7Y2FzZSAzOmNhc2UgNDpjYXNlIDY6Y2FzZSA3OmNhc2UgMTA6Y2FzZSA5OnZhciBjPVwiXCI7YnJlYWsgYTtkZWZhdWx0OnZhciBkPWEuX2RlYnVnT3duZXIsZT1hLl9kZWJ1Z1NvdXJjZSxmPXBiKGEudHlwZSk7Yz1udWxsO2QmJihjPXBiKGQudHlwZSkpO2Q9ZjtmPVwiXCI7ZT9mPVwiIChhdCBcIitlLmZpbGVOYW1lLnJlcGxhY2UoWWEsXCJcIikrXCI6XCIrZS5saW5lTnVtYmVyK1wiKVwiOmMmJihmPVwiIChjcmVhdGVkIGJ5IFwiK2MrXCIpXCIpO2M9XCJcXG4gICAgaW4gXCIrKGR8fFwiVW5rbm93blwiKStmfWIrPWM7YT1hLnJldHVybn13aGlsZShhKTtyZXR1cm4gYn1cbmZ1bmN0aW9uIHJiKGEpe3N3aXRjaCh0eXBlb2YgYSl7Y2FzZSBcImJvb2xlYW5cIjpjYXNlIFwibnVtYmVyXCI6Y2FzZSBcIm9iamVjdFwiOmNhc2UgXCJzdHJpbmdcIjpjYXNlIFwidW5kZWZpbmVkXCI6cmV0dXJuIGE7ZGVmYXVsdDpyZXR1cm5cIlwifX1mdW5jdGlvbiBzYihhKXt2YXIgYj1hLnR5cGU7cmV0dXJuKGE9YS5ub2RlTmFtZSkmJlwiaW5wdXRcIj09PWEudG9Mb3dlckNhc2UoKSYmKFwiY2hlY2tib3hcIj09PWJ8fFwicmFkaW9cIj09PWIpfVxuZnVuY3Rpb24gdGIoYSl7dmFyIGI9c2IoYSk/XCJjaGVja2VkXCI6XCJ2YWx1ZVwiLGM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxiKSxkPVwiXCIrYVtiXTtpZighYS5oYXNPd25Qcm9wZXJ0eShiKSYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5nZXQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLnNldCl7dmFyIGU9Yy5nZXQsZj1jLnNldDtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGUuY2FsbCh0aGlzKX0sc2V0OmZ1bmN0aW9uKGEpe2Q9XCJcIithO2YuY2FsbCh0aGlzLGEpfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIse2VudW1lcmFibGU6Yy5lbnVtZXJhYmxlfSk7cmV0dXJue2dldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGR9LHNldFZhbHVlOmZ1bmN0aW9uKGEpe2Q9XCJcIithfSxzdG9wVHJhY2tpbmc6ZnVuY3Rpb24oKXthLl92YWx1ZVRyYWNrZXI9XG5udWxsO2RlbGV0ZSBhW2JdfX19fWZ1bmN0aW9uIHhiKGEpe2EuX3ZhbHVlVHJhY2tlcnx8KGEuX3ZhbHVlVHJhY2tlcj10YihhKSl9ZnVuY3Rpb24geWIoYSl7aWYoIWEpcmV0dXJuITE7dmFyIGI9YS5fdmFsdWVUcmFja2VyO2lmKCFiKXJldHVybiEwO3ZhciBjPWIuZ2V0VmFsdWUoKTt2YXIgZD1cIlwiO2EmJihkPXNiKGEpP2EuY2hlY2tlZD9cInRydWVcIjpcImZhbHNlXCI6YS52YWx1ZSk7YT1kO3JldHVybiBhIT09Yz8oYi5zZXRWYWx1ZShhKSwhMCk6ITF9ZnVuY3Rpb24gemIoYSxiKXt2YXIgYz1iLmNoZWNrZWQ7cmV0dXJuIG4oe30sYix7ZGVmYXVsdENoZWNrZWQ6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsdmFsdWU6dm9pZCAwLGNoZWNrZWQ6bnVsbCE9Yz9jOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZH0pfVxuZnVuY3Rpb24gQWIoYSxiKXt2YXIgYz1udWxsPT1iLmRlZmF1bHRWYWx1ZT9cIlwiOmIuZGVmYXVsdFZhbHVlLGQ9bnVsbCE9Yi5jaGVja2VkP2IuY2hlY2tlZDpiLmRlZmF1bHRDaGVja2VkO2M9cmIobnVsbCE9Yi52YWx1ZT9iLnZhbHVlOmMpO2EuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbENoZWNrZWQ6ZCxpbml0aWFsVmFsdWU6Yyxjb250cm9sbGVkOlwiY2hlY2tib3hcIj09PWIudHlwZXx8XCJyYWRpb1wiPT09Yi50eXBlP251bGwhPWIuY2hlY2tlZDpudWxsIT1iLnZhbHVlfX1mdW5jdGlvbiBCYihhLGIpe2I9Yi5jaGVja2VkO251bGwhPWImJlhhKGEsXCJjaGVja2VkXCIsYiwhMSl9XG5mdW5jdGlvbiBDYihhLGIpe0JiKGEsYik7dmFyIGM9cmIoYi52YWx1ZSksZD1iLnR5cGU7aWYobnVsbCE9YylpZihcIm51bWJlclwiPT09ZCl7aWYoMD09PWMmJlwiXCI9PT1hLnZhbHVlfHxhLnZhbHVlIT1jKWEudmFsdWU9XCJcIitjfWVsc2UgYS52YWx1ZSE9PVwiXCIrYyYmKGEudmFsdWU9XCJcIitjKTtlbHNlIGlmKFwic3VibWl0XCI9PT1kfHxcInJlc2V0XCI9PT1kKXthLnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO3JldHVybn1iLmhhc093blByb3BlcnR5KFwidmFsdWVcIik/RGIoYSxiLnR5cGUsYyk6Yi5oYXNPd25Qcm9wZXJ0eShcImRlZmF1bHRWYWx1ZVwiKSYmRGIoYSxiLnR5cGUscmIoYi5kZWZhdWx0VmFsdWUpKTtudWxsPT1iLmNoZWNrZWQmJm51bGwhPWIuZGVmYXVsdENoZWNrZWQmJihhLmRlZmF1bHRDaGVja2VkPSEhYi5kZWZhdWx0Q2hlY2tlZCl9XG5mdW5jdGlvbiBFYihhLGIsYyl7aWYoYi5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpfHxiLmhhc093blByb3BlcnR5KFwiZGVmYXVsdFZhbHVlXCIpKXt2YXIgZD1iLnR5cGU7aWYoIShcInN1Ym1pdFwiIT09ZCYmXCJyZXNldFwiIT09ZHx8dm9pZCAwIT09Yi52YWx1ZSYmbnVsbCE9PWIudmFsdWUpKXJldHVybjtiPVwiXCIrYS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtjfHxiPT09YS52YWx1ZXx8KGEudmFsdWU9Yik7YS5kZWZhdWx0VmFsdWU9Yn1jPWEubmFtZTtcIlwiIT09YyYmKGEubmFtZT1cIlwiKTthLmRlZmF1bHRDaGVja2VkPSEhYS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkO1wiXCIhPT1jJiYoYS5uYW1lPWMpfVxuZnVuY3Rpb24gRGIoYSxiLGMpe2lmKFwibnVtYmVyXCIhPT1ifHxhLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCE9PWEpbnVsbD09Yz9hLmRlZmF1bHRWYWx1ZT1cIlwiK2EuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU6YS5kZWZhdWx0VmFsdWUhPT1cIlwiK2MmJihhLmRlZmF1bHRWYWx1ZT1cIlwiK2MpfWZ1bmN0aW9uIEZiKGEpe3ZhciBiPVwiXCI7YWEuQ2hpbGRyZW4uZm9yRWFjaChhLGZ1bmN0aW9uKGEpe251bGwhPWEmJihiKz1hKX0pO3JldHVybiBifWZ1bmN0aW9uIEdiKGEsYil7YT1uKHtjaGlsZHJlbjp2b2lkIDB9LGIpO2lmKGI9RmIoYi5jaGlsZHJlbikpYS5jaGlsZHJlbj1iO3JldHVybiBhfVxuZnVuY3Rpb24gSGIoYSxiLGMsZCl7YT1hLm9wdGlvbnM7aWYoYil7Yj17fTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyliW1wiJFwiK2NbZV1dPSEwO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspZT1iLmhhc093blByb3BlcnR5KFwiJFwiK2FbY10udmFsdWUpLGFbY10uc2VsZWN0ZWQhPT1lJiYoYVtjXS5zZWxlY3RlZD1lKSxlJiZkJiYoYVtjXS5kZWZhdWx0U2VsZWN0ZWQ9ITApfWVsc2V7Yz1cIlwiK3JiKGMpO2I9bnVsbDtmb3IoZT0wO2U8YS5sZW5ndGg7ZSsrKXtpZihhW2VdLnZhbHVlPT09Yyl7YVtlXS5zZWxlY3RlZD0hMDtkJiYoYVtlXS5kZWZhdWx0U2VsZWN0ZWQ9ITApO3JldHVybn1udWxsIT09Ynx8YVtlXS5kaXNhYmxlZHx8KGI9YVtlXSl9bnVsbCE9PWImJihiLnNlbGVjdGVkPSEwKX19XG5mdW5jdGlvbiBJYihhLGIpe2lmKG51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpdGhyb3cgRXJyb3IodSg5MSkpO3JldHVybiBuKHt9LGIse3ZhbHVlOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLGNoaWxkcmVuOlwiXCIrYS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZX0pfWZ1bmN0aW9uIEpiKGEsYil7dmFyIGM9Yi52YWx1ZTtpZihudWxsPT1jKXtjPWIuY2hpbGRyZW47Yj1iLmRlZmF1bHRWYWx1ZTtpZihudWxsIT1jKXtpZihudWxsIT1iKXRocm93IEVycm9yKHUoOTIpKTtpZihBcnJheS5pc0FycmF5KGMpKXtpZighKDE+PWMubGVuZ3RoKSl0aHJvdyBFcnJvcih1KDkzKSk7Yz1jWzBdfWI9Y31udWxsPT1iJiYoYj1cIlwiKTtjPWJ9YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6cmIoYyl9fVxuZnVuY3Rpb24gS2IoYSxiKXt2YXIgYz1yYihiLnZhbHVlKSxkPXJiKGIuZGVmYXVsdFZhbHVlKTtudWxsIT1jJiYoYz1cIlwiK2MsYyE9PWEudmFsdWUmJihhLnZhbHVlPWMpLG51bGw9PWIuZGVmYXVsdFZhbHVlJiZhLmRlZmF1bHRWYWx1ZSE9PWMmJihhLmRlZmF1bHRWYWx1ZT1jKSk7bnVsbCE9ZCYmKGEuZGVmYXVsdFZhbHVlPVwiXCIrZCl9ZnVuY3Rpb24gTGIoYSl7dmFyIGI9YS50ZXh0Q29udGVudDtiPT09YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSYmXCJcIiE9PWImJm51bGwhPT1iJiYoYS52YWx1ZT1iKX12YXIgTWI9e2h0bWw6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsbWF0aG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLHN2ZzpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJ9O1xuZnVuY3Rpb24gTmIoYSl7c3dpdGNoKGEpe2Nhc2UgXCJzdmdcIjpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7Y2FzZSBcIm1hdGhcIjpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjtkZWZhdWx0OnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwifX1mdW5jdGlvbiBPYihhLGIpe3JldHVybiBudWxsPT1hfHxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj09PWE/TmIoYik6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPT09YSYmXCJmb3JlaWduT2JqZWN0XCI9PT1iP1wiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiOmF9XG52YXIgUGIsUWI9ZnVuY3Rpb24oYSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBNU0FwcCYmTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24/ZnVuY3Rpb24oYixjLGQsZSl7TVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24oKXtyZXR1cm4gYShiLGMsZCxlKX0pfTphfShmdW5jdGlvbihhLGIpe2lmKGEubmFtZXNwYWNlVVJJIT09TWIuc3ZnfHxcImlubmVySFRNTFwiaW4gYSlhLmlubmVySFRNTD1iO2Vsc2V7UGI9UGJ8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7UGIuaW5uZXJIVE1MPVwiPHN2Zz5cIitiLnZhbHVlT2YoKS50b1N0cmluZygpK1wiPC9zdmc+XCI7Zm9yKGI9UGIuZmlyc3RDaGlsZDthLmZpcnN0Q2hpbGQ7KWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKTtmb3IoO2IuZmlyc3RDaGlsZDspYS5hcHBlbmRDaGlsZChiLmZpcnN0Q2hpbGQpfX0pO1xuZnVuY3Rpb24gUmIoYSxiKXtpZihiKXt2YXIgYz1hLmZpcnN0Q2hpbGQ7aWYoYyYmYz09PWEubGFzdENoaWxkJiYzPT09Yy5ub2RlVHlwZSl7Yy5ub2RlVmFsdWU9YjtyZXR1cm59fWEudGV4dENvbnRlbnQ9Yn1mdW5jdGlvbiBTYihhLGIpe3ZhciBjPXt9O2NbYS50b0xvd2VyQ2FzZSgpXT1iLnRvTG93ZXJDYXNlKCk7Y1tcIldlYmtpdFwiK2FdPVwid2Via2l0XCIrYjtjW1wiTW96XCIrYV09XCJtb3pcIitiO3JldHVybiBjfXZhciBUYj17YW5pbWF0aW9uZW5kOlNiKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25FbmRcIiksYW5pbWF0aW9uaXRlcmF0aW9uOlNiKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25JdGVyYXRpb25cIiksYW5pbWF0aW9uc3RhcnQ6U2IoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvblN0YXJ0XCIpLHRyYW5zaXRpb25lbmQ6U2IoXCJUcmFuc2l0aW9uXCIsXCJUcmFuc2l0aW9uRW5kXCIpfSxVYj17fSxWYj17fTtcbnlhJiYoVmI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSxcIkFuaW1hdGlvbkV2ZW50XCJpbiB3aW5kb3d8fChkZWxldGUgVGIuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbixkZWxldGUgVGIuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbixkZWxldGUgVGIuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uKSxcIlRyYW5zaXRpb25FdmVudFwiaW4gd2luZG93fHxkZWxldGUgVGIudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uKTtmdW5jdGlvbiBXYihhKXtpZihVYlthXSlyZXR1cm4gVWJbYV07aWYoIVRiW2FdKXJldHVybiBhO3ZhciBiPVRiW2FdLGM7Zm9yKGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpJiZjIGluIFZiKXJldHVybiBVYlthXT1iW2NdO3JldHVybiBhfVxudmFyIFhiPVdiKFwiYW5pbWF0aW9uZW5kXCIpLFliPVdiKFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIpLFpiPVdiKFwiYW5pbWF0aW9uc3RhcnRcIiksJGI9V2IoXCJ0cmFuc2l0aW9uZW5kXCIpLGFjPVwiYWJvcnQgY2FucGxheSBjYW5wbGF5dGhyb3VnaCBkdXJhdGlvbmNoYW5nZSBlbXB0aWVkIGVuY3J5cHRlZCBlbmRlZCBlcnJvciBsb2FkZWRkYXRhIGxvYWRlZG1ldGFkYXRhIGxvYWRzdGFydCBwYXVzZSBwbGF5IHBsYXlpbmcgcHJvZ3Jlc3MgcmF0ZWNoYW5nZSBzZWVrZWQgc2Vla2luZyBzdGFsbGVkIHN1c3BlbmQgdGltZXVwZGF0ZSB2b2x1bWVjaGFuZ2Ugd2FpdGluZ1wiLnNwbGl0KFwiIFwiKSxiYz1uZXcgKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBXZWFrTWFwP1dlYWtNYXA6TWFwKTtmdW5jdGlvbiBjYyhhKXt2YXIgYj1iYy5nZXQoYSk7dm9pZCAwPT09YiYmKGI9bmV3IE1hcCxiYy5zZXQoYSxiKSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBkYyhhKXt2YXIgYj1hLGM9YTtpZihhLmFsdGVybmF0ZSlmb3IoO2IucmV0dXJuOyliPWIucmV0dXJuO2Vsc2V7YT1iO2RvIGI9YSwwIT09KGIuZWZmZWN0VGFnJjEwMjYpJiYoYz1iLnJldHVybiksYT1iLnJldHVybjt3aGlsZShhKX1yZXR1cm4gMz09PWIudGFnP2M6bnVsbH1mdW5jdGlvbiBlYyhhKXtpZigxMz09PWEudGFnKXt2YXIgYj1hLm1lbW9pemVkU3RhdGU7bnVsbD09PWImJihhPWEuYWx0ZXJuYXRlLG51bGwhPT1hJiYoYj1hLm1lbW9pemVkU3RhdGUpKTtpZihudWxsIT09YilyZXR1cm4gYi5kZWh5ZHJhdGVkfXJldHVybiBudWxsfWZ1bmN0aW9uIGZjKGEpe2lmKGRjKGEpIT09YSl0aHJvdyBFcnJvcih1KDE4OCkpO31cbmZ1bmN0aW9uIGdjKGEpe3ZhciBiPWEuYWx0ZXJuYXRlO2lmKCFiKXtiPWRjKGEpO2lmKG51bGw9PT1iKXRocm93IEVycm9yKHUoMTg4KSk7cmV0dXJuIGIhPT1hP251bGw6YX1mb3IodmFyIGM9YSxkPWI7Oyl7dmFyIGU9Yy5yZXR1cm47aWYobnVsbD09PWUpYnJlYWs7dmFyIGY9ZS5hbHRlcm5hdGU7aWYobnVsbD09PWYpe2Q9ZS5yZXR1cm47aWYobnVsbCE9PWQpe2M9ZDtjb250aW51ZX1icmVha31pZihlLmNoaWxkPT09Zi5jaGlsZCl7Zm9yKGY9ZS5jaGlsZDtmOyl7aWYoZj09PWMpcmV0dXJuIGZjKGUpLGE7aWYoZj09PWQpcmV0dXJuIGZjKGUpLGI7Zj1mLnNpYmxpbmd9dGhyb3cgRXJyb3IodSgxODgpKTt9aWYoYy5yZXR1cm4hPT1kLnJldHVybiljPWUsZD1mO2Vsc2V7Zm9yKHZhciBnPSExLGg9ZS5jaGlsZDtoOyl7aWYoaD09PWMpe2c9ITA7Yz1lO2Q9ZjticmVha31pZihoPT09ZCl7Zz0hMDtkPWU7Yz1mO2JyZWFrfWg9aC5zaWJsaW5nfWlmKCFnKXtmb3IoaD1mLmNoaWxkO2g7KXtpZihoPT09XG5jKXtnPSEwO2M9ZjtkPWU7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1mO2M9ZTticmVha31oPWguc2libGluZ31pZighZyl0aHJvdyBFcnJvcih1KDE4OSkpO319aWYoYy5hbHRlcm5hdGUhPT1kKXRocm93IEVycm9yKHUoMTkwKSk7fWlmKDMhPT1jLnRhZyl0aHJvdyBFcnJvcih1KDE4OCkpO3JldHVybiBjLnN0YXRlTm9kZS5jdXJyZW50PT09Yz9hOmJ9ZnVuY3Rpb24gaGMoYSl7YT1nYyhhKTtpZighYSlyZXR1cm4gbnVsbDtmb3IodmFyIGI9YTs7KXtpZig1PT09Yi50YWd8fDY9PT1iLnRhZylyZXR1cm4gYjtpZihiLmNoaWxkKWIuY2hpbGQucmV0dXJuPWIsYj1iLmNoaWxkO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDshYi5zaWJsaW5nOyl7aWYoIWIucmV0dXJufHxiLnJldHVybj09PWEpcmV0dXJuIG51bGw7Yj1iLnJldHVybn1iLnNpYmxpbmcucmV0dXJuPWIucmV0dXJuO2I9Yi5zaWJsaW5nfX1yZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIGljKGEsYil7aWYobnVsbD09Yil0aHJvdyBFcnJvcih1KDMwKSk7aWYobnVsbD09YSlyZXR1cm4gYjtpZihBcnJheS5pc0FycmF5KGEpKXtpZihBcnJheS5pc0FycmF5KGIpKXJldHVybiBhLnB1c2guYXBwbHkoYSxiKSxhO2EucHVzaChiKTtyZXR1cm4gYX1yZXR1cm4gQXJyYXkuaXNBcnJheShiKT9bYV0uY29uY2F0KGIpOlthLGJdfWZ1bmN0aW9uIGpjKGEsYixjKXtBcnJheS5pc0FycmF5KGEpP2EuZm9yRWFjaChiLGMpOmEmJmIuY2FsbChjLGEpfXZhciBrYz1udWxsO1xuZnVuY3Rpb24gbGMoYSl7aWYoYSl7dmFyIGI9YS5fZGlzcGF0Y2hMaXN0ZW5lcnMsYz1hLl9kaXNwYXRjaEluc3RhbmNlcztpZihBcnJheS5pc0FycmF5KGIpKWZvcih2YXIgZD0wO2Q8Yi5sZW5ndGgmJiFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7ZCsrKW9hKGEsYltkXSxjW2RdKTtlbHNlIGImJm9hKGEsYixjKTthLl9kaXNwYXRjaExpc3RlbmVycz1udWxsO2EuX2Rpc3BhdGNoSW5zdGFuY2VzPW51bGw7YS5pc1BlcnNpc3RlbnQoKXx8YS5jb25zdHJ1Y3Rvci5yZWxlYXNlKGEpfX1mdW5jdGlvbiBtYyhhKXtudWxsIT09YSYmKGtjPWljKGtjLGEpKTthPWtjO2tjPW51bGw7aWYoYSl7amMoYSxsYyk7aWYoa2MpdGhyb3cgRXJyb3IodSg5NSkpO2lmKGZhKXRocm93IGE9aGEsZmE9ITEsaGE9bnVsbCxhO319XG5mdW5jdGlvbiBuYyhhKXthPWEudGFyZ2V0fHxhLnNyY0VsZW1lbnR8fHdpbmRvdzthLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoYT1hLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtyZXR1cm4gMz09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmF9ZnVuY3Rpb24gb2MoYSl7aWYoIXlhKXJldHVybiExO2E9XCJvblwiK2E7dmFyIGI9YSBpbiBkb2N1bWVudDtifHwoYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGIuc2V0QXR0cmlidXRlKGEsXCJyZXR1cm47XCIpLGI9XCJmdW5jdGlvblwiPT09dHlwZW9mIGJbYV0pO3JldHVybiBifXZhciBwYz1bXTtmdW5jdGlvbiBxYyhhKXthLnRvcExldmVsVHlwZT1udWxsO2EubmF0aXZlRXZlbnQ9bnVsbDthLnRhcmdldEluc3Q9bnVsbDthLmFuY2VzdG9ycy5sZW5ndGg9MDsxMD5wYy5sZW5ndGgmJnBjLnB1c2goYSl9XG5mdW5jdGlvbiByYyhhLGIsYyxkKXtpZihwYy5sZW5ndGgpe3ZhciBlPXBjLnBvcCgpO2UudG9wTGV2ZWxUeXBlPWE7ZS5ldmVudFN5c3RlbUZsYWdzPWQ7ZS5uYXRpdmVFdmVudD1iO2UudGFyZ2V0SW5zdD1jO3JldHVybiBlfXJldHVybnt0b3BMZXZlbFR5cGU6YSxldmVudFN5c3RlbUZsYWdzOmQsbmF0aXZlRXZlbnQ6Yix0YXJnZXRJbnN0OmMsYW5jZXN0b3JzOltdfX1cbmZ1bmN0aW9uIHNjKGEpe3ZhciBiPWEudGFyZ2V0SW5zdCxjPWI7ZG97aWYoIWMpe2EuYW5jZXN0b3JzLnB1c2goYyk7YnJlYWt9dmFyIGQ9YztpZigzPT09ZC50YWcpZD1kLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Vsc2V7Zm9yKDtkLnJldHVybjspZD1kLnJldHVybjtkPTMhPT1kLnRhZz9udWxsOmQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm99aWYoIWQpYnJlYWs7Yj1jLnRhZzs1IT09YiYmNiE9PWJ8fGEuYW5jZXN0b3JzLnB1c2goYyk7Yz10YyhkKX13aGlsZShjKTtmb3IoYz0wO2M8YS5hbmNlc3RvcnMubGVuZ3RoO2MrKyl7Yj1hLmFuY2VzdG9yc1tjXTt2YXIgZT1uYyhhLm5hdGl2ZUV2ZW50KTtkPWEudG9wTGV2ZWxUeXBlO3ZhciBmPWEubmF0aXZlRXZlbnQsZz1hLmV2ZW50U3lzdGVtRmxhZ3M7MD09PWMmJihnfD02NCk7Zm9yKHZhciBoPW51bGwsaz0wO2s8c2EubGVuZ3RoO2srKyl7dmFyIGw9c2Fba107bCYmKGw9bC5leHRyYWN0RXZlbnRzKGQsYixmLGUsZykpJiYoaD1cbmljKGgsbCkpfW1jKGgpfX1mdW5jdGlvbiB1YyhhLGIsYyl7aWYoIWMuaGFzKGEpKXtzd2l0Y2goYSl7Y2FzZSBcInNjcm9sbFwiOnZjKGIsXCJzY3JvbGxcIiwhMCk7YnJlYWs7Y2FzZSBcImZvY3VzXCI6Y2FzZSBcImJsdXJcIjp2YyhiLFwiZm9jdXNcIiwhMCk7dmMoYixcImJsdXJcIiwhMCk7Yy5zZXQoXCJibHVyXCIsbnVsbCk7Yy5zZXQoXCJmb2N1c1wiLG51bGwpO2JyZWFrO2Nhc2UgXCJjYW5jZWxcIjpjYXNlIFwiY2xvc2VcIjpvYyhhKSYmdmMoYixhLCEwKTticmVhaztjYXNlIFwiaW52YWxpZFwiOmNhc2UgXCJzdWJtaXRcIjpjYXNlIFwicmVzZXRcIjpicmVhaztkZWZhdWx0Oi0xPT09YWMuaW5kZXhPZihhKSYmRihhLGIpfWMuc2V0KGEsbnVsbCl9fVxudmFyIHdjLHhjLHljLHpjPSExLEFjPVtdLEJjPW51bGwsQ2M9bnVsbCxEYz1udWxsLEVjPW5ldyBNYXAsRmM9bmV3IE1hcCxHYz1bXSxIYz1cIm1vdXNlZG93biBtb3VzZXVwIHRvdWNoY2FuY2VsIHRvdWNoZW5kIHRvdWNoc3RhcnQgYXV4Y2xpY2sgZGJsY2xpY2sgcG9pbnRlcmNhbmNlbCBwb2ludGVyZG93biBwb2ludGVydXAgZHJhZ2VuZCBkcmFnc3RhcnQgZHJvcCBjb21wb3NpdGlvbmVuZCBjb21wb3NpdGlvbnN0YXJ0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgaW5wdXQgdGV4dElucHV0IGNsb3NlIGNhbmNlbCBjb3B5IGN1dCBwYXN0ZSBjbGljayBjaGFuZ2UgY29udGV4dG1lbnUgcmVzZXQgc3VibWl0XCIuc3BsaXQoXCIgXCIpLEljPVwiZm9jdXMgYmx1ciBkcmFnZW50ZXIgZHJhZ2xlYXZlIG1vdXNlb3ZlciBtb3VzZW91dCBwb2ludGVyb3ZlciBwb2ludGVyb3V0IGdvdHBvaW50ZXJjYXB0dXJlIGxvc3Rwb2ludGVyY2FwdHVyZVwiLnNwbGl0KFwiIFwiKTtcbmZ1bmN0aW9uIEpjKGEsYil7dmFyIGM9Y2MoYik7SGMuZm9yRWFjaChmdW5jdGlvbihhKXt1YyhhLGIsYyl9KTtJYy5mb3JFYWNoKGZ1bmN0aW9uKGEpe3VjKGEsYixjKX0pfWZ1bmN0aW9uIEtjKGEsYixjLGQsZSl7cmV0dXJue2Jsb2NrZWRPbjphLHRvcExldmVsVHlwZTpiLGV2ZW50U3lzdGVtRmxhZ3M6Y3wzMixuYXRpdmVFdmVudDplLGNvbnRhaW5lcjpkfX1cbmZ1bmN0aW9uIExjKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJmb2N1c1wiOmNhc2UgXCJibHVyXCI6QmM9bnVsbDticmVhaztjYXNlIFwiZHJhZ2VudGVyXCI6Y2FzZSBcImRyYWdsZWF2ZVwiOkNjPW51bGw7YnJlYWs7Y2FzZSBcIm1vdXNlb3ZlclwiOmNhc2UgXCJtb3VzZW91dFwiOkRjPW51bGw7YnJlYWs7Y2FzZSBcInBvaW50ZXJvdmVyXCI6Y2FzZSBcInBvaW50ZXJvdXRcIjpFYy5kZWxldGUoYi5wb2ludGVySWQpO2JyZWFrO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpGYy5kZWxldGUoYi5wb2ludGVySWQpfX1mdW5jdGlvbiBNYyhhLGIsYyxkLGUsZil7aWYobnVsbD09PWF8fGEubmF0aXZlRXZlbnQhPT1mKXJldHVybiBhPUtjKGIsYyxkLGUsZiksbnVsbCE9PWImJihiPU5jKGIpLG51bGwhPT1iJiZ4YyhiKSksYTthLmV2ZW50U3lzdGVtRmxhZ3N8PWQ7cmV0dXJuIGF9XG5mdW5jdGlvbiBPYyhhLGIsYyxkLGUpe3N3aXRjaChiKXtjYXNlIFwiZm9jdXNcIjpyZXR1cm4gQmM9TWMoQmMsYSxiLGMsZCxlKSwhMDtjYXNlIFwiZHJhZ2VudGVyXCI6cmV0dXJuIENjPU1jKENjLGEsYixjLGQsZSksITA7Y2FzZSBcIm1vdXNlb3ZlclwiOnJldHVybiBEYz1NYyhEYyxhLGIsYyxkLGUpLCEwO2Nhc2UgXCJwb2ludGVyb3ZlclwiOnZhciBmPWUucG9pbnRlcklkO0VjLnNldChmLE1jKEVjLmdldChmKXx8bnVsbCxhLGIsYyxkLGUpKTtyZXR1cm4hMDtjYXNlIFwiZ290cG9pbnRlcmNhcHR1cmVcIjpyZXR1cm4gZj1lLnBvaW50ZXJJZCxGYy5zZXQoZixNYyhGYy5nZXQoZil8fG51bGwsYSxiLGMsZCxlKSksITB9cmV0dXJuITF9XG5mdW5jdGlvbiBQYyhhKXt2YXIgYj10YyhhLnRhcmdldCk7aWYobnVsbCE9PWIpe3ZhciBjPWRjKGIpO2lmKG51bGwhPT1jKWlmKGI9Yy50YWcsMTM9PT1iKXtpZihiPWVjKGMpLG51bGwhPT1iKXthLmJsb2NrZWRPbj1iO3IudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KGEucHJpb3JpdHksZnVuY3Rpb24oKXt5YyhjKX0pO3JldHVybn19ZWxzZSBpZigzPT09YiYmYy5zdGF0ZU5vZGUuaHlkcmF0ZSl7YS5ibG9ja2VkT249Mz09PWMudGFnP2Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm86bnVsbDtyZXR1cm59fWEuYmxvY2tlZE9uPW51bGx9ZnVuY3Rpb24gUWMoYSl7aWYobnVsbCE9PWEuYmxvY2tlZE9uKXJldHVybiExO3ZhciBiPVJjKGEudG9wTGV2ZWxUeXBlLGEuZXZlbnRTeXN0ZW1GbGFncyxhLmNvbnRhaW5lcixhLm5hdGl2ZUV2ZW50KTtpZihudWxsIT09Yil7dmFyIGM9TmMoYik7bnVsbCE9PWMmJnhjKGMpO2EuYmxvY2tlZE9uPWI7cmV0dXJuITF9cmV0dXJuITB9XG5mdW5jdGlvbiBTYyhhLGIsYyl7UWMoYSkmJmMuZGVsZXRlKGIpfWZ1bmN0aW9uIFRjKCl7Zm9yKHpjPSExOzA8QWMubGVuZ3RoOyl7dmFyIGE9QWNbMF07aWYobnVsbCE9PWEuYmxvY2tlZE9uKXthPU5jKGEuYmxvY2tlZE9uKTtudWxsIT09YSYmd2MoYSk7YnJlYWt9dmFyIGI9UmMoYS50b3BMZXZlbFR5cGUsYS5ldmVudFN5c3RlbUZsYWdzLGEuY29udGFpbmVyLGEubmF0aXZlRXZlbnQpO251bGwhPT1iP2EuYmxvY2tlZE9uPWI6QWMuc2hpZnQoKX1udWxsIT09QmMmJlFjKEJjKSYmKEJjPW51bGwpO251bGwhPT1DYyYmUWMoQ2MpJiYoQ2M9bnVsbCk7bnVsbCE9PURjJiZRYyhEYykmJihEYz1udWxsKTtFYy5mb3JFYWNoKFNjKTtGYy5mb3JFYWNoKFNjKX1mdW5jdGlvbiBVYyhhLGIpe2EuYmxvY2tlZE9uPT09YiYmKGEuYmxvY2tlZE9uPW51bGwsemN8fCh6Yz0hMCxyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxUYykpKX1cbmZ1bmN0aW9uIFZjKGEpe2Z1bmN0aW9uIGIoYil7cmV0dXJuIFVjKGIsYSl9aWYoMDxBYy5sZW5ndGgpe1VjKEFjWzBdLGEpO2Zvcih2YXIgYz0xO2M8QWMubGVuZ3RoO2MrKyl7dmFyIGQ9QWNbY107ZC5ibG9ja2VkT249PT1hJiYoZC5ibG9ja2VkT249bnVsbCl9fW51bGwhPT1CYyYmVWMoQmMsYSk7bnVsbCE9PUNjJiZVYyhDYyxhKTtudWxsIT09RGMmJlVjKERjLGEpO0VjLmZvckVhY2goYik7RmMuZm9yRWFjaChiKTtmb3IoYz0wO2M8R2MubGVuZ3RoO2MrKylkPUdjW2NdLGQuYmxvY2tlZE9uPT09YSYmKGQuYmxvY2tlZE9uPW51bGwpO2Zvcig7MDxHYy5sZW5ndGgmJihjPUdjWzBdLG51bGw9PT1jLmJsb2NrZWRPbik7KVBjKGMpLG51bGw9PT1jLmJsb2NrZWRPbiYmR2Muc2hpZnQoKX1cbnZhciBXYz17fSxZYz1uZXcgTWFwLFpjPW5ldyBNYXAsJGM9W1wiYWJvcnRcIixcImFib3J0XCIsWGIsXCJhbmltYXRpb25FbmRcIixZYixcImFuaW1hdGlvbkl0ZXJhdGlvblwiLFpiLFwiYW5pbWF0aW9uU3RhcnRcIixcImNhbnBsYXlcIixcImNhblBsYXlcIixcImNhbnBsYXl0aHJvdWdoXCIsXCJjYW5QbGF5VGhyb3VnaFwiLFwiZHVyYXRpb25jaGFuZ2VcIixcImR1cmF0aW9uQ2hhbmdlXCIsXCJlbXB0aWVkXCIsXCJlbXB0aWVkXCIsXCJlbmNyeXB0ZWRcIixcImVuY3J5cHRlZFwiLFwiZW5kZWRcIixcImVuZGVkXCIsXCJlcnJvclwiLFwiZXJyb3JcIixcImdvdHBvaW50ZXJjYXB0dXJlXCIsXCJnb3RQb2ludGVyQ2FwdHVyZVwiLFwibG9hZFwiLFwibG9hZFwiLFwibG9hZGVkZGF0YVwiLFwibG9hZGVkRGF0YVwiLFwibG9hZGVkbWV0YWRhdGFcIixcImxvYWRlZE1ldGFkYXRhXCIsXCJsb2Fkc3RhcnRcIixcImxvYWRTdGFydFwiLFwibG9zdHBvaW50ZXJjYXB0dXJlXCIsXCJsb3N0UG9pbnRlckNhcHR1cmVcIixcInBsYXlpbmdcIixcInBsYXlpbmdcIixcInByb2dyZXNzXCIsXCJwcm9ncmVzc1wiLFwic2Vla2luZ1wiLFxuXCJzZWVraW5nXCIsXCJzdGFsbGVkXCIsXCJzdGFsbGVkXCIsXCJzdXNwZW5kXCIsXCJzdXNwZW5kXCIsXCJ0aW1ldXBkYXRlXCIsXCJ0aW1lVXBkYXRlXCIsJGIsXCJ0cmFuc2l0aW9uRW5kXCIsXCJ3YWl0aW5nXCIsXCJ3YWl0aW5nXCJdO2Z1bmN0aW9uIGFkKGEsYil7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKz0yKXt2YXIgZD1hW2NdLGU9YVtjKzFdLGY9XCJvblwiKyhlWzBdLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSk7Zj17cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6ZixjYXB0dXJlZDpmK1wiQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6W2RdLGV2ZW50UHJpb3JpdHk6Yn07WmMuc2V0KGQsYik7WWMuc2V0KGQsZik7V2NbZV09Zn19XG5hZChcImJsdXIgYmx1ciBjYW5jZWwgY2FuY2VsIGNsaWNrIGNsaWNrIGNsb3NlIGNsb3NlIGNvbnRleHRtZW51IGNvbnRleHRNZW51IGNvcHkgY29weSBjdXQgY3V0IGF1eGNsaWNrIGF1eENsaWNrIGRibGNsaWNrIGRvdWJsZUNsaWNrIGRyYWdlbmQgZHJhZ0VuZCBkcmFnc3RhcnQgZHJhZ1N0YXJ0IGRyb3AgZHJvcCBmb2N1cyBmb2N1cyBpbnB1dCBpbnB1dCBpbnZhbGlkIGludmFsaWQga2V5ZG93biBrZXlEb3duIGtleXByZXNzIGtleVByZXNzIGtleXVwIGtleVVwIG1vdXNlZG93biBtb3VzZURvd24gbW91c2V1cCBtb3VzZVVwIHBhc3RlIHBhc3RlIHBhdXNlIHBhdXNlIHBsYXkgcGxheSBwb2ludGVyY2FuY2VsIHBvaW50ZXJDYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlckRvd24gcG9pbnRlcnVwIHBvaW50ZXJVcCByYXRlY2hhbmdlIHJhdGVDaGFuZ2UgcmVzZXQgcmVzZXQgc2Vla2VkIHNlZWtlZCBzdWJtaXQgc3VibWl0IHRvdWNoY2FuY2VsIHRvdWNoQ2FuY2VsIHRvdWNoZW5kIHRvdWNoRW5kIHRvdWNoc3RhcnQgdG91Y2hTdGFydCB2b2x1bWVjaGFuZ2Ugdm9sdW1lQ2hhbmdlXCIuc3BsaXQoXCIgXCIpLDApO1xuYWQoXCJkcmFnIGRyYWcgZHJhZ2VudGVyIGRyYWdFbnRlciBkcmFnZXhpdCBkcmFnRXhpdCBkcmFnbGVhdmUgZHJhZ0xlYXZlIGRyYWdvdmVyIGRyYWdPdmVyIG1vdXNlbW92ZSBtb3VzZU1vdmUgbW91c2VvdXQgbW91c2VPdXQgbW91c2VvdmVyIG1vdXNlT3ZlciBwb2ludGVybW92ZSBwb2ludGVyTW92ZSBwb2ludGVyb3V0IHBvaW50ZXJPdXQgcG9pbnRlcm92ZXIgcG9pbnRlck92ZXIgc2Nyb2xsIHNjcm9sbCB0b2dnbGUgdG9nZ2xlIHRvdWNobW92ZSB0b3VjaE1vdmUgd2hlZWwgd2hlZWxcIi5zcGxpdChcIiBcIiksMSk7YWQoJGMsMik7Zm9yKHZhciBiZD1cImNoYW5nZSBzZWxlY3Rpb25jaGFuZ2UgdGV4dElucHV0IGNvbXBvc2l0aW9uc3RhcnQgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb251cGRhdGVcIi5zcGxpdChcIiBcIiksY2Q9MDtjZDxiZC5sZW5ndGg7Y2QrKylaYy5zZXQoYmRbY2RdLDApO1xudmFyIGRkPXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksZWQ9ci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHksZmQ9ITA7ZnVuY3Rpb24gRihhLGIpe3ZjKGIsYSwhMSl9ZnVuY3Rpb24gdmMoYSxiLGMpe3ZhciBkPVpjLmdldChiKTtzd2l0Y2godm9pZCAwPT09ZD8yOmQpe2Nhc2UgMDpkPWdkLmJpbmQobnVsbCxiLDEsYSk7YnJlYWs7Y2FzZSAxOmQ9aGQuYmluZChudWxsLGIsMSxhKTticmVhaztkZWZhdWx0OmQ9aWQuYmluZChudWxsLGIsMSxhKX1jP2EuYWRkRXZlbnRMaXN0ZW5lcihiLGQsITApOmEuYWRkRXZlbnRMaXN0ZW5lcihiLGQsITEpfWZ1bmN0aW9uIGdkKGEsYixjLGQpe0phfHxIYSgpO3ZhciBlPWlkLGY9SmE7SmE9ITA7dHJ5e0dhKGUsYSxiLGMsZCl9ZmluYWxseXsoSmE9Zil8fExhKCl9fWZ1bmN0aW9uIGhkKGEsYixjLGQpe2VkKGRkLGlkLmJpbmQobnVsbCxhLGIsYyxkKSl9XG5mdW5jdGlvbiBpZChhLGIsYyxkKXtpZihmZClpZigwPEFjLmxlbmd0aCYmLTE8SGMuaW5kZXhPZihhKSlhPUtjKG51bGwsYSxiLGMsZCksQWMucHVzaChhKTtlbHNle3ZhciBlPVJjKGEsYixjLGQpO2lmKG51bGw9PT1lKUxjKGEsZCk7ZWxzZSBpZigtMTxIYy5pbmRleE9mKGEpKWE9S2MoZSxhLGIsYyxkKSxBYy5wdXNoKGEpO2Vsc2UgaWYoIU9jKGUsYSxiLGMsZCkpe0xjKGEsZCk7YT1yYyhhLGQsbnVsbCxiKTt0cnl7TWEoc2MsYSl9ZmluYWxseXtxYyhhKX19fX1cbmZ1bmN0aW9uIFJjKGEsYixjLGQpe2M9bmMoZCk7Yz10YyhjKTtpZihudWxsIT09Yyl7dmFyIGU9ZGMoYyk7aWYobnVsbD09PWUpYz1udWxsO2Vsc2V7dmFyIGY9ZS50YWc7aWYoMTM9PT1mKXtjPWVjKGUpO2lmKG51bGwhPT1jKXJldHVybiBjO2M9bnVsbH1lbHNlIGlmKDM9PT1mKXtpZihlLnN0YXRlTm9kZS5oeWRyYXRlKXJldHVybiAzPT09ZS50YWc/ZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpudWxsO2M9bnVsbH1lbHNlIGUhPT1jJiYoYz1udWxsKX19YT1yYyhhLGQsYyxiKTt0cnl7TWEoc2MsYSl9ZmluYWxseXtxYyhhKX1yZXR1cm4gbnVsbH1cbnZhciBqZD17YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ITAsYm9yZGVySW1hZ2VPdXRzZXQ6ITAsYm9yZGVySW1hZ2VTbGljZTohMCxib3JkZXJJbWFnZVdpZHRoOiEwLGJveEZsZXg6ITAsYm94RmxleEdyb3VwOiEwLGJveE9yZGluYWxHcm91cDohMCxjb2x1bW5Db3VudDohMCxjb2x1bW5zOiEwLGZsZXg6ITAsZmxleEdyb3c6ITAsZmxleFBvc2l0aXZlOiEwLGZsZXhTaHJpbms6ITAsZmxleE5lZ2F0aXZlOiEwLGZsZXhPcmRlcjohMCxncmlkQXJlYTohMCxncmlkUm93OiEwLGdyaWRSb3dFbmQ6ITAsZ3JpZFJvd1NwYW46ITAsZ3JpZFJvd1N0YXJ0OiEwLGdyaWRDb2x1bW46ITAsZ3JpZENvbHVtbkVuZDohMCxncmlkQ29sdW1uU3BhbjohMCxncmlkQ29sdW1uU3RhcnQ6ITAsZm9udFdlaWdodDohMCxsaW5lQ2xhbXA6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsdGFiU2l6ZTohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITAsZmlsbE9wYWNpdHk6ITAsXG5mbG9vZE9wYWNpdHk6ITAsc3RvcE9wYWNpdHk6ITAsc3Ryb2tlRGFzaGFycmF5OiEwLHN0cm9rZURhc2hvZmZzZXQ6ITAsc3Ryb2tlTWl0ZXJsaW1pdDohMCxzdHJva2VPcGFjaXR5OiEwLHN0cm9rZVdpZHRoOiEwfSxrZD1bXCJXZWJraXRcIixcIm1zXCIsXCJNb3pcIixcIk9cIl07T2JqZWN0LmtleXMoamQpLmZvckVhY2goZnVuY3Rpb24oYSl7a2QuZm9yRWFjaChmdW5jdGlvbihiKXtiPWIrYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnN1YnN0cmluZygxKTtqZFtiXT1qZFthXX0pfSk7ZnVuY3Rpb24gbGQoYSxiLGMpe3JldHVybiBudWxsPT1ifHxcImJvb2xlYW5cIj09PXR5cGVvZiBifHxcIlwiPT09Yj9cIlwiOmN8fFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MD09PWJ8fGpkLmhhc093blByb3BlcnR5KGEpJiZqZFthXT8oXCJcIitiKS50cmltKCk6YitcInB4XCJ9XG5mdW5jdGlvbiBtZChhLGIpe2E9YS5zdHlsZTtmb3IodmFyIGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD0wPT09Yy5pbmRleE9mKFwiLS1cIiksZT1sZChjLGJbY10sZCk7XCJmbG9hdFwiPT09YyYmKGM9XCJjc3NGbG9hdFwiKTtkP2Euc2V0UHJvcGVydHkoYyxlKTphW2NdPWV9fXZhciBuZD1uKHttZW51aXRlbTohMH0se2FyZWE6ITAsYmFzZTohMCxicjohMCxjb2w6ITAsZW1iZWQ6ITAsaHI6ITAsaW1nOiEwLGlucHV0OiEwLGtleWdlbjohMCxsaW5rOiEwLG1ldGE6ITAscGFyYW06ITAsc291cmNlOiEwLHRyYWNrOiEwLHdicjohMH0pO1xuZnVuY3Rpb24gb2QoYSxiKXtpZihiKXtpZihuZFthXSYmKG51bGwhPWIuY2hpbGRyZW58fG51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpKXRocm93IEVycm9yKHUoMTM3LGEsXCJcIikpO2lmKG51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpe2lmKG51bGwhPWIuY2hpbGRyZW4pdGhyb3cgRXJyb3IodSg2MCkpO2lmKCEoXCJvYmplY3RcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZcIl9faHRtbFwiaW4gYi5kYW5nZXJvdXNseVNldElubmVySFRNTCkpdGhyb3cgRXJyb3IodSg2MSkpO31pZihudWxsIT1iLnN0eWxlJiZcIm9iamVjdFwiIT09dHlwZW9mIGIuc3R5bGUpdGhyb3cgRXJyb3IodSg2MixcIlwiKSk7fX1cbmZ1bmN0aW9uIHBkKGEsYil7aWYoLTE9PT1hLmluZGV4T2YoXCItXCIpKXJldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYi5pcztzd2l0Y2goYSl7Y2FzZSBcImFubm90YXRpb24teG1sXCI6Y2FzZSBcImNvbG9yLXByb2ZpbGVcIjpjYXNlIFwiZm9udC1mYWNlXCI6Y2FzZSBcImZvbnQtZmFjZS1zcmNcIjpjYXNlIFwiZm9udC1mYWNlLXVyaVwiOmNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6Y2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6Y2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX12YXIgcWQ9TWIuaHRtbDtmdW5jdGlvbiByZChhLGIpe2E9OT09PWEubm9kZVR5cGV8fDExPT09YS5ub2RlVHlwZT9hOmEub3duZXJEb2N1bWVudDt2YXIgYz1jYyhhKTtiPXdhW2JdO2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKXVjKGJbZF0sYSxjKX1mdW5jdGlvbiBzZCgpe31cbmZ1bmN0aW9uIHRkKGEpe2E9YXx8KFwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQ6dm9pZCAwKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEpcmV0dXJuIG51bGw7dHJ5e3JldHVybiBhLmFjdGl2ZUVsZW1lbnR8fGEuYm9keX1jYXRjaChiKXtyZXR1cm4gYS5ib2R5fX1mdW5jdGlvbiB1ZChhKXtmb3IoO2EmJmEuZmlyc3RDaGlsZDspYT1hLmZpcnN0Q2hpbGQ7cmV0dXJuIGF9ZnVuY3Rpb24gdmQoYSxiKXt2YXIgYz11ZChhKTthPTA7Zm9yKHZhciBkO2M7KXtpZigzPT09Yy5ub2RlVHlwZSl7ZD1hK2MudGV4dENvbnRlbnQubGVuZ3RoO2lmKGE8PWImJmQ+PWIpcmV0dXJue25vZGU6YyxvZmZzZXQ6Yi1hfTthPWR9YTp7Zm9yKDtjOyl7aWYoYy5uZXh0U2libGluZyl7Yz1jLm5leHRTaWJsaW5nO2JyZWFrIGF9Yz1jLnBhcmVudE5vZGV9Yz12b2lkIDB9Yz11ZChjKX19XG5mdW5jdGlvbiB3ZChhLGIpe3JldHVybiBhJiZiP2E9PT1iPyEwOmEmJjM9PT1hLm5vZGVUeXBlPyExOmImJjM9PT1iLm5vZGVUeXBlP3dkKGEsYi5wYXJlbnROb2RlKTpcImNvbnRhaW5zXCJpbiBhP2EuY29udGFpbnMoYik6YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj8hIShhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpJjE2KTohMTohMX1mdW5jdGlvbiB4ZCgpe2Zvcih2YXIgYT13aW5kb3csYj10ZCgpO2IgaW5zdGFuY2VvZiBhLkhUTUxJRnJhbWVFbGVtZW50Oyl7dHJ5e3ZhciBjPVwic3RyaW5nXCI9PT10eXBlb2YgYi5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWZ9Y2F0Y2goZCl7Yz0hMX1pZihjKWE9Yi5jb250ZW50V2luZG93O2Vsc2UgYnJlYWs7Yj10ZChhLmRvY3VtZW50KX1yZXR1cm4gYn1cbmZ1bmN0aW9uIHlkKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gYiYmKFwiaW5wdXRcIj09PWImJihcInRleHRcIj09PWEudHlwZXx8XCJzZWFyY2hcIj09PWEudHlwZXx8XCJ0ZWxcIj09PWEudHlwZXx8XCJ1cmxcIj09PWEudHlwZXx8XCJwYXNzd29yZFwiPT09YS50eXBlKXx8XCJ0ZXh0YXJlYVwiPT09Ynx8XCJ0cnVlXCI9PT1hLmNvbnRlbnRFZGl0YWJsZSl9dmFyIHpkPVwiJFwiLEFkPVwiLyRcIixCZD1cIiQ/XCIsQ2Q9XCIkIVwiLERkPW51bGwsRWQ9bnVsbDtmdW5jdGlvbiBGZChhLGIpe3N3aXRjaChhKXtjYXNlIFwiYnV0dG9uXCI6Y2FzZSBcImlucHV0XCI6Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJ0ZXh0YXJlYVwiOnJldHVybiEhYi5hdXRvRm9jdXN9cmV0dXJuITF9XG5mdW5jdGlvbiBHZChhLGIpe3JldHVyblwidGV4dGFyZWFcIj09PWF8fFwib3B0aW9uXCI9PT1hfHxcIm5vc2NyaXB0XCI9PT1hfHxcInN0cmluZ1wiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwibnVtYmVyXCI9PT10eXBlb2YgYi5jaGlsZHJlbnx8XCJvYmplY3RcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT09Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWx9dmFyIEhkPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBzZXRUaW1lb3V0P3NldFRpbWVvdXQ6dm9pZCAwLElkPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBjbGVhclRpbWVvdXQ/Y2xlYXJUaW1lb3V0OnZvaWQgMDtmdW5jdGlvbiBKZChhKXtmb3IoO251bGwhPWE7YT1hLm5leHRTaWJsaW5nKXt2YXIgYj1hLm5vZGVUeXBlO2lmKDE9PT1ifHwzPT09YilicmVha31yZXR1cm4gYX1cbmZ1bmN0aW9uIEtkKGEpe2E9YS5wcmV2aW91c1NpYmxpbmc7Zm9yKHZhciBiPTA7YTspe2lmKDg9PT1hLm5vZGVUeXBlKXt2YXIgYz1hLmRhdGE7aWYoYz09PXpkfHxjPT09Q2R8fGM9PT1CZCl7aWYoMD09PWIpcmV0dXJuIGE7Yi0tfWVsc2UgYz09PUFkJiZiKyt9YT1hLnByZXZpb3VzU2libGluZ31yZXR1cm4gbnVsbH12YXIgTGQ9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksTWQ9XCJfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSRcIitMZCxOZD1cIl9fcmVhY3RFdmVudEhhbmRsZXJzJFwiK0xkLE9kPVwiX19yZWFjdENvbnRhaW5lcmUkXCIrTGQ7XG5mdW5jdGlvbiB0YyhhKXt2YXIgYj1hW01kXTtpZihiKXJldHVybiBiO2Zvcih2YXIgYz1hLnBhcmVudE5vZGU7Yzspe2lmKGI9Y1tPZF18fGNbTWRdKXtjPWIuYWx0ZXJuYXRlO2lmKG51bGwhPT1iLmNoaWxkfHxudWxsIT09YyYmbnVsbCE9PWMuY2hpbGQpZm9yKGE9S2QoYSk7bnVsbCE9PWE7KXtpZihjPWFbTWRdKXJldHVybiBjO2E9S2QoYSl9cmV0dXJuIGJ9YT1jO2M9YS5wYXJlbnROb2RlfXJldHVybiBudWxsfWZ1bmN0aW9uIE5jKGEpe2E9YVtNZF18fGFbT2RdO3JldHVybiFhfHw1IT09YS50YWcmJjYhPT1hLnRhZyYmMTMhPT1hLnRhZyYmMyE9PWEudGFnP251bGw6YX1mdW5jdGlvbiBQZChhKXtpZig1PT09YS50YWd8fDY9PT1hLnRhZylyZXR1cm4gYS5zdGF0ZU5vZGU7dGhyb3cgRXJyb3IodSgzMykpO31mdW5jdGlvbiBRZChhKXtyZXR1cm4gYVtOZF18fG51bGx9XG5mdW5jdGlvbiBSZChhKXtkbyBhPWEucmV0dXJuO3doaWxlKGEmJjUhPT1hLnRhZyk7cmV0dXJuIGE/YTpudWxsfVxuZnVuY3Rpb24gU2QoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZTtpZighYylyZXR1cm4gbnVsbDt2YXIgZD1sYShjKTtpZighZClyZXR1cm4gbnVsbDtjPWRbYl07YTpzd2l0Y2goYil7Y2FzZSBcIm9uQ2xpY2tcIjpjYXNlIFwib25DbGlja0NhcHR1cmVcIjpjYXNlIFwib25Eb3VibGVDbGlja1wiOmNhc2UgXCJvbkRvdWJsZUNsaWNrQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlRG93blwiOmNhc2UgXCJvbk1vdXNlRG93bkNhcHR1cmVcIjpjYXNlIFwib25Nb3VzZU1vdmVcIjpjYXNlIFwib25Nb3VzZU1vdmVDYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VVcFwiOmNhc2UgXCJvbk1vdXNlVXBDYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VFbnRlclwiOihkPSFkLmRpc2FibGVkKXx8KGE9YS50eXBlLGQ9IShcImJ1dHRvblwiPT09YXx8XCJpbnB1dFwiPT09YXx8XCJzZWxlY3RcIj09PWF8fFwidGV4dGFyZWFcIj09PWEpKTthPSFkO2JyZWFrIGE7ZGVmYXVsdDphPSExfWlmKGEpcmV0dXJuIG51bGw7aWYoYyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGMpdGhyb3cgRXJyb3IodSgyMzEsXG5iLHR5cGVvZiBjKSk7cmV0dXJuIGN9ZnVuY3Rpb24gVGQoYSxiLGMpe2lmKGI9U2QoYSxjLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW2JdKSljLl9kaXNwYXRjaExpc3RlbmVycz1pYyhjLl9kaXNwYXRjaExpc3RlbmVycyxiKSxjLl9kaXNwYXRjaEluc3RhbmNlcz1pYyhjLl9kaXNwYXRjaEluc3RhbmNlcyxhKX1mdW5jdGlvbiBVZChhKXtpZihhJiZhLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKXtmb3IodmFyIGI9YS5fdGFyZ2V0SW5zdCxjPVtdO2I7KWMucHVzaChiKSxiPVJkKGIpO2ZvcihiPWMubGVuZ3RoOzA8Yi0tOylUZChjW2JdLFwiY2FwdHVyZWRcIixhKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKVRkKGNbYl0sXCJidWJibGVkXCIsYSl9fVxuZnVuY3Rpb24gVmQoYSxiLGMpe2EmJmMmJmMuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSYmKGI9U2QoYSxjLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpKSYmKGMuX2Rpc3BhdGNoTGlzdGVuZXJzPWljKGMuX2Rpc3BhdGNoTGlzdGVuZXJzLGIpLGMuX2Rpc3BhdGNoSW5zdGFuY2VzPWljKGMuX2Rpc3BhdGNoSW5zdGFuY2VzLGEpKX1mdW5jdGlvbiBXZChhKXthJiZhLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUmJlZkKGEuX3RhcmdldEluc3QsbnVsbCxhKX1mdW5jdGlvbiBYZChhKXtqYyhhLFVkKX12YXIgWWQ9bnVsbCxaZD1udWxsLCRkPW51bGw7XG5mdW5jdGlvbiBhZSgpe2lmKCRkKXJldHVybiAkZDt2YXIgYSxiPVpkLGM9Yi5sZW5ndGgsZCxlPVwidmFsdWVcImluIFlkP1lkLnZhbHVlOllkLnRleHRDb250ZW50LGY9ZS5sZW5ndGg7Zm9yKGE9MDthPGMmJmJbYV09PT1lW2FdO2ErKyk7dmFyIGc9Yy1hO2ZvcihkPTE7ZDw9ZyYmYltjLWRdPT09ZVtmLWRdO2QrKyk7cmV0dXJuICRkPWUuc2xpY2UoYSwxPGQ/MS1kOnZvaWQgMCl9ZnVuY3Rpb24gYmUoKXtyZXR1cm4hMH1mdW5jdGlvbiBjZSgpe3JldHVybiExfVxuZnVuY3Rpb24gRyhhLGIsYyxkKXt0aGlzLmRpc3BhdGNoQ29uZmlnPWE7dGhpcy5fdGFyZ2V0SW5zdD1iO3RoaXMubmF0aXZlRXZlbnQ9YzthPXRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO2Zvcih2YXIgZSBpbiBhKWEuaGFzT3duUHJvcGVydHkoZSkmJigoYj1hW2VdKT90aGlzW2VdPWIoYyk6XCJ0YXJnZXRcIj09PWU/dGhpcy50YXJnZXQ9ZDp0aGlzW2VdPWNbZV0pO3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPShudWxsIT1jLmRlZmF1bHRQcmV2ZW50ZWQ/Yy5kZWZhdWx0UHJldmVudGVkOiExPT09Yy5yZXR1cm5WYWx1ZSk/YmU6Y2U7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1jZTtyZXR1cm4gdGhpc31cbm4oRy5wcm90b3R5cGUse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOlwidW5rbm93blwiIT09dHlwZW9mIGEucmV0dXJuVmFsdWUmJihhLnJldHVyblZhbHVlPSExKSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1iZSl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEuc3RvcFByb3BhZ2F0aW9uP2Euc3RvcFByb3BhZ2F0aW9uKCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5jYW5jZWxCdWJibGUmJihhLmNhbmNlbEJ1YmJsZT0hMCksdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1iZSl9LHBlcnNpc3Q6ZnVuY3Rpb24oKXt0aGlzLmlzUGVyc2lzdGVudD1iZX0saXNQZXJzaXN0ZW50OmNlLGRlc3RydWN0b3I6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZSxcbmI7Zm9yKGIgaW4gYSl0aGlzW2JdPW51bGw7dGhpcy5uYXRpdmVFdmVudD10aGlzLl90YXJnZXRJbnN0PXRoaXMuZGlzcGF0Y2hDb25maWc9bnVsbDt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPXRoaXMuaXNEZWZhdWx0UHJldmVudGVkPWNlO3RoaXMuX2Rpc3BhdGNoSW5zdGFuY2VzPXRoaXMuX2Rpc3BhdGNoTGlzdGVuZXJzPW51bGx9fSk7Ry5JbnRlcmZhY2U9e3R5cGU6bnVsbCx0YXJnZXQ6bnVsbCxjdXJyZW50VGFyZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGV2ZW50UGhhc2U6bnVsbCxidWJibGVzOm51bGwsY2FuY2VsYWJsZTpudWxsLHRpbWVTdGFtcDpmdW5jdGlvbihhKXtyZXR1cm4gYS50aW1lU3RhbXB8fERhdGUubm93KCl9LGRlZmF1bHRQcmV2ZW50ZWQ6bnVsbCxpc1RydXN0ZWQ6bnVsbH07XG5HLmV4dGVuZD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7fWZ1bmN0aW9uIGMoKXtyZXR1cm4gZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGQ9dGhpcztiLnByb3RvdHlwZT1kLnByb3RvdHlwZTt2YXIgZT1uZXcgYjtuKGUsYy5wcm90b3R5cGUpO2MucHJvdG90eXBlPWU7Yy5wcm90b3R5cGUuY29uc3RydWN0b3I9YztjLkludGVyZmFjZT1uKHt9LGQuSW50ZXJmYWNlLGEpO2MuZXh0ZW5kPWQuZXh0ZW5kO2RlKGMpO3JldHVybiBjfTtkZShHKTtmdW5jdGlvbiBlZShhLGIsYyxkKXtpZih0aGlzLmV2ZW50UG9vbC5sZW5ndGgpe3ZhciBlPXRoaXMuZXZlbnRQb29sLnBvcCgpO3RoaXMuY2FsbChlLGEsYixjLGQpO3JldHVybiBlfXJldHVybiBuZXcgdGhpcyhhLGIsYyxkKX1cbmZ1bmN0aW9uIGZlKGEpe2lmKCEoYSBpbnN0YW5jZW9mIHRoaXMpKXRocm93IEVycm9yKHUoMjc5KSk7YS5kZXN0cnVjdG9yKCk7MTA+dGhpcy5ldmVudFBvb2wubGVuZ3RoJiZ0aGlzLmV2ZW50UG9vbC5wdXNoKGEpfWZ1bmN0aW9uIGRlKGEpe2EuZXZlbnRQb29sPVtdO2EuZ2V0UG9vbGVkPWVlO2EucmVsZWFzZT1mZX12YXIgZ2U9Ry5leHRlbmQoe2RhdGE6bnVsbH0pLGhlPUcuZXh0ZW5kKHtkYXRhOm51bGx9KSxpZT1bOSwxMywyNywzMl0samU9eWEmJlwiQ29tcG9zaXRpb25FdmVudFwiaW4gd2luZG93LGtlPW51bGw7eWEmJlwiZG9jdW1lbnRNb2RlXCJpbiBkb2N1bWVudCYmKGtlPWRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG52YXIgbGU9eWEmJlwiVGV4dEV2ZW50XCJpbiB3aW5kb3cmJiFrZSxtZT15YSYmKCFqZXx8a2UmJjg8a2UmJjExPj1rZSksbmU9U3RyaW5nLmZyb21DaGFyQ29kZSgzMiksb2U9e2JlZm9yZUlucHV0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQmVmb3JlSW5wdXRcIixjYXB0dXJlZDpcIm9uQmVmb3JlSW5wdXRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpbXCJjb21wb3NpdGlvbmVuZFwiLFwia2V5cHJlc3NcIixcInRleHRJbnB1dFwiLFwicGFzdGVcIl19LGNvbXBvc2l0aW9uRW5kOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25FbmRcIixjYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25FbmRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcImJsdXIgY29tcG9zaXRpb25lbmQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIil9LGNvbXBvc2l0aW9uU3RhcnQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvblN0YXJ0XCIsXG5jYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25TdGFydENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwiYmx1ciBjb21wb3NpdGlvbnN0YXJ0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpfSxjb21wb3NpdGlvblVwZGF0ZTp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uVXBkYXRlXCIsY2FwdHVyZWQ6XCJvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJibHVyIGNvbXBvc2l0aW9udXBkYXRlIGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpfX0scGU9ITE7XG5mdW5jdGlvbiBxZShhLGIpe3N3aXRjaChhKXtjYXNlIFwia2V5dXBcIjpyZXR1cm4tMSE9PWllLmluZGV4T2YoYi5rZXlDb2RlKTtjYXNlIFwia2V5ZG93blwiOnJldHVybiAyMjkhPT1iLmtleUNvZGU7Y2FzZSBcImtleXByZXNzXCI6Y2FzZSBcIm1vdXNlZG93blwiOmNhc2UgXCJibHVyXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gcmUoYSl7YT1hLmRldGFpbDtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiZGF0YVwiaW4gYT9hLmRhdGE6bnVsbH12YXIgc2U9ITE7ZnVuY3Rpb24gdGUoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6cmV0dXJuIHJlKGIpO2Nhc2UgXCJrZXlwcmVzc1wiOmlmKDMyIT09Yi53aGljaClyZXR1cm4gbnVsbDtwZT0hMDtyZXR1cm4gbmU7Y2FzZSBcInRleHRJbnB1dFwiOnJldHVybiBhPWIuZGF0YSxhPT09bmUmJnBlP251bGw6YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbmZ1bmN0aW9uIHVlKGEsYil7aWYoc2UpcmV0dXJuXCJjb21wb3NpdGlvbmVuZFwiPT09YXx8IWplJiZxZShhLGIpPyhhPWFlKCksJGQ9WmQ9WWQ9bnVsbCxzZT0hMSxhKTpudWxsO3N3aXRjaChhKXtjYXNlIFwicGFzdGVcIjpyZXR1cm4gbnVsbDtjYXNlIFwia2V5cHJlc3NcIjppZighKGIuY3RybEtleXx8Yi5hbHRLZXl8fGIubWV0YUtleSl8fGIuY3RybEtleSYmYi5hbHRLZXkpe2lmKGIuY2hhciYmMTxiLmNoYXIubGVuZ3RoKXJldHVybiBiLmNoYXI7aWYoYi53aGljaClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShiLndoaWNoKX1yZXR1cm4gbnVsbDtjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpyZXR1cm4gbWUmJlwia29cIiE9PWIubG9jYWxlP251bGw6Yi5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxudmFyIHZlPXtldmVudFR5cGVzOm9lLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU7aWYoamUpYjp7c3dpdGNoKGEpe2Nhc2UgXCJjb21wb3NpdGlvbnN0YXJ0XCI6dmFyIGY9b2UuY29tcG9zaXRpb25TdGFydDticmVhayBiO2Nhc2UgXCJjb21wb3NpdGlvbmVuZFwiOmY9b2UuY29tcG9zaXRpb25FbmQ7YnJlYWsgYjtjYXNlIFwiY29tcG9zaXRpb251cGRhdGVcIjpmPW9lLmNvbXBvc2l0aW9uVXBkYXRlO2JyZWFrIGJ9Zj12b2lkIDB9ZWxzZSBzZT9xZShhLGMpJiYoZj1vZS5jb21wb3NpdGlvbkVuZCk6XCJrZXlkb3duXCI9PT1hJiYyMjk9PT1jLmtleUNvZGUmJihmPW9lLmNvbXBvc2l0aW9uU3RhcnQpO2Y/KG1lJiZcImtvXCIhPT1jLmxvY2FsZSYmKHNlfHxmIT09b2UuY29tcG9zaXRpb25TdGFydD9mPT09b2UuY29tcG9zaXRpb25FbmQmJnNlJiYoZT1hZSgpKTooWWQ9ZCxaZD1cInZhbHVlXCJpbiBZZD9ZZC52YWx1ZTpZZC50ZXh0Q29udGVudCxzZT0hMCkpLGY9Z2UuZ2V0UG9vbGVkKGYsXG5iLGMsZCksZT9mLmRhdGE9ZTooZT1yZShjKSxudWxsIT09ZSYmKGYuZGF0YT1lKSksWGQoZiksZT1mKTplPW51bGw7KGE9bGU/dGUoYSxjKTp1ZShhLGMpKT8oYj1oZS5nZXRQb29sZWQob2UuYmVmb3JlSW5wdXQsYixjLGQpLGIuZGF0YT1hLFhkKGIpKTpiPW51bGw7cmV0dXJuIG51bGw9PT1lP2I6bnVsbD09PWI/ZTpbZSxiXX19LHdlPXtjb2xvcjohMCxkYXRlOiEwLGRhdGV0aW1lOiEwLFwiZGF0ZXRpbWUtbG9jYWxcIjohMCxlbWFpbDohMCxtb250aDohMCxudW1iZXI6ITAscGFzc3dvcmQ6ITAscmFuZ2U6ITAsc2VhcmNoOiEwLHRlbDohMCx0ZXh0OiEwLHRpbWU6ITAsdXJsOiEwLHdlZWs6ITB9O2Z1bmN0aW9uIHhlKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm5cImlucHV0XCI9PT1iPyEhd2VbYS50eXBlXTpcInRleHRhcmVhXCI9PT1iPyEwOiExfVxudmFyIHllPXtjaGFuZ2U6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25DaGFuZ2VcIixjYXB0dXJlZDpcIm9uQ2hhbmdlQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJibHVyIGNoYW5nZSBjbGljayBmb2N1cyBpbnB1dCBrZXlkb3duIGtleXVwIHNlbGVjdGlvbmNoYW5nZVwiLnNwbGl0KFwiIFwiKX19O2Z1bmN0aW9uIHplKGEsYixjKXthPUcuZ2V0UG9vbGVkKHllLmNoYW5nZSxhLGIsYyk7YS50eXBlPVwiY2hhbmdlXCI7RGEoYyk7WGQoYSk7cmV0dXJuIGF9dmFyIEFlPW51bGwsQmU9bnVsbDtmdW5jdGlvbiBDZShhKXttYyhhKX1mdW5jdGlvbiBEZShhKXt2YXIgYj1QZChhKTtpZih5YihiKSlyZXR1cm4gYX1mdW5jdGlvbiBFZShhLGIpe2lmKFwiY2hhbmdlXCI9PT1hKXJldHVybiBifXZhciBGZT0hMTt5YSYmKEZlPW9jKFwiaW5wdXRcIikmJighZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw5PGRvY3VtZW50LmRvY3VtZW50TW9kZSkpO1xuZnVuY3Rpb24gR2UoKXtBZSYmKEFlLmRldGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLEhlKSxCZT1BZT1udWxsKX1mdW5jdGlvbiBIZShhKXtpZihcInZhbHVlXCI9PT1hLnByb3BlcnR5TmFtZSYmRGUoQmUpKWlmKGE9emUoQmUsYSxuYyhhKSksSmEpbWMoYSk7ZWxzZXtKYT0hMDt0cnl7RmEoQ2UsYSl9ZmluYWxseXtKYT0hMSxMYSgpfX19ZnVuY3Rpb24gSWUoYSxiLGMpe1wiZm9jdXNcIj09PWE/KEdlKCksQWU9YixCZT1jLEFlLmF0dGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLEhlKSk6XCJibHVyXCI9PT1hJiZHZSgpfWZ1bmN0aW9uIEplKGEpe2lmKFwic2VsZWN0aW9uY2hhbmdlXCI9PT1hfHxcImtleXVwXCI9PT1hfHxcImtleWRvd25cIj09PWEpcmV0dXJuIERlKEJlKX1mdW5jdGlvbiBLZShhLGIpe2lmKFwiY2xpY2tcIj09PWEpcmV0dXJuIERlKGIpfWZ1bmN0aW9uIExlKGEsYil7aWYoXCJpbnB1dFwiPT09YXx8XCJjaGFuZ2VcIj09PWEpcmV0dXJuIERlKGIpfVxudmFyIE1lPXtldmVudFR5cGVzOnllLF9pc0lucHV0RXZlbnRTdXBwb3J0ZWQ6RmUsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1iP1BkKGIpOndpbmRvdyxmPWUubm9kZU5hbWUmJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihcInNlbGVjdFwiPT09Znx8XCJpbnB1dFwiPT09ZiYmXCJmaWxlXCI9PT1lLnR5cGUpdmFyIGc9RWU7ZWxzZSBpZih4ZShlKSlpZihGZSlnPUxlO2Vsc2V7Zz1KZTt2YXIgaD1JZX1lbHNlKGY9ZS5ub2RlTmFtZSkmJlwiaW5wdXRcIj09PWYudG9Mb3dlckNhc2UoKSYmKFwiY2hlY2tib3hcIj09PWUudHlwZXx8XCJyYWRpb1wiPT09ZS50eXBlKSYmKGc9S2UpO2lmKGcmJihnPWcoYSxiKSkpcmV0dXJuIHplKGcsYyxkKTtoJiZoKGEsZSxiKTtcImJsdXJcIj09PWEmJihhPWUuX3dyYXBwZXJTdGF0ZSkmJmEuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWUudHlwZSYmRGIoZSxcIm51bWJlclwiLGUudmFsdWUpfX0sTmU9Ry5leHRlbmQoe3ZpZXc6bnVsbCxkZXRhaWw6bnVsbH0pLFxuT2U9e0FsdDpcImFsdEtleVwiLENvbnRyb2w6XCJjdHJsS2V5XCIsTWV0YTpcIm1ldGFLZXlcIixTaGlmdDpcInNoaWZ0S2V5XCJ9O2Z1bmN0aW9uIFBlKGEpe3ZhciBiPXRoaXMubmF0aXZlRXZlbnQ7cmV0dXJuIGIuZ2V0TW9kaWZpZXJTdGF0ZT9iLmdldE1vZGlmaWVyU3RhdGUoYSk6KGE9T2VbYV0pPyEhYlthXTohMX1mdW5jdGlvbiBRZSgpe3JldHVybiBQZX1cbnZhciBSZT0wLFNlPTAsVGU9ITEsVWU9ITEsVmU9TmUuZXh0ZW5kKHtzY3JlZW5YOm51bGwsc2NyZWVuWTpudWxsLGNsaWVudFg6bnVsbCxjbGllbnRZOm51bGwscGFnZVg6bnVsbCxwYWdlWTpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxnZXRNb2RpZmllclN0YXRlOlFlLGJ1dHRvbjpudWxsLGJ1dHRvbnM6bnVsbCxyZWxhdGVkVGFyZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlbGF0ZWRUYXJnZXR8fChhLmZyb21FbGVtZW50PT09YS5zcmNFbGVtZW50P2EudG9FbGVtZW50OmEuZnJvbUVsZW1lbnQpfSxtb3ZlbWVudFg6ZnVuY3Rpb24oYSl7aWYoXCJtb3ZlbWVudFhcImluIGEpcmV0dXJuIGEubW92ZW1lbnRYO3ZhciBiPVJlO1JlPWEuc2NyZWVuWDtyZXR1cm4gVGU/XCJtb3VzZW1vdmVcIj09PWEudHlwZT9hLnNjcmVlblgtYjowOihUZT0hMCwwKX0sbW92ZW1lbnRZOmZ1bmN0aW9uKGEpe2lmKFwibW92ZW1lbnRZXCJpbiBhKXJldHVybiBhLm1vdmVtZW50WTtcbnZhciBiPVNlO1NlPWEuc2NyZWVuWTtyZXR1cm4gVWU/XCJtb3VzZW1vdmVcIj09PWEudHlwZT9hLnNjcmVlblktYjowOihVZT0hMCwwKX19KSxXZT1WZS5leHRlbmQoe3BvaW50ZXJJZDpudWxsLHdpZHRoOm51bGwsaGVpZ2h0Om51bGwscHJlc3N1cmU6bnVsbCx0YW5nZW50aWFsUHJlc3N1cmU6bnVsbCx0aWx0WDpudWxsLHRpbHRZOm51bGwsdHdpc3Q6bnVsbCxwb2ludGVyVHlwZTpudWxsLGlzUHJpbWFyeTpudWxsfSksWGU9e21vdXNlRW50ZXI6e3JlZ2lzdHJhdGlvbk5hbWU6XCJvbk1vdXNlRW50ZXJcIixkZXBlbmRlbmNpZXM6W1wibW91c2VvdXRcIixcIm1vdXNlb3ZlclwiXX0sbW91c2VMZWF2ZTp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uTW91c2VMZWF2ZVwiLGRlcGVuZGVuY2llczpbXCJtb3VzZW91dFwiLFwibW91c2VvdmVyXCJdfSxwb2ludGVyRW50ZXI6e3JlZ2lzdHJhdGlvbk5hbWU6XCJvblBvaW50ZXJFbnRlclwiLGRlcGVuZGVuY2llczpbXCJwb2ludGVyb3V0XCIsXCJwb2ludGVyb3ZlclwiXX0scG9pbnRlckxlYXZlOntyZWdpc3RyYXRpb25OYW1lOlwib25Qb2ludGVyTGVhdmVcIixcbmRlcGVuZGVuY2llczpbXCJwb2ludGVyb3V0XCIsXCJwb2ludGVyb3ZlclwiXX19LFllPXtldmVudFR5cGVzOlhlLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1cIm1vdXNlb3ZlclwiPT09YXx8XCJwb2ludGVyb3ZlclwiPT09YSxnPVwibW91c2VvdXRcIj09PWF8fFwicG9pbnRlcm91dFwiPT09YTtpZihmJiYwPT09KGUmMzIpJiYoYy5yZWxhdGVkVGFyZ2V0fHxjLmZyb21FbGVtZW50KXx8IWcmJiFmKXJldHVybiBudWxsO2Y9ZC53aW5kb3c9PT1kP2Q6KGY9ZC5vd25lckRvY3VtZW50KT9mLmRlZmF1bHRWaWV3fHxmLnBhcmVudFdpbmRvdzp3aW5kb3c7aWYoZyl7aWYoZz1iLGI9KGI9Yy5yZWxhdGVkVGFyZ2V0fHxjLnRvRWxlbWVudCk/dGMoYik6bnVsbCxudWxsIT09Yil7dmFyIGg9ZGMoYik7aWYoYiE9PWh8fDUhPT1iLnRhZyYmNiE9PWIudGFnKWI9bnVsbH19ZWxzZSBnPW51bGw7aWYoZz09PWIpcmV0dXJuIG51bGw7aWYoXCJtb3VzZW91dFwiPT09YXx8XCJtb3VzZW92ZXJcIj09PVxuYSl7dmFyIGs9VmU7dmFyIGw9WGUubW91c2VMZWF2ZTt2YXIgbT1YZS5tb3VzZUVudGVyO3ZhciBwPVwibW91c2VcIn1lbHNlIGlmKFwicG9pbnRlcm91dFwiPT09YXx8XCJwb2ludGVyb3ZlclwiPT09YSlrPVdlLGw9WGUucG9pbnRlckxlYXZlLG09WGUucG9pbnRlckVudGVyLHA9XCJwb2ludGVyXCI7YT1udWxsPT1nP2Y6UGQoZyk7Zj1udWxsPT1iP2Y6UGQoYik7bD1rLmdldFBvb2xlZChsLGcsYyxkKTtsLnR5cGU9cCtcImxlYXZlXCI7bC50YXJnZXQ9YTtsLnJlbGF0ZWRUYXJnZXQ9ZjtjPWsuZ2V0UG9vbGVkKG0sYixjLGQpO2MudHlwZT1wK1wiZW50ZXJcIjtjLnRhcmdldD1mO2MucmVsYXRlZFRhcmdldD1hO2Q9ZztwPWI7aWYoZCYmcClhOntrPWQ7bT1wO2c9MDtmb3IoYT1rO2E7YT1SZChhKSlnKys7YT0wO2ZvcihiPW07YjtiPVJkKGIpKWErKztmb3IoOzA8Zy1hOylrPVJkKGspLGctLTtmb3IoOzA8YS1nOyltPVJkKG0pLGEtLTtmb3IoO2ctLTspe2lmKGs9PT1tfHxrPT09bS5hbHRlcm5hdGUpYnJlYWsgYTtcbms9UmQoayk7bT1SZChtKX1rPW51bGx9ZWxzZSBrPW51bGw7bT1rO2ZvcihrPVtdO2QmJmQhPT1tOyl7Zz1kLmFsdGVybmF0ZTtpZihudWxsIT09ZyYmZz09PW0pYnJlYWs7ay5wdXNoKGQpO2Q9UmQoZCl9Zm9yKGQ9W107cCYmcCE9PW07KXtnPXAuYWx0ZXJuYXRlO2lmKG51bGwhPT1nJiZnPT09bSlicmVhaztkLnB1c2gocCk7cD1SZChwKX1mb3IocD0wO3A8ay5sZW5ndGg7cCsrKVZkKGtbcF0sXCJidWJibGVkXCIsbCk7Zm9yKHA9ZC5sZW5ndGg7MDxwLS07KVZkKGRbcF0sXCJjYXB0dXJlZFwiLGMpO3JldHVybiAwPT09KGUmNjQpP1tsXTpbbCxjXX19O2Z1bmN0aW9uIFplKGEsYil7cmV0dXJuIGE9PT1iJiYoMCE9PWF8fDEvYT09PTEvYil8fGEhPT1hJiZiIT09Yn12YXIgJGU9XCJmdW5jdGlvblwiPT09dHlwZW9mIE9iamVjdC5pcz9PYmplY3QuaXM6WmUsYWY9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGJmKGEsYil7aWYoJGUoYSxiKSlyZXR1cm4hMDtpZihcIm9iamVjdFwiIT09dHlwZW9mIGF8fG51bGw9PT1hfHxcIm9iamVjdFwiIT09dHlwZW9mIGJ8fG51bGw9PT1iKXJldHVybiExO3ZhciBjPU9iamVjdC5rZXlzKGEpLGQ9T2JqZWN0LmtleXMoYik7aWYoYy5sZW5ndGghPT1kLmxlbmd0aClyZXR1cm4hMTtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKWlmKCFhZi5jYWxsKGIsY1tkXSl8fCEkZShhW2NbZF1dLGJbY1tkXV0pKXJldHVybiExO3JldHVybiEwfVxudmFyIGNmPXlhJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJjExPj1kb2N1bWVudC5kb2N1bWVudE1vZGUsZGY9e3NlbGVjdDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvblNlbGVjdFwiLGNhcHR1cmVkOlwib25TZWxlY3RDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcImJsdXIgY29udGV4dG1lbnUgZHJhZ2VuZCBmb2N1cyBrZXlkb3duIGtleXVwIG1vdXNlZG93biBtb3VzZXVwIHNlbGVjdGlvbmNoYW5nZVwiLnNwbGl0KFwiIFwiKX19LGVmPW51bGwsZmY9bnVsbCxnZj1udWxsLGhmPSExO1xuZnVuY3Rpb24gamYoYSxiKXt2YXIgYz1iLndpbmRvdz09PWI/Yi5kb2N1bWVudDo5PT09Yi5ub2RlVHlwZT9iOmIub3duZXJEb2N1bWVudDtpZihoZnx8bnVsbD09ZWZ8fGVmIT09dGQoYykpcmV0dXJuIG51bGw7Yz1lZjtcInNlbGVjdGlvblN0YXJ0XCJpbiBjJiZ5ZChjKT9jPXtzdGFydDpjLnNlbGVjdGlvblN0YXJ0LGVuZDpjLnNlbGVjdGlvbkVuZH06KGM9KGMub3duZXJEb2N1bWVudCYmYy5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3fHx3aW5kb3cpLmdldFNlbGVjdGlvbigpLGM9e2FuY2hvck5vZGU6Yy5hbmNob3JOb2RlLGFuY2hvck9mZnNldDpjLmFuY2hvck9mZnNldCxmb2N1c05vZGU6Yy5mb2N1c05vZGUsZm9jdXNPZmZzZXQ6Yy5mb2N1c09mZnNldH0pO3JldHVybiBnZiYmYmYoZ2YsYyk/bnVsbDooZ2Y9YyxhPUcuZ2V0UG9vbGVkKGRmLnNlbGVjdCxmZixhLGIpLGEudHlwZT1cInNlbGVjdFwiLGEudGFyZ2V0PWVmLFhkKGEpLGEpfVxudmFyIGtmPXtldmVudFR5cGVzOmRmLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2U9Znx8KGQud2luZG93PT09ZD9kLmRvY3VtZW50Ojk9PT1kLm5vZGVUeXBlP2Q6ZC5vd25lckRvY3VtZW50KTtpZighKGY9IWUpKXthOntlPWNjKGUpO2Y9d2Eub25TZWxlY3Q7Zm9yKHZhciBnPTA7ZzxmLmxlbmd0aDtnKyspaWYoIWUuaGFzKGZbZ10pKXtlPSExO2JyZWFrIGF9ZT0hMH1mPSFlfWlmKGYpcmV0dXJuIG51bGw7ZT1iP1BkKGIpOndpbmRvdztzd2l0Y2goYSl7Y2FzZSBcImZvY3VzXCI6aWYoeGUoZSl8fFwidHJ1ZVwiPT09ZS5jb250ZW50RWRpdGFibGUpZWY9ZSxmZj1iLGdmPW51bGw7YnJlYWs7Y2FzZSBcImJsdXJcIjpnZj1mZj1lZj1udWxsO2JyZWFrO2Nhc2UgXCJtb3VzZWRvd25cIjpoZj0hMDticmVhaztjYXNlIFwiY29udGV4dG1lbnVcIjpjYXNlIFwibW91c2V1cFwiOmNhc2UgXCJkcmFnZW5kXCI6cmV0dXJuIGhmPSExLGpmKGMsZCk7Y2FzZSBcInNlbGVjdGlvbmNoYW5nZVwiOmlmKGNmKWJyZWFrO1xuY2FzZSBcImtleWRvd25cIjpjYXNlIFwia2V5dXBcIjpyZXR1cm4gamYoYyxkKX1yZXR1cm4gbnVsbH19LGxmPUcuZXh0ZW5kKHthbmltYXRpb25OYW1lOm51bGwsZWxhcHNlZFRpbWU6bnVsbCxwc2V1ZG9FbGVtZW50Om51bGx9KSxtZj1HLmV4dGVuZCh7Y2xpcGJvYXJkRGF0YTpmdW5jdGlvbihhKXtyZXR1cm5cImNsaXBib2FyZERhdGFcImluIGE/YS5jbGlwYm9hcmREYXRhOndpbmRvdy5jbGlwYm9hcmREYXRhfX0pLG5mPU5lLmV4dGVuZCh7cmVsYXRlZFRhcmdldDpudWxsfSk7ZnVuY3Rpb24gb2YoYSl7dmFyIGI9YS5rZXlDb2RlO1wiY2hhckNvZGVcImluIGE/KGE9YS5jaGFyQ29kZSwwPT09YSYmMTM9PT1iJiYoYT0xMykpOmE9YjsxMD09PWEmJihhPTEzKTtyZXR1cm4gMzI8PWF8fDEzPT09YT9hOjB9XG52YXIgcGY9e0VzYzpcIkVzY2FwZVwiLFNwYWNlYmFyOlwiIFwiLExlZnQ6XCJBcnJvd0xlZnRcIixVcDpcIkFycm93VXBcIixSaWdodDpcIkFycm93UmlnaHRcIixEb3duOlwiQXJyb3dEb3duXCIsRGVsOlwiRGVsZXRlXCIsV2luOlwiT1NcIixNZW51OlwiQ29udGV4dE1lbnVcIixBcHBzOlwiQ29udGV4dE1lbnVcIixTY3JvbGw6XCJTY3JvbGxMb2NrXCIsTW96UHJpbnRhYmxlS2V5OlwiVW5pZGVudGlmaWVkXCJ9LHFmPXs4OlwiQmFja3NwYWNlXCIsOTpcIlRhYlwiLDEyOlwiQ2xlYXJcIiwxMzpcIkVudGVyXCIsMTY6XCJTaGlmdFwiLDE3OlwiQ29udHJvbFwiLDE4OlwiQWx0XCIsMTk6XCJQYXVzZVwiLDIwOlwiQ2Fwc0xvY2tcIiwyNzpcIkVzY2FwZVwiLDMyOlwiIFwiLDMzOlwiUGFnZVVwXCIsMzQ6XCJQYWdlRG93blwiLDM1OlwiRW5kXCIsMzY6XCJIb21lXCIsMzc6XCJBcnJvd0xlZnRcIiwzODpcIkFycm93VXBcIiwzOTpcIkFycm93UmlnaHRcIiw0MDpcIkFycm93RG93blwiLDQ1OlwiSW5zZXJ0XCIsNDY6XCJEZWxldGVcIiwxMTI6XCJGMVwiLDExMzpcIkYyXCIsMTE0OlwiRjNcIiwxMTU6XCJGNFwiLFxuMTE2OlwiRjVcIiwxMTc6XCJGNlwiLDExODpcIkY3XCIsMTE5OlwiRjhcIiwxMjA6XCJGOVwiLDEyMTpcIkYxMFwiLDEyMjpcIkYxMVwiLDEyMzpcIkYxMlwiLDE0NDpcIk51bUxvY2tcIiwxNDU6XCJTY3JvbGxMb2NrXCIsMjI0OlwiTWV0YVwifSxyZj1OZS5leHRlbmQoe2tleTpmdW5jdGlvbihhKXtpZihhLmtleSl7dmFyIGI9cGZbYS5rZXldfHxhLmtleTtpZihcIlVuaWRlbnRpZmllZFwiIT09YilyZXR1cm4gYn1yZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/KGE9b2YoYSksMTM9PT1hP1wiRW50ZXJcIjpTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP3FmW2Eua2V5Q29kZV18fFwiVW5pZGVudGlmaWVkXCI6XCJcIn0sbG9jYXRpb246bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwscmVwZWF0Om51bGwsbG9jYWxlOm51bGwsZ2V0TW9kaWZpZXJTdGF0ZTpRZSxjaGFyQ29kZTpmdW5jdGlvbihhKXtyZXR1cm5cImtleXByZXNzXCI9PT1cbmEudHlwZT9vZihhKTowfSxrZXlDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9LHdoaWNoOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT9vZihhKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP2Eua2V5Q29kZTowfX0pLHNmPVZlLmV4dGVuZCh7ZGF0YVRyYW5zZmVyOm51bGx9KSx0Zj1OZS5leHRlbmQoe3RvdWNoZXM6bnVsbCx0YXJnZXRUb3VjaGVzOm51bGwsY2hhbmdlZFRvdWNoZXM6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwsY3RybEtleTpudWxsLHNoaWZ0S2V5Om51bGwsZ2V0TW9kaWZpZXJTdGF0ZTpRZX0pLHVmPUcuZXh0ZW5kKHtwcm9wZXJ0eU5hbWU6bnVsbCxlbGFwc2VkVGltZTpudWxsLHBzZXVkb0VsZW1lbnQ6bnVsbH0pLHZmPVZlLmV4dGVuZCh7ZGVsdGFYOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFYXCJpbiBhP2EuZGVsdGFYOlwid2hlZWxEZWx0YVhcImluXG5hPy1hLndoZWVsRGVsdGFYOjB9LGRlbHRhWTpmdW5jdGlvbihhKXtyZXR1cm5cImRlbHRhWVwiaW4gYT9hLmRlbHRhWTpcIndoZWVsRGVsdGFZXCJpbiBhPy1hLndoZWVsRGVsdGFZOlwid2hlZWxEZWx0YVwiaW4gYT8tYS53aGVlbERlbHRhOjB9LGRlbHRhWjpudWxsLGRlbHRhTW9kZTpudWxsfSksd2Y9e2V2ZW50VHlwZXM6V2MsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1ZYy5nZXQoYSk7aWYoIWUpcmV0dXJuIG51bGw7c3dpdGNoKGEpe2Nhc2UgXCJrZXlwcmVzc1wiOmlmKDA9PT1vZihjKSlyZXR1cm4gbnVsbDtjYXNlIFwia2V5ZG93blwiOmNhc2UgXCJrZXl1cFwiOmE9cmY7YnJlYWs7Y2FzZSBcImJsdXJcIjpjYXNlIFwiZm9jdXNcIjphPW5mO2JyZWFrO2Nhc2UgXCJjbGlja1wiOmlmKDI9PT1jLmJ1dHRvbilyZXR1cm4gbnVsbDtjYXNlIFwiYXV4Y2xpY2tcIjpjYXNlIFwiZGJsY2xpY2tcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcIm1vdXNlbW92ZVwiOmNhc2UgXCJtb3VzZXVwXCI6Y2FzZSBcIm1vdXNlb3V0XCI6Y2FzZSBcIm1vdXNlb3ZlclwiOmNhc2UgXCJjb250ZXh0bWVudVwiOmE9XG5WZTticmVhaztjYXNlIFwiZHJhZ1wiOmNhc2UgXCJkcmFnZW5kXCI6Y2FzZSBcImRyYWdlbnRlclwiOmNhc2UgXCJkcmFnZXhpdFwiOmNhc2UgXCJkcmFnbGVhdmVcIjpjYXNlIFwiZHJhZ292ZXJcIjpjYXNlIFwiZHJhZ3N0YXJ0XCI6Y2FzZSBcImRyb3BcIjphPXNmO2JyZWFrO2Nhc2UgXCJ0b3VjaGNhbmNlbFwiOmNhc2UgXCJ0b3VjaGVuZFwiOmNhc2UgXCJ0b3VjaG1vdmVcIjpjYXNlIFwidG91Y2hzdGFydFwiOmE9dGY7YnJlYWs7Y2FzZSBYYjpjYXNlIFliOmNhc2UgWmI6YT1sZjticmVhaztjYXNlICRiOmE9dWY7YnJlYWs7Y2FzZSBcInNjcm9sbFwiOmE9TmU7YnJlYWs7Y2FzZSBcIndoZWVsXCI6YT12ZjticmVhaztjYXNlIFwiY29weVwiOmNhc2UgXCJjdXRcIjpjYXNlIFwicGFzdGVcIjphPW1mO2JyZWFrO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpjYXNlIFwicG9pbnRlcmNhbmNlbFwiOmNhc2UgXCJwb2ludGVyZG93blwiOmNhc2UgXCJwb2ludGVybW92ZVwiOmNhc2UgXCJwb2ludGVyb3V0XCI6Y2FzZSBcInBvaW50ZXJvdmVyXCI6Y2FzZSBcInBvaW50ZXJ1cFwiOmE9XG5XZTticmVhaztkZWZhdWx0OmE9R31iPWEuZ2V0UG9vbGVkKGUsYixjLGQpO1hkKGIpO3JldHVybiBifX07aWYocGEpdGhyb3cgRXJyb3IodSgxMDEpKTtwYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcIlJlc3BvbmRlckV2ZW50UGx1Z2luIFNpbXBsZUV2ZW50UGx1Z2luIEVudGVyTGVhdmVFdmVudFBsdWdpbiBDaGFuZ2VFdmVudFBsdWdpbiBTZWxlY3RFdmVudFBsdWdpbiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXCIuc3BsaXQoXCIgXCIpKTtyYSgpO3ZhciB4Zj1OYztsYT1RZDttYT14ZjtuYT1QZDt4YSh7U2ltcGxlRXZlbnRQbHVnaW46d2YsRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOlllLENoYW5nZUV2ZW50UGx1Z2luOk1lLFNlbGVjdEV2ZW50UGx1Z2luOmtmLEJlZm9yZUlucHV0RXZlbnRQbHVnaW46dmV9KTt2YXIgeWY9W10semY9LTE7ZnVuY3Rpb24gSChhKXswPnpmfHwoYS5jdXJyZW50PXlmW3pmXSx5Zlt6Zl09bnVsbCx6Zi0tKX1cbmZ1bmN0aW9uIEkoYSxiKXt6ZisrO3lmW3pmXT1hLmN1cnJlbnQ7YS5jdXJyZW50PWJ9dmFyIEFmPXt9LEo9e2N1cnJlbnQ6QWZ9LEs9e2N1cnJlbnQ6ITF9LEJmPUFmO2Z1bmN0aW9uIENmKGEsYil7dmFyIGM9YS50eXBlLmNvbnRleHRUeXBlcztpZighYylyZXR1cm4gQWY7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoZCYmZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PT09YilyZXR1cm4gZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDt2YXIgZT17fSxmO2ZvcihmIGluIGMpZVtmXT1iW2ZdO2QmJihhPWEuc3RhdGVOb2RlLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1iLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9ZSk7cmV0dXJuIGV9ZnVuY3Rpb24gTChhKXthPWEuY2hpbGRDb250ZXh0VHlwZXM7cmV0dXJuIG51bGwhPT1hJiZ2b2lkIDAhPT1hfVxuZnVuY3Rpb24gRGYoKXtIKEspO0goSil9ZnVuY3Rpb24gRWYoYSxiLGMpe2lmKEouY3VycmVudCE9PUFmKXRocm93IEVycm9yKHUoMTY4KSk7SShKLGIpO0koSyxjKX1mdW5jdGlvbiBGZihhLGIsYyl7dmFyIGQ9YS5zdGF0ZU5vZGU7YT1iLmNoaWxkQ29udGV4dFR5cGVzO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBkLmdldENoaWxkQ29udGV4dClyZXR1cm4gYztkPWQuZ2V0Q2hpbGRDb250ZXh0KCk7Zm9yKHZhciBlIGluIGQpaWYoIShlIGluIGEpKXRocm93IEVycm9yKHUoMTA4LHBiKGIpfHxcIlVua25vd25cIixlKSk7cmV0dXJuIG4oe30sYyx7fSxkKX1mdW5jdGlvbiBHZihhKXthPShhPWEuc3RhdGVOb2RlKSYmYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dHx8QWY7QmY9Si5jdXJyZW50O0koSixhKTtJKEssSy5jdXJyZW50KTtyZXR1cm4hMH1cbmZ1bmN0aW9uIEhmKGEsYixjKXt2YXIgZD1hLnN0YXRlTm9kZTtpZighZCl0aHJvdyBFcnJvcih1KDE2OSkpO2M/KGE9RmYoYSxiLEJmKSxkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0PWEsSChLKSxIKEopLEkoSixhKSk6SChLKTtJKEssYyl9XG52YXIgSWY9ci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHksSmY9ci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLEtmPXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssTGY9ci51bnN0YWJsZV9yZXF1ZXN0UGFpbnQsTWY9ci51bnN0YWJsZV9ub3csTmY9ci51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCxPZj1yLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LFBmPXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksUWY9ci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxSZj1yLnVuc3RhYmxlX0xvd1ByaW9yaXR5LFNmPXIudW5zdGFibGVfSWRsZVByaW9yaXR5LFRmPXt9LFVmPXIudW5zdGFibGVfc2hvdWxkWWllbGQsVmY9dm9pZCAwIT09TGY/TGY6ZnVuY3Rpb24oKXt9LFdmPW51bGwsWGY9bnVsbCxZZj0hMSxaZj1NZigpLCRmPTFFND5aZj9NZjpmdW5jdGlvbigpe3JldHVybiBNZigpLVpmfTtcbmZ1bmN0aW9uIGFnKCl7c3dpdGNoKE5mKCkpe2Nhc2UgT2Y6cmV0dXJuIDk5O2Nhc2UgUGY6cmV0dXJuIDk4O2Nhc2UgUWY6cmV0dXJuIDk3O2Nhc2UgUmY6cmV0dXJuIDk2O2Nhc2UgU2Y6cmV0dXJuIDk1O2RlZmF1bHQ6dGhyb3cgRXJyb3IodSgzMzIpKTt9fWZ1bmN0aW9uIGJnKGEpe3N3aXRjaChhKXtjYXNlIDk5OnJldHVybiBPZjtjYXNlIDk4OnJldHVybiBQZjtjYXNlIDk3OnJldHVybiBRZjtjYXNlIDk2OnJldHVybiBSZjtjYXNlIDk1OnJldHVybiBTZjtkZWZhdWx0OnRocm93IEVycm9yKHUoMzMyKSk7fX1mdW5jdGlvbiBjZyhhLGIpe2E9YmcoYSk7cmV0dXJuIElmKGEsYil9ZnVuY3Rpb24gZGcoYSxiLGMpe2E9YmcoYSk7cmV0dXJuIEpmKGEsYixjKX1mdW5jdGlvbiBlZyhhKXtudWxsPT09V2Y/KFdmPVthXSxYZj1KZihPZixmZykpOldmLnB1c2goYSk7cmV0dXJuIFRmfWZ1bmN0aW9uIGdnKCl7aWYobnVsbCE9PVhmKXt2YXIgYT1YZjtYZj1udWxsO0tmKGEpfWZnKCl9XG5mdW5jdGlvbiBmZygpe2lmKCFZZiYmbnVsbCE9PVdmKXtZZj0hMDt2YXIgYT0wO3RyeXt2YXIgYj1XZjtjZyg5OSxmdW5jdGlvbigpe2Zvcig7YTxiLmxlbmd0aDthKyspe3ZhciBjPWJbYV07ZG8gYz1jKCEwKTt3aGlsZShudWxsIT09Yyl9fSk7V2Y9bnVsbH1jYXRjaChjKXt0aHJvdyBudWxsIT09V2YmJihXZj1XZi5zbGljZShhKzEpKSxKZihPZixnZyksYzt9ZmluYWxseXtZZj0hMX19fWZ1bmN0aW9uIGhnKGEsYixjKXtjLz0xMDtyZXR1cm4gMTA3Mzc0MTgyMS0oKCgxMDczNzQxODIxLWErYi8xMCkvY3wwKSsxKSpjfWZ1bmN0aW9uIGlnKGEsYil7aWYoYSYmYS5kZWZhdWx0UHJvcHMpe2I9bih7fSxiKTthPWEuZGVmYXVsdFByb3BzO2Zvcih2YXIgYyBpbiBhKXZvaWQgMD09PWJbY10mJihiW2NdPWFbY10pfXJldHVybiBifXZhciBqZz17Y3VycmVudDpudWxsfSxrZz1udWxsLGxnPW51bGwsbWc9bnVsbDtmdW5jdGlvbiBuZygpe21nPWxnPWtnPW51bGx9XG5mdW5jdGlvbiBvZyhhKXt2YXIgYj1qZy5jdXJyZW50O0goamcpO2EudHlwZS5fY29udGV4dC5fY3VycmVudFZhbHVlPWJ9ZnVuY3Rpb24gcGcoYSxiKXtmb3IoO251bGwhPT1hOyl7dmFyIGM9YS5hbHRlcm5hdGU7aWYoYS5jaGlsZEV4cGlyYXRpb25UaW1lPGIpYS5jaGlsZEV4cGlyYXRpb25UaW1lPWIsbnVsbCE9PWMmJmMuY2hpbGRFeHBpcmF0aW9uVGltZTxiJiYoYy5jaGlsZEV4cGlyYXRpb25UaW1lPWIpO2Vsc2UgaWYobnVsbCE9PWMmJmMuY2hpbGRFeHBpcmF0aW9uVGltZTxiKWMuY2hpbGRFeHBpcmF0aW9uVGltZT1iO2Vsc2UgYnJlYWs7YT1hLnJldHVybn19ZnVuY3Rpb24gcWcoYSxiKXtrZz1hO21nPWxnPW51bGw7YT1hLmRlcGVuZGVuY2llcztudWxsIT09YSYmbnVsbCE9PWEuZmlyc3RDb250ZXh0JiYoYS5leHBpcmF0aW9uVGltZT49YiYmKHJnPSEwKSxhLmZpcnN0Q29udGV4dD1udWxsKX1cbmZ1bmN0aW9uIHNnKGEsYil7aWYobWchPT1hJiYhMSE9PWImJjAhPT1iKXtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDEwNzM3NDE4MjM9PT1iKW1nPWEsYj0xMDczNzQxODIzO2I9e2NvbnRleHQ6YSxvYnNlcnZlZEJpdHM6YixuZXh0Om51bGx9O2lmKG51bGw9PT1sZyl7aWYobnVsbD09PWtnKXRocm93IEVycm9yKHUoMzA4KSk7bGc9YjtrZy5kZXBlbmRlbmNpZXM9e2V4cGlyYXRpb25UaW1lOjAsZmlyc3RDb250ZXh0OmIscmVzcG9uZGVyczpudWxsfX1lbHNlIGxnPWxnLm5leHQ9Yn1yZXR1cm4gYS5fY3VycmVudFZhbHVlfXZhciB0Zz0hMTtmdW5jdGlvbiB1ZyhhKXthLnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6YS5tZW1vaXplZFN0YXRlLGJhc2VRdWV1ZTpudWxsLHNoYXJlZDp7cGVuZGluZzpudWxsfSxlZmZlY3RzOm51bGx9fVxuZnVuY3Rpb24gdmcoYSxiKXthPWEudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT09PWEmJihiLnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6YS5iYXNlU3RhdGUsYmFzZVF1ZXVlOmEuYmFzZVF1ZXVlLHNoYXJlZDphLnNoYXJlZCxlZmZlY3RzOmEuZWZmZWN0c30pfWZ1bmN0aW9uIHdnKGEsYil7YT17ZXhwaXJhdGlvblRpbWU6YSxzdXNwZW5zZUNvbmZpZzpiLHRhZzowLHBheWxvYWQ6bnVsbCxjYWxsYmFjazpudWxsLG5leHQ6bnVsbH07cmV0dXJuIGEubmV4dD1hfWZ1bmN0aW9uIHhnKGEsYil7YT1hLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1hKXthPWEuc2hhcmVkO3ZhciBjPWEucGVuZGluZztudWxsPT09Yz9iLm5leHQ9YjooYi5uZXh0PWMubmV4dCxjLm5leHQ9Yik7YS5wZW5kaW5nPWJ9fVxuZnVuY3Rpb24geWcoYSxiKXt2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09YyYmdmcoYyxhKTthPWEudXBkYXRlUXVldWU7Yz1hLmJhc2VRdWV1ZTtudWxsPT09Yz8oYS5iYXNlUXVldWU9Yi5uZXh0PWIsYi5uZXh0PWIpOihiLm5leHQ9Yy5uZXh0LGMubmV4dD1iKX1cbmZ1bmN0aW9uIHpnKGEsYixjLGQpe3ZhciBlPWEudXBkYXRlUXVldWU7dGc9ITE7dmFyIGY9ZS5iYXNlUXVldWUsZz1lLnNoYXJlZC5wZW5kaW5nO2lmKG51bGwhPT1nKXtpZihudWxsIT09Zil7dmFyIGg9Zi5uZXh0O2YubmV4dD1nLm5leHQ7Zy5uZXh0PWh9Zj1nO2Uuc2hhcmVkLnBlbmRpbmc9bnVsbDtoPWEuYWx0ZXJuYXRlO251bGwhPT1oJiYoaD1oLnVwZGF0ZVF1ZXVlLG51bGwhPT1oJiYoaC5iYXNlUXVldWU9ZykpfWlmKG51bGwhPT1mKXtoPWYubmV4dDt2YXIgaz1lLmJhc2VTdGF0ZSxsPTAsbT1udWxsLHA9bnVsbCx4PW51bGw7aWYobnVsbCE9PWgpe3ZhciB6PWg7ZG97Zz16LmV4cGlyYXRpb25UaW1lO2lmKGc8ZCl7dmFyIGNhPXtleHBpcmF0aW9uVGltZTp6LmV4cGlyYXRpb25UaW1lLHN1c3BlbnNlQ29uZmlnOnouc3VzcGVuc2VDb25maWcsdGFnOnoudGFnLHBheWxvYWQ6ei5wYXlsb2FkLGNhbGxiYWNrOnouY2FsbGJhY2ssbmV4dDpudWxsfTtudWxsPT09eD8ocD14PVxuY2EsbT1rKTp4PXgubmV4dD1jYTtnPmwmJihsPWcpfWVsc2V7bnVsbCE9PXgmJih4PXgubmV4dD17ZXhwaXJhdGlvblRpbWU6MTA3Mzc0MTgyMyxzdXNwZW5zZUNvbmZpZzp6LnN1c3BlbnNlQ29uZmlnLHRhZzp6LnRhZyxwYXlsb2FkOnoucGF5bG9hZCxjYWxsYmFjazp6LmNhbGxiYWNrLG5leHQ6bnVsbH0pO0FnKGcsei5zdXNwZW5zZUNvbmZpZyk7YTp7dmFyIEQ9YSx0PXo7Zz1iO2NhPWM7c3dpdGNoKHQudGFnKXtjYXNlIDE6RD10LnBheWxvYWQ7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIEQpe2s9RC5jYWxsKGNhLGssZyk7YnJlYWsgYX1rPUQ7YnJlYWsgYTtjYXNlIDM6RC5lZmZlY3RUYWc9RC5lZmZlY3RUYWcmLTQwOTd8NjQ7Y2FzZSAwOkQ9dC5wYXlsb2FkO2c9XCJmdW5jdGlvblwiPT09dHlwZW9mIEQ/RC5jYWxsKGNhLGssZyk6RDtpZihudWxsPT09Z3x8dm9pZCAwPT09ZylicmVhayBhO2s9bih7fSxrLGcpO2JyZWFrIGE7Y2FzZSAyOnRnPSEwfX1udWxsIT09ei5jYWxsYmFjayYmXG4oYS5lZmZlY3RUYWd8PTMyLGc9ZS5lZmZlY3RzLG51bGw9PT1nP2UuZWZmZWN0cz1bel06Zy5wdXNoKHopKX16PXoubmV4dDtpZihudWxsPT09enx8ej09PWgpaWYoZz1lLnNoYXJlZC5wZW5kaW5nLG51bGw9PT1nKWJyZWFrO2Vsc2Ugej1mLm5leHQ9Zy5uZXh0LGcubmV4dD1oLGUuYmFzZVF1ZXVlPWY9ZyxlLnNoYXJlZC5wZW5kaW5nPW51bGx9d2hpbGUoMSl9bnVsbD09PXg/bT1rOngubmV4dD1wO2UuYmFzZVN0YXRlPW07ZS5iYXNlUXVldWU9eDtCZyhsKTthLmV4cGlyYXRpb25UaW1lPWw7YS5tZW1vaXplZFN0YXRlPWt9fVxuZnVuY3Rpb24gQ2coYSxiLGMpe2E9Yi5lZmZlY3RzO2IuZWZmZWN0cz1udWxsO2lmKG51bGwhPT1hKWZvcihiPTA7YjxhLmxlbmd0aDtiKyspe3ZhciBkPWFbYl0sZT1kLmNhbGxiYWNrO2lmKG51bGwhPT1lKXtkLmNhbGxiYWNrPW51bGw7ZD1lO2U9YztpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZCl0aHJvdyBFcnJvcih1KDE5MSxkKSk7ZC5jYWxsKGUpfX19dmFyIERnPVdhLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLEVnPShuZXcgYWEuQ29tcG9uZW50KS5yZWZzO2Z1bmN0aW9uIEZnKGEsYixjLGQpe2I9YS5tZW1vaXplZFN0YXRlO2M9YyhkLGIpO2M9bnVsbD09PWN8fHZvaWQgMD09PWM/YjpuKHt9LGIsYyk7YS5tZW1vaXplZFN0YXRlPWM7MD09PWEuZXhwaXJhdGlvblRpbWUmJihhLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1jKX1cbnZhciBKZz17aXNNb3VudGVkOmZ1bmN0aW9uKGEpe3JldHVybihhPWEuX3JlYWN0SW50ZXJuYWxGaWJlcik/ZGMoYSk9PT1hOiExfSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oYSxiLGMpe2E9YS5fcmVhY3RJbnRlcm5hbEZpYmVyO3ZhciBkPUdnKCksZT1EZy5zdXNwZW5zZTtkPUhnKGQsYSxlKTtlPXdnKGQsZSk7ZS5wYXlsb2FkPWI7dm9pZCAwIT09YyYmbnVsbCE9PWMmJihlLmNhbGxiYWNrPWMpO3hnKGEsZSk7SWcoYSxkKX0sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsRmliZXI7dmFyIGQ9R2coKSxlPURnLnN1c3BlbnNlO2Q9SGcoZCxhLGUpO2U9d2coZCxlKTtlLnRhZz0xO2UucGF5bG9hZD1iO3ZvaWQgMCE9PWMmJm51bGwhPT1jJiYoZS5jYWxsYmFjaz1jKTt4ZyhhLGUpO0lnKGEsZCl9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbihhLGIpe2E9YS5fcmVhY3RJbnRlcm5hbEZpYmVyO3ZhciBjPUdnKCksZD1EZy5zdXNwZW5zZTtcbmM9SGcoYyxhLGQpO2Q9d2coYyxkKTtkLnRhZz0yO3ZvaWQgMCE9PWImJm51bGwhPT1iJiYoZC5jYWxsYmFjaz1iKTt4ZyhhLGQpO0lnKGEsYyl9fTtmdW5jdGlvbiBLZyhhLGIsYyxkLGUsZixnKXthPWEuc3RhdGVOb2RlO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnNob3VsZENvbXBvbmVudFVwZGF0ZT9hLnNob3VsZENvbXBvbmVudFVwZGF0ZShkLGYsZyk6Yi5wcm90b3R5cGUmJmIucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50PyFiZihjLGQpfHwhYmYoZSxmKTohMH1cbmZ1bmN0aW9uIExnKGEsYixjKXt2YXIgZD0hMSxlPUFmO3ZhciBmPWIuY29udGV4dFR5cGU7XCJvYmplY3RcIj09PXR5cGVvZiBmJiZudWxsIT09Zj9mPXNnKGYpOihlPUwoYik/QmY6Si5jdXJyZW50LGQ9Yi5jb250ZXh0VHlwZXMsZj0oZD1udWxsIT09ZCYmdm9pZCAwIT09ZCk/Q2YoYSxlKTpBZik7Yj1uZXcgYihjLGYpO2EubWVtb2l6ZWRTdGF0ZT1udWxsIT09Yi5zdGF0ZSYmdm9pZCAwIT09Yi5zdGF0ZT9iLnN0YXRlOm51bGw7Yi51cGRhdGVyPUpnO2Euc3RhdGVOb2RlPWI7Yi5fcmVhY3RJbnRlcm5hbEZpYmVyPWE7ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1mKTtyZXR1cm4gYn1cbmZ1bmN0aW9uIE1nKGEsYixjLGQpe2E9Yi5zdGF0ZTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZiLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoYyxkKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmYi5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhjLGQpO2Iuc3RhdGUhPT1hJiZKZy5lbnF1ZXVlUmVwbGFjZVN0YXRlKGIsYi5zdGF0ZSxudWxsKX1cbmZ1bmN0aW9uIE5nKGEsYixjLGQpe3ZhciBlPWEuc3RhdGVOb2RlO2UucHJvcHM9YztlLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZTtlLnJlZnM9RWc7dWcoYSk7dmFyIGY9Yi5jb250ZXh0VHlwZTtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mP2UuY29udGV4dD1zZyhmKTooZj1MKGIpP0JmOkouY3VycmVudCxlLmNvbnRleHQ9Q2YoYSxmKSk7emcoYSxjLGUsZCk7ZS5zdGF0ZT1hLm1lbW9pemVkU3RhdGU7Zj1iLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcImZ1bmN0aW9uXCI9PT10eXBlb2YgZiYmKEZnKGEsYixmLGMpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHN8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5jb21wb25lbnRXaWxsTW91bnR8fFxuKGI9ZS5zdGF0ZSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5jb21wb25lbnRXaWxsTW91bnQmJmUuY29tcG9uZW50V2lsbE1vdW50KCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCksYiE9PWUuc3RhdGUmJkpnLmVucXVldWVSZXBsYWNlU3RhdGUoZSxlLnN0YXRlLG51bGwpLHpnKGEsYyxlLGQpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5jb21wb25lbnREaWRNb3VudCYmKGEuZWZmZWN0VGFnfD00KX12YXIgT2c9QXJyYXkuaXNBcnJheTtcbmZ1bmN0aW9uIFBnKGEsYixjKXthPWMucmVmO2lmKG51bGwhPT1hJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSYmXCJvYmplY3RcIiE9PXR5cGVvZiBhKXtpZihjLl9vd25lcil7Yz1jLl9vd25lcjtpZihjKXtpZigxIT09Yy50YWcpdGhyb3cgRXJyb3IodSgzMDkpKTt2YXIgZD1jLnN0YXRlTm9kZX1pZighZCl0aHJvdyBFcnJvcih1KDE0NyxhKSk7dmFyIGU9XCJcIithO2lmKG51bGwhPT1iJiZudWxsIT09Yi5yZWYmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBiLnJlZiYmYi5yZWYuX3N0cmluZ1JlZj09PWUpcmV0dXJuIGIucmVmO2I9ZnVuY3Rpb24oYSl7dmFyIGI9ZC5yZWZzO2I9PT1FZyYmKGI9ZC5yZWZzPXt9KTtudWxsPT09YT9kZWxldGUgYltlXTpiW2VdPWF9O2IuX3N0cmluZ1JlZj1lO3JldHVybiBifWlmKFwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBFcnJvcih1KDI4NCkpO2lmKCFjLl9vd25lcil0aHJvdyBFcnJvcih1KDI5MCxhKSk7fXJldHVybiBhfVxuZnVuY3Rpb24gUWcoYSxiKXtpZihcInRleHRhcmVhXCIhPT1hLnR5cGUpdGhyb3cgRXJyb3IodSgzMSxcIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYikuam9pbihcIiwgXCIpK1wifVwiOmIsXCJcIikpO31cbmZ1bmN0aW9uIFJnKGEpe2Z1bmN0aW9uIGIoYixjKXtpZihhKXt2YXIgZD1iLmxhc3RFZmZlY3Q7bnVsbCE9PWQ/KGQubmV4dEVmZmVjdD1jLGIubGFzdEVmZmVjdD1jKTpiLmZpcnN0RWZmZWN0PWIubGFzdEVmZmVjdD1jO2MubmV4dEVmZmVjdD1udWxsO2MuZWZmZWN0VGFnPTh9fWZ1bmN0aW9uIGMoYyxkKXtpZighYSlyZXR1cm4gbnVsbDtmb3IoO251bGwhPT1kOyliKGMsZCksZD1kLnNpYmxpbmc7cmV0dXJuIG51bGx9ZnVuY3Rpb24gZChhLGIpe2ZvcihhPW5ldyBNYXA7bnVsbCE9PWI7KW51bGwhPT1iLmtleT9hLnNldChiLmtleSxiKTphLnNldChiLmluZGV4LGIpLGI9Yi5zaWJsaW5nO3JldHVybiBhfWZ1bmN0aW9uIGUoYSxiKXthPVNnKGEsYik7YS5pbmRleD0wO2Euc2libGluZz1udWxsO3JldHVybiBhfWZ1bmN0aW9uIGYoYixjLGQpe2IuaW5kZXg9ZDtpZighYSlyZXR1cm4gYztkPWIuYWx0ZXJuYXRlO2lmKG51bGwhPT1kKXJldHVybiBkPWQuaW5kZXgsZDxjPyhiLmVmZmVjdFRhZz1cbjIsYyk6ZDtiLmVmZmVjdFRhZz0yO3JldHVybiBjfWZ1bmN0aW9uIGcoYil7YSYmbnVsbD09PWIuYWx0ZXJuYXRlJiYoYi5lZmZlY3RUYWc9Mik7cmV0dXJuIGJ9ZnVuY3Rpb24gaChhLGIsYyxkKXtpZihudWxsPT09Ynx8NiE9PWIudGFnKXJldHVybiBiPVRnKGMsYS5tb2RlLGQpLGIucmV0dXJuPWEsYjtiPWUoYixjKTtiLnJldHVybj1hO3JldHVybiBifWZ1bmN0aW9uIGsoYSxiLGMsZCl7aWYobnVsbCE9PWImJmIuZWxlbWVudFR5cGU9PT1jLnR5cGUpcmV0dXJuIGQ9ZShiLGMucHJvcHMpLGQucmVmPVBnKGEsYixjKSxkLnJldHVybj1hLGQ7ZD1VZyhjLnR5cGUsYy5rZXksYy5wcm9wcyxudWxsLGEubW9kZSxkKTtkLnJlZj1QZyhhLGIsYyk7ZC5yZXR1cm49YTtyZXR1cm4gZH1mdW5jdGlvbiBsKGEsYixjLGQpe2lmKG51bGw9PT1ifHw0IT09Yi50YWd8fGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8hPT1jLmNvbnRhaW5lckluZm98fGIuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09XG5jLmltcGxlbWVudGF0aW9uKXJldHVybiBiPVZnKGMsYS5tb2RlLGQpLGIucmV0dXJuPWEsYjtiPWUoYixjLmNoaWxkcmVufHxbXSk7Yi5yZXR1cm49YTtyZXR1cm4gYn1mdW5jdGlvbiBtKGEsYixjLGQsZil7aWYobnVsbD09PWJ8fDchPT1iLnRhZylyZXR1cm4gYj1XZyhjLGEubW9kZSxkLGYpLGIucmV0dXJuPWEsYjtiPWUoYixjKTtiLnJldHVybj1hO3JldHVybiBifWZ1bmN0aW9uIHAoYSxiLGMpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYnx8XCJudW1iZXJcIj09PXR5cGVvZiBiKXJldHVybiBiPVRnKFwiXCIrYixhLm1vZGUsYyksYi5yZXR1cm49YSxiO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYiYmbnVsbCE9PWIpe3N3aXRjaChiLiQkdHlwZW9mKXtjYXNlIFphOnJldHVybiBjPVVnKGIudHlwZSxiLmtleSxiLnByb3BzLG51bGwsYS5tb2RlLGMpLGMucmVmPVBnKGEsbnVsbCxiKSxjLnJldHVybj1hLGM7Y2FzZSAkYTpyZXR1cm4gYj1WZyhiLGEubW9kZSxjKSxiLnJldHVybj1hLGJ9aWYoT2coYil8fFxubmIoYikpcmV0dXJuIGI9V2coYixhLm1vZGUsYyxudWxsKSxiLnJldHVybj1hLGI7UWcoYSxiKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiB4KGEsYixjLGQpe3ZhciBlPW51bGwhPT1iP2Iua2V5Om51bGw7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBjfHxcIm51bWJlclwiPT09dHlwZW9mIGMpcmV0dXJuIG51bGwhPT1lP251bGw6aChhLGIsXCJcIitjLGQpO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYyYmbnVsbCE9PWMpe3N3aXRjaChjLiQkdHlwZW9mKXtjYXNlIFphOnJldHVybiBjLmtleT09PWU/Yy50eXBlPT09YWI/bShhLGIsYy5wcm9wcy5jaGlsZHJlbixkLGUpOmsoYSxiLGMsZCk6bnVsbDtjYXNlICRhOnJldHVybiBjLmtleT09PWU/bChhLGIsYyxkKTpudWxsfWlmKE9nKGMpfHxuYihjKSlyZXR1cm4gbnVsbCE9PWU/bnVsbDptKGEsYixjLGQsbnVsbCk7UWcoYSxjKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiB6KGEsYixjLGQsZSl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBkfHxcIm51bWJlclwiPT09dHlwZW9mIGQpcmV0dXJuIGE9XG5hLmdldChjKXx8bnVsbCxoKGIsYSxcIlwiK2QsZSk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCl7c3dpdGNoKGQuJCR0eXBlb2Ype2Nhc2UgWmE6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLGQudHlwZT09PWFiP20oYixhLGQucHJvcHMuY2hpbGRyZW4sZSxkLmtleSk6ayhiLGEsZCxlKTtjYXNlICRhOnJldHVybiBhPWEuZ2V0KG51bGw9PT1kLmtleT9jOmQua2V5KXx8bnVsbCxsKGIsYSxkLGUpfWlmKE9nKGQpfHxuYihkKSlyZXR1cm4gYT1hLmdldChjKXx8bnVsbCxtKGIsYSxkLGUsbnVsbCk7UWcoYixkKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBjYShlLGcsaCxrKXtmb3IodmFyIGw9bnVsbCx0PW51bGwsbT1nLHk9Zz0wLEE9bnVsbDtudWxsIT09bSYmeTxoLmxlbmd0aDt5Kyspe20uaW5kZXg+eT8oQT1tLG09bnVsbCk6QT1tLnNpYmxpbmc7dmFyIHE9eChlLG0saFt5XSxrKTtpZihudWxsPT09cSl7bnVsbD09PW0mJihtPUEpO2JyZWFrfWEmJlxubSYmbnVsbD09PXEuYWx0ZXJuYXRlJiZiKGUsbSk7Zz1mKHEsZyx5KTtudWxsPT09dD9sPXE6dC5zaWJsaW5nPXE7dD1xO209QX1pZih5PT09aC5sZW5ndGgpcmV0dXJuIGMoZSxtKSxsO2lmKG51bGw9PT1tKXtmb3IoO3k8aC5sZW5ndGg7eSsrKW09cChlLGhbeV0sayksbnVsbCE9PW0mJihnPWYobSxnLHkpLG51bGw9PT10P2w9bTp0LnNpYmxpbmc9bSx0PW0pO3JldHVybiBsfWZvcihtPWQoZSxtKTt5PGgubGVuZ3RoO3krKylBPXoobSxlLHksaFt5XSxrKSxudWxsIT09QSYmKGEmJm51bGwhPT1BLmFsdGVybmF0ZSYmbS5kZWxldGUobnVsbD09PUEua2V5P3k6QS5rZXkpLGc9ZihBLGcseSksbnVsbD09PXQ/bD1BOnQuc2libGluZz1BLHQ9QSk7YSYmbS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JldHVybiBiKGUsYSl9KTtyZXR1cm4gbH1mdW5jdGlvbiBEKGUsZyxoLGwpe3ZhciBrPW5iKGgpO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBrKXRocm93IEVycm9yKHUoMTUwKSk7aD1rLmNhbGwoaCk7XG5pZihudWxsPT1oKXRocm93IEVycm9yKHUoMTUxKSk7Zm9yKHZhciBtPWs9bnVsbCx0PWcseT1nPTAsQT1udWxsLHE9aC5uZXh0KCk7bnVsbCE9PXQmJiFxLmRvbmU7eSsrLHE9aC5uZXh0KCkpe3QuaW5kZXg+eT8oQT10LHQ9bnVsbCk6QT10LnNpYmxpbmc7dmFyIEQ9eChlLHQscS52YWx1ZSxsKTtpZihudWxsPT09RCl7bnVsbD09PXQmJih0PUEpO2JyZWFrfWEmJnQmJm51bGw9PT1ELmFsdGVybmF0ZSYmYihlLHQpO2c9ZihELGcseSk7bnVsbD09PW0/az1EOm0uc2libGluZz1EO209RDt0PUF9aWYocS5kb25lKXJldHVybiBjKGUsdCksaztpZihudWxsPT09dCl7Zm9yKDshcS5kb25lO3krKyxxPWgubmV4dCgpKXE9cChlLHEudmFsdWUsbCksbnVsbCE9PXEmJihnPWYocSxnLHkpLG51bGw9PT1tP2s9cTptLnNpYmxpbmc9cSxtPXEpO3JldHVybiBrfWZvcih0PWQoZSx0KTshcS5kb25lO3krKyxxPWgubmV4dCgpKXE9eih0LGUseSxxLnZhbHVlLGwpLG51bGwhPT1xJiYoYSYmbnVsbCE9PVxucS5hbHRlcm5hdGUmJnQuZGVsZXRlKG51bGw9PT1xLmtleT95OnEua2V5KSxnPWYocSxnLHkpLG51bGw9PT1tP2s9cTptLnNpYmxpbmc9cSxtPXEpO2EmJnQuZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGt9cmV0dXJuIGZ1bmN0aW9uKGEsZCxmLGgpe3ZhciBrPVwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWYmJmYudHlwZT09PWFiJiZudWxsPT09Zi5rZXk7ayYmKGY9Zi5wcm9wcy5jaGlsZHJlbik7dmFyIGw9XCJvYmplY3RcIj09PXR5cGVvZiBmJiZudWxsIT09ZjtpZihsKXN3aXRjaChmLiQkdHlwZW9mKXtjYXNlIFphOmE6e2w9Zi5rZXk7Zm9yKGs9ZDtudWxsIT09azspe2lmKGsua2V5PT09bCl7c3dpdGNoKGsudGFnKXtjYXNlIDc6aWYoZi50eXBlPT09YWIpe2MoYSxrLnNpYmxpbmcpO2Q9ZShrLGYucHJvcHMuY2hpbGRyZW4pO2QucmV0dXJuPWE7YT1kO2JyZWFrIGF9YnJlYWs7ZGVmYXVsdDppZihrLmVsZW1lbnRUeXBlPT09Zi50eXBlKXtjKGEsXG5rLnNpYmxpbmcpO2Q9ZShrLGYucHJvcHMpO2QucmVmPVBnKGEsayxmKTtkLnJldHVybj1hO2E9ZDticmVhayBhfX1jKGEsayk7YnJlYWt9ZWxzZSBiKGEsayk7az1rLnNpYmxpbmd9Zi50eXBlPT09YWI/KGQ9V2coZi5wcm9wcy5jaGlsZHJlbixhLm1vZGUsaCxmLmtleSksZC5yZXR1cm49YSxhPWQpOihoPVVnKGYudHlwZSxmLmtleSxmLnByb3BzLG51bGwsYS5tb2RlLGgpLGgucmVmPVBnKGEsZCxmKSxoLnJldHVybj1hLGE9aCl9cmV0dXJuIGcoYSk7Y2FzZSAkYTphOntmb3Ioaz1mLmtleTtudWxsIT09ZDspe2lmKGQua2V5PT09aylpZig0PT09ZC50YWcmJmQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm89PT1mLmNvbnRhaW5lckluZm8mJmQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uPT09Zi5pbXBsZW1lbnRhdGlvbil7YyhhLGQuc2libGluZyk7ZD1lKGQsZi5jaGlsZHJlbnx8W10pO2QucmV0dXJuPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsZCk7YnJlYWt9ZWxzZSBiKGEsZCk7ZD1cbmQuc2libGluZ31kPVZnKGYsYS5tb2RlLGgpO2QucmV0dXJuPWE7YT1kfXJldHVybiBnKGEpfWlmKFwic3RyaW5nXCI9PT10eXBlb2YgZnx8XCJudW1iZXJcIj09PXR5cGVvZiBmKXJldHVybiBmPVwiXCIrZixudWxsIT09ZCYmNj09PWQudGFnPyhjKGEsZC5zaWJsaW5nKSxkPWUoZCxmKSxkLnJldHVybj1hLGE9ZCk6KGMoYSxkKSxkPVRnKGYsYS5tb2RlLGgpLGQucmV0dXJuPWEsYT1kKSxnKGEpO2lmKE9nKGYpKXJldHVybiBjYShhLGQsZixoKTtpZihuYihmKSlyZXR1cm4gRChhLGQsZixoKTtsJiZRZyhhLGYpO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgZiYmIWspc3dpdGNoKGEudGFnKXtjYXNlIDE6Y2FzZSAwOnRocm93IGE9YS50eXBlLEVycm9yKHUoMTUyLGEuZGlzcGxheU5hbWV8fGEubmFtZXx8XCJDb21wb25lbnRcIikpO31yZXR1cm4gYyhhLGQpfX12YXIgWGc9UmcoITApLFlnPVJnKCExKSxaZz17fSwkZz17Y3VycmVudDpaZ30sYWg9e2N1cnJlbnQ6Wmd9LGJoPXtjdXJyZW50OlpnfTtcbmZ1bmN0aW9uIGNoKGEpe2lmKGE9PT1aZyl0aHJvdyBFcnJvcih1KDE3NCkpO3JldHVybiBhfWZ1bmN0aW9uIGRoKGEsYil7SShiaCxiKTtJKGFoLGEpO0koJGcsWmcpO2E9Yi5ub2RlVHlwZTtzd2l0Y2goYSl7Y2FzZSA5OmNhc2UgMTE6Yj0oYj1iLmRvY3VtZW50RWxlbWVudCk/Yi5uYW1lc3BhY2VVUkk6T2IobnVsbCxcIlwiKTticmVhaztkZWZhdWx0OmE9OD09PWE/Yi5wYXJlbnROb2RlOmIsYj1hLm5hbWVzcGFjZVVSSXx8bnVsbCxhPWEudGFnTmFtZSxiPU9iKGIsYSl9SCgkZyk7SSgkZyxiKX1mdW5jdGlvbiBlaCgpe0goJGcpO0goYWgpO0goYmgpfWZ1bmN0aW9uIGZoKGEpe2NoKGJoLmN1cnJlbnQpO3ZhciBiPWNoKCRnLmN1cnJlbnQpO3ZhciBjPU9iKGIsYS50eXBlKTtiIT09YyYmKEkoYWgsYSksSSgkZyxjKSl9ZnVuY3Rpb24gZ2goYSl7YWguY3VycmVudD09PWEmJihIKCRnKSxIKGFoKSl9dmFyIE09e2N1cnJlbnQ6MH07XG5mdW5jdGlvbiBoaChhKXtmb3IodmFyIGI9YTtudWxsIT09Yjspe2lmKDEzPT09Yi50YWcpe3ZhciBjPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09YyYmKGM9Yy5kZWh5ZHJhdGVkLG51bGw9PT1jfHxjLmRhdGE9PT1CZHx8Yy5kYXRhPT09Q2QpKXJldHVybiBifWVsc2UgaWYoMTk9PT1iLnRhZyYmdm9pZCAwIT09Yi5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyKXtpZigwIT09KGIuZWZmZWN0VGFnJjY0KSlyZXR1cm4gYn1lbHNlIGlmKG51bGwhPT1iLmNoaWxkKXtiLmNoaWxkLnJldHVybj1iO2I9Yi5jaGlsZDtjb250aW51ZX1pZihiPT09YSlicmVhaztmb3IoO251bGw9PT1iLnNpYmxpbmc7KXtpZihudWxsPT09Yi5yZXR1cm58fGIucmV0dXJuPT09YSlyZXR1cm4gbnVsbDtiPWIucmV0dXJufWIuc2libGluZy5yZXR1cm49Yi5yZXR1cm47Yj1iLnNpYmxpbmd9cmV0dXJuIG51bGx9ZnVuY3Rpb24gaWgoYSxiKXtyZXR1cm57cmVzcG9uZGVyOmEscHJvcHM6Yn19XG52YXIgamg9V2EuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixraD1XYS5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxsaD0wLE49bnVsbCxPPW51bGwsUD1udWxsLG1oPSExO2Z1bmN0aW9uIFEoKXt0aHJvdyBFcnJvcih1KDMyMSkpO31mdW5jdGlvbiBuaChhLGIpe2lmKG51bGw9PT1iKXJldHVybiExO2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGgmJmM8YS5sZW5ndGg7YysrKWlmKCEkZShhW2NdLGJbY10pKXJldHVybiExO3JldHVybiEwfVxuZnVuY3Rpb24gb2goYSxiLGMsZCxlLGYpe2xoPWY7Tj1iO2IubWVtb2l6ZWRTdGF0ZT1udWxsO2IudXBkYXRlUXVldWU9bnVsbDtiLmV4cGlyYXRpb25UaW1lPTA7amguY3VycmVudD1udWxsPT09YXx8bnVsbD09PWEubWVtb2l6ZWRTdGF0ZT9waDpxaDthPWMoZCxlKTtpZihiLmV4cGlyYXRpb25UaW1lPT09bGgpe2Y9MDtkb3tiLmV4cGlyYXRpb25UaW1lPTA7aWYoISgyNT5mKSl0aHJvdyBFcnJvcih1KDMwMSkpO2YrPTE7UD1PPW51bGw7Yi51cGRhdGVRdWV1ZT1udWxsO2poLmN1cnJlbnQ9cmg7YT1jKGQsZSl9d2hpbGUoYi5leHBpcmF0aW9uVGltZT09PWxoKX1qaC5jdXJyZW50PXNoO2I9bnVsbCE9PU8mJm51bGwhPT1PLm5leHQ7bGg9MDtQPU89Tj1udWxsO21oPSExO2lmKGIpdGhyb3cgRXJyb3IodSgzMDApKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIHRoKCl7dmFyIGE9e21lbW9pemVkU3RhdGU6bnVsbCxiYXNlU3RhdGU6bnVsbCxiYXNlUXVldWU6bnVsbCxxdWV1ZTpudWxsLG5leHQ6bnVsbH07bnVsbD09PVA/Ti5tZW1vaXplZFN0YXRlPVA9YTpQPVAubmV4dD1hO3JldHVybiBQfWZ1bmN0aW9uIHVoKCl7aWYobnVsbD09PU8pe3ZhciBhPU4uYWx0ZXJuYXRlO2E9bnVsbCE9PWE/YS5tZW1vaXplZFN0YXRlOm51bGx9ZWxzZSBhPU8ubmV4dDt2YXIgYj1udWxsPT09UD9OLm1lbW9pemVkU3RhdGU6UC5uZXh0O2lmKG51bGwhPT1iKVA9YixPPWE7ZWxzZXtpZihudWxsPT09YSl0aHJvdyBFcnJvcih1KDMxMCkpO089YTthPXttZW1vaXplZFN0YXRlOk8ubWVtb2l6ZWRTdGF0ZSxiYXNlU3RhdGU6Ty5iYXNlU3RhdGUsYmFzZVF1ZXVlOk8uYmFzZVF1ZXVlLHF1ZXVlOk8ucXVldWUsbmV4dDpudWxsfTtudWxsPT09UD9OLm1lbW9pemVkU3RhdGU9UD1hOlA9UC5uZXh0PWF9cmV0dXJuIFB9XG5mdW5jdGlvbiB2aChhLGIpe3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBiP2IoYSk6Yn1cbmZ1bmN0aW9uIHdoKGEpe3ZhciBiPXVoKCksYz1iLnF1ZXVlO2lmKG51bGw9PT1jKXRocm93IEVycm9yKHUoMzExKSk7Yy5sYXN0UmVuZGVyZWRSZWR1Y2VyPWE7dmFyIGQ9TyxlPWQuYmFzZVF1ZXVlLGY9Yy5wZW5kaW5nO2lmKG51bGwhPT1mKXtpZihudWxsIT09ZSl7dmFyIGc9ZS5uZXh0O2UubmV4dD1mLm5leHQ7Zi5uZXh0PWd9ZC5iYXNlUXVldWU9ZT1mO2MucGVuZGluZz1udWxsfWlmKG51bGwhPT1lKXtlPWUubmV4dDtkPWQuYmFzZVN0YXRlO3ZhciBoPWc9Zj1udWxsLGs9ZTtkb3t2YXIgbD1rLmV4cGlyYXRpb25UaW1lO2lmKGw8bGgpe3ZhciBtPXtleHBpcmF0aW9uVGltZTprLmV4cGlyYXRpb25UaW1lLHN1c3BlbnNlQ29uZmlnOmsuc3VzcGVuc2VDb25maWcsYWN0aW9uOmsuYWN0aW9uLGVhZ2VyUmVkdWNlcjprLmVhZ2VyUmVkdWNlcixlYWdlclN0YXRlOmsuZWFnZXJTdGF0ZSxuZXh0Om51bGx9O251bGw9PT1oPyhnPWg9bSxmPWQpOmg9aC5uZXh0PW07bD5OLmV4cGlyYXRpb25UaW1lJiZcbihOLmV4cGlyYXRpb25UaW1lPWwsQmcobCkpfWVsc2UgbnVsbCE9PWgmJihoPWgubmV4dD17ZXhwaXJhdGlvblRpbWU6MTA3Mzc0MTgyMyxzdXNwZW5zZUNvbmZpZzprLnN1c3BlbnNlQ29uZmlnLGFjdGlvbjprLmFjdGlvbixlYWdlclJlZHVjZXI6ay5lYWdlclJlZHVjZXIsZWFnZXJTdGF0ZTprLmVhZ2VyU3RhdGUsbmV4dDpudWxsfSksQWcobCxrLnN1c3BlbnNlQ29uZmlnKSxkPWsuZWFnZXJSZWR1Y2VyPT09YT9rLmVhZ2VyU3RhdGU6YShkLGsuYWN0aW9uKTtrPWsubmV4dH13aGlsZShudWxsIT09ayYmayE9PWUpO251bGw9PT1oP2Y9ZDpoLm5leHQ9ZzskZShkLGIubWVtb2l6ZWRTdGF0ZSl8fChyZz0hMCk7Yi5tZW1vaXplZFN0YXRlPWQ7Yi5iYXNlU3RhdGU9ZjtiLmJhc2VRdWV1ZT1oO2MubGFzdFJlbmRlcmVkU3RhdGU9ZH1yZXR1cm5bYi5tZW1vaXplZFN0YXRlLGMuZGlzcGF0Y2hdfVxuZnVuY3Rpb24geGgoYSl7dmFyIGI9dWgoKSxjPWIucXVldWU7aWYobnVsbD09PWMpdGhyb3cgRXJyb3IodSgzMTEpKTtjLmxhc3RSZW5kZXJlZFJlZHVjZXI9YTt2YXIgZD1jLmRpc3BhdGNoLGU9Yy5wZW5kaW5nLGY9Yi5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1lKXtjLnBlbmRpbmc9bnVsbDt2YXIgZz1lPWUubmV4dDtkbyBmPWEoZixnLmFjdGlvbiksZz1nLm5leHQ7d2hpbGUoZyE9PWUpOyRlKGYsYi5tZW1vaXplZFN0YXRlKXx8KHJnPSEwKTtiLm1lbW9pemVkU3RhdGU9ZjtudWxsPT09Yi5iYXNlUXVldWUmJihiLmJhc2VTdGF0ZT1mKTtjLmxhc3RSZW5kZXJlZFN0YXRlPWZ9cmV0dXJuW2YsZF19XG5mdW5jdGlvbiB5aChhKXt2YXIgYj10aCgpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBhJiYoYT1hKCkpO2IubWVtb2l6ZWRTdGF0ZT1iLmJhc2VTdGF0ZT1hO2E9Yi5xdWV1ZT17cGVuZGluZzpudWxsLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjp2aCxsYXN0UmVuZGVyZWRTdGF0ZTphfTthPWEuZGlzcGF0Y2g9emguYmluZChudWxsLE4sYSk7cmV0dXJuW2IubWVtb2l6ZWRTdGF0ZSxhXX1mdW5jdGlvbiBBaChhLGIsYyxkKXthPXt0YWc6YSxjcmVhdGU6YixkZXN0cm95OmMsZGVwczpkLG5leHQ6bnVsbH07Yj1OLnVwZGF0ZVF1ZXVlO251bGw9PT1iPyhiPXtsYXN0RWZmZWN0Om51bGx9LE4udXBkYXRlUXVldWU9YixiLmxhc3RFZmZlY3Q9YS5uZXh0PWEpOihjPWIubGFzdEVmZmVjdCxudWxsPT09Yz9iLmxhc3RFZmZlY3Q9YS5uZXh0PWE6KGQ9Yy5uZXh0LGMubmV4dD1hLGEubmV4dD1kLGIubGFzdEVmZmVjdD1hKSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBCaCgpe3JldHVybiB1aCgpLm1lbW9pemVkU3RhdGV9ZnVuY3Rpb24gQ2goYSxiLGMsZCl7dmFyIGU9dGgoKTtOLmVmZmVjdFRhZ3w9YTtlLm1lbW9pemVkU3RhdGU9QWgoMXxiLGMsdm9pZCAwLHZvaWQgMD09PWQ/bnVsbDpkKX1mdW5jdGlvbiBEaChhLGIsYyxkKXt2YXIgZT11aCgpO2Q9dm9pZCAwPT09ZD9udWxsOmQ7dmFyIGY9dm9pZCAwO2lmKG51bGwhPT1PKXt2YXIgZz1PLm1lbW9pemVkU3RhdGU7Zj1nLmRlc3Ryb3k7aWYobnVsbCE9PWQmJm5oKGQsZy5kZXBzKSl7QWgoYixjLGYsZCk7cmV0dXJufX1OLmVmZmVjdFRhZ3w9YTtlLm1lbW9pemVkU3RhdGU9QWgoMXxiLGMsZixkKX1mdW5jdGlvbiBFaChhLGIpe3JldHVybiBDaCg1MTYsNCxhLGIpfWZ1bmN0aW9uIEZoKGEsYil7cmV0dXJuIERoKDUxNiw0LGEsYil9ZnVuY3Rpb24gR2goYSxiKXtyZXR1cm4gRGgoNCwyLGEsYil9XG5mdW5jdGlvbiBIaChhLGIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXJldHVybiBhPWEoKSxiKGEpLGZ1bmN0aW9uKCl7YihudWxsKX07aWYobnVsbCE9PWImJnZvaWQgMCE9PWIpcmV0dXJuIGE9YSgpLGIuY3VycmVudD1hLGZ1bmN0aW9uKCl7Yi5jdXJyZW50PW51bGx9fWZ1bmN0aW9uIEloKGEsYixjKXtjPW51bGwhPT1jJiZ2b2lkIDAhPT1jP2MuY29uY2F0KFthXSk6bnVsbDtyZXR1cm4gRGgoNCwyLEhoLmJpbmQobnVsbCxiLGEpLGMpfWZ1bmN0aW9uIEpoKCl7fWZ1bmN0aW9uIEtoKGEsYil7dGgoKS5tZW1vaXplZFN0YXRlPVthLHZvaWQgMD09PWI/bnVsbDpiXTtyZXR1cm4gYX1mdW5jdGlvbiBMaChhLGIpe3ZhciBjPXVoKCk7Yj12b2lkIDA9PT1iP251bGw6Yjt2YXIgZD1jLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWQmJm51bGwhPT1iJiZuaChiLGRbMV0pKXJldHVybiBkWzBdO2MubWVtb2l6ZWRTdGF0ZT1bYSxiXTtyZXR1cm4gYX1cbmZ1bmN0aW9uIE1oKGEsYil7dmFyIGM9dWgoKTtiPXZvaWQgMD09PWI/bnVsbDpiO3ZhciBkPWMubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09ZCYmbnVsbCE9PWImJm5oKGIsZFsxXSkpcmV0dXJuIGRbMF07YT1hKCk7Yy5tZW1vaXplZFN0YXRlPVthLGJdO3JldHVybiBhfWZ1bmN0aW9uIE5oKGEsYixjKXt2YXIgZD1hZygpO2NnKDk4PmQ/OTg6ZCxmdW5jdGlvbigpe2EoITApfSk7Y2coOTc8ZD85NzpkLGZ1bmN0aW9uKCl7dmFyIGQ9a2guc3VzcGVuc2U7a2guc3VzcGVuc2U9dm9pZCAwPT09Yj9udWxsOmI7dHJ5e2EoITEpLGMoKX1maW5hbGx5e2toLnN1c3BlbnNlPWR9fSl9XG5mdW5jdGlvbiB6aChhLGIsYyl7dmFyIGQ9R2coKSxlPURnLnN1c3BlbnNlO2Q9SGcoZCxhLGUpO2U9e2V4cGlyYXRpb25UaW1lOmQsc3VzcGVuc2VDb25maWc6ZSxhY3Rpb246YyxlYWdlclJlZHVjZXI6bnVsbCxlYWdlclN0YXRlOm51bGwsbmV4dDpudWxsfTt2YXIgZj1iLnBlbmRpbmc7bnVsbD09PWY/ZS5uZXh0PWU6KGUubmV4dD1mLm5leHQsZi5uZXh0PWUpO2IucGVuZGluZz1lO2Y9YS5hbHRlcm5hdGU7aWYoYT09PU58fG51bGwhPT1mJiZmPT09TiltaD0hMCxlLmV4cGlyYXRpb25UaW1lPWxoLE4uZXhwaXJhdGlvblRpbWU9bGg7ZWxzZXtpZigwPT09YS5leHBpcmF0aW9uVGltZSYmKG51bGw9PT1mfHwwPT09Zi5leHBpcmF0aW9uVGltZSkmJihmPWIubGFzdFJlbmRlcmVkUmVkdWNlcixudWxsIT09ZikpdHJ5e3ZhciBnPWIubGFzdFJlbmRlcmVkU3RhdGUsaD1mKGcsYyk7ZS5lYWdlclJlZHVjZXI9ZjtlLmVhZ2VyU3RhdGU9aDtpZigkZShoLGcpKXJldHVybn1jYXRjaChrKXt9ZmluYWxseXt9SWcoYSxcbmQpfX1cbnZhciBzaD17cmVhZENvbnRleHQ6c2csdXNlQ2FsbGJhY2s6USx1c2VDb250ZXh0OlEsdXNlRWZmZWN0OlEsdXNlSW1wZXJhdGl2ZUhhbmRsZTpRLHVzZUxheW91dEVmZmVjdDpRLHVzZU1lbW86USx1c2VSZWR1Y2VyOlEsdXNlUmVmOlEsdXNlU3RhdGU6USx1c2VEZWJ1Z1ZhbHVlOlEsdXNlUmVzcG9uZGVyOlEsdXNlRGVmZXJyZWRWYWx1ZTpRLHVzZVRyYW5zaXRpb246UX0scGg9e3JlYWRDb250ZXh0OnNnLHVzZUNhbGxiYWNrOktoLHVzZUNvbnRleHQ6c2csdXNlRWZmZWN0OkVoLHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9PWMmJnZvaWQgMCE9PWM/Yy5jb25jYXQoW2FdKTpudWxsO3JldHVybiBDaCg0LDIsSGguYmluZChudWxsLGIsYSksYyl9LHVzZUxheW91dEVmZmVjdDpmdW5jdGlvbihhLGIpe3JldHVybiBDaCg0LDIsYSxiKX0sdXNlTWVtbzpmdW5jdGlvbihhLGIpe3ZhciBjPXRoKCk7Yj12b2lkIDA9PT1iP251bGw6YjthPWEoKTtjLm1lbW9pemVkU3RhdGU9W2EsXG5iXTtyZXR1cm4gYX0sdXNlUmVkdWNlcjpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGgoKTtiPXZvaWQgMCE9PWM/YyhiKTpiO2QubWVtb2l6ZWRTdGF0ZT1kLmJhc2VTdGF0ZT1iO2E9ZC5xdWV1ZT17cGVuZGluZzpudWxsLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjphLGxhc3RSZW5kZXJlZFN0YXRlOmJ9O2E9YS5kaXNwYXRjaD16aC5iaW5kKG51bGwsTixhKTtyZXR1cm5bZC5tZW1vaXplZFN0YXRlLGFdfSx1c2VSZWY6ZnVuY3Rpb24oYSl7dmFyIGI9dGgoKTthPXtjdXJyZW50OmF9O3JldHVybiBiLm1lbW9pemVkU3RhdGU9YX0sdXNlU3RhdGU6eWgsdXNlRGVidWdWYWx1ZTpKaCx1c2VSZXNwb25kZXI6aWgsdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbihhLGIpe3ZhciBjPXloKGEpLGQ9Y1swXSxlPWNbMV07RWgoZnVuY3Rpb24oKXt2YXIgYz1raC5zdXNwZW5zZTtraC5zdXNwZW5zZT12b2lkIDA9PT1iP251bGw6Yjt0cnl7ZShhKX1maW5hbGx5e2toLnN1c3BlbnNlPVxuY319LFthLGJdKTtyZXR1cm4gZH0sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbihhKXt2YXIgYj15aCghMSksYz1iWzBdO2I9YlsxXTtyZXR1cm5bS2goTmguYmluZChudWxsLGIsYSksW2IsYV0pLGNdfX0scWg9e3JlYWRDb250ZXh0OnNnLHVzZUNhbGxiYWNrOkxoLHVzZUNvbnRleHQ6c2csdXNlRWZmZWN0OkZoLHVzZUltcGVyYXRpdmVIYW5kbGU6SWgsdXNlTGF5b3V0RWZmZWN0OkdoLHVzZU1lbW86TWgsdXNlUmVkdWNlcjp3aCx1c2VSZWY6QmgsdXNlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gd2godmgpfSx1c2VEZWJ1Z1ZhbHVlOkpoLHVzZVJlc3BvbmRlcjppaCx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9d2godmgpLGQ9Y1swXSxlPWNbMV07RmgoZnVuY3Rpb24oKXt2YXIgYz1raC5zdXNwZW5zZTtraC5zdXNwZW5zZT12b2lkIDA9PT1iP251bGw6Yjt0cnl7ZShhKX1maW5hbGx5e2toLnN1c3BlbnNlPWN9fSxbYSxiXSk7cmV0dXJuIGR9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGI9XG53aCh2aCksYz1iWzBdO2I9YlsxXTtyZXR1cm5bTGgoTmguYmluZChudWxsLGIsYSksW2IsYV0pLGNdfX0scmg9e3JlYWRDb250ZXh0OnNnLHVzZUNhbGxiYWNrOkxoLHVzZUNvbnRleHQ6c2csdXNlRWZmZWN0OkZoLHVzZUltcGVyYXRpdmVIYW5kbGU6SWgsdXNlTGF5b3V0RWZmZWN0OkdoLHVzZU1lbW86TWgsdXNlUmVkdWNlcjp4aCx1c2VSZWY6QmgsdXNlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4geGgodmgpfSx1c2VEZWJ1Z1ZhbHVlOkpoLHVzZVJlc3BvbmRlcjppaCx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9eGgodmgpLGQ9Y1swXSxlPWNbMV07RmgoZnVuY3Rpb24oKXt2YXIgYz1raC5zdXNwZW5zZTtraC5zdXNwZW5zZT12b2lkIDA9PT1iP251bGw6Yjt0cnl7ZShhKX1maW5hbGx5e2toLnN1c3BlbnNlPWN9fSxbYSxiXSk7cmV0dXJuIGR9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGI9eGgodmgpLGM9YlswXTtiPWJbMV07cmV0dXJuW0xoKE5oLmJpbmQobnVsbCxcbmIsYSksW2IsYV0pLGNdfX0sT2g9bnVsbCxQaD1udWxsLFFoPSExO2Z1bmN0aW9uIFJoKGEsYil7dmFyIGM9U2goNSxudWxsLG51bGwsMCk7Yy5lbGVtZW50VHlwZT1cIkRFTEVURURcIjtjLnR5cGU9XCJERUxFVEVEXCI7Yy5zdGF0ZU5vZGU9YjtjLnJldHVybj1hO2MuZWZmZWN0VGFnPTg7bnVsbCE9PWEubGFzdEVmZmVjdD8oYS5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YyxhLmxhc3RFZmZlY3Q9Yyk6YS5maXJzdEVmZmVjdD1hLmxhc3RFZmZlY3Q9Y31cbmZ1bmN0aW9uIFRoKGEsYil7c3dpdGNoKGEudGFnKXtjYXNlIDU6dmFyIGM9YS50eXBlO2I9MSE9PWIubm9kZVR5cGV8fGMudG9Mb3dlckNhc2UoKSE9PWIubm9kZU5hbWUudG9Mb3dlckNhc2UoKT9udWxsOmI7cmV0dXJuIG51bGwhPT1iPyhhLnN0YXRlTm9kZT1iLCEwKTohMTtjYXNlIDY6cmV0dXJuIGI9XCJcIj09PWEucGVuZGluZ1Byb3BzfHwzIT09Yi5ub2RlVHlwZT9udWxsOmIsbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsITApOiExO2Nhc2UgMTM6cmV0dXJuITE7ZGVmYXVsdDpyZXR1cm4hMX19XG5mdW5jdGlvbiBVaChhKXtpZihRaCl7dmFyIGI9UGg7aWYoYil7dmFyIGM9YjtpZighVGgoYSxiKSl7Yj1KZChjLm5leHRTaWJsaW5nKTtpZighYnx8IVRoKGEsYikpe2EuZWZmZWN0VGFnPWEuZWZmZWN0VGFnJi0xMDI1fDI7UWg9ITE7T2g9YTtyZXR1cm59UmgoT2gsYyl9T2g9YTtQaD1KZChiLmZpcnN0Q2hpbGQpfWVsc2UgYS5lZmZlY3RUYWc9YS5lZmZlY3RUYWcmLTEwMjV8MixRaD0hMSxPaD1hfX1mdW5jdGlvbiBWaChhKXtmb3IoYT1hLnJldHVybjtudWxsIT09YSYmNSE9PWEudGFnJiYzIT09YS50YWcmJjEzIT09YS50YWc7KWE9YS5yZXR1cm47T2g9YX1cbmZ1bmN0aW9uIFdoKGEpe2lmKGEhPT1PaClyZXR1cm4hMTtpZighUWgpcmV0dXJuIFZoKGEpLFFoPSEwLCExO3ZhciBiPWEudHlwZTtpZig1IT09YS50YWd8fFwiaGVhZFwiIT09YiYmXCJib2R5XCIhPT1iJiYhR2QoYixhLm1lbW9pemVkUHJvcHMpKWZvcihiPVBoO2I7KVJoKGEsYiksYj1KZChiLm5leHRTaWJsaW5nKTtWaChhKTtpZigxMz09PWEudGFnKXthPWEubWVtb2l6ZWRTdGF0ZTthPW51bGwhPT1hP2EuZGVoeWRyYXRlZDpudWxsO2lmKCFhKXRocm93IEVycm9yKHUoMzE3KSk7YTp7YT1hLm5leHRTaWJsaW5nO2ZvcihiPTA7YTspe2lmKDg9PT1hLm5vZGVUeXBlKXt2YXIgYz1hLmRhdGE7aWYoYz09PUFkKXtpZigwPT09Yil7UGg9SmQoYS5uZXh0U2libGluZyk7YnJlYWsgYX1iLS19ZWxzZSBjIT09emQmJmMhPT1DZCYmYyE9PUJkfHxiKyt9YT1hLm5leHRTaWJsaW5nfVBoPW51bGx9fWVsc2UgUGg9T2g/SmQoYS5zdGF0ZU5vZGUubmV4dFNpYmxpbmcpOm51bGw7cmV0dXJuITB9XG5mdW5jdGlvbiBYaCgpe1BoPU9oPW51bGw7UWg9ITF9dmFyIFloPVdhLlJlYWN0Q3VycmVudE93bmVyLHJnPSExO2Z1bmN0aW9uIFIoYSxiLGMsZCl7Yi5jaGlsZD1udWxsPT09YT9ZZyhiLG51bGwsYyxkKTpYZyhiLGEuY2hpbGQsYyxkKX1mdW5jdGlvbiBaaChhLGIsYyxkLGUpe2M9Yy5yZW5kZXI7dmFyIGY9Yi5yZWY7cWcoYixlKTtkPW9oKGEsYixjLGQsZixlKTtpZihudWxsIT09YSYmIXJnKXJldHVybiBiLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWUsYi5lZmZlY3RUYWcmPS01MTcsYS5leHBpcmF0aW9uVGltZTw9ZSYmKGEuZXhwaXJhdGlvblRpbWU9MCksJGgoYSxiLGUpO2IuZWZmZWN0VGFnfD0xO1IoYSxiLGQsZSk7cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiBhaShhLGIsYyxkLGUsZil7aWYobnVsbD09PWEpe3ZhciBnPWMudHlwZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZyYmIWJpKGcpJiZ2b2lkIDA9PT1nLmRlZmF1bHRQcm9wcyYmbnVsbD09PWMuY29tcGFyZSYmdm9pZCAwPT09Yy5kZWZhdWx0UHJvcHMpcmV0dXJuIGIudGFnPTE1LGIudHlwZT1nLGNpKGEsYixnLGQsZSxmKTthPVVnKGMudHlwZSxudWxsLGQsbnVsbCxiLm1vZGUsZik7YS5yZWY9Yi5yZWY7YS5yZXR1cm49YjtyZXR1cm4gYi5jaGlsZD1hfWc9YS5jaGlsZDtpZihlPGYmJihlPWcubWVtb2l6ZWRQcm9wcyxjPWMuY29tcGFyZSxjPW51bGwhPT1jP2M6YmYsYyhlLGQpJiZhLnJlZj09PWIucmVmKSlyZXR1cm4gJGgoYSxiLGYpO2IuZWZmZWN0VGFnfD0xO2E9U2coZyxkKTthLnJlZj1iLnJlZjthLnJldHVybj1iO3JldHVybiBiLmNoaWxkPWF9XG5mdW5jdGlvbiBjaShhLGIsYyxkLGUsZil7cmV0dXJuIG51bGwhPT1hJiZiZihhLm1lbW9pemVkUHJvcHMsZCkmJmEucmVmPT09Yi5yZWYmJihyZz0hMSxlPGYpPyhiLmV4cGlyYXRpb25UaW1lPWEuZXhwaXJhdGlvblRpbWUsJGgoYSxiLGYpKTpkaShhLGIsYyxkLGYpfWZ1bmN0aW9uIGVpKGEsYil7dmFyIGM9Yi5yZWY7aWYobnVsbD09PWEmJm51bGwhPT1jfHxudWxsIT09YSYmYS5yZWYhPT1jKWIuZWZmZWN0VGFnfD0xMjh9ZnVuY3Rpb24gZGkoYSxiLGMsZCxlKXt2YXIgZj1MKGMpP0JmOkouY3VycmVudDtmPUNmKGIsZik7cWcoYixlKTtjPW9oKGEsYixjLGQsZixlKTtpZihudWxsIT09YSYmIXJnKXJldHVybiBiLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWUsYi5lZmZlY3RUYWcmPS01MTcsYS5leHBpcmF0aW9uVGltZTw9ZSYmKGEuZXhwaXJhdGlvblRpbWU9MCksJGgoYSxiLGUpO2IuZWZmZWN0VGFnfD0xO1IoYSxiLGMsZSk7cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiBmaShhLGIsYyxkLGUpe2lmKEwoYykpe3ZhciBmPSEwO0dmKGIpfWVsc2UgZj0hMTtxZyhiLGUpO2lmKG51bGw9PT1iLnN0YXRlTm9kZSludWxsIT09YSYmKGEuYWx0ZXJuYXRlPW51bGwsYi5hbHRlcm5hdGU9bnVsbCxiLmVmZmVjdFRhZ3w9MiksTGcoYixjLGQpLE5nKGIsYyxkLGUpLGQ9ITA7ZWxzZSBpZihudWxsPT09YSl7dmFyIGc9Yi5zdGF0ZU5vZGUsaD1iLm1lbW9pemVkUHJvcHM7Zy5wcm9wcz1oO3ZhciBrPWcuY29udGV4dCxsPWMuY29udGV4dFR5cGU7XCJvYmplY3RcIj09PXR5cGVvZiBsJiZudWxsIT09bD9sPXNnKGwpOihsPUwoYyk/QmY6Si5jdXJyZW50LGw9Q2YoYixsKSk7dmFyIG09Yy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMscD1cImZ1bmN0aW9uXCI9PT10eXBlb2YgbXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGcuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU7cHx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJlxuXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc3x8KGghPT1kfHxrIT09bCkmJk1nKGIsZyxkLGwpO3RnPSExO3ZhciB4PWIubWVtb2l6ZWRTdGF0ZTtnLnN0YXRlPXg7emcoYixkLGcsZSk7az1iLm1lbW9pemVkU3RhdGU7aCE9PWR8fHghPT1rfHxLLmN1cnJlbnR8fHRnPyhcImZ1bmN0aW9uXCI9PT10eXBlb2YgbSYmKEZnKGIsYyxtLGQpLGs9Yi5tZW1vaXplZFN0YXRlKSwoaD10Z3x8S2coYixjLGgsZCx4LGssbCkpPyhwfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsTW91bnR8fChcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnRXaWxsTW91bnQmJmcuY29tcG9uZW50V2lsbE1vdW50KCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmZy5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCkpLFwiZnVuY3Rpb25cIj09PVxudHlwZW9mIGcuY29tcG9uZW50RGlkTW91bnQmJihiLmVmZmVjdFRhZ3w9NCkpOihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZWZmZWN0VGFnfD00KSxiLm1lbW9pemVkUHJvcHM9ZCxiLm1lbW9pemVkU3RhdGU9ayksZy5wcm9wcz1kLGcuc3RhdGU9ayxnLmNvbnRleHQ9bCxkPWgpOihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZWZmZWN0VGFnfD00KSxkPSExKX1lbHNlIGc9Yi5zdGF0ZU5vZGUsdmcoYSxiKSxoPWIubWVtb2l6ZWRQcm9wcyxnLnByb3BzPWIudHlwZT09PWIuZWxlbWVudFR5cGU/aDppZyhiLnR5cGUsaCksaz1nLmNvbnRleHQsbD1jLmNvbnRleHRUeXBlLFwib2JqZWN0XCI9PT10eXBlb2YgbCYmbnVsbCE9PWw/bD1zZyhsKToobD1MKGMpP0JmOkouY3VycmVudCxsPUNmKGIsbCkpLG09Yy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsKHA9XCJmdW5jdGlvblwiPT09dHlwZW9mIG18fFwiZnVuY3Rpb25cIj09PVxudHlwZW9mIGcuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUpfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc3x8KGghPT1kfHxrIT09bCkmJk1nKGIsZyxkLGwpLHRnPSExLGs9Yi5tZW1vaXplZFN0YXRlLGcuc3RhdGU9ayx6ZyhiLGQsZyxlKSx4PWIubWVtb2l6ZWRTdGF0ZSxoIT09ZHx8ayE9PXh8fEsuY3VycmVudHx8dGc/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBtJiYoRmcoYixjLG0sZCkseD1iLm1lbW9pemVkU3RhdGUpLChtPXRnfHxLZyhiLGMsaCxkLGsseCxsKSk/KHB8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsVXBkYXRlfHwoXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFVwZGF0ZSYmZy5jb21wb25lbnRXaWxsVXBkYXRlKGQsXG54LGwpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJiZnLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKGQseCxsKSksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlJiYoYi5lZmZlY3RUYWd8PTQpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlJiYoYi5lZmZlY3RUYWd8PTI1NikpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJms9PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9NCksXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJms9PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9MjU2KSxiLm1lbW9pemVkUHJvcHM9ZCxiLm1lbW9pemVkU3RhdGU9eCksZy5wcm9wcz1kLGcuc3RhdGU9eCxnLmNvbnRleHQ9bCxkPW0pOlxuKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmaz09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmaz09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD0yNTYpLGQ9ITEpO3JldHVybiBnaShhLGIsYyxkLGYsZSl9XG5mdW5jdGlvbiBnaShhLGIsYyxkLGUsZil7ZWkoYSxiKTt2YXIgZz0wIT09KGIuZWZmZWN0VGFnJjY0KTtpZighZCYmIWcpcmV0dXJuIGUmJkhmKGIsYywhMSksJGgoYSxiLGYpO2Q9Yi5zdGF0ZU5vZGU7WWguY3VycmVudD1iO3ZhciBoPWcmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcj9udWxsOmQucmVuZGVyKCk7Yi5lZmZlY3RUYWd8PTE7bnVsbCE9PWEmJmc/KGIuY2hpbGQ9WGcoYixhLmNoaWxkLG51bGwsZiksYi5jaGlsZD1YZyhiLG51bGwsaCxmKSk6UihhLGIsaCxmKTtiLm1lbW9pemVkU3RhdGU9ZC5zdGF0ZTtlJiZIZihiLGMsITApO3JldHVybiBiLmNoaWxkfWZ1bmN0aW9uIGhpKGEpe3ZhciBiPWEuc3RhdGVOb2RlO2IucGVuZGluZ0NvbnRleHQ/RWYoYSxiLnBlbmRpbmdDb250ZXh0LGIucGVuZGluZ0NvbnRleHQhPT1iLmNvbnRleHQpOmIuY29udGV4dCYmRWYoYSxiLmNvbnRleHQsITEpO2RoKGEsYi5jb250YWluZXJJbmZvKX1cbnZhciBpaT17ZGVoeWRyYXRlZDpudWxsLHJldHJ5VGltZTowfTtcbmZ1bmN0aW9uIGppKGEsYixjKXt2YXIgZD1iLm1vZGUsZT1iLnBlbmRpbmdQcm9wcyxmPU0uY3VycmVudCxnPSExLGg7KGg9MCE9PShiLmVmZmVjdFRhZyY2NCkpfHwoaD0wIT09KGYmMikmJihudWxsPT09YXx8bnVsbCE9PWEubWVtb2l6ZWRTdGF0ZSkpO2g/KGc9ITAsYi5lZmZlY3RUYWcmPS02NSk6bnVsbCE9PWEmJm51bGw9PT1hLm1lbW9pemVkU3RhdGV8fHZvaWQgMD09PWUuZmFsbGJhY2t8fCEwPT09ZS51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFja3x8KGZ8PTEpO0koTSxmJjEpO2lmKG51bGw9PT1hKXt2b2lkIDAhPT1lLmZhbGxiYWNrJiZVaChiKTtpZihnKXtnPWUuZmFsbGJhY2s7ZT1XZyhudWxsLGQsMCxudWxsKTtlLnJldHVybj1iO2lmKDA9PT0oYi5tb2RlJjIpKWZvcihhPW51bGwhPT1iLm1lbW9pemVkU3RhdGU/Yi5jaGlsZC5jaGlsZDpiLmNoaWxkLGUuY2hpbGQ9YTtudWxsIT09YTspYS5yZXR1cm49ZSxhPWEuc2libGluZztjPVdnKGcsZCxjLG51bGwpO2MucmV0dXJuPVxuYjtlLnNpYmxpbmc9YztiLm1lbW9pemVkU3RhdGU9aWk7Yi5jaGlsZD1lO3JldHVybiBjfWQ9ZS5jaGlsZHJlbjtiLm1lbW9pemVkU3RhdGU9bnVsbDtyZXR1cm4gYi5jaGlsZD1ZZyhiLG51bGwsZCxjKX1pZihudWxsIT09YS5tZW1vaXplZFN0YXRlKXthPWEuY2hpbGQ7ZD1hLnNpYmxpbmc7aWYoZyl7ZT1lLmZhbGxiYWNrO2M9U2coYSxhLnBlbmRpbmdQcm9wcyk7Yy5yZXR1cm49YjtpZigwPT09KGIubW9kZSYyKSYmKGc9bnVsbCE9PWIubWVtb2l6ZWRTdGF0ZT9iLmNoaWxkLmNoaWxkOmIuY2hpbGQsZyE9PWEuY2hpbGQpKWZvcihjLmNoaWxkPWc7bnVsbCE9PWc7KWcucmV0dXJuPWMsZz1nLnNpYmxpbmc7ZD1TZyhkLGUpO2QucmV0dXJuPWI7Yy5zaWJsaW5nPWQ7Yy5jaGlsZEV4cGlyYXRpb25UaW1lPTA7Yi5tZW1vaXplZFN0YXRlPWlpO2IuY2hpbGQ9YztyZXR1cm4gZH1jPVhnKGIsYS5jaGlsZCxlLmNoaWxkcmVuLGMpO2IubWVtb2l6ZWRTdGF0ZT1udWxsO3JldHVybiBiLmNoaWxkPVxuY31hPWEuY2hpbGQ7aWYoZyl7Zz1lLmZhbGxiYWNrO2U9V2cobnVsbCxkLDAsbnVsbCk7ZS5yZXR1cm49YjtlLmNoaWxkPWE7bnVsbCE9PWEmJihhLnJldHVybj1lKTtpZigwPT09KGIubW9kZSYyKSlmb3IoYT1udWxsIT09Yi5tZW1vaXplZFN0YXRlP2IuY2hpbGQuY2hpbGQ6Yi5jaGlsZCxlLmNoaWxkPWE7bnVsbCE9PWE7KWEucmV0dXJuPWUsYT1hLnNpYmxpbmc7Yz1XZyhnLGQsYyxudWxsKTtjLnJldHVybj1iO2Uuc2libGluZz1jO2MuZWZmZWN0VGFnfD0yO2UuY2hpbGRFeHBpcmF0aW9uVGltZT0wO2IubWVtb2l6ZWRTdGF0ZT1paTtiLmNoaWxkPWU7cmV0dXJuIGN9Yi5tZW1vaXplZFN0YXRlPW51bGw7cmV0dXJuIGIuY2hpbGQ9WGcoYixhLGUuY2hpbGRyZW4sYyl9XG5mdW5jdGlvbiBraShhLGIpe2EuZXhwaXJhdGlvblRpbWU8YiYmKGEuZXhwaXJhdGlvblRpbWU9Yik7dmFyIGM9YS5hbHRlcm5hdGU7bnVsbCE9PWMmJmMuZXhwaXJhdGlvblRpbWU8YiYmKGMuZXhwaXJhdGlvblRpbWU9Yik7cGcoYS5yZXR1cm4sYil9ZnVuY3Rpb24gbGkoYSxiLGMsZCxlLGYpe3ZhciBnPWEubWVtb2l6ZWRTdGF0ZTtudWxsPT09Zz9hLm1lbW9pemVkU3RhdGU9e2lzQmFja3dhcmRzOmIscmVuZGVyaW5nOm51bGwscmVuZGVyaW5nU3RhcnRUaW1lOjAsbGFzdDpkLHRhaWw6Yyx0YWlsRXhwaXJhdGlvbjowLHRhaWxNb2RlOmUsbGFzdEVmZmVjdDpmfTooZy5pc0JhY2t3YXJkcz1iLGcucmVuZGVyaW5nPW51bGwsZy5yZW5kZXJpbmdTdGFydFRpbWU9MCxnLmxhc3Q9ZCxnLnRhaWw9YyxnLnRhaWxFeHBpcmF0aW9uPTAsZy50YWlsTW9kZT1lLGcubGFzdEVmZmVjdD1mKX1cbmZ1bmN0aW9uIG1pKGEsYixjKXt2YXIgZD1iLnBlbmRpbmdQcm9wcyxlPWQucmV2ZWFsT3JkZXIsZj1kLnRhaWw7UihhLGIsZC5jaGlsZHJlbixjKTtkPU0uY3VycmVudDtpZigwIT09KGQmMikpZD1kJjF8MixiLmVmZmVjdFRhZ3w9NjQ7ZWxzZXtpZihudWxsIT09YSYmMCE9PShhLmVmZmVjdFRhZyY2NCkpYTpmb3IoYT1iLmNoaWxkO251bGwhPT1hOyl7aWYoMTM9PT1hLnRhZyludWxsIT09YS5tZW1vaXplZFN0YXRlJiZraShhLGMpO2Vsc2UgaWYoMTk9PT1hLnRhZylraShhLGMpO2Vsc2UgaWYobnVsbCE9PWEuY2hpbGQpe2EuY2hpbGQucmV0dXJuPWE7YT1hLmNoaWxkO2NvbnRpbnVlfWlmKGE9PT1iKWJyZWFrIGE7Zm9yKDtudWxsPT09YS5zaWJsaW5nOyl7aWYobnVsbD09PWEucmV0dXJufHxhLnJldHVybj09PWIpYnJlYWsgYTthPWEucmV0dXJufWEuc2libGluZy5yZXR1cm49YS5yZXR1cm47YT1hLnNpYmxpbmd9ZCY9MX1JKE0sZCk7aWYoMD09PShiLm1vZGUmMikpYi5tZW1vaXplZFN0YXRlPVxubnVsbDtlbHNlIHN3aXRjaChlKXtjYXNlIFwiZm9yd2FyZHNcIjpjPWIuY2hpbGQ7Zm9yKGU9bnVsbDtudWxsIT09YzspYT1jLmFsdGVybmF0ZSxudWxsIT09YSYmbnVsbD09PWhoKGEpJiYoZT1jKSxjPWMuc2libGluZztjPWU7bnVsbD09PWM/KGU9Yi5jaGlsZCxiLmNoaWxkPW51bGwpOihlPWMuc2libGluZyxjLnNpYmxpbmc9bnVsbCk7bGkoYiwhMSxlLGMsZixiLmxhc3RFZmZlY3QpO2JyZWFrO2Nhc2UgXCJiYWNrd2FyZHNcIjpjPW51bGw7ZT1iLmNoaWxkO2ZvcihiLmNoaWxkPW51bGw7bnVsbCE9PWU7KXthPWUuYWx0ZXJuYXRlO2lmKG51bGwhPT1hJiZudWxsPT09aGgoYSkpe2IuY2hpbGQ9ZTticmVha31hPWUuc2libGluZztlLnNpYmxpbmc9YztjPWU7ZT1hfWxpKGIsITAsYyxudWxsLGYsYi5sYXN0RWZmZWN0KTticmVhaztjYXNlIFwidG9nZXRoZXJcIjpsaShiLCExLG51bGwsbnVsbCx2b2lkIDAsYi5sYXN0RWZmZWN0KTticmVhaztkZWZhdWx0OmIubWVtb2l6ZWRTdGF0ZT1udWxsfXJldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gJGgoYSxiLGMpe251bGwhPT1hJiYoYi5kZXBlbmRlbmNpZXM9YS5kZXBlbmRlbmNpZXMpO3ZhciBkPWIuZXhwaXJhdGlvblRpbWU7MCE9PWQmJkJnKGQpO2lmKGIuY2hpbGRFeHBpcmF0aW9uVGltZTxjKXJldHVybiBudWxsO2lmKG51bGwhPT1hJiZiLmNoaWxkIT09YS5jaGlsZCl0aHJvdyBFcnJvcih1KDE1MykpO2lmKG51bGwhPT1iLmNoaWxkKXthPWIuY2hpbGQ7Yz1TZyhhLGEucGVuZGluZ1Byb3BzKTtiLmNoaWxkPWM7Zm9yKGMucmV0dXJuPWI7bnVsbCE9PWEuc2libGluZzspYT1hLnNpYmxpbmcsYz1jLnNpYmxpbmc9U2coYSxhLnBlbmRpbmdQcm9wcyksYy5yZXR1cm49YjtjLnNpYmxpbmc9bnVsbH1yZXR1cm4gYi5jaGlsZH12YXIgbmksb2kscGkscWk7XG5uaT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1iLmNoaWxkO251bGwhPT1jOyl7aWYoNT09PWMudGFnfHw2PT09Yy50YWcpYS5hcHBlbmRDaGlsZChjLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09Yy50YWcmJm51bGwhPT1jLmNoaWxkKXtjLmNoaWxkLnJldHVybj1jO2M9Yy5jaGlsZDtjb250aW51ZX1pZihjPT09YilicmVhaztmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGMucmV0dXJuPT09YilyZXR1cm47Yz1jLnJldHVybn1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2M9Yy5zaWJsaW5nfX07b2k9ZnVuY3Rpb24oKXt9O1xucGk9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1hLm1lbW9pemVkUHJvcHM7aWYoZiE9PWQpe3ZhciBnPWIuc3RhdGVOb2RlO2NoKCRnLmN1cnJlbnQpO2E9bnVsbDtzd2l0Y2goYyl7Y2FzZSBcImlucHV0XCI6Zj16YihnLGYpO2Q9emIoZyxkKTthPVtdO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpmPUdiKGcsZik7ZD1HYihnLGQpO2E9W107YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmY9bih7fSxmLHt2YWx1ZTp2b2lkIDB9KTtkPW4oe30sZCx7dmFsdWU6dm9pZCAwfSk7YT1bXTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpmPUliKGcsZik7ZD1JYihnLGQpO2E9W107YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCIhPT10eXBlb2YgZi5vbkNsaWNrJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5vbkNsaWNrJiYoZy5vbmNsaWNrPXNkKX1vZChjLGQpO3ZhciBoLGs7Yz1udWxsO2ZvcihoIGluIGYpaWYoIWQuaGFzT3duUHJvcGVydHkoaCkmJmYuaGFzT3duUHJvcGVydHkoaCkmJm51bGwhPWZbaF0paWYoXCJzdHlsZVwiPT09XG5oKWZvcihrIGluIGc9ZltoXSxnKWcuaGFzT3duUHJvcGVydHkoaykmJihjfHwoYz17fSksY1trXT1cIlwiKTtlbHNlXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiIT09aCYmXCJjaGlsZHJlblwiIT09aCYmXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWgmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1oJiZcImF1dG9Gb2N1c1wiIT09aCYmKHZhLmhhc093blByb3BlcnR5KGgpP2F8fChhPVtdKTooYT1hfHxbXSkucHVzaChoLG51bGwpKTtmb3IoaCBpbiBkKXt2YXIgbD1kW2hdO2c9bnVsbCE9Zj9mW2hdOnZvaWQgMDtpZihkLmhhc093blByb3BlcnR5KGgpJiZsIT09ZyYmKG51bGwhPWx8fG51bGwhPWcpKWlmKFwic3R5bGVcIj09PWgpaWYoZyl7Zm9yKGsgaW4gZykhZy5oYXNPd25Qcm9wZXJ0eShrKXx8bCYmbC5oYXNPd25Qcm9wZXJ0eShrKXx8KGN8fChjPXt9KSxjW2tdPVwiXCIpO2ZvcihrIGluIGwpbC5oYXNPd25Qcm9wZXJ0eShrKSYmZ1trXSE9PWxba10mJihjfHwoYz17fSksXG5jW2tdPWxba10pfWVsc2UgY3x8KGF8fChhPVtdKSxhLnB1c2goaCxjKSksYz1sO2Vsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1oPyhsPWw/bC5fX2h0bWw6dm9pZCAwLGc9Zz9nLl9faHRtbDp2b2lkIDAsbnVsbCE9bCYmZyE9PWwmJihhPWF8fFtdKS5wdXNoKGgsbCkpOlwiY2hpbGRyZW5cIj09PWg/Zz09PWx8fFwic3RyaW5nXCIhPT10eXBlb2YgbCYmXCJudW1iZXJcIiE9PXR5cGVvZiBsfHwoYT1hfHxbXSkucHVzaChoLFwiXCIrbCk6XCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWgmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1oJiYodmEuaGFzT3duUHJvcGVydHkoaCk/KG51bGwhPWwmJnJkKGUsaCksYXx8Zz09PWx8fChhPVtdKSk6KGE9YXx8W10pLnB1c2goaCxsKSl9YyYmKGE9YXx8W10pLnB1c2goXCJzdHlsZVwiLGMpO2U9YTtpZihiLnVwZGF0ZVF1ZXVlPWUpYi5lZmZlY3RUYWd8PTR9fTtcbnFpPWZ1bmN0aW9uKGEsYixjLGQpe2MhPT1kJiYoYi5lZmZlY3RUYWd8PTQpfTtmdW5jdGlvbiByaShhLGIpe3N3aXRjaChhLnRhaWxNb2RlKXtjYXNlIFwiaGlkZGVuXCI6Yj1hLnRhaWw7Zm9yKHZhciBjPW51bGw7bnVsbCE9PWI7KW51bGwhPT1iLmFsdGVybmF0ZSYmKGM9YiksYj1iLnNpYmxpbmc7bnVsbD09PWM/YS50YWlsPW51bGw6Yy5zaWJsaW5nPW51bGw7YnJlYWs7Y2FzZSBcImNvbGxhcHNlZFwiOmM9YS50YWlsO2Zvcih2YXIgZD1udWxsO251bGwhPT1jOyludWxsIT09Yy5hbHRlcm5hdGUmJihkPWMpLGM9Yy5zaWJsaW5nO251bGw9PT1kP2J8fG51bGw9PT1hLnRhaWw/YS50YWlsPW51bGw6YS50YWlsLnNpYmxpbmc9bnVsbDpkLnNpYmxpbmc9bnVsbH19XG5mdW5jdGlvbiBzaShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHM7c3dpdGNoKGIudGFnKXtjYXNlIDI6Y2FzZSAxNjpjYXNlIDE1OmNhc2UgMDpjYXNlIDExOmNhc2UgNzpjYXNlIDg6Y2FzZSAxMjpjYXNlIDk6Y2FzZSAxNDpyZXR1cm4gbnVsbDtjYXNlIDE6cmV0dXJuIEwoYi50eXBlKSYmRGYoKSxudWxsO2Nhc2UgMzpyZXR1cm4gZWgoKSxIKEspLEgoSiksYz1iLnN0YXRlTm9kZSxjLnBlbmRpbmdDb250ZXh0JiYoYy5jb250ZXh0PWMucGVuZGluZ0NvbnRleHQsYy5wZW5kaW5nQ29udGV4dD1udWxsKSxudWxsIT09YSYmbnVsbCE9PWEuY2hpbGR8fCFXaChiKXx8KGIuZWZmZWN0VGFnfD00KSxvaShiKSxudWxsO2Nhc2UgNTpnaChiKTtjPWNoKGJoLmN1cnJlbnQpO3ZhciBlPWIudHlwZTtpZihudWxsIT09YSYmbnVsbCE9Yi5zdGF0ZU5vZGUpcGkoYSxiLGUsZCxjKSxhLnJlZiE9PWIucmVmJiYoYi5lZmZlY3RUYWd8PTEyOCk7ZWxzZXtpZighZCl7aWYobnVsbD09PWIuc3RhdGVOb2RlKXRocm93IEVycm9yKHUoMTY2KSk7XG5yZXR1cm4gbnVsbH1hPWNoKCRnLmN1cnJlbnQpO2lmKFdoKGIpKXtkPWIuc3RhdGVOb2RlO2U9Yi50eXBlO3ZhciBmPWIubWVtb2l6ZWRQcm9wcztkW01kXT1iO2RbTmRdPWY7c3dpdGNoKGUpe2Nhc2UgXCJpZnJhbWVcIjpjYXNlIFwib2JqZWN0XCI6Y2FzZSBcImVtYmVkXCI6RihcImxvYWRcIixkKTticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IoYT0wO2E8YWMubGVuZ3RoO2ErKylGKGFjW2FdLGQpO2JyZWFrO2Nhc2UgXCJzb3VyY2VcIjpGKFwiZXJyb3JcIixkKTticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6Y2FzZSBcImxpbmtcIjpGKFwiZXJyb3JcIixkKTtGKFwibG9hZFwiLGQpO2JyZWFrO2Nhc2UgXCJmb3JtXCI6RihcInJlc2V0XCIsZCk7RihcInN1Ym1pdFwiLGQpO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6RihcInRvZ2dsZVwiLGQpO2JyZWFrO2Nhc2UgXCJpbnB1dFwiOkFiKGQsZik7RihcImludmFsaWRcIixkKTtyZChjLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmQuX3dyYXBwZXJTdGF0ZT1cbnt3YXNNdWx0aXBsZTohIWYubXVsdGlwbGV9O0YoXCJpbnZhbGlkXCIsZCk7cmQoYyxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOkpiKGQsZiksRihcImludmFsaWRcIixkKSxyZChjLFwib25DaGFuZ2VcIil9b2QoZSxmKTthPW51bGw7Zm9yKHZhciBnIGluIGYpaWYoZi5oYXNPd25Qcm9wZXJ0eShnKSl7dmFyIGg9ZltnXTtcImNoaWxkcmVuXCI9PT1nP1wic3RyaW5nXCI9PT10eXBlb2YgaD9kLnRleHRDb250ZW50IT09aCYmKGE9W1wiY2hpbGRyZW5cIixoXSk6XCJudW1iZXJcIj09PXR5cGVvZiBoJiZkLnRleHRDb250ZW50IT09XCJcIitoJiYoYT1bXCJjaGlsZHJlblwiLFwiXCIraF0pOnZhLmhhc093blByb3BlcnR5KGcpJiZudWxsIT1oJiZyZChjLGcpfXN3aXRjaChlKXtjYXNlIFwiaW5wdXRcIjp4YihkKTtFYihkLGYsITApO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOnhiKGQpO0xiKGQpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpjYXNlIFwib3B0aW9uXCI6YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCI9PT10eXBlb2YgZi5vbkNsaWNrJiZcbihkLm9uY2xpY2s9c2QpfWM9YTtiLnVwZGF0ZVF1ZXVlPWM7bnVsbCE9PWMmJihiLmVmZmVjdFRhZ3w9NCl9ZWxzZXtnPTk9PT1jLm5vZGVUeXBlP2M6Yy5vd25lckRvY3VtZW50O2E9PT1xZCYmKGE9TmIoZSkpO2E9PT1xZD9cInNjcmlwdFwiPT09ZT8oYT1nLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksYS5pbm5lckhUTUw9XCI8c2NyaXB0PlxceDNjL3NjcmlwdD5cIixhPWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKSk6XCJzdHJpbmdcIj09PXR5cGVvZiBkLmlzP2E9Zy5jcmVhdGVFbGVtZW50KGUse2lzOmQuaXN9KTooYT1nLmNyZWF0ZUVsZW1lbnQoZSksXCJzZWxlY3RcIj09PWUmJihnPWEsZC5tdWx0aXBsZT9nLm11bHRpcGxlPSEwOmQuc2l6ZSYmKGcuc2l6ZT1kLnNpemUpKSk6YT1nLmNyZWF0ZUVsZW1lbnROUyhhLGUpO2FbTWRdPWI7YVtOZF09ZDtuaShhLGIsITEsITEpO2Iuc3RhdGVOb2RlPWE7Zz1wZChlLGQpO3N3aXRjaChlKXtjYXNlIFwiaWZyYW1lXCI6Y2FzZSBcIm9iamVjdFwiOmNhc2UgXCJlbWJlZFwiOkYoXCJsb2FkXCIsXG5hKTtoPWQ7YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKGg9MDtoPGFjLmxlbmd0aDtoKyspRihhY1toXSxhKTtoPWQ7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOkYoXCJlcnJvclwiLGEpO2g9ZDticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6Y2FzZSBcImxpbmtcIjpGKFwiZXJyb3JcIixhKTtGKFwibG9hZFwiLGEpO2g9ZDticmVhaztjYXNlIFwiZm9ybVwiOkYoXCJyZXNldFwiLGEpO0YoXCJzdWJtaXRcIixhKTtoPWQ7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpGKFwidG9nZ2xlXCIsYSk7aD1kO2JyZWFrO2Nhc2UgXCJpbnB1dFwiOkFiKGEsZCk7aD16YihhLGQpO0YoXCJpbnZhbGlkXCIsYSk7cmQoYyxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpoPUdiKGEsZCk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmEuX3dyYXBwZXJTdGF0ZT17d2FzTXVsdGlwbGU6ISFkLm11bHRpcGxlfTtoPW4oe30sZCx7dmFsdWU6dm9pZCAwfSk7RihcImludmFsaWRcIixhKTtyZChjLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6SmIoYSxcbmQpO2g9SWIoYSxkKTtGKFwiaW52YWxpZFwiLGEpO3JkKGMsXCJvbkNoYW5nZVwiKTticmVhaztkZWZhdWx0Omg9ZH1vZChlLGgpO3ZhciBrPWg7Zm9yKGYgaW4gaylpZihrLmhhc093blByb3BlcnR5KGYpKXt2YXIgbD1rW2ZdO1wic3R5bGVcIj09PWY/bWQoYSxsKTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1mPyhsPWw/bC5fX2h0bWw6dm9pZCAwLG51bGwhPWwmJlFiKGEsbCkpOlwiY2hpbGRyZW5cIj09PWY/XCJzdHJpbmdcIj09PXR5cGVvZiBsPyhcInRleHRhcmVhXCIhPT1lfHxcIlwiIT09bCkmJlJiKGEsbCk6XCJudW1iZXJcIj09PXR5cGVvZiBsJiZSYihhLFwiXCIrbCk6XCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWYmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1mJiZcImF1dG9Gb2N1c1wiIT09ZiYmKHZhLmhhc093blByb3BlcnR5KGYpP251bGwhPWwmJnJkKGMsZik6bnVsbCE9bCYmWGEoYSxmLGwsZykpfXN3aXRjaChlKXtjYXNlIFwiaW5wdXRcIjp4YihhKTtFYihhLGQsITEpO1xuYnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6eGIoYSk7TGIoYSk7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOm51bGwhPWQudmFsdWUmJmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK3JiKGQudmFsdWUpKTticmVhaztjYXNlIFwic2VsZWN0XCI6YS5tdWx0aXBsZT0hIWQubXVsdGlwbGU7Yz1kLnZhbHVlO251bGwhPWM/SGIoYSwhIWQubXVsdGlwbGUsYywhMSk6bnVsbCE9ZC5kZWZhdWx0VmFsdWUmJkhiKGEsISFkLm11bHRpcGxlLGQuZGVmYXVsdFZhbHVlLCEwKTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBoLm9uQ2xpY2smJihhLm9uY2xpY2s9c2QpfUZkKGUsZCkmJihiLmVmZmVjdFRhZ3w9NCl9bnVsbCE9PWIucmVmJiYoYi5lZmZlY3RUYWd8PTEyOCl9cmV0dXJuIG51bGw7Y2FzZSA2OmlmKGEmJm51bGwhPWIuc3RhdGVOb2RlKXFpKGEsYixhLm1lbW9pemVkUHJvcHMsZCk7ZWxzZXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGQmJm51bGw9PT1iLnN0YXRlTm9kZSl0aHJvdyBFcnJvcih1KDE2NikpO1xuYz1jaChiaC5jdXJyZW50KTtjaCgkZy5jdXJyZW50KTtXaChiKT8oYz1iLnN0YXRlTm9kZSxkPWIubWVtb2l6ZWRQcm9wcyxjW01kXT1iLGMubm9kZVZhbHVlIT09ZCYmKGIuZWZmZWN0VGFnfD00KSk6KGM9KDk9PT1jLm5vZGVUeXBlP2M6Yy5vd25lckRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZShkKSxjW01kXT1iLGIuc3RhdGVOb2RlPWMpfXJldHVybiBudWxsO2Nhc2UgMTM6SChNKTtkPWIubWVtb2l6ZWRTdGF0ZTtpZigwIT09KGIuZWZmZWN0VGFnJjY0KSlyZXR1cm4gYi5leHBpcmF0aW9uVGltZT1jLGI7Yz1udWxsIT09ZDtkPSExO251bGw9PT1hP3ZvaWQgMCE9PWIubWVtb2l6ZWRQcm9wcy5mYWxsYmFjayYmV2goYik6KGU9YS5tZW1vaXplZFN0YXRlLGQ9bnVsbCE9PWUsY3x8bnVsbD09PWV8fChlPWEuY2hpbGQuc2libGluZyxudWxsIT09ZSYmKGY9Yi5maXJzdEVmZmVjdCxudWxsIT09Zj8oYi5maXJzdEVmZmVjdD1lLGUubmV4dEVmZmVjdD1mKTooYi5maXJzdEVmZmVjdD1iLmxhc3RFZmZlY3Q9XG5lLGUubmV4dEVmZmVjdD1udWxsKSxlLmVmZmVjdFRhZz04KSkpO2lmKGMmJiFkJiYwIT09KGIubW9kZSYyKSlpZihudWxsPT09YSYmITAhPT1iLm1lbW9pemVkUHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2t8fDAhPT0oTS5jdXJyZW50JjEpKVM9PT10aSYmKFM9dWkpO2Vsc2V7aWYoUz09PXRpfHxTPT09dWkpUz12aTswIT09d2kmJm51bGwhPT1UJiYoeGkoVCxVKSx5aShULHdpKSl9aWYoY3x8ZCliLmVmZmVjdFRhZ3w9NDtyZXR1cm4gbnVsbDtjYXNlIDQ6cmV0dXJuIGVoKCksb2koYiksbnVsbDtjYXNlIDEwOnJldHVybiBvZyhiKSxudWxsO2Nhc2UgMTc6cmV0dXJuIEwoYi50eXBlKSYmRGYoKSxudWxsO2Nhc2UgMTk6SChNKTtkPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsPT09ZClyZXR1cm4gbnVsbDtlPTAhPT0oYi5lZmZlY3RUYWcmNjQpO2Y9ZC5yZW5kZXJpbmc7aWYobnVsbD09PWYpaWYoZSlyaShkLCExKTtlbHNle2lmKFMhPT10aXx8bnVsbCE9PWEmJjAhPT0oYS5lZmZlY3RUYWcmXG42NCkpZm9yKGY9Yi5jaGlsZDtudWxsIT09Zjspe2E9aGgoZik7aWYobnVsbCE9PWEpe2IuZWZmZWN0VGFnfD02NDtyaShkLCExKTtlPWEudXBkYXRlUXVldWU7bnVsbCE9PWUmJihiLnVwZGF0ZVF1ZXVlPWUsYi5lZmZlY3RUYWd8PTQpO251bGw9PT1kLmxhc3RFZmZlY3QmJihiLmZpcnN0RWZmZWN0PW51bGwpO2IubGFzdEVmZmVjdD1kLmxhc3RFZmZlY3Q7Zm9yKGQ9Yi5jaGlsZDtudWxsIT09ZDspZT1kLGY9YyxlLmVmZmVjdFRhZyY9MixlLm5leHRFZmZlY3Q9bnVsbCxlLmZpcnN0RWZmZWN0PW51bGwsZS5sYXN0RWZmZWN0PW51bGwsYT1lLmFsdGVybmF0ZSxudWxsPT09YT8oZS5jaGlsZEV4cGlyYXRpb25UaW1lPTAsZS5leHBpcmF0aW9uVGltZT1mLGUuY2hpbGQ9bnVsbCxlLm1lbW9pemVkUHJvcHM9bnVsbCxlLm1lbW9pemVkU3RhdGU9bnVsbCxlLnVwZGF0ZVF1ZXVlPW51bGwsZS5kZXBlbmRlbmNpZXM9bnVsbCk6KGUuY2hpbGRFeHBpcmF0aW9uVGltZT1hLmNoaWxkRXhwaXJhdGlvblRpbWUsXG5lLmV4cGlyYXRpb25UaW1lPWEuZXhwaXJhdGlvblRpbWUsZS5jaGlsZD1hLmNoaWxkLGUubWVtb2l6ZWRQcm9wcz1hLm1lbW9pemVkUHJvcHMsZS5tZW1vaXplZFN0YXRlPWEubWVtb2l6ZWRTdGF0ZSxlLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWUsZj1hLmRlcGVuZGVuY2llcyxlLmRlcGVuZGVuY2llcz1udWxsPT09Zj9udWxsOntleHBpcmF0aW9uVGltZTpmLmV4cGlyYXRpb25UaW1lLGZpcnN0Q29udGV4dDpmLmZpcnN0Q29udGV4dCxyZXNwb25kZXJzOmYucmVzcG9uZGVyc30pLGQ9ZC5zaWJsaW5nO0koTSxNLmN1cnJlbnQmMXwyKTtyZXR1cm4gYi5jaGlsZH1mPWYuc2libGluZ319ZWxzZXtpZighZSlpZihhPWhoKGYpLG51bGwhPT1hKXtpZihiLmVmZmVjdFRhZ3w9NjQsZT0hMCxjPWEudXBkYXRlUXVldWUsbnVsbCE9PWMmJihiLnVwZGF0ZVF1ZXVlPWMsYi5lZmZlY3RUYWd8PTQpLHJpKGQsITApLG51bGw9PT1kLnRhaWwmJlwiaGlkZGVuXCI9PT1kLnRhaWxNb2RlJiYhZi5hbHRlcm5hdGUpcmV0dXJuIGI9XG5iLmxhc3RFZmZlY3Q9ZC5sYXN0RWZmZWN0LG51bGwhPT1iJiYoYi5uZXh0RWZmZWN0PW51bGwpLG51bGx9ZWxzZSAyKiRmKCktZC5yZW5kZXJpbmdTdGFydFRpbWU+ZC50YWlsRXhwaXJhdGlvbiYmMTxjJiYoYi5lZmZlY3RUYWd8PTY0LGU9ITAscmkoZCwhMSksYi5leHBpcmF0aW9uVGltZT1iLmNoaWxkRXhwaXJhdGlvblRpbWU9Yy0xKTtkLmlzQmFja3dhcmRzPyhmLnNpYmxpbmc9Yi5jaGlsZCxiLmNoaWxkPWYpOihjPWQubGFzdCxudWxsIT09Yz9jLnNpYmxpbmc9ZjpiLmNoaWxkPWYsZC5sYXN0PWYpfXJldHVybiBudWxsIT09ZC50YWlsPygwPT09ZC50YWlsRXhwaXJhdGlvbiYmKGQudGFpbEV4cGlyYXRpb249JGYoKSs1MDApLGM9ZC50YWlsLGQucmVuZGVyaW5nPWMsZC50YWlsPWMuc2libGluZyxkLmxhc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0LGQucmVuZGVyaW5nU3RhcnRUaW1lPSRmKCksYy5zaWJsaW5nPW51bGwsYj1NLmN1cnJlbnQsSShNLGU/YiYxfDI6YiYxKSxjKTpudWxsfXRocm93IEVycm9yKHUoMTU2LFxuYi50YWcpKTt9ZnVuY3Rpb24gemkoYSl7c3dpdGNoKGEudGFnKXtjYXNlIDE6TChhLnR5cGUpJiZEZigpO3ZhciBiPWEuZWZmZWN0VGFnO3JldHVybiBiJjQwOTY/KGEuZWZmZWN0VGFnPWImLTQwOTd8NjQsYSk6bnVsbDtjYXNlIDM6ZWgoKTtIKEspO0goSik7Yj1hLmVmZmVjdFRhZztpZigwIT09KGImNjQpKXRocm93IEVycm9yKHUoMjg1KSk7YS5lZmZlY3RUYWc9YiYtNDA5N3w2NDtyZXR1cm4gYTtjYXNlIDU6cmV0dXJuIGdoKGEpLG51bGw7Y2FzZSAxMzpyZXR1cm4gSChNKSxiPWEuZWZmZWN0VGFnLGImNDA5Nj8oYS5lZmZlY3RUYWc9YiYtNDA5N3w2NCxhKTpudWxsO2Nhc2UgMTk6cmV0dXJuIEgoTSksbnVsbDtjYXNlIDQ6cmV0dXJuIGVoKCksbnVsbDtjYXNlIDEwOnJldHVybiBvZyhhKSxudWxsO2RlZmF1bHQ6cmV0dXJuIG51bGx9fWZ1bmN0aW9uIEFpKGEsYil7cmV0dXJue3ZhbHVlOmEsc291cmNlOmIsc3RhY2s6cWIoYil9fVxudmFyIEJpPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBXZWFrU2V0P1dlYWtTZXQ6U2V0O2Z1bmN0aW9uIENpKGEsYil7dmFyIGM9Yi5zb3VyY2UsZD1iLnN0YWNrO251bGw9PT1kJiZudWxsIT09YyYmKGQ9cWIoYykpO251bGwhPT1jJiZwYihjLnR5cGUpO2I9Yi52YWx1ZTtudWxsIT09YSYmMT09PWEudGFnJiZwYihhLnR5cGUpO3RyeXtjb25zb2xlLmVycm9yKGIpfWNhdGNoKGUpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlO30pfX1mdW5jdGlvbiBEaShhLGIpe3RyeXtiLnByb3BzPWEubWVtb2l6ZWRQcm9wcyxiLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZSxiLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2goYyl7RWkoYSxjKX19ZnVuY3Rpb24gRmkoYSl7dmFyIGI9YS5yZWY7aWYobnVsbCE9PWIpaWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGIpdHJ5e2IobnVsbCl9Y2F0Y2goYyl7RWkoYSxjKX1lbHNlIGIuY3VycmVudD1udWxsfVxuZnVuY3Rpb24gR2koYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6Y2FzZSAyMjpyZXR1cm47Y2FzZSAxOmlmKGIuZWZmZWN0VGFnJjI1NiYmbnVsbCE9PWEpe3ZhciBjPWEubWVtb2l6ZWRQcm9wcyxkPWEubWVtb2l6ZWRTdGF0ZTthPWIuc3RhdGVOb2RlO2I9YS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShiLmVsZW1lbnRUeXBlPT09Yi50eXBlP2M6aWcoYi50eXBlLGMpLGQpO2EuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGU9Yn1yZXR1cm47Y2FzZSAzOmNhc2UgNTpjYXNlIDY6Y2FzZSA0OmNhc2UgMTc6cmV0dXJufXRocm93IEVycm9yKHUoMTYzKSk7fVxuZnVuY3Rpb24gSGkoYSxiKXtiPWIudXBkYXRlUXVldWU7Yj1udWxsIT09Yj9iLmxhc3RFZmZlY3Q6bnVsbDtpZihudWxsIT09Yil7dmFyIGM9Yj1iLm5leHQ7ZG97aWYoKGMudGFnJmEpPT09YSl7dmFyIGQ9Yy5kZXN0cm95O2MuZGVzdHJveT12b2lkIDA7dm9pZCAwIT09ZCYmZCgpfWM9Yy5uZXh0fXdoaWxlKGMhPT1iKX19ZnVuY3Rpb24gSWkoYSxiKXtiPWIudXBkYXRlUXVldWU7Yj1udWxsIT09Yj9iLmxhc3RFZmZlY3Q6bnVsbDtpZihudWxsIT09Yil7dmFyIGM9Yj1iLm5leHQ7ZG97aWYoKGMudGFnJmEpPT09YSl7dmFyIGQ9Yy5jcmVhdGU7Yy5kZXN0cm95PWQoKX1jPWMubmV4dH13aGlsZShjIT09Yil9fVxuZnVuY3Rpb24gSmkoYSxiLGMpe3N3aXRjaChjLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpjYXNlIDIyOklpKDMsYyk7cmV0dXJuO2Nhc2UgMTphPWMuc3RhdGVOb2RlO2lmKGMuZWZmZWN0VGFnJjQpaWYobnVsbD09PWIpYS5jb21wb25lbnREaWRNb3VudCgpO2Vsc2V7dmFyIGQ9Yy5lbGVtZW50VHlwZT09PWMudHlwZT9iLm1lbW9pemVkUHJvcHM6aWcoYy50eXBlLGIubWVtb2l6ZWRQcm9wcyk7YS5jb21wb25lbnREaWRVcGRhdGUoZCxiLm1lbW9pemVkU3RhdGUsYS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSl9Yj1jLnVwZGF0ZVF1ZXVlO251bGwhPT1iJiZDZyhjLGIsYSk7cmV0dXJuO2Nhc2UgMzpiPWMudXBkYXRlUXVldWU7aWYobnVsbCE9PWIpe2E9bnVsbDtpZihudWxsIT09Yy5jaGlsZClzd2l0Y2goYy5jaGlsZC50YWcpe2Nhc2UgNTphPWMuY2hpbGQuc3RhdGVOb2RlO2JyZWFrO2Nhc2UgMTphPWMuY2hpbGQuc3RhdGVOb2RlfUNnKGMsYixhKX1yZXR1cm47XG5jYXNlIDU6YT1jLnN0YXRlTm9kZTtudWxsPT09YiYmYy5lZmZlY3RUYWcmNCYmRmQoYy50eXBlLGMubWVtb2l6ZWRQcm9wcykmJmEuZm9jdXMoKTtyZXR1cm47Y2FzZSA2OnJldHVybjtjYXNlIDQ6cmV0dXJuO2Nhc2UgMTI6cmV0dXJuO2Nhc2UgMTM6bnVsbD09PWMubWVtb2l6ZWRTdGF0ZSYmKGM9Yy5hbHRlcm5hdGUsbnVsbCE9PWMmJihjPWMubWVtb2l6ZWRTdGF0ZSxudWxsIT09YyYmKGM9Yy5kZWh5ZHJhdGVkLG51bGwhPT1jJiZWYyhjKSkpKTtyZXR1cm47Y2FzZSAxOTpjYXNlIDE3OmNhc2UgMjA6Y2FzZSAyMTpyZXR1cm59dGhyb3cgRXJyb3IodSgxNjMpKTt9XG5mdW5jdGlvbiBLaShhLGIsYyl7XCJmdW5jdGlvblwiPT09dHlwZW9mIExpJiZMaShiKTtzd2l0Y2goYi50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTQ6Y2FzZSAxNTpjYXNlIDIyOmE9Yi51cGRhdGVRdWV1ZTtpZihudWxsIT09YSYmKGE9YS5sYXN0RWZmZWN0LG51bGwhPT1hKSl7dmFyIGQ9YS5uZXh0O2NnKDk3PGM/OTc6YyxmdW5jdGlvbigpe3ZhciBhPWQ7ZG97dmFyIGM9YS5kZXN0cm95O2lmKHZvaWQgMCE9PWMpe3ZhciBnPWI7dHJ5e2MoKX1jYXRjaChoKXtFaShnLGgpfX1hPWEubmV4dH13aGlsZShhIT09ZCl9KX1icmVhaztjYXNlIDE6RmkoYik7Yz1iLnN0YXRlTm9kZTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5jb21wb25lbnRXaWxsVW5tb3VudCYmRGkoYixjKTticmVhaztjYXNlIDU6RmkoYik7YnJlYWs7Y2FzZSA0Ok1pKGEsYixjKX19XG5mdW5jdGlvbiBOaShhKXt2YXIgYj1hLmFsdGVybmF0ZTthLnJldHVybj1udWxsO2EuY2hpbGQ9bnVsbDthLm1lbW9pemVkU3RhdGU9bnVsbDthLnVwZGF0ZVF1ZXVlPW51bGw7YS5kZXBlbmRlbmNpZXM9bnVsbDthLmFsdGVybmF0ZT1udWxsO2EuZmlyc3RFZmZlY3Q9bnVsbDthLmxhc3RFZmZlY3Q9bnVsbDthLnBlbmRpbmdQcm9wcz1udWxsO2EubWVtb2l6ZWRQcm9wcz1udWxsO2Euc3RhdGVOb2RlPW51bGw7bnVsbCE9PWImJk5pKGIpfWZ1bmN0aW9uIE9pKGEpe3JldHVybiA1PT09YS50YWd8fDM9PT1hLnRhZ3x8ND09PWEudGFnfVxuZnVuY3Rpb24gUGkoYSl7YTp7Zm9yKHZhciBiPWEucmV0dXJuO251bGwhPT1iOyl7aWYoT2koYikpe3ZhciBjPWI7YnJlYWsgYX1iPWIucmV0dXJufXRocm93IEVycm9yKHUoMTYwKSk7fWI9Yy5zdGF0ZU5vZGU7c3dpdGNoKGMudGFnKXtjYXNlIDU6dmFyIGQ9ITE7YnJlYWs7Y2FzZSAzOmI9Yi5jb250YWluZXJJbmZvO2Q9ITA7YnJlYWs7Y2FzZSA0OmI9Yi5jb250YWluZXJJbmZvO2Q9ITA7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcih1KDE2MSkpO31jLmVmZmVjdFRhZyYxNiYmKFJiKGIsXCJcIiksYy5lZmZlY3RUYWcmPS0xNyk7YTpiOmZvcihjPWE7Oyl7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWMucmV0dXJufHxPaShjLnJldHVybikpe2M9bnVsbDticmVhayBhfWM9Yy5yZXR1cm59Yy5zaWJsaW5nLnJldHVybj1jLnJldHVybjtmb3IoYz1jLnNpYmxpbmc7NSE9PWMudGFnJiY2IT09Yy50YWcmJjE4IT09Yy50YWc7KXtpZihjLmVmZmVjdFRhZyYyKWNvbnRpbnVlIGI7XG5pZihudWxsPT09Yy5jaGlsZHx8ND09PWMudGFnKWNvbnRpbnVlIGI7ZWxzZSBjLmNoaWxkLnJldHVybj1jLGM9Yy5jaGlsZH1pZighKGMuZWZmZWN0VGFnJjIpKXtjPWMuc3RhdGVOb2RlO2JyZWFrIGF9fWQ/UWkoYSxjLGIpOlJpKGEsYyxiKX1cbmZ1bmN0aW9uIFFpKGEsYixjKXt2YXIgZD1hLnRhZyxlPTU9PT1kfHw2PT09ZDtpZihlKWE9ZT9hLnN0YXRlTm9kZTphLnN0YXRlTm9kZS5pbnN0YW5jZSxiPzg9PT1jLm5vZGVUeXBlP2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxiKTpjLmluc2VydEJlZm9yZShhLGIpOig4PT09Yy5ub2RlVHlwZT8oYj1jLnBhcmVudE5vZGUsYi5pbnNlcnRCZWZvcmUoYSxjKSk6KGI9YyxiLmFwcGVuZENoaWxkKGEpKSxjPWMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsIT09YyYmdm9pZCAwIT09Y3x8bnVsbCE9PWIub25jbGlja3x8KGIub25jbGljaz1zZCkpO2Vsc2UgaWYoNCE9PWQmJihhPWEuY2hpbGQsbnVsbCE9PWEpKWZvcihRaShhLGIsYyksYT1hLnNpYmxpbmc7bnVsbCE9PWE7KVFpKGEsYixjKSxhPWEuc2libGluZ31cbmZ1bmN0aW9uIFJpKGEsYixjKXt2YXIgZD1hLnRhZyxlPTU9PT1kfHw2PT09ZDtpZihlKWE9ZT9hLnN0YXRlTm9kZTphLnN0YXRlTm9kZS5pbnN0YW5jZSxiP2MuaW5zZXJ0QmVmb3JlKGEsYik6Yy5hcHBlbmRDaGlsZChhKTtlbHNlIGlmKDQhPT1kJiYoYT1hLmNoaWxkLG51bGwhPT1hKSlmb3IoUmkoYSxiLGMpLGE9YS5zaWJsaW5nO251bGwhPT1hOylSaShhLGIsYyksYT1hLnNpYmxpbmd9XG5mdW5jdGlvbiBNaShhLGIsYyl7Zm9yKHZhciBkPWIsZT0hMSxmLGc7Oyl7aWYoIWUpe2U9ZC5yZXR1cm47YTpmb3IoOzspe2lmKG51bGw9PT1lKXRocm93IEVycm9yKHUoMTYwKSk7Zj1lLnN0YXRlTm9kZTtzd2l0Y2goZS50YWcpe2Nhc2UgNTpnPSExO2JyZWFrIGE7Y2FzZSAzOmY9Zi5jb250YWluZXJJbmZvO2c9ITA7YnJlYWsgYTtjYXNlIDQ6Zj1mLmNvbnRhaW5lckluZm87Zz0hMDticmVhayBhfWU9ZS5yZXR1cm59ZT0hMH1pZig1PT09ZC50YWd8fDY9PT1kLnRhZyl7YTpmb3IodmFyIGg9YSxrPWQsbD1jLG09azs7KWlmKEtpKGgsbSxsKSxudWxsIT09bS5jaGlsZCYmNCE9PW0udGFnKW0uY2hpbGQucmV0dXJuPW0sbT1tLmNoaWxkO2Vsc2V7aWYobT09PWspYnJlYWsgYTtmb3IoO251bGw9PT1tLnNpYmxpbmc7KXtpZihudWxsPT09bS5yZXR1cm58fG0ucmV0dXJuPT09aylicmVhayBhO209bS5yZXR1cm59bS5zaWJsaW5nLnJldHVybj1tLnJldHVybjttPW0uc2libGluZ31nPyhoPVxuZixrPWQuc3RhdGVOb2RlLDg9PT1oLm5vZGVUeXBlP2gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChrKTpoLnJlbW92ZUNoaWxkKGspKTpmLnJlbW92ZUNoaWxkKGQuc3RhdGVOb2RlKX1lbHNlIGlmKDQ9PT1kLnRhZyl7aWYobnVsbCE9PWQuY2hpbGQpe2Y9ZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztnPSEwO2QuY2hpbGQucmV0dXJuPWQ7ZD1kLmNoaWxkO2NvbnRpbnVlfX1lbHNlIGlmKEtpKGEsZCxjKSxudWxsIT09ZC5jaGlsZCl7ZC5jaGlsZC5yZXR1cm49ZDtkPWQuY2hpbGQ7Y29udGludWV9aWYoZD09PWIpYnJlYWs7Zm9yKDtudWxsPT09ZC5zaWJsaW5nOyl7aWYobnVsbD09PWQucmV0dXJufHxkLnJldHVybj09PWIpcmV0dXJuO2Q9ZC5yZXR1cm47ND09PWQudGFnJiYoZT0hMSl9ZC5zaWJsaW5nLnJldHVybj1kLnJldHVybjtkPWQuc2libGluZ319XG5mdW5jdGlvbiBTaShhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OmNhc2UgMjI6SGkoMyxiKTtyZXR1cm47Y2FzZSAxOnJldHVybjtjYXNlIDU6dmFyIGM9Yi5zdGF0ZU5vZGU7aWYobnVsbCE9Yyl7dmFyIGQ9Yi5tZW1vaXplZFByb3BzLGU9bnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOmQ7YT1iLnR5cGU7dmFyIGY9Yi51cGRhdGVRdWV1ZTtiLnVwZGF0ZVF1ZXVlPW51bGw7aWYobnVsbCE9PWYpe2NbTmRdPWQ7XCJpbnB1dFwiPT09YSYmXCJyYWRpb1wiPT09ZC50eXBlJiZudWxsIT1kLm5hbWUmJkJiKGMsZCk7cGQoYSxlKTtiPXBkKGEsZCk7Zm9yKGU9MDtlPGYubGVuZ3RoO2UrPTIpe3ZhciBnPWZbZV0saD1mW2UrMV07XCJzdHlsZVwiPT09Zz9tZChjLGgpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWc/UWIoYyxoKTpcImNoaWxkcmVuXCI9PT1nP1JiKGMsaCk6WGEoYyxnLGgsYil9c3dpdGNoKGEpe2Nhc2UgXCJpbnB1dFwiOkNiKGMsZCk7YnJlYWs7XG5jYXNlIFwidGV4dGFyZWFcIjpLYihjLGQpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpiPWMuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSxjLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU9ISFkLm11bHRpcGxlLGE9ZC52YWx1ZSxudWxsIT1hP0hiKGMsISFkLm11bHRpcGxlLGEsITEpOmIhPT0hIWQubXVsdGlwbGUmJihudWxsIT1kLmRlZmF1bHRWYWx1ZT9IYihjLCEhZC5tdWx0aXBsZSxkLmRlZmF1bHRWYWx1ZSwhMCk6SGIoYywhIWQubXVsdGlwbGUsZC5tdWx0aXBsZT9bXTpcIlwiLCExKSl9fX1yZXR1cm47Y2FzZSA2OmlmKG51bGw9PT1iLnN0YXRlTm9kZSl0aHJvdyBFcnJvcih1KDE2MikpO2Iuc3RhdGVOb2RlLm5vZGVWYWx1ZT1iLm1lbW9pemVkUHJvcHM7cmV0dXJuO2Nhc2UgMzpiPWIuc3RhdGVOb2RlO2IuaHlkcmF0ZSYmKGIuaHlkcmF0ZT0hMSxWYyhiLmNvbnRhaW5lckluZm8pKTtyZXR1cm47Y2FzZSAxMjpyZXR1cm47Y2FzZSAxMzpjPWI7bnVsbD09PWIubWVtb2l6ZWRTdGF0ZT9cbmQ9ITE6KGQ9ITAsYz1iLmNoaWxkLFRpPSRmKCkpO2lmKG51bGwhPT1jKWE6Zm9yKGE9Yzs7KXtpZig1PT09YS50YWcpZj1hLnN0YXRlTm9kZSxkPyhmPWYuc3R5bGUsXCJmdW5jdGlvblwiPT09dHlwZW9mIGYuc2V0UHJvcGVydHk/Zi5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIm5vbmVcIixcImltcG9ydGFudFwiKTpmLmRpc3BsYXk9XCJub25lXCIpOihmPWEuc3RhdGVOb2RlLGU9YS5tZW1vaXplZFByb3BzLnN0eWxlLGU9dm9pZCAwIT09ZSYmbnVsbCE9PWUmJmUuaGFzT3duUHJvcGVydHkoXCJkaXNwbGF5XCIpP2UuZGlzcGxheTpudWxsLGYuc3R5bGUuZGlzcGxheT1sZChcImRpc3BsYXlcIixlKSk7ZWxzZSBpZig2PT09YS50YWcpYS5zdGF0ZU5vZGUubm9kZVZhbHVlPWQ/XCJcIjphLm1lbW9pemVkUHJvcHM7ZWxzZSBpZigxMz09PWEudGFnJiZudWxsIT09YS5tZW1vaXplZFN0YXRlJiZudWxsPT09YS5tZW1vaXplZFN0YXRlLmRlaHlkcmF0ZWQpe2Y9YS5jaGlsZC5zaWJsaW5nO2YucmV0dXJuPWE7YT1cbmY7Y29udGludWV9ZWxzZSBpZihudWxsIT09YS5jaGlsZCl7YS5jaGlsZC5yZXR1cm49YTthPWEuY2hpbGQ7Y29udGludWV9aWYoYT09PWMpYnJlYWs7Zm9yKDtudWxsPT09YS5zaWJsaW5nOyl7aWYobnVsbD09PWEucmV0dXJufHxhLnJldHVybj09PWMpYnJlYWsgYTthPWEucmV0dXJufWEuc2libGluZy5yZXR1cm49YS5yZXR1cm47YT1hLnNpYmxpbmd9VWkoYik7cmV0dXJuO2Nhc2UgMTk6VWkoYik7cmV0dXJuO2Nhc2UgMTc6cmV0dXJufXRocm93IEVycm9yKHUoMTYzKSk7fWZ1bmN0aW9uIFVpKGEpe3ZhciBiPWEudXBkYXRlUXVldWU7aWYobnVsbCE9PWIpe2EudXBkYXRlUXVldWU9bnVsbDt2YXIgYz1hLnN0YXRlTm9kZTtudWxsPT09YyYmKGM9YS5zdGF0ZU5vZGU9bmV3IEJpKTtiLmZvckVhY2goZnVuY3Rpb24oYil7dmFyIGQ9VmkuYmluZChudWxsLGEsYik7Yy5oYXMoYil8fChjLmFkZChiKSxiLnRoZW4oZCxkKSl9KX19XG52YXIgV2k9XCJmdW5jdGlvblwiPT09dHlwZW9mIFdlYWtNYXA/V2Vha01hcDpNYXA7ZnVuY3Rpb24gWGkoYSxiLGMpe2M9d2coYyxudWxsKTtjLnRhZz0zO2MucGF5bG9hZD17ZWxlbWVudDpudWxsfTt2YXIgZD1iLnZhbHVlO2MuY2FsbGJhY2s9ZnVuY3Rpb24oKXtZaXx8KFlpPSEwLFppPWQpO0NpKGEsYil9O3JldHVybiBjfVxuZnVuY3Rpb24gJGkoYSxiLGMpe2M9d2coYyxudWxsKTtjLnRhZz0zO3ZhciBkPWEudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGQpe3ZhciBlPWIudmFsdWU7Yy5wYXlsb2FkPWZ1bmN0aW9uKCl7Q2koYSxiKTtyZXR1cm4gZChlKX19dmFyIGY9YS5zdGF0ZU5vZGU7bnVsbCE9PWYmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLmNvbXBvbmVudERpZENhdGNoJiYoYy5jYWxsYmFjaz1mdW5jdGlvbigpe1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBkJiYobnVsbD09PWFqP2FqPW5ldyBTZXQoW3RoaXNdKTphai5hZGQodGhpcyksQ2koYSxiKSk7dmFyIGM9Yi5zdGFjazt0aGlzLmNvbXBvbmVudERpZENhdGNoKGIudmFsdWUse2NvbXBvbmVudFN0YWNrOm51bGwhPT1jP2M6XCJcIn0pfSk7cmV0dXJuIGN9XG52YXIgYmo9TWF0aC5jZWlsLGNqPVdhLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsZGo9V2EuUmVhY3RDdXJyZW50T3duZXIsVj0wLGVqPTgsZmo9MTYsZ2o9MzIsdGk9MCxoaj0xLGlqPTIsdWk9Myx2aT00LGpqPTUsVz1WLFQ9bnVsbCxYPW51bGwsVT0wLFM9dGksa2o9bnVsbCxsaj0xMDczNzQxODIzLG1qPTEwNzM3NDE4MjMsbmo9bnVsbCx3aT0wLG9qPSExLFRpPTAscGo9NTAwLFk9bnVsbCxZaT0hMSxaaT1udWxsLGFqPW51bGwscWo9ITEscmo9bnVsbCxzaj05MCx0aj1udWxsLHVqPTAsdmo9bnVsbCx3aj0wO2Z1bmN0aW9uIEdnKCl7cmV0dXJuKFcmKGZqfGdqKSkhPT1WPzEwNzM3NDE4MjEtKCRmKCkvMTB8MCk6MCE9PXdqP3dqOndqPTEwNzM3NDE4MjEtKCRmKCkvMTB8MCl9XG5mdW5jdGlvbiBIZyhhLGIsYyl7Yj1iLm1vZGU7aWYoMD09PShiJjIpKXJldHVybiAxMDczNzQxODIzO3ZhciBkPWFnKCk7aWYoMD09PShiJjQpKXJldHVybiA5OT09PWQ/MTA3Mzc0MTgyMzoxMDczNzQxODIyO2lmKChXJmZqKSE9PVYpcmV0dXJuIFU7aWYobnVsbCE9PWMpYT1oZyhhLGMudGltZW91dE1zfDB8fDVFMywyNTApO2Vsc2Ugc3dpdGNoKGQpe2Nhc2UgOTk6YT0xMDczNzQxODIzO2JyZWFrO2Nhc2UgOTg6YT1oZyhhLDE1MCwxMDApO2JyZWFrO2Nhc2UgOTc6Y2FzZSA5NjphPWhnKGEsNUUzLDI1MCk7YnJlYWs7Y2FzZSA5NTphPTI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcih1KDMyNikpO31udWxsIT09VCYmYT09PVUmJi0tYTtyZXR1cm4gYX1cbmZ1bmN0aW9uIElnKGEsYil7aWYoNTA8dWopdGhyb3cgdWo9MCx2aj1udWxsLEVycm9yKHUoMTg1KSk7YT14aihhLGIpO2lmKG51bGwhPT1hKXt2YXIgYz1hZygpOzEwNzM3NDE4MjM9PT1iPyhXJmVqKSE9PVYmJihXJihmanxnaikpPT09Vj95aihhKTooWihhKSxXPT09ViYmZ2coKSk6WihhKTsoVyY0KT09PVZ8fDk4IT09YyYmOTkhPT1jfHwobnVsbD09PXRqP3RqPW5ldyBNYXAoW1thLGJdXSk6KGM9dGouZ2V0KGEpLCh2b2lkIDA9PT1jfHxjPmIpJiZ0ai5zZXQoYSxiKSkpfX1cbmZ1bmN0aW9uIHhqKGEsYil7YS5leHBpcmF0aW9uVGltZTxiJiYoYS5leHBpcmF0aW9uVGltZT1iKTt2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09YyYmYy5leHBpcmF0aW9uVGltZTxiJiYoYy5leHBpcmF0aW9uVGltZT1iKTt2YXIgZD1hLnJldHVybixlPW51bGw7aWYobnVsbD09PWQmJjM9PT1hLnRhZyllPWEuc3RhdGVOb2RlO2Vsc2UgZm9yKDtudWxsIT09ZDspe2M9ZC5hbHRlcm5hdGU7ZC5jaGlsZEV4cGlyYXRpb25UaW1lPGImJihkLmNoaWxkRXhwaXJhdGlvblRpbWU9Yik7bnVsbCE9PWMmJmMuY2hpbGRFeHBpcmF0aW9uVGltZTxiJiYoYy5jaGlsZEV4cGlyYXRpb25UaW1lPWIpO2lmKG51bGw9PT1kLnJldHVybiYmMz09PWQudGFnKXtlPWQuc3RhdGVOb2RlO2JyZWFrfWQ9ZC5yZXR1cm59bnVsbCE9PWUmJihUPT09ZSYmKEJnKGIpLFM9PT12aSYmeGkoZSxVKSkseWkoZSxiKSk7cmV0dXJuIGV9XG5mdW5jdGlvbiB6aihhKXt2YXIgYj1hLmxhc3RFeHBpcmVkVGltZTtpZigwIT09YilyZXR1cm4gYjtiPWEuZmlyc3RQZW5kaW5nVGltZTtpZighQWooYSxiKSlyZXR1cm4gYjt2YXIgYz1hLmxhc3RQaW5nZWRUaW1lO2E9YS5uZXh0S25vd25QZW5kaW5nTGV2ZWw7YT1jPmE/YzphO3JldHVybiAyPj1hJiZiIT09YT8wOmF9XG5mdW5jdGlvbiBaKGEpe2lmKDAhPT1hLmxhc3RFeHBpcmVkVGltZSlhLmNhbGxiYWNrRXhwaXJhdGlvblRpbWU9MTA3Mzc0MTgyMyxhLmNhbGxiYWNrUHJpb3JpdHk9OTksYS5jYWxsYmFja05vZGU9ZWcoeWouYmluZChudWxsLGEpKTtlbHNle3ZhciBiPXpqKGEpLGM9YS5jYWxsYmFja05vZGU7aWYoMD09PWIpbnVsbCE9PWMmJihhLmNhbGxiYWNrTm9kZT1udWxsLGEuY2FsbGJhY2tFeHBpcmF0aW9uVGltZT0wLGEuY2FsbGJhY2tQcmlvcml0eT05MCk7ZWxzZXt2YXIgZD1HZygpOzEwNzM3NDE4MjM9PT1iP2Q9OTk6MT09PWJ8fDI9PT1iP2Q9OTU6KGQ9MTAqKDEwNzM3NDE4MjEtYiktMTAqKDEwNzM3NDE4MjEtZCksZD0wPj1kPzk5OjI1MD49ZD85ODo1MjUwPj1kPzk3Ojk1KTtpZihudWxsIT09Yyl7dmFyIGU9YS5jYWxsYmFja1ByaW9yaXR5O2lmKGEuY2FsbGJhY2tFeHBpcmF0aW9uVGltZT09PWImJmU+PWQpcmV0dXJuO2MhPT1UZiYmS2YoYyl9YS5jYWxsYmFja0V4cGlyYXRpb25UaW1lPVxuYjthLmNhbGxiYWNrUHJpb3JpdHk9ZDtiPTEwNzM3NDE4MjM9PT1iP2VnKHlqLmJpbmQobnVsbCxhKSk6ZGcoZCxCai5iaW5kKG51bGwsYSkse3RpbWVvdXQ6MTAqKDEwNzM3NDE4MjEtYiktJGYoKX0pO2EuY2FsbGJhY2tOb2RlPWJ9fX1cbmZ1bmN0aW9uIEJqKGEsYil7d2o9MDtpZihiKXJldHVybiBiPUdnKCksQ2ooYSxiKSxaKGEpLG51bGw7dmFyIGM9emooYSk7aWYoMCE9PWMpe2I9YS5jYWxsYmFja05vZGU7aWYoKFcmKGZqfGdqKSkhPT1WKXRocm93IEVycm9yKHUoMzI3KSk7RGooKTthPT09VCYmYz09PVV8fEVqKGEsYyk7aWYobnVsbCE9PVgpe3ZhciBkPVc7V3w9Zmo7dmFyIGU9RmooKTtkbyB0cnl7R2ooKTticmVha31jYXRjaChoKXtIaihhLGgpfXdoaWxlKDEpO25nKCk7Vz1kO2NqLmN1cnJlbnQ9ZTtpZihTPT09aGopdGhyb3cgYj1raixFaihhLGMpLHhpKGEsYyksWihhKSxiO2lmKG51bGw9PT1YKXN3aXRjaChlPWEuZmluaXNoZWRXb3JrPWEuY3VycmVudC5hbHRlcm5hdGUsYS5maW5pc2hlZEV4cGlyYXRpb25UaW1lPWMsZD1TLFQ9bnVsbCxkKXtjYXNlIHRpOmNhc2UgaGo6dGhyb3cgRXJyb3IodSgzNDUpKTtjYXNlIGlqOkNqKGEsMjxjPzI6Yyk7YnJlYWs7Y2FzZSB1aTp4aShhLGMpO2Q9YS5sYXN0U3VzcGVuZGVkVGltZTtcbmM9PT1kJiYoYS5uZXh0S25vd25QZW5kaW5nTGV2ZWw9SWooZSkpO2lmKDEwNzM3NDE4MjM9PT1saiYmKGU9VGkrcGotJGYoKSwxMDxlKSl7aWYob2ope3ZhciBmPWEubGFzdFBpbmdlZFRpbWU7aWYoMD09PWZ8fGY+PWMpe2EubGFzdFBpbmdlZFRpbWU9YztFaihhLGMpO2JyZWFrfX1mPXpqKGEpO2lmKDAhPT1mJiZmIT09YylicmVhaztpZigwIT09ZCYmZCE9PWMpe2EubGFzdFBpbmdlZFRpbWU9ZDticmVha31hLnRpbWVvdXRIYW5kbGU9SGQoSmouYmluZChudWxsLGEpLGUpO2JyZWFrfUpqKGEpO2JyZWFrO2Nhc2Ugdmk6eGkoYSxjKTtkPWEubGFzdFN1c3BlbmRlZFRpbWU7Yz09PWQmJihhLm5leHRLbm93blBlbmRpbmdMZXZlbD1JaihlKSk7aWYob2omJihlPWEubGFzdFBpbmdlZFRpbWUsMD09PWV8fGU+PWMpKXthLmxhc3RQaW5nZWRUaW1lPWM7RWooYSxjKTticmVha31lPXpqKGEpO2lmKDAhPT1lJiZlIT09YylicmVhaztpZigwIT09ZCYmZCE9PWMpe2EubGFzdFBpbmdlZFRpbWU9XG5kO2JyZWFrfTEwNzM3NDE4MjMhPT1taj9kPTEwKigxMDczNzQxODIxLW1qKS0kZigpOjEwNzM3NDE4MjM9PT1saj9kPTA6KGQ9MTAqKDEwNzM3NDE4MjEtbGopLTVFMyxlPSRmKCksYz0xMCooMTA3Mzc0MTgyMS1jKS1lLGQ9ZS1kLDA+ZCYmKGQ9MCksZD0oMTIwPmQ/MTIwOjQ4MD5kPzQ4MDoxMDgwPmQ/MTA4MDoxOTIwPmQ/MTkyMDozRTM+ZD8zRTM6NDMyMD5kPzQzMjA6MTk2MCpiaihkLzE5NjApKS1kLGM8ZCYmKGQ9YykpO2lmKDEwPGQpe2EudGltZW91dEhhbmRsZT1IZChKai5iaW5kKG51bGwsYSksZCk7YnJlYWt9SmooYSk7YnJlYWs7Y2FzZSBqajppZigxMDczNzQxODIzIT09bGomJm51bGwhPT1uail7Zj1sajt2YXIgZz1uajtkPWcuYnVzeU1pbkR1cmF0aW9uTXN8MDswPj1kP2Q9MDooZT1nLmJ1c3lEZWxheU1zfDAsZj0kZigpLSgxMCooMTA3Mzc0MTgyMS1mKS0oZy50aW1lb3V0TXN8MHx8NUUzKSksZD1mPD1lPzA6ZStkLWYpO2lmKDEwPGQpe3hpKGEsYyk7YS50aW1lb3V0SGFuZGxlPVxuSGQoSmouYmluZChudWxsLGEpLGQpO2JyZWFrfX1KaihhKTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKHUoMzI5KSk7fVooYSk7aWYoYS5jYWxsYmFja05vZGU9PT1iKXJldHVybiBCai5iaW5kKG51bGwsYSl9fXJldHVybiBudWxsfVxuZnVuY3Rpb24geWooYSl7dmFyIGI9YS5sYXN0RXhwaXJlZFRpbWU7Yj0wIT09Yj9iOjEwNzM3NDE4MjM7aWYoKFcmKGZqfGdqKSkhPT1WKXRocm93IEVycm9yKHUoMzI3KSk7RGooKTthPT09VCYmYj09PVV8fEVqKGEsYik7aWYobnVsbCE9PVgpe3ZhciBjPVc7V3w9Zmo7dmFyIGQ9RmooKTtkbyB0cnl7S2ooKTticmVha31jYXRjaChlKXtIaihhLGUpfXdoaWxlKDEpO25nKCk7Vz1jO2NqLmN1cnJlbnQ9ZDtpZihTPT09aGopdGhyb3cgYz1raixFaihhLGIpLHhpKGEsYiksWihhKSxjO2lmKG51bGwhPT1YKXRocm93IEVycm9yKHUoMjYxKSk7YS5maW5pc2hlZFdvcms9YS5jdXJyZW50LmFsdGVybmF0ZTthLmZpbmlzaGVkRXhwaXJhdGlvblRpbWU9YjtUPW51bGw7SmooYSk7WihhKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBMaigpe2lmKG51bGwhPT10ail7dmFyIGE9dGo7dGo9bnVsbDthLmZvckVhY2goZnVuY3Rpb24oYSxjKXtDaihjLGEpO1ooYyl9KTtnZygpfX1cbmZ1bmN0aW9uIE1qKGEsYil7dmFyIGM9VztXfD0xO3RyeXtyZXR1cm4gYShiKX1maW5hbGx5e1c9YyxXPT09ViYmZ2coKX19ZnVuY3Rpb24gTmooYSxiKXt2YXIgYz1XO1cmPS0yO1d8PWVqO3RyeXtyZXR1cm4gYShiKX1maW5hbGx5e1c9YyxXPT09ViYmZ2coKX19XG5mdW5jdGlvbiBFaihhLGIpe2EuZmluaXNoZWRXb3JrPW51bGw7YS5maW5pc2hlZEV4cGlyYXRpb25UaW1lPTA7dmFyIGM9YS50aW1lb3V0SGFuZGxlOy0xIT09YyYmKGEudGltZW91dEhhbmRsZT0tMSxJZChjKSk7aWYobnVsbCE9PVgpZm9yKGM9WC5yZXR1cm47bnVsbCE9PWM7KXt2YXIgZD1jO3N3aXRjaChkLnRhZyl7Y2FzZSAxOmQ9ZC50eXBlLmNoaWxkQ29udGV4dFR5cGVzO251bGwhPT1kJiZ2b2lkIDAhPT1kJiZEZigpO2JyZWFrO2Nhc2UgMzplaCgpO0goSyk7SChKKTticmVhaztjYXNlIDU6Z2goZCk7YnJlYWs7Y2FzZSA0OmVoKCk7YnJlYWs7Y2FzZSAxMzpIKE0pO2JyZWFrO2Nhc2UgMTk6SChNKTticmVhaztjYXNlIDEwOm9nKGQpfWM9Yy5yZXR1cm59VD1hO1g9U2coYS5jdXJyZW50LG51bGwpO1U9YjtTPXRpO2tqPW51bGw7bWo9bGo9MTA3Mzc0MTgyMztuaj1udWxsO3dpPTA7b2o9ITF9XG5mdW5jdGlvbiBIaihhLGIpe2Rve3RyeXtuZygpO2poLmN1cnJlbnQ9c2g7aWYobWgpZm9yKHZhciBjPU4ubWVtb2l6ZWRTdGF0ZTtudWxsIT09Yzspe3ZhciBkPWMucXVldWU7bnVsbCE9PWQmJihkLnBlbmRpbmc9bnVsbCk7Yz1jLm5leHR9bGg9MDtQPU89Tj1udWxsO21oPSExO2lmKG51bGw9PT1YfHxudWxsPT09WC5yZXR1cm4pcmV0dXJuIFM9aGosa2o9YixYPW51bGw7YTp7dmFyIGU9YSxmPVgucmV0dXJuLGc9WCxoPWI7Yj1VO2cuZWZmZWN0VGFnfD0yMDQ4O2cuZmlyc3RFZmZlY3Q9Zy5sYXN0RWZmZWN0PW51bGw7aWYobnVsbCE9PWgmJlwib2JqZWN0XCI9PT10eXBlb2YgaCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGgudGhlbil7dmFyIGs9aDtpZigwPT09KGcubW9kZSYyKSl7dmFyIGw9Zy5hbHRlcm5hdGU7bD8oZy51cGRhdGVRdWV1ZT1sLnVwZGF0ZVF1ZXVlLGcubWVtb2l6ZWRTdGF0ZT1sLm1lbW9pemVkU3RhdGUsZy5leHBpcmF0aW9uVGltZT1sLmV4cGlyYXRpb25UaW1lKTooZy51cGRhdGVRdWV1ZT1cbm51bGwsZy5tZW1vaXplZFN0YXRlPW51bGwpfXZhciBtPTAhPT0oTS5jdXJyZW50JjEpLHA9Zjtkb3t2YXIgeDtpZih4PTEzPT09cC50YWcpe3ZhciB6PXAubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09eil4PW51bGwhPT16LmRlaHlkcmF0ZWQ/ITA6ITE7ZWxzZXt2YXIgY2E9cC5tZW1vaXplZFByb3BzO3g9dm9pZCAwPT09Y2EuZmFsbGJhY2s/ITE6ITAhPT1jYS51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjaz8hMDptPyExOiEwfX1pZih4KXt2YXIgRD1wLnVwZGF0ZVF1ZXVlO2lmKG51bGw9PT1EKXt2YXIgdD1uZXcgU2V0O3QuYWRkKGspO3AudXBkYXRlUXVldWU9dH1lbHNlIEQuYWRkKGspO2lmKDA9PT0ocC5tb2RlJjIpKXtwLmVmZmVjdFRhZ3w9NjQ7Zy5lZmZlY3RUYWcmPS0yOTgxO2lmKDE9PT1nLnRhZylpZihudWxsPT09Zy5hbHRlcm5hdGUpZy50YWc9MTc7ZWxzZXt2YXIgeT13ZygxMDczNzQxODIzLG51bGwpO3kudGFnPTI7eGcoZyx5KX1nLmV4cGlyYXRpb25UaW1lPTEwNzM3NDE4MjM7XG5icmVhayBhfWg9dm9pZCAwO2c9Yjt2YXIgQT1lLnBpbmdDYWNoZTtudWxsPT09QT8oQT1lLnBpbmdDYWNoZT1uZXcgV2ksaD1uZXcgU2V0LEEuc2V0KGssaCkpOihoPUEuZ2V0KGspLHZvaWQgMD09PWgmJihoPW5ldyBTZXQsQS5zZXQoayxoKSkpO2lmKCFoLmhhcyhnKSl7aC5hZGQoZyk7dmFyIHE9T2ouYmluZChudWxsLGUsayxnKTtrLnRoZW4ocSxxKX1wLmVmZmVjdFRhZ3w9NDA5NjtwLmV4cGlyYXRpb25UaW1lPWI7YnJlYWsgYX1wPXAucmV0dXJufXdoaWxlKG51bGwhPT1wKTtoPUVycm9yKChwYihnLnR5cGUpfHxcIkEgUmVhY3QgY29tcG9uZW50XCIpK1wiIHN1c3BlbmRlZCB3aGlsZSByZW5kZXJpbmcsIGJ1dCBubyBmYWxsYmFjayBVSSB3YXMgc3BlY2lmaWVkLlxcblxcbkFkZCBhIDxTdXNwZW5zZSBmYWxsYmFjaz0uLi4+IGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIHRyZWUgdG8gcHJvdmlkZSBhIGxvYWRpbmcgaW5kaWNhdG9yIG9yIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkuXCIrcWIoZykpfVMhPT1cbmpqJiYoUz1paik7aD1BaShoLGcpO3A9Zjtkb3tzd2l0Y2gocC50YWcpe2Nhc2UgMzprPWg7cC5lZmZlY3RUYWd8PTQwOTY7cC5leHBpcmF0aW9uVGltZT1iO3ZhciBCPVhpKHAsayxiKTt5ZyhwLEIpO2JyZWFrIGE7Y2FzZSAxOms9aDt2YXIgdz1wLnR5cGUsdWI9cC5zdGF0ZU5vZGU7aWYoMD09PShwLmVmZmVjdFRhZyY2NCkmJihcImZ1bmN0aW9uXCI9PT10eXBlb2Ygdy5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3J8fG51bGwhPT11YiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIHViLmNvbXBvbmVudERpZENhdGNoJiYobnVsbD09PWFqfHwhYWouaGFzKHViKSkpKXtwLmVmZmVjdFRhZ3w9NDA5NjtwLmV4cGlyYXRpb25UaW1lPWI7dmFyIHZiPSRpKHAsayxiKTt5ZyhwLHZiKTticmVhayBhfX1wPXAucmV0dXJufXdoaWxlKG51bGwhPT1wKX1YPVBqKFgpfWNhdGNoKFhjKXtiPVhjO2NvbnRpbnVlfWJyZWFrfXdoaWxlKDEpfVxuZnVuY3Rpb24gRmooKXt2YXIgYT1jai5jdXJyZW50O2NqLmN1cnJlbnQ9c2g7cmV0dXJuIG51bGw9PT1hP3NoOmF9ZnVuY3Rpb24gQWcoYSxiKXthPGxqJiYyPGEmJihsaj1hKTtudWxsIT09YiYmYTxtaiYmMjxhJiYobWo9YSxuaj1iKX1mdW5jdGlvbiBCZyhhKXthPndpJiYod2k9YSl9ZnVuY3Rpb24gS2ooKXtmb3IoO251bGwhPT1YOylYPVFqKFgpfWZ1bmN0aW9uIEdqKCl7Zm9yKDtudWxsIT09WCYmIVVmKCk7KVg9UWooWCl9ZnVuY3Rpb24gUWooYSl7dmFyIGI9UmooYS5hbHRlcm5hdGUsYSxVKTthLm1lbW9pemVkUHJvcHM9YS5wZW5kaW5nUHJvcHM7bnVsbD09PWImJihiPVBqKGEpKTtkai5jdXJyZW50PW51bGw7cmV0dXJuIGJ9XG5mdW5jdGlvbiBQaihhKXtYPWE7ZG97dmFyIGI9WC5hbHRlcm5hdGU7YT1YLnJldHVybjtpZigwPT09KFguZWZmZWN0VGFnJjIwNDgpKXtiPXNpKGIsWCxVKTtpZigxPT09VXx8MSE9PVguY2hpbGRFeHBpcmF0aW9uVGltZSl7Zm9yKHZhciBjPTAsZD1YLmNoaWxkO251bGwhPT1kOyl7dmFyIGU9ZC5leHBpcmF0aW9uVGltZSxmPWQuY2hpbGRFeHBpcmF0aW9uVGltZTtlPmMmJihjPWUpO2Y+YyYmKGM9Zik7ZD1kLnNpYmxpbmd9WC5jaGlsZEV4cGlyYXRpb25UaW1lPWN9aWYobnVsbCE9PWIpcmV0dXJuIGI7bnVsbCE9PWEmJjA9PT0oYS5lZmZlY3RUYWcmMjA0OCkmJihudWxsPT09YS5maXJzdEVmZmVjdCYmKGEuZmlyc3RFZmZlY3Q9WC5maXJzdEVmZmVjdCksbnVsbCE9PVgubGFzdEVmZmVjdCYmKG51bGwhPT1hLmxhc3RFZmZlY3QmJihhLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1YLmZpcnN0RWZmZWN0KSxhLmxhc3RFZmZlY3Q9WC5sYXN0RWZmZWN0KSwxPFguZWZmZWN0VGFnJiYobnVsbCE9PVxuYS5sYXN0RWZmZWN0P2EubGFzdEVmZmVjdC5uZXh0RWZmZWN0PVg6YS5maXJzdEVmZmVjdD1YLGEubGFzdEVmZmVjdD1YKSl9ZWxzZXtiPXppKFgpO2lmKG51bGwhPT1iKXJldHVybiBiLmVmZmVjdFRhZyY9MjA0NyxiO251bGwhPT1hJiYoYS5maXJzdEVmZmVjdD1hLmxhc3RFZmZlY3Q9bnVsbCxhLmVmZmVjdFRhZ3w9MjA0OCl9Yj1YLnNpYmxpbmc7aWYobnVsbCE9PWIpcmV0dXJuIGI7WD1hfXdoaWxlKG51bGwhPT1YKTtTPT09dGkmJihTPWpqKTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBJaihhKXt2YXIgYj1hLmV4cGlyYXRpb25UaW1lO2E9YS5jaGlsZEV4cGlyYXRpb25UaW1lO3JldHVybiBiPmE/YjphfWZ1bmN0aW9uIEpqKGEpe3ZhciBiPWFnKCk7Y2coOTksU2ouYmluZChudWxsLGEsYikpO3JldHVybiBudWxsfVxuZnVuY3Rpb24gU2ooYSxiKXtkbyBEaigpO3doaWxlKG51bGwhPT1yaik7aWYoKFcmKGZqfGdqKSkhPT1WKXRocm93IEVycm9yKHUoMzI3KSk7dmFyIGM9YS5maW5pc2hlZFdvcmssZD1hLmZpbmlzaGVkRXhwaXJhdGlvblRpbWU7aWYobnVsbD09PWMpcmV0dXJuIG51bGw7YS5maW5pc2hlZFdvcms9bnVsbDthLmZpbmlzaGVkRXhwaXJhdGlvblRpbWU9MDtpZihjPT09YS5jdXJyZW50KXRocm93IEVycm9yKHUoMTc3KSk7YS5jYWxsYmFja05vZGU9bnVsbDthLmNhbGxiYWNrRXhwaXJhdGlvblRpbWU9MDthLmNhbGxiYWNrUHJpb3JpdHk9OTA7YS5uZXh0S25vd25QZW5kaW5nTGV2ZWw9MDt2YXIgZT1JaihjKTthLmZpcnN0UGVuZGluZ1RpbWU9ZTtkPD1hLmxhc3RTdXNwZW5kZWRUaW1lP2EuZmlyc3RTdXNwZW5kZWRUaW1lPWEubGFzdFN1c3BlbmRlZFRpbWU9YS5uZXh0S25vd25QZW5kaW5nTGV2ZWw9MDpkPD1hLmZpcnN0U3VzcGVuZGVkVGltZSYmKGEuZmlyc3RTdXNwZW5kZWRUaW1lPVxuZC0xKTtkPD1hLmxhc3RQaW5nZWRUaW1lJiYoYS5sYXN0UGluZ2VkVGltZT0wKTtkPD1hLmxhc3RFeHBpcmVkVGltZSYmKGEubGFzdEV4cGlyZWRUaW1lPTApO2E9PT1UJiYoWD1UPW51bGwsVT0wKTsxPGMuZWZmZWN0VGFnP251bGwhPT1jLmxhc3RFZmZlY3Q/KGMubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWMsZT1jLmZpcnN0RWZmZWN0KTplPWM6ZT1jLmZpcnN0RWZmZWN0O2lmKG51bGwhPT1lKXt2YXIgZj1XO1d8PWdqO2RqLmN1cnJlbnQ9bnVsbDtEZD1mZDt2YXIgZz14ZCgpO2lmKHlkKGcpKXtpZihcInNlbGVjdGlvblN0YXJ0XCJpbiBnKXZhciBoPXtzdGFydDpnLnNlbGVjdGlvblN0YXJ0LGVuZDpnLnNlbGVjdGlvbkVuZH07ZWxzZSBhOntoPShoPWcub3duZXJEb2N1bWVudCkmJmguZGVmYXVsdFZpZXd8fHdpbmRvdzt2YXIgaz1oLmdldFNlbGVjdGlvbiYmaC5nZXRTZWxlY3Rpb24oKTtpZihrJiYwIT09ay5yYW5nZUNvdW50KXtoPWsuYW5jaG9yTm9kZTt2YXIgbD1rLmFuY2hvck9mZnNldCxcbm09ay5mb2N1c05vZGU7az1rLmZvY3VzT2Zmc2V0O3RyeXtoLm5vZGVUeXBlLG0ubm9kZVR5cGV9Y2F0Y2god2Ipe2g9bnVsbDticmVhayBhfXZhciBwPTAseD0tMSx6PS0xLGNhPTAsRD0wLHQ9Zyx5PW51bGw7Yjpmb3IoOzspe2Zvcih2YXIgQTs7KXt0IT09aHx8MCE9PWwmJjMhPT10Lm5vZGVUeXBlfHwoeD1wK2wpO3QhPT1tfHwwIT09ayYmMyE9PXQubm9kZVR5cGV8fCh6PXArayk7Mz09PXQubm9kZVR5cGUmJihwKz10Lm5vZGVWYWx1ZS5sZW5ndGgpO2lmKG51bGw9PT0oQT10LmZpcnN0Q2hpbGQpKWJyZWFrO3k9dDt0PUF9Zm9yKDs7KXtpZih0PT09ZylicmVhayBiO3k9PT1oJiYrK2NhPT09bCYmKHg9cCk7eT09PW0mJisrRD09PWsmJih6PXApO2lmKG51bGwhPT0oQT10Lm5leHRTaWJsaW5nKSlicmVhazt0PXk7eT10LnBhcmVudE5vZGV9dD1BfWg9LTE9PT14fHwtMT09PXo/bnVsbDp7c3RhcnQ6eCxlbmQ6en19ZWxzZSBoPW51bGx9aD1ofHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSBoPVxubnVsbDtFZD17YWN0aXZlRWxlbWVudERldGFjaGVkOm51bGwsZm9jdXNlZEVsZW06ZyxzZWxlY3Rpb25SYW5nZTpofTtmZD0hMTtZPWU7ZG8gdHJ5e1RqKCl9Y2F0Y2god2Ipe2lmKG51bGw9PT1ZKXRocm93IEVycm9yKHUoMzMwKSk7RWkoWSx3Yik7WT1ZLm5leHRFZmZlY3R9d2hpbGUobnVsbCE9PVkpO1k9ZTtkbyB0cnl7Zm9yKGc9YSxoPWI7bnVsbCE9PVk7KXt2YXIgcT1ZLmVmZmVjdFRhZztxJjE2JiZSYihZLnN0YXRlTm9kZSxcIlwiKTtpZihxJjEyOCl7dmFyIEI9WS5hbHRlcm5hdGU7aWYobnVsbCE9PUIpe3ZhciB3PUIucmVmO251bGwhPT13JiYoXCJmdW5jdGlvblwiPT09dHlwZW9mIHc/dyhudWxsKTp3LmN1cnJlbnQ9bnVsbCl9fXN3aXRjaChxJjEwMzgpe2Nhc2UgMjpQaShZKTtZLmVmZmVjdFRhZyY9LTM7YnJlYWs7Y2FzZSA2OlBpKFkpO1kuZWZmZWN0VGFnJj0tMztTaShZLmFsdGVybmF0ZSxZKTticmVhaztjYXNlIDEwMjQ6WS5lZmZlY3RUYWcmPS0xMDI1O2JyZWFrO2Nhc2UgMTAyODpZLmVmZmVjdFRhZyY9XG4tMTAyNTtTaShZLmFsdGVybmF0ZSxZKTticmVhaztjYXNlIDQ6U2koWS5hbHRlcm5hdGUsWSk7YnJlYWs7Y2FzZSA4Omw9WSxNaShnLGwsaCksTmkobCl9WT1ZLm5leHRFZmZlY3R9fWNhdGNoKHdiKXtpZihudWxsPT09WSl0aHJvdyBFcnJvcih1KDMzMCkpO0VpKFksd2IpO1k9WS5uZXh0RWZmZWN0fXdoaWxlKG51bGwhPT1ZKTt3PUVkO0I9eGQoKTtxPXcuZm9jdXNlZEVsZW07aD13LnNlbGVjdGlvblJhbmdlO2lmKEIhPT1xJiZxJiZxLm93bmVyRG9jdW1lbnQmJndkKHEub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQscSkpe251bGwhPT1oJiZ5ZChxKSYmKEI9aC5zdGFydCx3PWguZW5kLHZvaWQgMD09PXcmJih3PUIpLFwic2VsZWN0aW9uU3RhcnRcImluIHE/KHEuc2VsZWN0aW9uU3RhcnQ9QixxLnNlbGVjdGlvbkVuZD1NYXRoLm1pbih3LHEudmFsdWUubGVuZ3RoKSk6KHc9KEI9cS5vd25lckRvY3VtZW50fHxkb2N1bWVudCkmJkIuZGVmYXVsdFZpZXd8fHdpbmRvdyx3LmdldFNlbGVjdGlvbiYmXG4odz13LmdldFNlbGVjdGlvbigpLGw9cS50ZXh0Q29udGVudC5sZW5ndGgsZz1NYXRoLm1pbihoLnN0YXJ0LGwpLGg9dm9pZCAwPT09aC5lbmQ/ZzpNYXRoLm1pbihoLmVuZCxsKSwhdy5leHRlbmQmJmc+aCYmKGw9aCxoPWcsZz1sKSxsPXZkKHEsZyksbT12ZChxLGgpLGwmJm0mJigxIT09dy5yYW5nZUNvdW50fHx3LmFuY2hvck5vZGUhPT1sLm5vZGV8fHcuYW5jaG9yT2Zmc2V0IT09bC5vZmZzZXR8fHcuZm9jdXNOb2RlIT09bS5ub2RlfHx3LmZvY3VzT2Zmc2V0IT09bS5vZmZzZXQpJiYoQj1CLmNyZWF0ZVJhbmdlKCksQi5zZXRTdGFydChsLm5vZGUsbC5vZmZzZXQpLHcucmVtb3ZlQWxsUmFuZ2VzKCksZz5oPyh3LmFkZFJhbmdlKEIpLHcuZXh0ZW5kKG0ubm9kZSxtLm9mZnNldCkpOihCLnNldEVuZChtLm5vZGUsbS5vZmZzZXQpLHcuYWRkUmFuZ2UoQikpKSkpKTtCPVtdO2Zvcih3PXE7dz13LnBhcmVudE5vZGU7KTE9PT13Lm5vZGVUeXBlJiZCLnB1c2goe2VsZW1lbnQ6dyxsZWZ0Oncuc2Nyb2xsTGVmdCxcbnRvcDp3LnNjcm9sbFRvcH0pO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBxLmZvY3VzJiZxLmZvY3VzKCk7Zm9yKHE9MDtxPEIubGVuZ3RoO3ErKyl3PUJbcV0sdy5lbGVtZW50LnNjcm9sbExlZnQ9dy5sZWZ0LHcuZWxlbWVudC5zY3JvbGxUb3A9dy50b3B9ZmQ9ISFEZDtFZD1EZD1udWxsO2EuY3VycmVudD1jO1k9ZTtkbyB0cnl7Zm9yKHE9YTtudWxsIT09WTspe3ZhciB1Yj1ZLmVmZmVjdFRhZzt1YiYzNiYmSmkocSxZLmFsdGVybmF0ZSxZKTtpZih1YiYxMjgpe0I9dm9pZCAwO3ZhciB2Yj1ZLnJlZjtpZihudWxsIT09dmIpe3ZhciBYYz1ZLnN0YXRlTm9kZTtzd2l0Y2goWS50YWcpe2Nhc2UgNTpCPVhjO2JyZWFrO2RlZmF1bHQ6Qj1YY31cImZ1bmN0aW9uXCI9PT10eXBlb2YgdmI/dmIoQik6dmIuY3VycmVudD1CfX1ZPVkubmV4dEVmZmVjdH19Y2F0Y2god2Ipe2lmKG51bGw9PT1ZKXRocm93IEVycm9yKHUoMzMwKSk7RWkoWSx3Yik7WT1ZLm5leHRFZmZlY3R9d2hpbGUobnVsbCE9PVkpO1k9XG5udWxsO1ZmKCk7Vz1mfWVsc2UgYS5jdXJyZW50PWM7aWYocWopcWo9ITEscmo9YSxzaj1iO2Vsc2UgZm9yKFk9ZTtudWxsIT09WTspYj1ZLm5leHRFZmZlY3QsWS5uZXh0RWZmZWN0PW51bGwsWT1iO2I9YS5maXJzdFBlbmRpbmdUaW1lOzA9PT1iJiYoYWo9bnVsbCk7MTA3Mzc0MTgyMz09PWI/YT09PXZqP3VqKys6KHVqPTAsdmo9YSk6dWo9MDtcImZ1bmN0aW9uXCI9PT10eXBlb2YgVWomJlVqKGMuc3RhdGVOb2RlLGQpO1ooYSk7aWYoWWkpdGhyb3cgWWk9ITEsYT1aaSxaaT1udWxsLGE7aWYoKFcmZWopIT09VilyZXR1cm4gbnVsbDtnZygpO3JldHVybiBudWxsfWZ1bmN0aW9uIFRqKCl7Zm9yKDtudWxsIT09WTspe3ZhciBhPVkuZWZmZWN0VGFnOzAhPT0oYSYyNTYpJiZHaShZLmFsdGVybmF0ZSxZKTswPT09KGEmNTEyKXx8cWp8fChxaj0hMCxkZyg5NyxmdW5jdGlvbigpe0RqKCk7cmV0dXJuIG51bGx9KSk7WT1ZLm5leHRFZmZlY3R9fVxuZnVuY3Rpb24gRGooKXtpZig5MCE9PXNqKXt2YXIgYT05Nzxzaj85Nzpzajtzaj05MDtyZXR1cm4gY2coYSxWail9fWZ1bmN0aW9uIFZqKCl7aWYobnVsbD09PXJqKXJldHVybiExO3ZhciBhPXJqO3JqPW51bGw7aWYoKFcmKGZqfGdqKSkhPT1WKXRocm93IEVycm9yKHUoMzMxKSk7dmFyIGI9VztXfD1najtmb3IoYT1hLmN1cnJlbnQuZmlyc3RFZmZlY3Q7bnVsbCE9PWE7KXt0cnl7dmFyIGM9YTtpZigwIT09KGMuZWZmZWN0VGFnJjUxMikpc3dpdGNoKGMudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OmNhc2UgMjI6SGkoNSxjKSxJaSg1LGMpfX1jYXRjaChkKXtpZihudWxsPT09YSl0aHJvdyBFcnJvcih1KDMzMCkpO0VpKGEsZCl9Yz1hLm5leHRFZmZlY3Q7YS5uZXh0RWZmZWN0PW51bGw7YT1jfVc9YjtnZygpO3JldHVybiEwfVxuZnVuY3Rpb24gV2ooYSxiLGMpe2I9QWkoYyxiKTtiPVhpKGEsYiwxMDczNzQxODIzKTt4ZyhhLGIpO2E9eGooYSwxMDczNzQxODIzKTtudWxsIT09YSYmWihhKX1mdW5jdGlvbiBFaShhLGIpe2lmKDM9PT1hLnRhZylXaihhLGEsYik7ZWxzZSBmb3IodmFyIGM9YS5yZXR1cm47bnVsbCE9PWM7KXtpZigzPT09Yy50YWcpe1dqKGMsYSxiKTticmVha31lbHNlIGlmKDE9PT1jLnRhZyl7dmFyIGQ9Yy5zdGF0ZU5vZGU7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGMudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3J8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudERpZENhdGNoJiYobnVsbD09PWFqfHwhYWouaGFzKGQpKSl7YT1BaShiLGEpO2E9JGkoYyxhLDEwNzM3NDE4MjMpO3hnKGMsYSk7Yz14aihjLDEwNzM3NDE4MjMpO251bGwhPT1jJiZaKGMpO2JyZWFrfX1jPWMucmV0dXJufX1cbmZ1bmN0aW9uIE9qKGEsYixjKXt2YXIgZD1hLnBpbmdDYWNoZTtudWxsIT09ZCYmZC5kZWxldGUoYik7VD09PWEmJlU9PT1jP1M9PT12aXx8Uz09PXVpJiYxMDczNzQxODIzPT09bGomJiRmKCktVGk8cGo/RWooYSxVKTpvaj0hMDpBaihhLGMpJiYoYj1hLmxhc3RQaW5nZWRUaW1lLDAhPT1iJiZiPGN8fChhLmxhc3RQaW5nZWRUaW1lPWMsWihhKSkpfWZ1bmN0aW9uIFZpKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7bnVsbCE9PWMmJmMuZGVsZXRlKGIpO2I9MDswPT09YiYmKGI9R2coKSxiPUhnKGIsYSxudWxsKSk7YT14aihhLGIpO251bGwhPT1hJiZaKGEpfXZhciBSajtcblJqPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1iLmV4cGlyYXRpb25UaW1lO2lmKG51bGwhPT1hKXt2YXIgZT1iLnBlbmRpbmdQcm9wcztpZihhLm1lbW9pemVkUHJvcHMhPT1lfHxLLmN1cnJlbnQpcmc9ITA7ZWxzZXtpZihkPGMpe3JnPSExO3N3aXRjaChiLnRhZyl7Y2FzZSAzOmhpKGIpO1hoKCk7YnJlYWs7Y2FzZSA1OmZoKGIpO2lmKGIubW9kZSY0JiYxIT09YyYmZS5oaWRkZW4pcmV0dXJuIGIuZXhwaXJhdGlvblRpbWU9Yi5jaGlsZEV4cGlyYXRpb25UaW1lPTEsbnVsbDticmVhaztjYXNlIDE6TChiLnR5cGUpJiZHZihiKTticmVhaztjYXNlIDQ6ZGgoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTticmVhaztjYXNlIDEwOmQ9Yi5tZW1vaXplZFByb3BzLnZhbHVlO2U9Yi50eXBlLl9jb250ZXh0O0koamcsZS5fY3VycmVudFZhbHVlKTtlLl9jdXJyZW50VmFsdWU9ZDticmVhaztjYXNlIDEzOmlmKG51bGwhPT1iLm1lbW9pemVkU3RhdGUpe2Q9Yi5jaGlsZC5jaGlsZEV4cGlyYXRpb25UaW1lO1xuaWYoMCE9PWQmJmQ+PWMpcmV0dXJuIGppKGEsYixjKTtJKE0sTS5jdXJyZW50JjEpO2I9JGgoYSxiLGMpO3JldHVybiBudWxsIT09Yj9iLnNpYmxpbmc6bnVsbH1JKE0sTS5jdXJyZW50JjEpO2JyZWFrO2Nhc2UgMTk6ZD1iLmNoaWxkRXhwaXJhdGlvblRpbWU+PWM7aWYoMCE9PShhLmVmZmVjdFRhZyY2NCkpe2lmKGQpcmV0dXJuIG1pKGEsYixjKTtiLmVmZmVjdFRhZ3w9NjR9ZT1iLm1lbW9pemVkU3RhdGU7bnVsbCE9PWUmJihlLnJlbmRlcmluZz1udWxsLGUudGFpbD1udWxsKTtJKE0sTS5jdXJyZW50KTtpZighZClyZXR1cm4gbnVsbH1yZXR1cm4gJGgoYSxiLGMpfXJnPSExfX1lbHNlIHJnPSExO2IuZXhwaXJhdGlvblRpbWU9MDtzd2l0Y2goYi50YWcpe2Nhc2UgMjpkPWIudHlwZTtudWxsIT09YSYmKGEuYWx0ZXJuYXRlPW51bGwsYi5hbHRlcm5hdGU9bnVsbCxiLmVmZmVjdFRhZ3w9Mik7YT1iLnBlbmRpbmdQcm9wcztlPUNmKGIsSi5jdXJyZW50KTtxZyhiLGMpO2U9b2gobnVsbCxcbmIsZCxhLGUsYyk7Yi5lZmZlY3RUYWd8PTE7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBlJiZudWxsIT09ZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGUucmVuZGVyJiZ2b2lkIDA9PT1lLiQkdHlwZW9mKXtiLnRhZz0xO2IubWVtb2l6ZWRTdGF0ZT1udWxsO2IudXBkYXRlUXVldWU9bnVsbDtpZihMKGQpKXt2YXIgZj0hMDtHZihiKX1lbHNlIGY9ITE7Yi5tZW1vaXplZFN0YXRlPW51bGwhPT1lLnN0YXRlJiZ2b2lkIDAhPT1lLnN0YXRlP2Uuc3RhdGU6bnVsbDt1ZyhiKTt2YXIgZz1kLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcImZ1bmN0aW9uXCI9PT10eXBlb2YgZyYmRmcoYixkLGcsYSk7ZS51cGRhdGVyPUpnO2Iuc3RhdGVOb2RlPWU7ZS5fcmVhY3RJbnRlcm5hbEZpYmVyPWI7TmcoYixkLGEsYyk7Yj1naShudWxsLGIsZCwhMCxmLGMpfWVsc2UgYi50YWc9MCxSKG51bGwsYixlLGMpLGI9Yi5jaGlsZDtyZXR1cm4gYjtjYXNlIDE2OmE6e2U9Yi5lbGVtZW50VHlwZTtudWxsIT09YSYmKGEuYWx0ZXJuYXRlPVxubnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZWZmZWN0VGFnfD0yKTthPWIucGVuZGluZ1Byb3BzO29iKGUpO2lmKDEhPT1lLl9zdGF0dXMpdGhyb3cgZS5fcmVzdWx0O2U9ZS5fcmVzdWx0O2IudHlwZT1lO2Y9Yi50YWc9WGooZSk7YT1pZyhlLGEpO3N3aXRjaChmKXtjYXNlIDA6Yj1kaShudWxsLGIsZSxhLGMpO2JyZWFrIGE7Y2FzZSAxOmI9ZmkobnVsbCxiLGUsYSxjKTticmVhayBhO2Nhc2UgMTE6Yj1aaChudWxsLGIsZSxhLGMpO2JyZWFrIGE7Y2FzZSAxNDpiPWFpKG51bGwsYixlLGlnKGUudHlwZSxhKSxkLGMpO2JyZWFrIGF9dGhyb3cgRXJyb3IodSgzMDYsZSxcIlwiKSk7fXJldHVybiBiO2Nhc2UgMDpyZXR1cm4gZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxlPWIuZWxlbWVudFR5cGU9PT1kP2U6aWcoZCxlKSxkaShhLGIsZCxlLGMpO2Nhc2UgMTpyZXR1cm4gZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxlPWIuZWxlbWVudFR5cGU9PT1kP2U6aWcoZCxlKSxmaShhLGIsZCxlLGMpO1xuY2FzZSAzOmhpKGIpO2Q9Yi51cGRhdGVRdWV1ZTtpZihudWxsPT09YXx8bnVsbD09PWQpdGhyb3cgRXJyb3IodSgyODIpKTtkPWIucGVuZGluZ1Byb3BzO2U9Yi5tZW1vaXplZFN0YXRlO2U9bnVsbCE9PWU/ZS5lbGVtZW50Om51bGw7dmcoYSxiKTt6ZyhiLGQsbnVsbCxjKTtkPWIubWVtb2l6ZWRTdGF0ZS5lbGVtZW50O2lmKGQ9PT1lKVhoKCksYj0kaChhLGIsYyk7ZWxzZXtpZihlPWIuc3RhdGVOb2RlLmh5ZHJhdGUpUGg9SmQoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mby5maXJzdENoaWxkKSxPaD1iLGU9UWg9ITA7aWYoZSlmb3IoYz1ZZyhiLG51bGwsZCxjKSxiLmNoaWxkPWM7YzspYy5lZmZlY3RUYWc9Yy5lZmZlY3RUYWcmLTN8MTAyNCxjPWMuc2libGluZztlbHNlIFIoYSxiLGQsYyksWGgoKTtiPWIuY2hpbGR9cmV0dXJuIGI7Y2FzZSA1OnJldHVybiBmaChiKSxudWxsPT09YSYmVWgoYiksZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxmPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpcbm51bGwsZz1lLmNoaWxkcmVuLEdkKGQsZSk/Zz1udWxsOm51bGwhPT1mJiZHZChkLGYpJiYoYi5lZmZlY3RUYWd8PTE2KSxlaShhLGIpLGIubW9kZSY0JiYxIT09YyYmZS5oaWRkZW4/KGIuZXhwaXJhdGlvblRpbWU9Yi5jaGlsZEV4cGlyYXRpb25UaW1lPTEsYj1udWxsKTooUihhLGIsZyxjKSxiPWIuY2hpbGQpLGI7Y2FzZSA2OnJldHVybiBudWxsPT09YSYmVWgoYiksbnVsbDtjYXNlIDEzOnJldHVybiBqaShhLGIsYyk7Y2FzZSA0OnJldHVybiBkaChiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pLGQ9Yi5wZW5kaW5nUHJvcHMsbnVsbD09PWE/Yi5jaGlsZD1YZyhiLG51bGwsZCxjKTpSKGEsYixkLGMpLGIuY2hpbGQ7Y2FzZSAxMTpyZXR1cm4gZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxlPWIuZWxlbWVudFR5cGU9PT1kP2U6aWcoZCxlKSxaaChhLGIsZCxlLGMpO2Nhc2UgNzpyZXR1cm4gUihhLGIsYi5wZW5kaW5nUHJvcHMsYyksYi5jaGlsZDtjYXNlIDg6cmV0dXJuIFIoYSxcbmIsYi5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sYyksYi5jaGlsZDtjYXNlIDEyOnJldHVybiBSKGEsYixiLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixjKSxiLmNoaWxkO2Nhc2UgMTA6YTp7ZD1iLnR5cGUuX2NvbnRleHQ7ZT1iLnBlbmRpbmdQcm9wcztnPWIubWVtb2l6ZWRQcm9wcztmPWUudmFsdWU7dmFyIGg9Yi50eXBlLl9jb250ZXh0O0koamcsaC5fY3VycmVudFZhbHVlKTtoLl9jdXJyZW50VmFsdWU9ZjtpZihudWxsIT09ZylpZihoPWcudmFsdWUsZj0kZShoLGYpPzA6KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLl9jYWxjdWxhdGVDaGFuZ2VkQml0cz9kLl9jYWxjdWxhdGVDaGFuZ2VkQml0cyhoLGYpOjEwNzM3NDE4MjMpfDAsMD09PWYpe2lmKGcuY2hpbGRyZW49PT1lLmNoaWxkcmVuJiYhSy5jdXJyZW50KXtiPSRoKGEsYixjKTticmVhayBhfX1lbHNlIGZvcihoPWIuY2hpbGQsbnVsbCE9PWgmJihoLnJldHVybj1iKTtudWxsIT09aDspe3ZhciBrPWguZGVwZW5kZW5jaWVzO2lmKG51bGwhPT1cbmspe2c9aC5jaGlsZDtmb3IodmFyIGw9ay5maXJzdENvbnRleHQ7bnVsbCE9PWw7KXtpZihsLmNvbnRleHQ9PT1kJiYwIT09KGwub2JzZXJ2ZWRCaXRzJmYpKXsxPT09aC50YWcmJihsPXdnKGMsbnVsbCksbC50YWc9Mix4ZyhoLGwpKTtoLmV4cGlyYXRpb25UaW1lPGMmJihoLmV4cGlyYXRpb25UaW1lPWMpO2w9aC5hbHRlcm5hdGU7bnVsbCE9PWwmJmwuZXhwaXJhdGlvblRpbWU8YyYmKGwuZXhwaXJhdGlvblRpbWU9Yyk7cGcoaC5yZXR1cm4sYyk7ay5leHBpcmF0aW9uVGltZTxjJiYoay5leHBpcmF0aW9uVGltZT1jKTticmVha31sPWwubmV4dH19ZWxzZSBnPTEwPT09aC50YWc/aC50eXBlPT09Yi50eXBlP251bGw6aC5jaGlsZDpoLmNoaWxkO2lmKG51bGwhPT1nKWcucmV0dXJuPWg7ZWxzZSBmb3IoZz1oO251bGwhPT1nOyl7aWYoZz09PWIpe2c9bnVsbDticmVha31oPWcuc2libGluZztpZihudWxsIT09aCl7aC5yZXR1cm49Zy5yZXR1cm47Zz1oO2JyZWFrfWc9Zy5yZXR1cm59aD1cbmd9UihhLGIsZS5jaGlsZHJlbixjKTtiPWIuY2hpbGR9cmV0dXJuIGI7Y2FzZSA5OnJldHVybiBlPWIudHlwZSxmPWIucGVuZGluZ1Byb3BzLGQ9Zi5jaGlsZHJlbixxZyhiLGMpLGU9c2coZSxmLnVuc3RhYmxlX29ic2VydmVkQml0cyksZD1kKGUpLGIuZWZmZWN0VGFnfD0xLFIoYSxiLGQsYyksYi5jaGlsZDtjYXNlIDE0OnJldHVybiBlPWIudHlwZSxmPWlnKGUsYi5wZW5kaW5nUHJvcHMpLGY9aWcoZS50eXBlLGYpLGFpKGEsYixlLGYsZCxjKTtjYXNlIDE1OnJldHVybiBjaShhLGIsYi50eXBlLGIucGVuZGluZ1Byb3BzLGQsYyk7Y2FzZSAxNzpyZXR1cm4gZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxlPWIuZWxlbWVudFR5cGU9PT1kP2U6aWcoZCxlKSxudWxsIT09YSYmKGEuYWx0ZXJuYXRlPW51bGwsYi5hbHRlcm5hdGU9bnVsbCxiLmVmZmVjdFRhZ3w9MiksYi50YWc9MSxMKGQpPyhhPSEwLEdmKGIpKTphPSExLHFnKGIsYyksTGcoYixkLGUpLE5nKGIsZCxlLGMpLGdpKG51bGwsXG5iLGQsITAsYSxjKTtjYXNlIDE5OnJldHVybiBtaShhLGIsYyl9dGhyb3cgRXJyb3IodSgxNTYsYi50YWcpKTt9O3ZhciBVaj1udWxsLExpPW51bGw7ZnVuY3Rpb24gWWooYSl7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pcmV0dXJuITE7dmFyIGI9X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO2lmKGIuaXNEaXNhYmxlZHx8IWIuc3VwcG9ydHNGaWJlcilyZXR1cm4hMDt0cnl7dmFyIGM9Yi5pbmplY3QoYSk7VWo9ZnVuY3Rpb24oYSl7dHJ5e2Iub25Db21taXRGaWJlclJvb3QoYyxhLHZvaWQgMCw2ND09PShhLmN1cnJlbnQuZWZmZWN0VGFnJjY0KSl9Y2F0Y2goZSl7fX07TGk9ZnVuY3Rpb24oYSl7dHJ5e2Iub25Db21taXRGaWJlclVubW91bnQoYyxhKX1jYXRjaChlKXt9fX1jYXRjaChkKXt9cmV0dXJuITB9XG5mdW5jdGlvbiBaaihhLGIsYyxkKXt0aGlzLnRhZz1hO3RoaXMua2V5PWM7dGhpcy5zaWJsaW5nPXRoaXMuY2hpbGQ9dGhpcy5yZXR1cm49dGhpcy5zdGF0ZU5vZGU9dGhpcy50eXBlPXRoaXMuZWxlbWVudFR5cGU9bnVsbDt0aGlzLmluZGV4PTA7dGhpcy5yZWY9bnVsbDt0aGlzLnBlbmRpbmdQcm9wcz1iO3RoaXMuZGVwZW5kZW5jaWVzPXRoaXMubWVtb2l6ZWRTdGF0ZT10aGlzLnVwZGF0ZVF1ZXVlPXRoaXMubWVtb2l6ZWRQcm9wcz1udWxsO3RoaXMubW9kZT1kO3RoaXMuZWZmZWN0VGFnPTA7dGhpcy5sYXN0RWZmZWN0PXRoaXMuZmlyc3RFZmZlY3Q9dGhpcy5uZXh0RWZmZWN0PW51bGw7dGhpcy5jaGlsZEV4cGlyYXRpb25UaW1lPXRoaXMuZXhwaXJhdGlvblRpbWU9MDt0aGlzLmFsdGVybmF0ZT1udWxsfWZ1bmN0aW9uIFNoKGEsYixjLGQpe3JldHVybiBuZXcgWmooYSxiLGMsZCl9XG5mdW5jdGlvbiBiaShhKXthPWEucHJvdG90eXBlO3JldHVybiEoIWF8fCFhLmlzUmVhY3RDb21wb25lbnQpfWZ1bmN0aW9uIFhqKGEpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBiaShhKT8xOjA7aWYodm9pZCAwIT09YSYmbnVsbCE9PWEpe2E9YS4kJHR5cGVvZjtpZihhPT09Z2IpcmV0dXJuIDExO2lmKGE9PT1qYilyZXR1cm4gMTR9cmV0dXJuIDJ9XG5mdW5jdGlvbiBTZyhhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlO251bGw9PT1jPyhjPVNoKGEudGFnLGIsYS5rZXksYS5tb2RlKSxjLmVsZW1lbnRUeXBlPWEuZWxlbWVudFR5cGUsYy50eXBlPWEudHlwZSxjLnN0YXRlTm9kZT1hLnN0YXRlTm9kZSxjLmFsdGVybmF0ZT1hLGEuYWx0ZXJuYXRlPWMpOihjLnBlbmRpbmdQcm9wcz1iLGMuZWZmZWN0VGFnPTAsYy5uZXh0RWZmZWN0PW51bGwsYy5maXJzdEVmZmVjdD1udWxsLGMubGFzdEVmZmVjdD1udWxsKTtjLmNoaWxkRXhwaXJhdGlvblRpbWU9YS5jaGlsZEV4cGlyYXRpb25UaW1lO2MuZXhwaXJhdGlvblRpbWU9YS5leHBpcmF0aW9uVGltZTtjLmNoaWxkPWEuY2hpbGQ7Yy5tZW1vaXplZFByb3BzPWEubWVtb2l6ZWRQcm9wcztjLm1lbW9pemVkU3RhdGU9YS5tZW1vaXplZFN0YXRlO2MudXBkYXRlUXVldWU9YS51cGRhdGVRdWV1ZTtiPWEuZGVwZW5kZW5jaWVzO2MuZGVwZW5kZW5jaWVzPW51bGw9PT1iP251bGw6e2V4cGlyYXRpb25UaW1lOmIuZXhwaXJhdGlvblRpbWUsXG5maXJzdENvbnRleHQ6Yi5maXJzdENvbnRleHQscmVzcG9uZGVyczpiLnJlc3BvbmRlcnN9O2Muc2libGluZz1hLnNpYmxpbmc7Yy5pbmRleD1hLmluZGV4O2MucmVmPWEucmVmO3JldHVybiBjfVxuZnVuY3Rpb24gVWcoYSxiLGMsZCxlLGYpe3ZhciBnPTI7ZD1hO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKWJpKGEpJiYoZz0xKTtlbHNlIGlmKFwic3RyaW5nXCI9PT10eXBlb2YgYSlnPTU7ZWxzZSBhOnN3aXRjaChhKXtjYXNlIGFiOnJldHVybiBXZyhjLmNoaWxkcmVuLGUsZixiKTtjYXNlIGZiOmc9ODtlfD03O2JyZWFrO2Nhc2UgYmI6Zz04O2V8PTE7YnJlYWs7Y2FzZSBjYjpyZXR1cm4gYT1TaCgxMixjLGIsZXw4KSxhLmVsZW1lbnRUeXBlPWNiLGEudHlwZT1jYixhLmV4cGlyYXRpb25UaW1lPWYsYTtjYXNlIGhiOnJldHVybiBhPVNoKDEzLGMsYixlKSxhLnR5cGU9aGIsYS5lbGVtZW50VHlwZT1oYixhLmV4cGlyYXRpb25UaW1lPWYsYTtjYXNlIGliOnJldHVybiBhPVNoKDE5LGMsYixlKSxhLmVsZW1lbnRUeXBlPWliLGEuZXhwaXJhdGlvblRpbWU9ZixhO2RlZmF1bHQ6aWYoXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSlzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSBkYjpnPVxuMTA7YnJlYWsgYTtjYXNlIGViOmc9OTticmVhayBhO2Nhc2UgZ2I6Zz0xMTticmVhayBhO2Nhc2UgamI6Zz0xNDticmVhayBhO2Nhc2Uga2I6Zz0xNjtkPW51bGw7YnJlYWsgYTtjYXNlIGxiOmc9MjI7YnJlYWsgYX10aHJvdyBFcnJvcih1KDEzMCxudWxsPT1hP2E6dHlwZW9mIGEsXCJcIikpO31iPVNoKGcsYyxiLGUpO2IuZWxlbWVudFR5cGU9YTtiLnR5cGU9ZDtiLmV4cGlyYXRpb25UaW1lPWY7cmV0dXJuIGJ9ZnVuY3Rpb24gV2coYSxiLGMsZCl7YT1TaCg3LGEsZCxiKTthLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGF9ZnVuY3Rpb24gVGcoYSxiLGMpe2E9U2goNixhLG51bGwsYik7YS5leHBpcmF0aW9uVGltZT1jO3JldHVybiBhfVxuZnVuY3Rpb24gVmcoYSxiLGMpe2I9U2goNCxudWxsIT09YS5jaGlsZHJlbj9hLmNoaWxkcmVuOltdLGEua2V5LGIpO2IuZXhwaXJhdGlvblRpbWU9YztiLnN0YXRlTm9kZT17Y29udGFpbmVySW5mbzphLmNvbnRhaW5lckluZm8scGVuZGluZ0NoaWxkcmVuOm51bGwsaW1wbGVtZW50YXRpb246YS5pbXBsZW1lbnRhdGlvbn07cmV0dXJuIGJ9XG5mdW5jdGlvbiBhayhhLGIsYyl7dGhpcy50YWc9Yjt0aGlzLmN1cnJlbnQ9bnVsbDt0aGlzLmNvbnRhaW5lckluZm89YTt0aGlzLnBpbmdDYWNoZT10aGlzLnBlbmRpbmdDaGlsZHJlbj1udWxsO3RoaXMuZmluaXNoZWRFeHBpcmF0aW9uVGltZT0wO3RoaXMuZmluaXNoZWRXb3JrPW51bGw7dGhpcy50aW1lb3V0SGFuZGxlPS0xO3RoaXMucGVuZGluZ0NvbnRleHQ9dGhpcy5jb250ZXh0PW51bGw7dGhpcy5oeWRyYXRlPWM7dGhpcy5jYWxsYmFja05vZGU9bnVsbDt0aGlzLmNhbGxiYWNrUHJpb3JpdHk9OTA7dGhpcy5sYXN0RXhwaXJlZFRpbWU9dGhpcy5sYXN0UGluZ2VkVGltZT10aGlzLm5leHRLbm93blBlbmRpbmdMZXZlbD10aGlzLmxhc3RTdXNwZW5kZWRUaW1lPXRoaXMuZmlyc3RTdXNwZW5kZWRUaW1lPXRoaXMuZmlyc3RQZW5kaW5nVGltZT0wfVxuZnVuY3Rpb24gQWooYSxiKXt2YXIgYz1hLmZpcnN0U3VzcGVuZGVkVGltZTthPWEubGFzdFN1c3BlbmRlZFRpbWU7cmV0dXJuIDAhPT1jJiZjPj1iJiZhPD1ifWZ1bmN0aW9uIHhpKGEsYil7dmFyIGM9YS5maXJzdFN1c3BlbmRlZFRpbWUsZD1hLmxhc3RTdXNwZW5kZWRUaW1lO2M8YiYmKGEuZmlyc3RTdXNwZW5kZWRUaW1lPWIpO2lmKGQ+Ynx8MD09PWMpYS5sYXN0U3VzcGVuZGVkVGltZT1iO2I8PWEubGFzdFBpbmdlZFRpbWUmJihhLmxhc3RQaW5nZWRUaW1lPTApO2I8PWEubGFzdEV4cGlyZWRUaW1lJiYoYS5sYXN0RXhwaXJlZFRpbWU9MCl9XG5mdW5jdGlvbiB5aShhLGIpe2I+YS5maXJzdFBlbmRpbmdUaW1lJiYoYS5maXJzdFBlbmRpbmdUaW1lPWIpO3ZhciBjPWEuZmlyc3RTdXNwZW5kZWRUaW1lOzAhPT1jJiYoYj49Yz9hLmZpcnN0U3VzcGVuZGVkVGltZT1hLmxhc3RTdXNwZW5kZWRUaW1lPWEubmV4dEtub3duUGVuZGluZ0xldmVsPTA6Yj49YS5sYXN0U3VzcGVuZGVkVGltZSYmKGEubGFzdFN1c3BlbmRlZFRpbWU9YisxKSxiPmEubmV4dEtub3duUGVuZGluZ0xldmVsJiYoYS5uZXh0S25vd25QZW5kaW5nTGV2ZWw9YikpfWZ1bmN0aW9uIENqKGEsYil7dmFyIGM9YS5sYXN0RXhwaXJlZFRpbWU7aWYoMD09PWN8fGM+YilhLmxhc3RFeHBpcmVkVGltZT1ifVxuZnVuY3Rpb24gYmsoYSxiLGMsZCl7dmFyIGU9Yi5jdXJyZW50LGY9R2coKSxnPURnLnN1c3BlbnNlO2Y9SGcoZixlLGcpO2E6aWYoYyl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7Yjp7aWYoZGMoYykhPT1jfHwxIT09Yy50YWcpdGhyb3cgRXJyb3IodSgxNzApKTt2YXIgaD1jO2Rve3N3aXRjaChoLnRhZyl7Y2FzZSAzOmg9aC5zdGF0ZU5vZGUuY29udGV4dDticmVhayBiO2Nhc2UgMTppZihMKGgudHlwZSkpe2g9aC5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7YnJlYWsgYn19aD1oLnJldHVybn13aGlsZShudWxsIT09aCk7dGhyb3cgRXJyb3IodSgxNzEpKTt9aWYoMT09PWMudGFnKXt2YXIgaz1jLnR5cGU7aWYoTChrKSl7Yz1GZihjLGssaCk7YnJlYWsgYX19Yz1ofWVsc2UgYz1BZjtudWxsPT09Yi5jb250ZXh0P2IuY29udGV4dD1jOmIucGVuZGluZ0NvbnRleHQ9YztiPXdnKGYsZyk7Yi5wYXlsb2FkPXtlbGVtZW50OmF9O2Q9dm9pZCAwPT09XG5kP251bGw6ZDtudWxsIT09ZCYmKGIuY2FsbGJhY2s9ZCk7eGcoZSxiKTtJZyhlLGYpO3JldHVybiBmfWZ1bmN0aW9uIGNrKGEpe2E9YS5jdXJyZW50O2lmKCFhLmNoaWxkKXJldHVybiBudWxsO3N3aXRjaChhLmNoaWxkLnRhZyl7Y2FzZSA1OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZTtkZWZhdWx0OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZX19ZnVuY3Rpb24gZGsoYSxiKXthPWEubWVtb2l6ZWRTdGF0ZTtudWxsIT09YSYmbnVsbCE9PWEuZGVoeWRyYXRlZCYmYS5yZXRyeVRpbWU8YiYmKGEucmV0cnlUaW1lPWIpfWZ1bmN0aW9uIGVrKGEsYil7ZGsoYSxiKTsoYT1hLmFsdGVybmF0ZSkmJmRrKGEsYil9XG5mdW5jdGlvbiBmayhhLGIsYyl7Yz1udWxsIT1jJiYhMD09PWMuaHlkcmF0ZTt2YXIgZD1uZXcgYWsoYSxiLGMpLGU9U2goMyxudWxsLG51bGwsMj09PWI/NzoxPT09Yj8zOjApO2QuY3VycmVudD1lO2Uuc3RhdGVOb2RlPWQ7dWcoZSk7YVtPZF09ZC5jdXJyZW50O2MmJjAhPT1iJiZKYyhhLDk9PT1hLm5vZGVUeXBlP2E6YS5vd25lckRvY3VtZW50KTt0aGlzLl9pbnRlcm5hbFJvb3Q9ZH1may5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGEpe2JrKGEsdGhpcy5faW50ZXJuYWxSb290LG51bGwsbnVsbCl9O2ZrLnByb3RvdHlwZS51bm1vdW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5faW50ZXJuYWxSb290LGI9YS5jb250YWluZXJJbmZvO2JrKG51bGwsYSxudWxsLGZ1bmN0aW9uKCl7YltPZF09bnVsbH0pfTtcbmZ1bmN0aW9uIGdrKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlJiYoOCE9PWEubm9kZVR5cGV8fFwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlIFwiIT09YS5ub2RlVmFsdWUpKX1mdW5jdGlvbiBoayhhLGIpe2J8fChiPWE/OT09PWEubm9kZVR5cGU/YS5kb2N1bWVudEVsZW1lbnQ6YS5maXJzdENoaWxkOm51bGwsYj0hKCFifHwxIT09Yi5ub2RlVHlwZXx8IWIuaGFzQXR0cmlidXRlKFwiZGF0YS1yZWFjdHJvb3RcIikpKTtpZighYilmb3IodmFyIGM7Yz1hLmxhc3RDaGlsZDspYS5yZW1vdmVDaGlsZChjKTtyZXR1cm4gbmV3IGZrKGEsMCxiP3toeWRyYXRlOiEwfTp2b2lkIDApfVxuZnVuY3Rpb24gaWsoYSxiLGMsZCxlKXt2YXIgZj1jLl9yZWFjdFJvb3RDb250YWluZXI7aWYoZil7dmFyIGc9Zi5faW50ZXJuYWxSb290O2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlKXt2YXIgaD1lO2U9ZnVuY3Rpb24oKXt2YXIgYT1jayhnKTtoLmNhbGwoYSl9fWJrKGIsZyxhLGUpfWVsc2V7Zj1jLl9yZWFjdFJvb3RDb250YWluZXI9aGsoYyxkKTtnPWYuX2ludGVybmFsUm9vdDtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZSl7dmFyIGs9ZTtlPWZ1bmN0aW9uKCl7dmFyIGE9Y2soZyk7ay5jYWxsKGEpfX1OaihmdW5jdGlvbigpe2JrKGIsZyxhLGUpfSl9cmV0dXJuIGNrKGcpfWZ1bmN0aW9uIGprKGEsYixjKXt2YXIgZD0zPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106bnVsbDtyZXR1cm57JCR0eXBlb2Y6JGEsa2V5Om51bGw9PWQ/bnVsbDpcIlwiK2QsY2hpbGRyZW46YSxjb250YWluZXJJbmZvOmIsaW1wbGVtZW50YXRpb246Y319XG53Yz1mdW5jdGlvbihhKXtpZigxMz09PWEudGFnKXt2YXIgYj1oZyhHZygpLDE1MCwxMDApO0lnKGEsYik7ZWsoYSxiKX19O3hjPWZ1bmN0aW9uKGEpezEzPT09YS50YWcmJihJZyhhLDMpLGVrKGEsMykpfTt5Yz1mdW5jdGlvbihhKXtpZigxMz09PWEudGFnKXt2YXIgYj1HZygpO2I9SGcoYixhLG51bGwpO0lnKGEsYik7ZWsoYSxiKX19O1xuemE9ZnVuY3Rpb24oYSxiLGMpe3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpDYihhLGMpO2I9Yy5uYW1lO2lmKFwicmFkaW9cIj09PWMudHlwZSYmbnVsbCE9Yil7Zm9yKGM9YTtjLnBhcmVudE5vZGU7KWM9Yy5wYXJlbnROb2RlO2M9Yy5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRbbmFtZT1cIitKU09OLnN0cmluZ2lmeShcIlwiK2IpKyddW3R5cGU9XCJyYWRpb1wiXScpO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspe3ZhciBkPWNbYl07aWYoZCE9PWEmJmQuZm9ybT09PWEuZm9ybSl7dmFyIGU9UWQoZCk7aWYoIWUpdGhyb3cgRXJyb3IodSg5MCkpO3liKGQpO0NiKGQsZSl9fX1icmVhaztjYXNlIFwidGV4dGFyZWFcIjpLYihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpiPWMudmFsdWUsbnVsbCE9YiYmSGIoYSwhIWMubXVsdGlwbGUsYiwhMSl9fTtGYT1NajtcbkdhPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9VztXfD00O3RyeXtyZXR1cm4gY2coOTgsYS5iaW5kKG51bGwsYixjLGQsZSkpfWZpbmFsbHl7Vz1mLFc9PT1WJiZnZygpfX07SGE9ZnVuY3Rpb24oKXsoVyYoMXxmanxnaikpPT09ViYmKExqKCksRGooKSl9O0lhPWZ1bmN0aW9uKGEsYil7dmFyIGM9VztXfD0yO3RyeXtyZXR1cm4gYShiKX1maW5hbGx5e1c9YyxXPT09ViYmZ2coKX19O2Z1bmN0aW9uIGtrKGEsYil7dmFyIGM9Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGw7aWYoIWdrKGIpKXRocm93IEVycm9yKHUoMjAwKSk7cmV0dXJuIGprKGEsYixudWxsLGMpfXZhciBsaz17RXZlbnRzOltOYyxQZCxRZCx4YSx0YSxYZCxmdW5jdGlvbihhKXtqYyhhLFdkKX0sRGEsRWEsaWQsbWMsRGose2N1cnJlbnQ6ITF9XX07XG4oZnVuY3Rpb24oYSl7dmFyIGI9YS5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtyZXR1cm4gWWoobih7fSxhLHtvdmVycmlkZUhvb2tTdGF0ZTpudWxsLG92ZXJyaWRlUHJvcHM6bnVsbCxzZXRTdXNwZW5zZUhhbmRsZXI6bnVsbCxzY2hlZHVsZVVwZGF0ZTpudWxsLGN1cnJlbnREaXNwYXRjaGVyUmVmOldhLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oYSl7YT1oYyhhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX0sZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGI/YihhKTpudWxsfSxmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2g6bnVsbCxzY2hlZHVsZVJlZnJlc2g6bnVsbCxzY2hlZHVsZVJvb3Q6bnVsbCxzZXRSZWZyZXNoSGFuZGxlcjpudWxsLGdldEN1cnJlbnRGaWJlcjpudWxsfSkpfSkoe2ZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOnRjLGJ1bmRsZVR5cGU6MCx2ZXJzaW9uOlwiMTYuMTMuMVwiLFxucmVuZGVyZXJQYWNrYWdlTmFtZTpcInJlYWN0LWRvbVwifSk7ZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRD1saztleHBvcnRzLmNyZWF0ZVBvcnRhbD1raztleHBvcnRzLmZpbmRET01Ob2RlPWZ1bmN0aW9uKGEpe2lmKG51bGw9PWEpcmV0dXJuIG51bGw7aWYoMT09PWEubm9kZVR5cGUpcmV0dXJuIGE7dmFyIGI9YS5fcmVhY3RJbnRlcm5hbEZpYmVyO2lmKHZvaWQgMD09PWIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnJlbmRlcil0aHJvdyBFcnJvcih1KDE4OCkpO3Rocm93IEVycm9yKHUoMjY4LE9iamVjdC5rZXlzKGEpKSk7fWE9aGMoYik7YT1udWxsPT09YT9udWxsOmEuc3RhdGVOb2RlO3JldHVybiBhfTtcbmV4cG9ydHMuZmx1c2hTeW5jPWZ1bmN0aW9uKGEsYil7aWYoKFcmKGZqfGdqKSkhPT1WKXRocm93IEVycm9yKHUoMTg3KSk7dmFyIGM9VztXfD0xO3RyeXtyZXR1cm4gY2coOTksYS5iaW5kKG51bGwsYikpfWZpbmFsbHl7Vz1jLGdnKCl9fTtleHBvcnRzLmh5ZHJhdGU9ZnVuY3Rpb24oYSxiLGMpe2lmKCFnayhiKSl0aHJvdyBFcnJvcih1KDIwMCkpO3JldHVybiBpayhudWxsLGEsYiwhMCxjKX07ZXhwb3J0cy5yZW5kZXI9ZnVuY3Rpb24oYSxiLGMpe2lmKCFnayhiKSl0aHJvdyBFcnJvcih1KDIwMCkpO3JldHVybiBpayhudWxsLGEsYiwhMSxjKX07XG5leHBvcnRzLnVubW91bnRDb21wb25lbnRBdE5vZGU9ZnVuY3Rpb24oYSl7aWYoIWdrKGEpKXRocm93IEVycm9yKHUoNDApKTtyZXR1cm4gYS5fcmVhY3RSb290Q29udGFpbmVyPyhOaihmdW5jdGlvbigpe2lrKG51bGwsbnVsbCxhLCExLGZ1bmN0aW9uKCl7YS5fcmVhY3RSb290Q29udGFpbmVyPW51bGw7YVtPZF09bnVsbH0pfSksITApOiExfTtleHBvcnRzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzPU1qO2V4cG9ydHMudW5zdGFibGVfY3JlYXRlUG9ydGFsPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGtrKGEsYiwyPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbCl9O1xuZXhwb3J0cy51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcj1mdW5jdGlvbihhLGIsYyxkKXtpZighZ2soYykpdGhyb3cgRXJyb3IodSgyMDApKTtpZihudWxsPT1hfHx2b2lkIDA9PT1hLl9yZWFjdEludGVybmFsRmliZXIpdGhyb3cgRXJyb3IodSgzOCkpO3JldHVybiBpayhhLGIsYywhMSxkKX07ZXhwb3J0cy52ZXJzaW9uPVwiMTYuMTMuMVwiO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///34\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(36);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzPzQwMjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUVBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35\n")},function(module,exports,__webpack_require__){"use strict";eval('/** @license React v0.19.1\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar f,g,h,k,l;\nif("undefined"===typeof window||"function"!==typeof MessageChannel){var p=null,q=null,t=function(){if(null!==p)try{var a=exports.unstable_now();p(!0,a);p=null}catch(b){throw setTimeout(t,0),b;}},u=Date.now();exports.unstable_now=function(){return Date.now()-u};f=function(a){null!==p?setTimeout(f,0,a):(p=a,setTimeout(t,0))};g=function(a,b){q=setTimeout(a,b)};h=function(){clearTimeout(q)};k=function(){return!1};l=exports.unstable_forceFrameRate=function(){}}else{var w=window.performance,x=window.Date,\ny=window.setTimeout,z=window.clearTimeout;if("undefined"!==typeof console){var A=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn\'t support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");"function"!==typeof A&&console.error("This browser doesn\'t support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills")}if("object"===\ntypeof w&&"function"===typeof w.now)exports.unstable_now=function(){return w.now()};else{var B=x.now();exports.unstable_now=function(){return x.now()-B}}var C=!1,D=null,E=-1,F=5,G=0;k=function(){return exports.unstable_now()>=G};l=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):F=0<a?Math.floor(1E3/a):5};var H=new MessageChannel,I=H.port2;H.port1.onmessage=\nfunction(){if(null!==D){var a=exports.unstable_now();G=a+F;try{D(!0,a)?I.postMessage(null):(C=!1,D=null)}catch(b){throw I.postMessage(null),b;}}else C=!1};f=function(a){D=a;C||(C=!0,I.postMessage(null))};g=function(a,b){E=y(function(){a(exports.unstable_now())},b)};h=function(){z(E);E=-1}}function J(a,b){var c=a.length;a.push(b);a:for(;;){var d=c-1>>>1,e=a[d];if(void 0!==e&&0<K(e,b))a[d]=b,a[c]=e,c=d;else break a}}function L(a){a=a[0];return void 0===a?null:a}\nfunction M(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>K(n,c))void 0!==r&&0>K(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>K(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function K(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var N=[],O=[],P=1,Q=null,R=3,S=!1,T=!1,U=!1;\nfunction V(a){for(var b=L(O);null!==b;){if(null===b.callback)M(O);else if(b.startTime<=a)M(O),b.sortIndex=b.expirationTime,J(N,b);else break;b=L(O)}}function W(a){U=!1;V(a);if(!T)if(null!==L(N))T=!0,f(X);else{var b=L(O);null!==b&&g(W,b.startTime-a)}}\nfunction X(a,b){T=!1;U&&(U=!1,h());S=!0;var c=R;try{V(b);for(Q=L(N);null!==Q&&(!(Q.expirationTime>b)||a&&!k());){var d=Q.callback;if(null!==d){Q.callback=null;R=Q.priorityLevel;var e=d(Q.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?Q.callback=e:Q===L(N)&&M(N);V(b)}else M(N);Q=L(N)}if(null!==Q)var m=!0;else{var n=L(O);null!==n&&g(W,n.startTime-b);m=!1}return m}finally{Q=null,R=c,S=!1}}\nfunction Y(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var Z=l;exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){T||S||(T=!0,f(X))};\nexports.unstable_getCurrentPriorityLevel=function(){return R};exports.unstable_getFirstCallbackNode=function(){return L(N)};exports.unstable_next=function(a){switch(R){case 1:case 2:case 3:var b=3;break;default:b=R}var c=R;R=b;try{return a()}finally{R=c}};exports.unstable_pauseExecution=function(){};exports.unstable_requestPaint=Z;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=R;R=a;try{return b()}finally{R=c}};\nexports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();if("object"===typeof c&&null!==c){var e=c.delay;e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:Y(a)}else c=Y(a),e=d;c=e+c;a={id:P++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,J(O,a),null===L(N)&&a===L(O)&&(U?h():U=!0,g(W,e-d))):(a.sortIndex=c,J(N,a),T||S||(T=!0,f(X)));return a};\nexports.unstable_shouldYield=function(){var a=exports.unstable_now();V(a);var b=L(N);return b!==Q&&null!==Q&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<Q.expirationTime||k()};exports.unstable_wrapCallback=function(a){var b=R;return function(){var c=R;R=b;try{return a.apply(this,arguments)}finally{R=c}}};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanM/ZmIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMTkuMVxuICogc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO3ZhciBmLGcsaCxrLGw7XG5pZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvd3x8XCJmdW5jdGlvblwiIT09dHlwZW9mIE1lc3NhZ2VDaGFubmVsKXt2YXIgcD1udWxsLHE9bnVsbCx0PWZ1bmN0aW9uKCl7aWYobnVsbCE9PXApdHJ5e3ZhciBhPWV4cG9ydHMudW5zdGFibGVfbm93KCk7cCghMCxhKTtwPW51bGx9Y2F0Y2goYil7dGhyb3cgc2V0VGltZW91dCh0LDApLGI7fX0sdT1EYXRlLm5vdygpO2V4cG9ydHMudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCktdX07Zj1mdW5jdGlvbihhKXtudWxsIT09cD9zZXRUaW1lb3V0KGYsMCxhKToocD1hLHNldFRpbWVvdXQodCwwKSl9O2c9ZnVuY3Rpb24oYSxiKXtxPXNldFRpbWVvdXQoYSxiKX07aD1mdW5jdGlvbigpe2NsZWFyVGltZW91dChxKX07az1mdW5jdGlvbigpe3JldHVybiExfTtsPWV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGU9ZnVuY3Rpb24oKXt9fWVsc2V7dmFyIHc9d2luZG93LnBlcmZvcm1hbmNlLHg9d2luZG93LkRhdGUsXG55PXdpbmRvdy5zZXRUaW1lb3V0LHo9d2luZG93LmNsZWFyVGltZW91dDtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUpe3ZhciBBPXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZTtcImZ1bmN0aW9uXCIhPT10eXBlb2Ygd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSYmY29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhIHBvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL2ZiLm1lL3JlYWN0LXBvbHlmaWxsc1wiKTtcImZ1bmN0aW9uXCIhPT10eXBlb2YgQSYmY29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgY2FuY2VsQW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgcG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vZmIubWUvcmVhY3QtcG9seWZpbGxzXCIpfWlmKFwib2JqZWN0XCI9PT1cbnR5cGVvZiB3JiZcImZ1bmN0aW9uXCI9PT10eXBlb2Ygdy5ub3cpZXhwb3J0cy51bnN0YWJsZV9ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gdy5ub3coKX07ZWxzZXt2YXIgQj14Lm5vdygpO2V4cG9ydHMudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIHgubm93KCktQn19dmFyIEM9ITEsRD1udWxsLEU9LTEsRj01LEc9MDtrPWZ1bmN0aW9uKCl7cmV0dXJuIGV4cG9ydHMudW5zdGFibGVfbm93KCk+PUd9O2w9ZnVuY3Rpb24oKXt9O2V4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGU9ZnVuY3Rpb24oYSl7MD5hfHwxMjU8YT9jb25zb2xlLmVycm9yKFwiZm9yY2VGcmFtZVJhdGUgdGFrZXMgYSBwb3NpdGl2ZSBpbnQgYmV0d2VlbiAwIGFuZCAxMjUsIGZvcmNpbmcgZnJhbWVyYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCB1bnN1cHBvcnRlZFwiKTpGPTA8YT9NYXRoLmZsb29yKDFFMy9hKTo1fTt2YXIgSD1uZXcgTWVzc2FnZUNoYW5uZWwsST1ILnBvcnQyO0gucG9ydDEub25tZXNzYWdlPVxuZnVuY3Rpb24oKXtpZihudWxsIT09RCl7dmFyIGE9ZXhwb3J0cy51bnN0YWJsZV9ub3coKTtHPWErRjt0cnl7RCghMCxhKT9JLnBvc3RNZXNzYWdlKG51bGwpOihDPSExLEQ9bnVsbCl9Y2F0Y2goYil7dGhyb3cgSS5wb3N0TWVzc2FnZShudWxsKSxiO319ZWxzZSBDPSExfTtmPWZ1bmN0aW9uKGEpe0Q9YTtDfHwoQz0hMCxJLnBvc3RNZXNzYWdlKG51bGwpKX07Zz1mdW5jdGlvbihhLGIpe0U9eShmdW5jdGlvbigpe2EoZXhwb3J0cy51bnN0YWJsZV9ub3coKSl9LGIpfTtoPWZ1bmN0aW9uKCl7eihFKTtFPS0xfX1mdW5jdGlvbiBKKGEsYil7dmFyIGM9YS5sZW5ndGg7YS5wdXNoKGIpO2E6Zm9yKDs7KXt2YXIgZD1jLTE+Pj4xLGU9YVtkXTtpZih2b2lkIDAhPT1lJiYwPEsoZSxiKSlhW2RdPWIsYVtjXT1lLGM9ZDtlbHNlIGJyZWFrIGF9fWZ1bmN0aW9uIEwoYSl7YT1hWzBdO3JldHVybiB2b2lkIDA9PT1hP251bGw6YX1cbmZ1bmN0aW9uIE0oYSl7dmFyIGI9YVswXTtpZih2b2lkIDAhPT1iKXt2YXIgYz1hLnBvcCgpO2lmKGMhPT1iKXthWzBdPWM7YTpmb3IodmFyIGQ9MCxlPWEubGVuZ3RoO2Q8ZTspe3ZhciBtPTIqKGQrMSktMSxuPWFbbV0sdj1tKzEscj1hW3ZdO2lmKHZvaWQgMCE9PW4mJjA+SyhuLGMpKXZvaWQgMCE9PXImJjA+SyhyLG4pPyhhW2RdPXIsYVt2XT1jLGQ9dik6KGFbZF09bixhW21dPWMsZD1tKTtlbHNlIGlmKHZvaWQgMCE9PXImJjA+SyhyLGMpKWFbZF09cixhW3ZdPWMsZD12O2Vsc2UgYnJlYWsgYX19cmV0dXJuIGJ9cmV0dXJuIG51bGx9ZnVuY3Rpb24gSyhhLGIpe3ZhciBjPWEuc29ydEluZGV4LWIuc29ydEluZGV4O3JldHVybiAwIT09Yz9jOmEuaWQtYi5pZH12YXIgTj1bXSxPPVtdLFA9MSxRPW51bGwsUj0zLFM9ITEsVD0hMSxVPSExO1xuZnVuY3Rpb24gVihhKXtmb3IodmFyIGI9TChPKTtudWxsIT09Yjspe2lmKG51bGw9PT1iLmNhbGxiYWNrKU0oTyk7ZWxzZSBpZihiLnN0YXJ0VGltZTw9YSlNKE8pLGIuc29ydEluZGV4PWIuZXhwaXJhdGlvblRpbWUsSihOLGIpO2Vsc2UgYnJlYWs7Yj1MKE8pfX1mdW5jdGlvbiBXKGEpe1U9ITE7VihhKTtpZighVClpZihudWxsIT09TChOKSlUPSEwLGYoWCk7ZWxzZXt2YXIgYj1MKE8pO251bGwhPT1iJiZnKFcsYi5zdGFydFRpbWUtYSl9fVxuZnVuY3Rpb24gWChhLGIpe1Q9ITE7VSYmKFU9ITEsaCgpKTtTPSEwO3ZhciBjPVI7dHJ5e1YoYik7Zm9yKFE9TChOKTtudWxsIT09USYmKCEoUS5leHBpcmF0aW9uVGltZT5iKXx8YSYmIWsoKSk7KXt2YXIgZD1RLmNhbGxiYWNrO2lmKG51bGwhPT1kKXtRLmNhbGxiYWNrPW51bGw7Uj1RLnByaW9yaXR5TGV2ZWw7dmFyIGU9ZChRLmV4cGlyYXRpb25UaW1lPD1iKTtiPWV4cG9ydHMudW5zdGFibGVfbm93KCk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGU/US5jYWxsYmFjaz1lOlE9PT1MKE4pJiZNKE4pO1YoYil9ZWxzZSBNKE4pO1E9TChOKX1pZihudWxsIT09USl2YXIgbT0hMDtlbHNle3ZhciBuPUwoTyk7bnVsbCE9PW4mJmcoVyxuLnN0YXJ0VGltZS1iKTttPSExfXJldHVybiBtfWZpbmFsbHl7UT1udWxsLFI9YyxTPSExfX1cbmZ1bmN0aW9uIFkoYSl7c3dpdGNoKGEpe2Nhc2UgMTpyZXR1cm4tMTtjYXNlIDI6cmV0dXJuIDI1MDtjYXNlIDU6cmV0dXJuIDEwNzM3NDE4MjM7Y2FzZSA0OnJldHVybiAxRTQ7ZGVmYXVsdDpyZXR1cm4gNUUzfX12YXIgWj1sO2V4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5PTU7ZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eT0xO2V4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHk9NDtleHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5PTM7ZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmc9bnVsbDtleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5PTI7ZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaz1mdW5jdGlvbihhKXthLmNhbGxiYWNrPW51bGx9O2V4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb249ZnVuY3Rpb24oKXtUfHxTfHwoVD0hMCxmKFgpKX07XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsPWZ1bmN0aW9uKCl7cmV0dXJuIFJ9O2V4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gTChOKX07ZXhwb3J0cy51bnN0YWJsZV9uZXh0PWZ1bmN0aW9uKGEpe3N3aXRjaChSKXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzp2YXIgYj0zO2JyZWFrO2RlZmF1bHQ6Yj1SfXZhciBjPVI7Uj1iO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7Uj1jfX07ZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbj1mdW5jdGlvbigpe307ZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQ9WjtleHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eT1mdW5jdGlvbihhLGIpe3N3aXRjaChhKXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmJyZWFrO2RlZmF1bHQ6YT0zfXZhciBjPVI7Uj1hO3RyeXtyZXR1cm4gYigpfWZpbmFsbHl7Uj1jfX07XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWV4cG9ydHMudW5zdGFibGVfbm93KCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7dmFyIGU9Yy5kZWxheTtlPVwibnVtYmVyXCI9PT10eXBlb2YgZSYmMDxlP2QrZTpkO2M9XCJudW1iZXJcIj09PXR5cGVvZiBjLnRpbWVvdXQ/Yy50aW1lb3V0OlkoYSl9ZWxzZSBjPVkoYSksZT1kO2M9ZStjO2E9e2lkOlArKyxjYWxsYmFjazpiLHByaW9yaXR5TGV2ZWw6YSxzdGFydFRpbWU6ZSxleHBpcmF0aW9uVGltZTpjLHNvcnRJbmRleDotMX07ZT5kPyhhLnNvcnRJbmRleD1lLEooTyxhKSxudWxsPT09TChOKSYmYT09PUwoTykmJihVP2goKTpVPSEwLGcoVyxlLWQpKSk6KGEuc29ydEluZGV4PWMsSihOLGEpLFR8fFN8fChUPSEwLGYoWCkpKTtyZXR1cm4gYX07XG5leHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkPWZ1bmN0aW9uKCl7dmFyIGE9ZXhwb3J0cy51bnN0YWJsZV9ub3coKTtWKGEpO3ZhciBiPUwoTik7cmV0dXJuIGIhPT1RJiZudWxsIT09USYmbnVsbCE9PWImJm51bGwhPT1iLmNhbGxiYWNrJiZiLnN0YXJ0VGltZTw9YSYmYi5leHBpcmF0aW9uVGltZTxRLmV4cGlyYXRpb25UaW1lfHxrKCl9O2V4cG9ydHMudW5zdGFibGVfd3JhcENhbGxiYWNrPWZ1bmN0aW9uKGEpe3ZhciBiPVI7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9UjtSPWI7dHJ5e3JldHVybiBhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5hbGx5e1I9Y319fTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///36\n')},function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = __webpack_require__(38);\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanM/ZDdhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0KCkge31cbmVtcHR5RnVuY3Rpb25XaXRoUmVzZXQucmVzZXRXYXJuaW5nQ2FjaGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgdGhyb3cgZXJyO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgZWxlbWVudFR5cGU6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbSxcblxuICAgIGNoZWNrUHJvcFR5cGVzOiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0LFxuICAgIHJlc2V0V2FybmluZ0NhY2hlOiBlbXB0eUZ1bmN0aW9uXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///37\n")},function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/NTliMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///38\n")},function(module,exports,__webpack_require__){"use strict";eval('/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?\nSymbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;\nfunction z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;\nexports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};\nexports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};\nexports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzP2E5M2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0Jzt2YXIgYj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yLGM9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyxkPWI/U3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTo2MDEwNixlPWI/U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LGY9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik6NjAxMDgsZz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTo2MDExNCxoPWI/U3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpOjYwMTA5LGs9Yj9TeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKTo2MDExMCxsPWI/U3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIik6NjAxMTEsbT1iP1N5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIik6NjAxMTEsbj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTo2MDExMixwPWI/U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpOjYwMTEzLHE9Yj9cblN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpOjYwMTIwLHI9Yj9TeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTo2MDExNSx0PWI/U3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik6NjAxMTYsdj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKTo2MDEyMSx3PWI/U3ltYm9sLmZvcihcInJlYWN0LmZ1bmRhbWVudGFsXCIpOjYwMTE3LHg9Yj9TeW1ib2wuZm9yKFwicmVhY3QucmVzcG9uZGVyXCIpOjYwMTE4LHk9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik6NjAxMTk7XG5mdW5jdGlvbiB6KGEpe2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEpe3ZhciB1PWEuJCR0eXBlb2Y7c3dpdGNoKHUpe2Nhc2UgYzpzd2l0Y2goYT1hLnR5cGUsYSl7Y2FzZSBsOmNhc2UgbTpjYXNlIGU6Y2FzZSBnOmNhc2UgZjpjYXNlIHA6cmV0dXJuIGE7ZGVmYXVsdDpzd2l0Y2goYT1hJiZhLiQkdHlwZW9mLGEpe2Nhc2UgazpjYXNlIG46Y2FzZSB0OmNhc2UgcjpjYXNlIGg6cmV0dXJuIGE7ZGVmYXVsdDpyZXR1cm4gdX19Y2FzZSBkOnJldHVybiB1fX19ZnVuY3Rpb24gQShhKXtyZXR1cm4geihhKT09PW19ZXhwb3J0cy5Bc3luY01vZGU9bDtleHBvcnRzLkNvbmN1cnJlbnRNb2RlPW07ZXhwb3J0cy5Db250ZXh0Q29uc3VtZXI9aztleHBvcnRzLkNvbnRleHRQcm92aWRlcj1oO2V4cG9ydHMuRWxlbWVudD1jO2V4cG9ydHMuRm9yd2FyZFJlZj1uO2V4cG9ydHMuRnJhZ21lbnQ9ZTtleHBvcnRzLkxhenk9dDtleHBvcnRzLk1lbW89cjtleHBvcnRzLlBvcnRhbD1kO1xuZXhwb3J0cy5Qcm9maWxlcj1nO2V4cG9ydHMuU3RyaWN0TW9kZT1mO2V4cG9ydHMuU3VzcGVuc2U9cDtleHBvcnRzLmlzQXN5bmNNb2RlPWZ1bmN0aW9uKGEpe3JldHVybiBBKGEpfHx6KGEpPT09bH07ZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlPUE7ZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lcj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWt9O2V4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1ofTtleHBvcnRzLmlzRWxlbWVudD1mdW5jdGlvbihhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09Y307ZXhwb3J0cy5pc0ZvcndhcmRSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1ufTtleHBvcnRzLmlzRnJhZ21lbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1lfTtleHBvcnRzLmlzTGF6eT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXR9O1xuZXhwb3J0cy5pc01lbW89ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1yfTtleHBvcnRzLmlzUG9ydGFsPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09ZH07ZXhwb3J0cy5pc1Byb2ZpbGVyPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09Z307ZXhwb3J0cy5pc1N0cmljdE1vZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1mfTtleHBvcnRzLmlzU3VzcGVuc2U9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1wfTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlPWZ1bmN0aW9uKGEpe3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGF8fGE9PT1lfHxhPT09bXx8YT09PWd8fGE9PT1mfHxhPT09cHx8YT09PXF8fFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJihhLiQkdHlwZW9mPT09dHx8YS4kJHR5cGVvZj09PXJ8fGEuJCR0eXBlb2Y9PT1ofHxhLiQkdHlwZW9mPT09a3x8YS4kJHR5cGVvZj09PW58fGEuJCR0eXBlb2Y9PT13fHxhLiQkdHlwZW9mPT09eHx8YS4kJHR5cGVvZj09PXl8fGEuJCR0eXBlb2Y9PT12KX07ZXhwb3J0cy50eXBlT2Y9ejtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39\n')},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///40\n')},function(module,exports){eval('module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, "loaded", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, "id", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, "exports", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanM/ODJiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XG5cdGlmICghb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///41\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Observable = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// === Symbol Support ===\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\n\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\n\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\nvar SymbolIterator = getSymbol('iterator');\nvar SymbolObservable = getSymbol('observable');\nvar SymbolSpecies = getSymbol('species'); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n  if (value == null) return undefined;\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({\n      type: type,\n      value: value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{\n      type: type,\n      value: value\n    }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription =\n/*#__PURE__*/\nfunction () {\n  function Subscription(observer, subscriber) {\n    _classCallCheck(this, Subscription);\n\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  _createClass(Subscription, [{\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      if (this._state !== 'closed') {\n        closeSubscription(this);\n        cleanupSubscription(this);\n      }\n    }\n  }, {\n    key: \"closed\",\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver =\n/*#__PURE__*/\nfunction () {\n  function SubscriptionObserver(subscription) {\n    _classCallCheck(this, SubscriptionObserver);\n\n    this._subscription = subscription;\n  }\n\n  _createClass(SubscriptionObserver, [{\n    key: \"next\",\n    value: function next(value) {\n      onNotify(this._subscription, 'next', value);\n    }\n  }, {\n    key: \"error\",\n    value: function error(value) {\n      onNotify(this._subscription, 'error', value);\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      onNotify(this._subscription, 'complete');\n    }\n  }, {\n    key: \"closed\",\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable =\n/*#__PURE__*/\nfunction () {\n  function Observable(subscriber) {\n    _classCallCheck(this, Observable);\n\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n    this._subscriber = subscriber;\n  }\n\n  _createClass(Observable, [{\n    key: \"subscribe\",\n    value: function subscribe(observer) {\n      if (typeof observer !== 'object' || observer === null) {\n        observer = {\n          next: observer,\n          error: arguments[1],\n          complete: arguments[2]\n        };\n      }\n\n      return new Subscription(observer, this._subscriber);\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== 'function') {\n          reject(new TypeError(fn + ' is not a function'));\n          return;\n        }\n\n        function done() {\n          subscription.unsubscribe();\n          resolve();\n        }\n\n        var subscription = _this.subscribe({\n          next: function (value) {\n            try {\n              fn(value, done);\n            } catch (e) {\n              reject(e);\n              subscription.unsubscribe();\n            }\n          },\n          error: reject,\n          complete: resolve\n        });\n      });\n    }\n  }, {\n    key: \"map\",\n    value: function map(fn) {\n      var _this2 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return _this2.subscribe({\n          next: function (value) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(fn) {\n      var _this3 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return _this3.subscribe({\n          next: function (value) {\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(fn) {\n      var _this4 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var seed = arguments[1];\n      var acc = seed;\n      return new C(function (observer) {\n        return _this4.subscribe({\n          next: function (value) {\n            var first = !hasValue;\n            hasValue = true;\n\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var _this5 = this;\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        var subscription;\n        var index = 0;\n\n        function startNext(next) {\n          subscription = next.subscribe({\n            next: function (v) {\n              observer.next(v);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              if (index === sources.length) {\n                subscription = undefined;\n                observer.complete();\n              } else {\n                startNext(C.from(sources[index++]));\n              }\n            }\n          });\n        }\n\n        startNext(_this5);\n        return function () {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = undefined;\n          }\n        };\n      });\n    }\n  }, {\n    key: \"flatMap\",\n    value: function flatMap(fn) {\n      var _this6 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        var subscriptions = [];\n\n        var outer = _this6.subscribe({\n          next: function (value) {\n            if (fn) {\n              try {\n                value = fn(value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            }\n\n            var inner = C.from(value).subscribe({\n              next: function (value) {\n                observer.next(value);\n              },\n              error: function (e) {\n                observer.error(e);\n              },\n              complete: function () {\n                var i = subscriptions.indexOf(inner);\n                if (i >= 0) subscriptions.splice(i, 1);\n                completeIfDone();\n              }\n            });\n            subscriptions.push(inner);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            completeIfDone();\n          }\n        });\n\n        function completeIfDone() {\n          if (outer.closed && subscriptions.length === 0) observer.complete();\n        }\n\n        return function () {\n          subscriptions.forEach(function (s) {\n            return s.unsubscribe();\n          });\n          outer.unsubscribe();\n        };\n      });\n    }\n  }, {\n    key: SymbolObservable,\n    value: function () {\n      return this;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(x) {\n      var C = typeof this === 'function' ? this : Observable;\n      if (x == null) throw new TypeError(x + ' is not an object');\n      var method = getMethod(x, SymbolObservable);\n\n      if (method) {\n        var observable = method.call(x);\n        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n        if (isObservable(observable) && observable.constructor === C) return observable;\n        return new C(function (observer) {\n          return observable.subscribe(observer);\n        });\n      }\n\n      if (hasSymbol('iterator')) {\n        method = getMethod(x, SymbolIterator);\n\n        if (method) {\n          return new C(function (observer) {\n            enqueue(function () {\n              if (observer.closed) return;\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var _item = _step.value;\n                  observer.next(_item);\n                  if (observer.closed) return;\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              observer.complete();\n            });\n          });\n        }\n      }\n\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n\n            for (var i = 0; i < x.length; ++i) {\n              observer.next(x[i]);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n\n      throw new TypeError(x + ' is not observable');\n    }\n  }, {\n    key: \"of\",\n    value: function of() {\n      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n\n      var C = typeof this === 'function' ? this : Observable;\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n\n          for (var i = 0; i < items.length; ++i) {\n            observer.next(items[i]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n  }, {\n    key: SymbolSpecies,\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nexports.Observable = Observable;\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvemVuLW9ic2VydmFibGUvbGliL09ic2VydmFibGUuanM/YTdiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vLyA9PT0gU3ltYm9sIFN1cHBvcnQgPT09XG52YXIgaGFzU3ltYm9scyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaGFzU3ltYm9sID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGhhc1N5bWJvbHMoKSAmJiBCb29sZWFuKFN5bWJvbFtuYW1lXSk7XG59O1xuXG52YXIgZ2V0U3ltYm9sID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGhhc1N5bWJvbChuYW1lKSA/IFN5bWJvbFtuYW1lXSA6ICdAQCcgKyBuYW1lO1xufTtcblxuaWYgKGhhc1N5bWJvbHMoKSAmJiAhaGFzU3ltYm9sKCdvYnNlcnZhYmxlJykpIHtcbiAgU3ltYm9sLm9ic2VydmFibGUgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcbn1cblxudmFyIFN5bWJvbEl0ZXJhdG9yID0gZ2V0U3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFN5bWJvbE9ic2VydmFibGUgPSBnZXRTeW1ib2woJ29ic2VydmFibGUnKTtcbnZhciBTeW1ib2xTcGVjaWVzID0gZ2V0U3ltYm9sKCdzcGVjaWVzJyk7IC8vID09PSBBYnN0cmFjdCBPcGVyYXRpb25zID09PVxuXG5mdW5jdGlvbiBnZXRNZXRob2Qob2JqLCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKHZhbHVlICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldFNwZWNpZXMob2JqKSB7XG4gIHZhciBjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuXG4gIGlmIChjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdG9yID0gY3RvcltTeW1ib2xTcGVjaWVzXTtcblxuICAgIGlmIChjdG9yID09PSBudWxsKSB7XG4gICAgICBjdG9yID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdG9yICE9PSB1bmRlZmluZWQgPyBjdG9yIDogT2JzZXJ2YWJsZTtcbn1cblxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBPYnNlcnZhYmxlOyAvLyBTUEVDOiBCcmFuZCBjaGVja1xufVxuXG5mdW5jdGlvbiBob3N0UmVwb3J0RXJyb3IoZSkge1xuICBpZiAoaG9zdFJlcG9ydEVycm9yLmxvZykge1xuICAgIGhvc3RSZXBvcnRFcnJvci5sb2coZSk7XG4gIH0gZWxzZSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVucXVldWUoZm4pIHtcbiAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaG9zdFJlcG9ydEVycm9yKGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIHZhciBjbGVhbnVwID0gc3Vic2NyaXB0aW9uLl9jbGVhbnVwO1xuICBpZiAoY2xlYW51cCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIHN1YnNjcmlwdGlvbi5fY2xlYW51cCA9IHVuZGVmaW5lZDtcblxuICBpZiAoIWNsZWFudXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdW5zdWJzY3JpYmUgPSBnZXRNZXRob2QoY2xlYW51cCwgJ3Vuc3Vic2NyaWJlJyk7XG5cbiAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICB1bnN1YnNjcmliZS5jYWxsKGNsZWFudXApO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGhvc3RSZXBvcnRFcnJvcihlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIHtcbiAgc3Vic2NyaXB0aW9uLl9vYnNlcnZlciA9IHVuZGVmaW5lZDtcbiAgc3Vic2NyaXB0aW9uLl9xdWV1ZSA9IHVuZGVmaW5lZDtcbiAgc3Vic2NyaXB0aW9uLl9zdGF0ZSA9ICdjbG9zZWQnO1xufVxuXG5mdW5jdGlvbiBmbHVzaFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIHtcbiAgdmFyIHF1ZXVlID0gc3Vic2NyaXB0aW9uLl9xdWV1ZTtcblxuICBpZiAoIXF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3Vic2NyaXB0aW9uLl9xdWV1ZSA9IHVuZGVmaW5lZDtcbiAgc3Vic2NyaXB0aW9uLl9zdGF0ZSA9ICdyZWFkeSc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgIG5vdGlmeVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24sIHF1ZXVlW2ldLnR5cGUsIHF1ZXVlW2ldLnZhbHVlKTtcbiAgICBpZiAoc3Vic2NyaXB0aW9uLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vdGlmeVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24sIHR5cGUsIHZhbHVlKSB7XG4gIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAncnVubmluZyc7XG4gIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fb2JzZXJ2ZXI7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlciwgdHlwZSk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICBpZiAobSkgbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIGlmIChtKSBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtlbHNlIHRocm93IHZhbHVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgICBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBpZiAobSkgbS5jYWxsKG9ic2VydmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaG9zdFJlcG9ydEVycm9yKGUpO1xuICB9XG5cbiAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnKSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7ZWxzZSBpZiAoc3Vic2NyaXB0aW9uLl9zdGF0ZSA9PT0gJ3J1bm5pbmcnKSBzdWJzY3JpcHRpb24uX3N0YXRlID0gJ3JlYWR5Jztcbn1cblxuZnVuY3Rpb24gb25Ob3RpZnkoc3Vic2NyaXB0aW9uLCB0eXBlLCB2YWx1ZSkge1xuICBpZiAoc3Vic2NyaXB0aW9uLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHJldHVybjtcblxuICBpZiAoc3Vic2NyaXB0aW9uLl9zdGF0ZSA9PT0gJ2J1ZmZlcmluZycpIHtcbiAgICBzdWJzY3JpcHRpb24uX3F1ZXVlLnB1c2goe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgIT09ICdyZWFkeScpIHtcbiAgICBzdWJzY3JpcHRpb24uX3N0YXRlID0gJ2J1ZmZlcmluZyc7XG4gICAgc3Vic2NyaXB0aW9uLl9xdWV1ZSA9IFt7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfV07XG4gICAgZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmx1c2hTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBub3RpZnlTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCB0eXBlLCB2YWx1ZSk7XG59XG5cbnZhciBTdWJzY3JpcHRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdWJzY3JpcHRpb24ob2JzZXJ2ZXIsIHN1YnNjcmliZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic2NyaXB0aW9uKTtcblxuICAgIC8vIEFTU0VSVDogb2JzZXJ2ZXIgaXMgYW4gb2JqZWN0XG4gICAgLy8gQVNTRVJUOiBzdWJzY3JpYmVyIGlzIGNhbGxhYmxlXG4gICAgdGhpcy5fY2xlYW51cCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuX3F1ZXVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N0YXRlID0gJ2luaXRpYWxpemluZyc7XG4gICAgdmFyIHN1YnNjcmlwdGlvbk9ic2VydmVyID0gbmV3IFN1YnNjcmlwdGlvbk9ic2VydmVyKHRoaXMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2NsZWFudXAgPSBzdWJzY3JpYmVyLmNhbGwodW5kZWZpbmVkLCBzdWJzY3JpcHRpb25PYnNlcnZlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3Vic2NyaXB0aW9uT2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSAnaW5pdGlhbGl6aW5nJykgdGhpcy5fc3RhdGUgPSAncmVhZHknO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN1YnNjcmlwdGlvbiwgW3tcbiAgICBrZXk6IFwidW5zdWJzY3JpYmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgIGNsb3NlU3Vic2NyaXB0aW9uKHRoaXMpO1xuICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSA9PT0gJ2Nsb3NlZCc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKTtcblxudmFyIFN1YnNjcmlwdGlvbk9ic2VydmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uT2JzZXJ2ZXIoc3Vic2NyaXB0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnNjcmlwdGlvbk9ic2VydmVyKTtcblxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdWJzY3JpcHRpb25PYnNlcnZlciwgW3tcbiAgICBrZXk6IFwibmV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgICBvbk5vdGlmeSh0aGlzLl9zdWJzY3JpcHRpb24sICduZXh0JywgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgICAgb25Ob3RpZnkodGhpcy5fc3Vic2NyaXB0aW9uLCAnZXJyb3InLCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgb25Ob3RpZnkodGhpcy5fc3Vic2NyaXB0aW9uLCAnY29tcGxldGUnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaXB0aW9uLl9zdGF0ZSA9PT0gJ2Nsb3NlZCc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN1YnNjcmlwdGlvbk9ic2VydmVyO1xufSgpO1xuXG52YXIgT2JzZXJ2YWJsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPYnNlcnZhYmxlKTtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JzZXJ2YWJsZSBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24nKTtcbiAgICBpZiAodHlwZW9mIHN1YnNjcmliZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ic2VydmFibGUgaW5pdGlhbGl6ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgdGhpcy5fc3Vic2NyaWJlciA9IHN1YnNjcmliZXI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT2JzZXJ2YWJsZSwgW3tcbiAgICBrZXk6IFwic3Vic2NyaWJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcgfHwgb2JzZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgbmV4dDogb2JzZXJ2ZXIsXG4gICAgICAgICAgZXJyb3I6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICBjb21wbGV0ZTogYXJndW1lbnRzWzJdXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9zdWJzY3JpYmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZSh7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmbih2YWx1ZSwgZG9uZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAoZm4pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgdmFyIEMgPSBnZXRTcGVjaWVzKHRoaXMpO1xuICAgICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnN1YnNjcmliZSh7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGZuKHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXIoZm4pIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgdmFyIEMgPSBnZXRTcGVjaWVzKHRoaXMpO1xuICAgICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnN1YnNjcmliZSh7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIWZuKHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVkdWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHVjZShmbikge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgICB2YXIgaGFzU2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxO1xuICAgICAgdmFyIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICB2YXIgc2VlZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBhY2MgPSBzZWVkO1xuICAgICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gX3RoaXM0LnN1YnNjcmliZSh7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSAhaGFzVmFsdWU7XG4gICAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghZmlyc3QgfHwgaGFzU2VlZCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGFjYyA9IGZuKGFjYywgdmFsdWUpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhY2MgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFoYXNWYWx1ZSAmJiAhaGFzU2VlZCkgcmV0dXJuIG9ic2VydmVyLmVycm9yKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCByZWR1Y2UgYW4gZW1wdHkgc2VxdWVuY2UnKSk7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGFjYyk7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uY2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc291cmNlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIEMgPSBnZXRTcGVjaWVzKHRoaXMpO1xuICAgICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0TmV4dChuZXh0KSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV4dC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0TmV4dChDLmZyb20oc291cmNlc1tpbmRleCsrXSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE5leHQoX3RoaXM1KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmxhdE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbGF0TWFwKGZuKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcbiAgICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBbXTtcblxuICAgICAgICB2YXIgb3V0ZXIgPSBfdGhpczYuc3Vic2NyaWJlKHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZm4odmFsdWUpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbm5lciA9IEMuZnJvbSh2YWx1ZSkuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gc3Vic2NyaXB0aW9ucy5pbmRleE9mKGlubmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSAwKSBzdWJzY3JpcHRpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUlmRG9uZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaChpbm5lcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbXBsZXRlSWZEb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBjb21wbGV0ZUlmRG9uZSgpIHtcbiAgICAgICAgICBpZiAob3V0ZXIuY2xvc2VkICYmIHN1YnNjcmlwdGlvbnMubGVuZ3RoID09PSAwKSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb3V0ZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogU3ltYm9sT2JzZXJ2YWJsZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKHgpIHtcbiAgICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogT2JzZXJ2YWJsZTtcbiAgICAgIGlmICh4ID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZCh4LCBTeW1ib2xPYnNlcnZhYmxlKTtcblxuICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG1ldGhvZC5jYWxsKHgpO1xuICAgICAgICBpZiAoT2JqZWN0KG9ic2VydmFibGUpICE9PSBvYnNlcnZhYmxlKSB0aHJvdyBuZXcgVHlwZUVycm9yKG9ic2VydmFibGUgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZShvYnNlcnZhYmxlKSAmJiBvYnNlcnZhYmxlLmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICAgICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzU3ltYm9sKCdpdGVyYXRvcicpKSB7XG4gICAgICAgIG1ldGhvZCA9IGdldE1ldGhvZCh4LCBTeW1ib2xJdGVyYXRvcik7XG5cbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGVucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIuY2xvc2VkKSByZXR1cm47XG4gICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IG1ldGhvZC5jYWxsKHgpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9pdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KF9pdGVtKTtcbiAgICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgIGVucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh4W2ldKTtcbiAgICAgICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBub3Qgb2JzZXJ2YWJsZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgaXRlbXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBPYnNlcnZhYmxlO1xuICAgICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIuY2xvc2VkKSByZXR1cm47XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2ldKTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogU3ltYm9sU3BlY2llcyxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYnNlcnZhYmxlO1xufSgpO1xuXG5leHBvcnRzLk9ic2VydmFibGUgPSBPYnNlcnZhYmxlO1xuXG5pZiAoaGFzU3ltYm9scygpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlLCBTeW1ib2woJ2V4dGVuc2lvbnMnKSwge1xuICAgIHZhbHVlOiB7XG4gICAgICBzeW1ib2w6IFN5bWJvbE9ic2VydmFibGUsXG4gICAgICBob3N0UmVwb3J0RXJyb3I6IGhvc3RSZXBvcnRFcnJvclxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///42\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(6);\nvar react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n// CONCATENATED MODULE: ./node_modules/is-in-browser/dist/module.js\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar isBrowser = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && (typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) === 'object' && document.nodeType === 9;\n\n/* harmony default export */ var dist_module = (isBrowser);\n\n// CONCATENATED MODULE: ./node_modules/tiny-warning/dist/tiny-warning.esm.js\nvar isProduction = \"production\" === 'production';\nfunction tiny_warning_esm_warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\n/* harmony default export */ var tiny_warning_esm = (tiny_warning_esm_warning);\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n// CONCATENATED MODULE: ./node_modules/jss/dist/jss.esm.js\n\n\n\n\n\n\n\n\nvar plainObjectConstrurctor = {}.constructor;\nfunction cloneStyle(style) {\n  if (style == null || typeof style !== 'object') return style;\n  if (Array.isArray(style)) return style.map(cloneStyle);\n  if (style.constructor !== plainObjectConstrurctor) return style;\n  var newStyle = {};\n\n  for (var name in style) {\n    newStyle[name] = cloneStyle(style[name]);\n  }\n\n  return newStyle;\n}\n\n/**\n * Create a rule instance.\n */\n\nfunction createRule(name, decl, options) {\n  if (name === void 0) {\n    name = 'unnamed';\n  }\n\n  var jss = options.jss;\n  var declCopy = cloneStyle(decl);\n  var rule = jss.plugins.onCreateRule(name, declCopy, options);\n  if (rule) return rule; // It is an at-rule and it has no instance.\n\n  if (name[0] === '@') {\n     false ? undefined : void 0;\n  }\n\n  return null;\n}\n\nvar join = function join(value, by) {\n  var result = '';\n\n  for (var i = 0; i < value.length; i++) {\n    // Remove !important from the value, it will be readded later.\n    if (value[i] === '!important') break;\n    if (result) result += by;\n    result += value[i];\n  }\n\n  return result;\n};\n/**\n * Converts array values to string.\n *\n * `margin: [['5px', '10px']]` > `margin: 5px 10px;`\n * `border: ['1px', '2px']` > `border: 1px, 2px;`\n * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`\n * `color: ['red', !important]` > `color: red !important;`\n */\n\n\nfunction toCssValue(value, ignoreImportant) {\n  if (ignoreImportant === void 0) {\n    ignoreImportant = false;\n  }\n\n  if (!Array.isArray(value)) return value;\n  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.\n\n  if (Array.isArray(value[0])) {\n    for (var i = 0; i < value.length; i++) {\n      if (value[i] === '!important') break;\n      if (cssValue) cssValue += ', ';\n      cssValue += join(value[i], ' ');\n    }\n  } else cssValue = join(value, ', '); // Add !important, because it was ignored.\n\n\n  if (!ignoreImportant && value[value.length - 1] === '!important') {\n    cssValue += ' !important';\n  }\n\n  return cssValue;\n}\n\n/**\n * Indent a string.\n * http://jsperf.com/array-join-vs-for\n */\nfunction indentStr(str, indent) {\n  var result = '';\n\n  for (var index = 0; index < indent; index++) {\n    result += '  ';\n  }\n\n  return result + str;\n}\n/**\n * Converts a Rule to CSS string.\n */\n\n\nfunction toCss(selector, style, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var result = '';\n  if (!style) return result;\n  var _options = options,\n      _options$indent = _options.indent,\n      indent = _options$indent === void 0 ? 0 : _options$indent;\n  var fallbacks = style.fallbacks;\n  if (selector) indent++; // Apply fallbacks first.\n\n  if (fallbacks) {\n    // Array syntax {fallbacks: [{prop: value}]}\n    if (Array.isArray(fallbacks)) {\n      for (var index = 0; index < fallbacks.length; index++) {\n        var fallback = fallbacks[index];\n\n        for (var prop in fallback) {\n          var value = fallback[prop];\n\n          if (value != null) {\n            if (result) result += '\\n';\n            result += \"\" + indentStr(prop + \": \" + toCssValue(value) + \";\", indent);\n          }\n        }\n      }\n    } else {\n      // Object syntax {fallbacks: {prop: value}}\n      for (var _prop in fallbacks) {\n        var _value = fallbacks[_prop];\n\n        if (_value != null) {\n          if (result) result += '\\n';\n          result += \"\" + indentStr(_prop + \": \" + toCssValue(_value) + \";\", indent);\n        }\n      }\n    }\n  }\n\n  for (var _prop2 in style) {\n    var _value2 = style[_prop2];\n\n    if (_value2 != null && _prop2 !== 'fallbacks') {\n      if (result) result += '\\n';\n      result += \"\" + indentStr(_prop2 + \": \" + toCssValue(_value2) + \";\", indent);\n    }\n  } // Allow empty style in this case, because properties will be added dynamically.\n\n\n  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.\n\n  if (!selector) return result;\n  indent--;\n  if (result) result = \"\\n\" + result + \"\\n\";\n  return indentStr(selector + \" {\" + result, indent) + indentStr('}', indent);\n}\n\nvar escapeRegex = /([[\\].#*$><+~=|^:(),\"'`\\s])/g;\nvar nativeEscape = typeof CSS !== 'undefined' && CSS.escape;\nvar jss_esm_escape = (function (str) {\n  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\\\$1');\n});\n\nvar BaseStyleRule =\n/*#__PURE__*/\nfunction () {\n  function BaseStyleRule(key, style, options) {\n    this.type = 'style';\n    this.key = void 0;\n    this.isProcessed = false;\n    this.style = void 0;\n    this.renderer = void 0;\n    this.renderable = void 0;\n    this.options = void 0;\n    var sheet = options.sheet,\n        Renderer = options.Renderer;\n    this.key = key;\n    this.options = options;\n    this.style = style;\n    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();\n  }\n  /**\n   * Get or set a style property.\n   */\n\n\n  var _proto = BaseStyleRule.prototype;\n\n  _proto.prop = function prop(name, value, options) {\n    // It's a getter.\n    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.\n\n    var force = options ? options.force : false;\n    if (!force && this.style[name] === value) return this;\n    var newValue = value;\n\n    if (!options || options.process !== false) {\n      newValue = this.options.jss.plugins.onChangeValue(value, name, this);\n    }\n\n    var isEmpty = newValue == null || newValue === false;\n    var isDefined = name in this.style; // Value is empty and wasn't defined before.\n\n    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.\n\n    var remove = isEmpty && isDefined;\n    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.\n\n    if (this.renderable && this.renderer) {\n      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);\n      return this;\n    }\n\n    var sheet = this.options.sheet;\n\n    if (sheet && sheet.attached) {\n       false ? undefined : void 0;\n    }\n\n    return this;\n  };\n\n  return BaseStyleRule;\n}();\nvar jss_esm_StyleRule =\n/*#__PURE__*/\nfunction (_BaseStyleRule) {\n  _inheritsLoose(StyleRule, _BaseStyleRule);\n\n  function StyleRule(key, style, options) {\n    var _this;\n\n    _this = _BaseStyleRule.call(this, key, style, options) || this;\n    _this.selectorText = void 0;\n    _this.id = void 0;\n    _this.renderable = void 0;\n    var selector = options.selector,\n        scoped = options.scoped,\n        sheet = options.sheet,\n        generateId = options.generateId;\n\n    if (selector) {\n      _this.selectorText = selector;\n    } else if (scoped !== false) {\n      _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);\n      _this.selectorText = \".\" + jss_esm_escape(_this.id);\n    }\n\n    return _this;\n  }\n  /**\n   * Set selector string.\n   * Attention: use this with caution. Most browsers didn't implement\n   * selectorText setter, so this may result in rerendering of entire Style Sheet.\n   */\n\n\n  var _proto2 = StyleRule.prototype;\n\n  /**\n   * Apply rule to an element inline.\n   */\n  _proto2.applyTo = function applyTo(renderable) {\n    var renderer = this.renderer;\n\n    if (renderer) {\n      var json = this.toJSON();\n\n      for (var prop in json) {\n        renderer.setProperty(renderable, prop, json[prop]);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Returns JSON representation of the rule.\n   * Fallbacks are not supported.\n   * Useful for inline styles.\n   */\n  ;\n\n  _proto2.toJSON = function toJSON() {\n    var json = {};\n\n    for (var prop in this.style) {\n      var value = this.style[prop];\n      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);\n    }\n\n    return json;\n  }\n  /**\n   * Generates a CSS string.\n   */\n  ;\n\n  _proto2.toString = function toString(options) {\n    var sheet = this.options.sheet;\n    var link = sheet ? sheet.options.link : false;\n    var opts = link ? _extends({}, options, {\n      allowEmpty: true\n    }) : options;\n    return toCss(this.selectorText, this.style, opts);\n  };\n\n  _createClass(StyleRule, [{\n    key: \"selector\",\n    set: function set(selector) {\n      if (selector === this.selectorText) return;\n      this.selectorText = selector;\n      var renderer = this.renderer,\n          renderable = this.renderable;\n      if (!renderable || !renderer) return;\n      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.\n\n      if (!hasChanged) {\n        renderer.replaceRule(renderable, this);\n      }\n    }\n    /**\n     * Get selector string.\n     */\n    ,\n    get: function get() {\n      return this.selectorText;\n    }\n  }]);\n\n  return StyleRule;\n}(BaseStyleRule);\nvar pluginStyleRule = {\n  onCreateRule: function onCreateRule(name, style, options) {\n    if (name[0] === '@' || options.parent && options.parent.type === 'keyframes') {\n      return null;\n    }\n\n    return new jss_esm_StyleRule(name, style, options);\n  }\n};\n\nvar defaultToStringOptions = {\n  indent: 1,\n  children: true\n};\nvar atRegExp = /@([\\w-]+)/;\n/**\n * Conditional rule for @media, @supports\n */\n\nvar jss_esm_ConditionalRule =\n/*#__PURE__*/\nfunction () {\n  function ConditionalRule(key, styles, options) {\n    this.type = 'conditional';\n    this.at = void 0;\n    this.key = void 0;\n    this.query = void 0;\n    this.rules = void 0;\n    this.options = void 0;\n    this.isProcessed = false;\n    this.renderable = void 0;\n    this.key = key; // Key might contain a unique suffix in case the `name` passed by user was duplicate.\n\n    this.query = options.name;\n    var atMatch = key.match(atRegExp);\n    this.at = atMatch ? atMatch[1] : 'unknown';\n    this.options = options;\n    this.rules = new jss_esm_RuleList(_extends({}, options, {\n      parent: this\n    }));\n\n    for (var name in styles) {\n      this.rules.add(name, styles[name]);\n    }\n\n    this.rules.process();\n  }\n  /**\n   * Get a rule.\n   */\n\n\n  var _proto = ConditionalRule.prototype;\n\n  _proto.getRule = function getRule(name) {\n    return this.rules.get(name);\n  }\n  /**\n   * Get index of a rule.\n   */\n  ;\n\n  _proto.indexOf = function indexOf(rule) {\n    return this.rules.indexOf(rule);\n  }\n  /**\n   * Create and register rule, run plugins.\n   */\n  ;\n\n  _proto.addRule = function addRule(name, style, options) {\n    var rule = this.rules.add(name, style, options);\n    if (!rule) return null;\n    this.options.jss.plugins.onProcessRule(rule);\n    return rule;\n  }\n  /**\n   * Generates a CSS string.\n   */\n  ;\n\n  _proto.toString = function toString(options) {\n    if (options === void 0) {\n      options = defaultToStringOptions;\n    }\n\n    if (options.indent == null) options.indent = defaultToStringOptions.indent;\n    if (options.children == null) options.children = defaultToStringOptions.children;\n\n    if (options.children === false) {\n      return this.query + \" {}\";\n    }\n\n    var children = this.rules.toString(options);\n    return children ? this.query + \" {\\n\" + children + \"\\n}\" : '';\n  };\n\n  return ConditionalRule;\n}();\nvar keyRegExp = /@media|@supports\\s+/;\nvar pluginConditionalRule = {\n  onCreateRule: function onCreateRule(key, styles, options) {\n    return keyRegExp.test(key) ? new jss_esm_ConditionalRule(key, styles, options) : null;\n  }\n};\n\nvar defaultToStringOptions$1 = {\n  indent: 1,\n  children: true\n};\nvar nameRegExp = /@keyframes\\s+([\\w-]+)/;\n/**\n * Rule for @keyframes\n */\n\nvar jss_esm_KeyframesRule =\n/*#__PURE__*/\nfunction () {\n  function KeyframesRule(key, frames, options) {\n    this.type = 'keyframes';\n    this.at = '@keyframes';\n    this.key = void 0;\n    this.name = void 0;\n    this.id = void 0;\n    this.rules = void 0;\n    this.options = void 0;\n    this.isProcessed = false;\n    this.renderable = void 0;\n    var nameMatch = key.match(nameRegExp);\n\n    if (nameMatch && nameMatch[1]) {\n      this.name = nameMatch[1];\n    } else {\n      this.name = 'noname';\n       false ? undefined : void 0;\n    }\n\n    this.key = this.type + \"-\" + this.name;\n    this.options = options;\n    var scoped = options.scoped,\n        sheet = options.sheet,\n        generateId = options.generateId;\n    this.id = scoped === false ? this.name : jss_esm_escape(generateId(this, sheet));\n    this.rules = new jss_esm_RuleList(_extends({}, options, {\n      parent: this\n    }));\n\n    for (var name in frames) {\n      this.rules.add(name, frames[name], _extends({}, options, {\n        parent: this\n      }));\n    }\n\n    this.rules.process();\n  }\n  /**\n   * Generates a CSS string.\n   */\n\n\n  var _proto = KeyframesRule.prototype;\n\n  _proto.toString = function toString(options) {\n    if (options === void 0) {\n      options = defaultToStringOptions$1;\n    }\n\n    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;\n    if (options.children == null) options.children = defaultToStringOptions$1.children;\n\n    if (options.children === false) {\n      return this.at + \" \" + this.id + \" {}\";\n    }\n\n    var children = this.rules.toString(options);\n    if (children) children = \"\\n\" + children + \"\\n\";\n    return this.at + \" \" + this.id + \" {\" + children + \"}\";\n  };\n\n  return KeyframesRule;\n}();\nvar keyRegExp$1 = /@keyframes\\s+/;\nvar refRegExp = /\\$([\\w-]+)/g;\n\nvar findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {\n  if (typeof val === 'string') {\n    return val.replace(refRegExp, function (match, name) {\n      if (name in keyframes) {\n        return keyframes[name];\n      }\n\n       false ? undefined : void 0;\n      return match;\n    });\n  }\n\n  return val;\n};\n/**\n * Replace the reference for a animation name.\n */\n\n\nvar jss_esm_replaceRef = function replaceRef(style, prop, keyframes) {\n  var value = style[prop];\n  var refKeyframe = findReferencedKeyframe(value, keyframes);\n\n  if (refKeyframe !== value) {\n    style[prop] = refKeyframe;\n  }\n};\n\nvar jss_esm_plugin = {\n  onCreateRule: function onCreateRule(key, frames, options) {\n    return typeof key === 'string' && keyRegExp$1.test(key) ? new jss_esm_KeyframesRule(key, frames, options) : null;\n  },\n  // Animation name ref replacer.\n  onProcessStyle: function onProcessStyle(style, rule, sheet) {\n    if (rule.type !== 'style' || !sheet) return style;\n    if ('animation-name' in style) jss_esm_replaceRef(style, 'animation-name', sheet.keyframes);\n    if ('animation' in style) jss_esm_replaceRef(style, 'animation', sheet.keyframes);\n    return style;\n  },\n  onChangeValue: function onChangeValue(val, prop, rule) {\n    var sheet = rule.options.sheet;\n\n    if (!sheet) {\n      return val;\n    }\n\n    switch (prop) {\n      case 'animation':\n        return findReferencedKeyframe(val, sheet.keyframes);\n\n      case 'animation-name':\n        return findReferencedKeyframe(val, sheet.keyframes);\n\n      default:\n        return val;\n    }\n  }\n};\n\nvar jss_esm_KeyframeRule =\n/*#__PURE__*/\nfunction (_BaseStyleRule) {\n  _inheritsLoose(KeyframeRule, _BaseStyleRule);\n\n  function KeyframeRule() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _BaseStyleRule.call.apply(_BaseStyleRule, [this].concat(args)) || this;\n    _this.renderable = void 0;\n    return _this;\n  }\n\n  var _proto = KeyframeRule.prototype;\n\n  /**\n   * Generates a CSS string.\n   */\n  _proto.toString = function toString(options) {\n    var sheet = this.options.sheet;\n    var link = sheet ? sheet.options.link : false;\n    var opts = link ? _extends({}, options, {\n      allowEmpty: true\n    }) : options;\n    return toCss(this.key, this.style, opts);\n  };\n\n  return KeyframeRule;\n}(BaseStyleRule);\nvar pluginKeyframeRule = {\n  onCreateRule: function onCreateRule(key, style, options) {\n    if (options.parent && options.parent.type === 'keyframes') {\n      return new jss_esm_KeyframeRule(key, style, options);\n    }\n\n    return null;\n  }\n};\n\nvar FontFaceRule =\n/*#__PURE__*/\nfunction () {\n  function FontFaceRule(key, style, options) {\n    this.type = 'font-face';\n    this.at = '@font-face';\n    this.key = void 0;\n    this.style = void 0;\n    this.options = void 0;\n    this.isProcessed = false;\n    this.renderable = void 0;\n    this.key = key;\n    this.style = style;\n    this.options = options;\n  }\n  /**\n   * Generates a CSS string.\n   */\n\n\n  var _proto = FontFaceRule.prototype;\n\n  _proto.toString = function toString(options) {\n    if (Array.isArray(this.style)) {\n      var str = '';\n\n      for (var index = 0; index < this.style.length; index++) {\n        str += toCss(this.at, this.style[index]);\n        if (this.style[index + 1]) str += '\\n';\n      }\n\n      return str;\n    }\n\n    return toCss(this.at, this.style, options);\n  };\n\n  return FontFaceRule;\n}();\nvar keyRegExp$2 = /@font-face/;\nvar pluginFontFaceRule = {\n  onCreateRule: function onCreateRule(key, style, options) {\n    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;\n  }\n};\n\nvar ViewportRule =\n/*#__PURE__*/\nfunction () {\n  function ViewportRule(key, style, options) {\n    this.type = 'viewport';\n    this.at = '@viewport';\n    this.key = void 0;\n    this.style = void 0;\n    this.options = void 0;\n    this.isProcessed = false;\n    this.renderable = void 0;\n    this.key = key;\n    this.style = style;\n    this.options = options;\n  }\n  /**\n   * Generates a CSS string.\n   */\n\n\n  var _proto = ViewportRule.prototype;\n\n  _proto.toString = function toString(options) {\n    return toCss(this.key, this.style, options);\n  };\n\n  return ViewportRule;\n}();\nvar pluginViewportRule = {\n  onCreateRule: function onCreateRule(key, style, options) {\n    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;\n  }\n};\n\nvar SimpleRule =\n/*#__PURE__*/\nfunction () {\n  function SimpleRule(key, value, options) {\n    this.type = 'simple';\n    this.key = void 0;\n    this.value = void 0;\n    this.options = void 0;\n    this.isProcessed = false;\n    this.renderable = void 0;\n    this.key = key;\n    this.value = value;\n    this.options = options;\n  }\n  /**\n   * Generates a CSS string.\n   */\n  // eslint-disable-next-line no-unused-vars\n\n\n  var _proto = SimpleRule.prototype;\n\n  _proto.toString = function toString(options) {\n    if (Array.isArray(this.value)) {\n      var str = '';\n\n      for (var index = 0; index < this.value.length; index++) {\n        str += this.key + \" \" + this.value[index] + \";\";\n        if (this.value[index + 1]) str += '\\n';\n      }\n\n      return str;\n    }\n\n    return this.key + \" \" + this.value + \";\";\n  };\n\n  return SimpleRule;\n}();\nvar keysMap = {\n  '@charset': true,\n  '@import': true,\n  '@namespace': true\n};\nvar pluginSimpleRule = {\n  onCreateRule: function onCreateRule(key, value, options) {\n    return key in keysMap ? new SimpleRule(key, value, options) : null;\n  }\n};\n\nvar plugins = [pluginStyleRule, pluginConditionalRule, jss_esm_plugin, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];\n\nvar defaultUpdateOptions = {\n  process: true\n};\nvar forceUpdateOptions = {\n  force: true,\n  process: true\n  /**\n   * Contains rules objects and allows adding/removing etc.\n   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.\n   */\n\n};\n\nvar jss_esm_RuleList =\n/*#__PURE__*/\nfunction () {\n  // Rules registry for access by .get() method.\n  // It contains the same rule registered by name and by selector.\n  // Original styles object.\n  // Used to ensure correct rules order.\n  function RuleList(options) {\n    this.map = {};\n    this.raw = {};\n    this.index = [];\n    this.counter = 0;\n    this.options = void 0;\n    this.classes = void 0;\n    this.keyframes = void 0;\n    this.options = options;\n    this.classes = options.classes;\n    this.keyframes = options.keyframes;\n  }\n  /**\n   * Create and register rule.\n   *\n   * Will not render after Style Sheet was rendered the first time.\n   */\n\n\n  var _proto = RuleList.prototype;\n\n  _proto.add = function add(name, decl, ruleOptions) {\n    var _this$options = this.options,\n        parent = _this$options.parent,\n        sheet = _this$options.sheet,\n        jss = _this$options.jss,\n        Renderer = _this$options.Renderer,\n        generateId = _this$options.generateId,\n        scoped = _this$options.scoped;\n\n    var options = _extends({\n      classes: this.classes,\n      parent: parent,\n      sheet: sheet,\n      jss: jss,\n      Renderer: Renderer,\n      generateId: generateId,\n      scoped: scoped,\n      name: name\n    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but\n    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens\n    // we need to make the key unique within this RuleList instance scope.\n\n\n    var key = name;\n\n    if (name in this.raw) {\n      key = name + \"-d\" + this.counter++;\n    } // We need to save the original decl before creating the rule\n    // because cache plugin needs to use it as a key to return a cached rule.\n\n\n    this.raw[key] = decl;\n\n    if (key in this.classes) {\n      // E.g. rules inside of @media container\n      options.selector = \".\" + jss_esm_escape(this.classes[key]);\n    }\n\n    var rule = createRule(key, decl, options);\n    if (!rule) return null;\n    this.register(rule);\n    var index = options.index === undefined ? this.index.length : options.index;\n    this.index.splice(index, 0, rule);\n    return rule;\n  }\n  /**\n   * Get a rule.\n   */\n  ;\n\n  _proto.get = function get(name) {\n    return this.map[name];\n  }\n  /**\n   * Delete a rule.\n   */\n  ;\n\n  _proto.remove = function remove(rule) {\n    this.unregister(rule);\n    delete this.raw[rule.key];\n    this.index.splice(this.index.indexOf(rule), 1);\n  }\n  /**\n   * Get index of a rule.\n   */\n  ;\n\n  _proto.indexOf = function indexOf(rule) {\n    return this.index.indexOf(rule);\n  }\n  /**\n   * Run `onProcessRule()` plugins on every rule.\n   */\n  ;\n\n  _proto.process = function process() {\n    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop\n    // we end up with very hard-to-track-down side effects.\n\n    this.index.slice(0).forEach(plugins.onProcessRule, plugins);\n  }\n  /**\n   * Register a rule in `.map`, `.classes` and `.keyframes` maps.\n   */\n  ;\n\n  _proto.register = function register(rule) {\n    this.map[rule.key] = rule;\n\n    if (rule instanceof jss_esm_StyleRule) {\n      this.map[rule.selector] = rule;\n      if (rule.id) this.classes[rule.key] = rule.id;\n    } else if (rule instanceof jss_esm_KeyframesRule && this.keyframes) {\n      this.keyframes[rule.name] = rule.id;\n    }\n  }\n  /**\n   * Unregister a rule.\n   */\n  ;\n\n  _proto.unregister = function unregister(rule) {\n    delete this.map[rule.key];\n\n    if (rule instanceof jss_esm_StyleRule) {\n      delete this.map[rule.selector];\n      delete this.classes[rule.key];\n    } else if (rule instanceof jss_esm_KeyframesRule) {\n      delete this.keyframes[rule.name];\n    }\n  }\n  /**\n   * Update the function values with a new data.\n   */\n  ;\n\n  _proto.update = function update() {\n    var name;\n    var data;\n    var options;\n\n    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {\n      name = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe\n\n      data = arguments.length <= 1 ? undefined : arguments[1]; // $FlowFixMe\n\n      options = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      data = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe\n\n      options = arguments.length <= 1 ? undefined : arguments[1];\n      name = null;\n    }\n\n    if (name) {\n      this.updateOne(this.map[name], data, options);\n    } else {\n      for (var index = 0; index < this.index.length; index++) {\n        this.updateOne(this.index[index], data, options);\n      }\n    }\n  }\n  /**\n   * Execute plugins, update rule props.\n   */\n  ;\n\n  _proto.updateOne = function updateOne(rule, data, options) {\n    if (options === void 0) {\n      options = defaultUpdateOptions;\n    }\n\n    var _this$options2 = this.options,\n        plugins = _this$options2.jss.plugins,\n        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.\n\n    if (rule.rules instanceof RuleList) {\n      rule.rules.update(data, options);\n      return;\n    }\n\n    var styleRule = rule;\n    var style = styleRule.style;\n    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.\n\n    if (options.process && style && style !== styleRule.style) {\n      // We need to run the plugins in case new `style` relies on syntax plugins.\n      plugins.onProcessStyle(styleRule.style, styleRule, sheet); // Update and add props.\n\n      for (var prop in styleRule.style) {\n        var nextValue = styleRule.style[prop];\n        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.\n        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.\n\n        if (nextValue !== prevValue) {\n          styleRule.prop(prop, nextValue, forceUpdateOptions);\n        }\n      } // Remove props.\n\n\n      for (var _prop in style) {\n        var _nextValue = styleRule.style[_prop];\n        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.\n        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.\n\n        if (_nextValue == null && _nextValue !== _prevValue) {\n          styleRule.prop(_prop, null, forceUpdateOptions);\n        }\n      }\n    }\n  }\n  /**\n   * Convert rules to a CSS string.\n   */\n  ;\n\n  _proto.toString = function toString(options) {\n    var str = '';\n    var sheet = this.options.sheet;\n    var link = sheet ? sheet.options.link : false;\n\n    for (var index = 0; index < this.index.length; index++) {\n      var rule = this.index[index];\n      var css = rule.toString(options); // No need to render an empty rule.\n\n      if (!css && !link) continue;\n      if (str) str += '\\n';\n      str += css;\n    }\n\n    return str;\n  };\n\n  return RuleList;\n}();\n\nvar jss_esm_StyleSheet =\n/*#__PURE__*/\nfunction () {\n  function StyleSheet(styles, options) {\n    this.options = void 0;\n    this.deployed = void 0;\n    this.attached = void 0;\n    this.rules = void 0;\n    this.renderer = void 0;\n    this.classes = void 0;\n    this.keyframes = void 0;\n    this.queue = void 0;\n    this.attached = false;\n    this.deployed = false;\n    this.classes = {};\n    this.keyframes = {};\n    this.options = _extends({}, options, {\n      sheet: this,\n      parent: this,\n      classes: this.classes,\n      keyframes: this.keyframes\n    });\n\n    if (options.Renderer) {\n      this.renderer = new options.Renderer(this);\n    }\n\n    this.rules = new jss_esm_RuleList(this.options);\n\n    for (var name in styles) {\n      this.rules.add(name, styles[name]);\n    }\n\n    this.rules.process();\n  }\n  /**\n   * Attach renderable to the render tree.\n   */\n\n\n  var _proto = StyleSheet.prototype;\n\n  _proto.attach = function attach() {\n    if (this.attached) return this;\n    if (this.renderer) this.renderer.attach();\n    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.\n\n    if (!this.deployed) this.deploy();\n    return this;\n  }\n  /**\n   * Remove renderable from render tree.\n   */\n  ;\n\n  _proto.detach = function detach() {\n    if (!this.attached) return this;\n    if (this.renderer) this.renderer.detach();\n    this.attached = false;\n    return this;\n  }\n  /**\n   * Add a rule to the current stylesheet.\n   * Will insert a rule also after the stylesheet has been rendered first time.\n   */\n  ;\n\n  _proto.addRule = function addRule(name, decl, options) {\n    var queue = this.queue; // Plugins can create rules.\n    // In order to preserve the right order, we need to queue all `.addRule` calls,\n    // which happen after the first `rules.add()` call.\n\n    if (this.attached && !queue) this.queue = [];\n    var rule = this.rules.add(name, decl, options);\n    if (!rule) return null;\n    this.options.jss.plugins.onProcessRule(rule);\n\n    if (this.attached) {\n      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.\n      // It will be inserted all together when .attach is called.\n\n      if (queue) queue.push(rule);else {\n        this.insertRule(rule);\n\n        if (this.queue) {\n          this.queue.forEach(this.insertRule, this);\n          this.queue = undefined;\n        }\n      }\n      return rule;\n    } // We can't add rules to a detached style node.\n    // We will redeploy the sheet once user will attach it.\n\n\n    this.deployed = false;\n    return rule;\n  }\n  /**\n   * Insert rule into the StyleSheet\n   */\n  ;\n\n  _proto.insertRule = function insertRule(rule) {\n    if (this.renderer) {\n      this.renderer.insertRule(rule);\n    }\n  }\n  /**\n   * Create and add rules.\n   * Will render also after Style Sheet was rendered the first time.\n   */\n  ;\n\n  _proto.addRules = function addRules(styles, options) {\n    var added = [];\n\n    for (var name in styles) {\n      var rule = this.addRule(name, styles[name], options);\n      if (rule) added.push(rule);\n    }\n\n    return added;\n  }\n  /**\n   * Get a rule by name.\n   */\n  ;\n\n  _proto.getRule = function getRule(name) {\n    return this.rules.get(name);\n  }\n  /**\n   * Delete a rule by name.\n   * Returns `true`: if rule has been deleted from the DOM.\n   */\n  ;\n\n  _proto.deleteRule = function deleteRule(name) {\n    var rule = typeof name === 'object' ? name : this.rules.get(name);\n    if (!rule) return false;\n    this.rules.remove(rule);\n\n    if (this.attached && rule.renderable && this.renderer) {\n      return this.renderer.deleteRule(rule.renderable);\n    }\n\n    return true;\n  }\n  /**\n   * Get index of a rule.\n   */\n  ;\n\n  _proto.indexOf = function indexOf(rule) {\n    return this.rules.indexOf(rule);\n  }\n  /**\n   * Deploy pure CSS string to a renderable.\n   */\n  ;\n\n  _proto.deploy = function deploy() {\n    if (this.renderer) this.renderer.deploy();\n    this.deployed = true;\n    return this;\n  }\n  /**\n   * Update the function values with a new data.\n   */\n  ;\n\n  _proto.update = function update() {\n    var _this$rules;\n\n    (_this$rules = this.rules).update.apply(_this$rules, arguments);\n\n    return this;\n  }\n  /**\n   * Updates a single rule.\n   */\n  ;\n\n  _proto.updateOne = function updateOne(rule, data, options) {\n    this.rules.updateOne(rule, data, options);\n    return this;\n  }\n  /**\n   * Convert rules to a CSS string.\n   */\n  ;\n\n  _proto.toString = function toString(options) {\n    return this.rules.toString(options);\n  };\n\n  return StyleSheet;\n}();\n\nvar PluginsRegistry =\n/*#__PURE__*/\nfunction () {\n  function PluginsRegistry() {\n    this.plugins = {\n      internal: [],\n      external: []\n    };\n    this.registry = void 0;\n  }\n\n  var _proto = PluginsRegistry.prototype;\n\n  /**\n   * Call `onCreateRule` hooks and return an object if returned by a hook.\n   */\n  _proto.onCreateRule = function onCreateRule(name, decl, options) {\n    for (var i = 0; i < this.registry.onCreateRule.length; i++) {\n      var rule = this.registry.onCreateRule[i](name, decl, options);\n      if (rule) return rule;\n    }\n\n    return null;\n  }\n  /**\n   * Call `onProcessRule` hooks.\n   */\n  ;\n\n  _proto.onProcessRule = function onProcessRule(rule) {\n    if (rule.isProcessed) return;\n    var sheet = rule.options.sheet;\n\n    for (var i = 0; i < this.registry.onProcessRule.length; i++) {\n      this.registry.onProcessRule[i](rule, sheet);\n    }\n\n    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);\n    rule.isProcessed = true;\n  }\n  /**\n   * Call `onProcessStyle` hooks.\n   */\n  ;\n\n  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {\n    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {\n      // $FlowFixMe\n      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);\n    }\n  }\n  /**\n   * Call `onProcessSheet` hooks.\n   */\n  ;\n\n  _proto.onProcessSheet = function onProcessSheet(sheet) {\n    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {\n      this.registry.onProcessSheet[i](sheet);\n    }\n  }\n  /**\n   * Call `onUpdate` hooks.\n   */\n  ;\n\n  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {\n    for (var i = 0; i < this.registry.onUpdate.length; i++) {\n      this.registry.onUpdate[i](data, rule, sheet, options);\n    }\n  }\n  /**\n   * Call `onChangeValue` hooks.\n   */\n  ;\n\n  _proto.onChangeValue = function onChangeValue(value, prop, rule) {\n    var processedValue = value;\n\n    for (var i = 0; i < this.registry.onChangeValue.length; i++) {\n      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);\n    }\n\n    return processedValue;\n  }\n  /**\n   * Register a plugin.\n   */\n  ;\n\n  _proto.use = function use(newPlugin, options) {\n    if (options === void 0) {\n      options = {\n        queue: 'external'\n      };\n    }\n\n    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.\n\n    if (plugins.indexOf(newPlugin) !== -1) {\n      return;\n    }\n\n    plugins.push(newPlugin);\n    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {\n      for (var name in plugin) {\n        if (name in registry) {\n          registry[name].push(plugin[name]);\n        } else {\n           false ? undefined : void 0;\n        }\n      }\n\n      return registry;\n    }, {\n      onCreateRule: [],\n      onProcessRule: [],\n      onProcessStyle: [],\n      onProcessSheet: [],\n      onChangeValue: [],\n      onUpdate: []\n    });\n  };\n\n  return PluginsRegistry;\n}();\n\n/**\n * Sheets registry to access them all at one place.\n */\nvar jss_esm_SheetsRegistry =\n/*#__PURE__*/\nfunction () {\n  function SheetsRegistry() {\n    this.registry = [];\n  }\n\n  var _proto = SheetsRegistry.prototype;\n\n  /**\n   * Register a Style Sheet.\n   */\n  _proto.add = function add(sheet) {\n    var registry = this.registry;\n    var index = sheet.options.index;\n    if (registry.indexOf(sheet) !== -1) return;\n\n    if (registry.length === 0 || index >= this.index) {\n      registry.push(sheet);\n      return;\n    } // Find a position.\n\n\n    for (var i = 0; i < registry.length; i++) {\n      if (registry[i].options.index > index) {\n        registry.splice(i, 0, sheet);\n        return;\n      }\n    }\n  }\n  /**\n   * Reset the registry.\n   */\n  ;\n\n  _proto.reset = function reset() {\n    this.registry = [];\n  }\n  /**\n   * Remove a Style Sheet.\n   */\n  ;\n\n  _proto.remove = function remove(sheet) {\n    var index = this.registry.indexOf(sheet);\n    this.registry.splice(index, 1);\n  }\n  /**\n   * Convert all attached sheets to a CSS string.\n   */\n  ;\n\n  _proto.toString = function toString(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        attached = _ref.attached,\n        options = _objectWithoutPropertiesLoose(_ref, [\"attached\"]);\n\n    var css = '';\n\n    for (var i = 0; i < this.registry.length; i++) {\n      var sheet = this.registry[i];\n\n      if (attached != null && sheet.attached !== attached) {\n        continue;\n      }\n\n      if (css) css += '\\n';\n      css += sheet.toString(options);\n    }\n\n    return css;\n  };\n\n  _createClass(SheetsRegistry, [{\n    key: \"index\",\n\n    /**\n     * Current highest index number.\n     */\n    get: function get() {\n      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;\n    }\n  }]);\n\n  return SheetsRegistry;\n}();\n\n/**\n * This is a global sheets registry. Only DomRenderer will add sheets to it.\n * On the server one should use an own SheetsRegistry instance and add the\n * sheets to it, because you need to make sure to create a new registry for\n * each request in order to not leak sheets across requests.\n */\n\nvar sheets = new jss_esm_SheetsRegistry();\n\n/* eslint-disable */\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar globalThis = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\nvar ns = '2f1acc6c3a606b082e5eef5e54414ffb';\nif (globalThis[ns] == null) globalThis[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify\n// the current version with just one short number and use it for classes generation\n// we use a counter. Also it is more accurate, because user can manually reevaluate\n// the module.\n\nvar moduleId = globalThis[ns]++;\n\nvar maxRules = 1e10;\n\n/**\n * Returns a function which generates unique class names based on counters.\n * When new generator function is created, rule counter is reseted.\n * We need to reset the rule counter for SSR for each request.\n */\nvar createGenerateId = function createGenerateId(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var ruleCounter = 0;\n  return function (rule, sheet) {\n    ruleCounter += 1;\n\n    if (ruleCounter > maxRules) {\n       false ? undefined : void 0;\n    }\n\n    var jssId = '';\n    var prefix = '';\n\n    if (sheet) {\n      if (sheet.options.classNamePrefix) {\n        prefix = sheet.options.classNamePrefix;\n      }\n\n      if (sheet.options.jss.id != null) {\n        jssId = String(sheet.options.jss.id);\n      }\n    }\n\n    if (options.minify) {\n      // Using \"c\" because a number can't be the first char in a class name.\n      return \"\" + (prefix || 'c') + moduleId + jssId + ruleCounter;\n    }\n\n    return prefix + rule.key + \"-\" + moduleId + (jssId ? \"-\" + jssId : '') + \"-\" + ruleCounter;\n  };\n};\n\n/**\n * Cache the value from the first time a function is called.\n */\nvar memoize = function memoize(fn) {\n  var value;\n  return function () {\n    if (!value) value = fn();\n    return value;\n  };\n};\n/**\n * Get a style property value.\n */\n\n\nfunction getPropertyValue(cssRule, prop) {\n  try {\n    // Support CSSTOM.\n    if (cssRule.attributeStyleMap) {\n      return cssRule.attributeStyleMap.get(prop);\n    }\n\n    return cssRule.style.getPropertyValue(prop);\n  } catch (err) {\n    // IE may throw if property is unknown.\n    return '';\n  }\n}\n/**\n * Set a style property.\n */\n\n\nfunction setProperty(cssRule, prop, value) {\n  try {\n    var cssValue = value;\n\n    if (Array.isArray(value)) {\n      cssValue = toCssValue(value, true);\n\n      if (value[value.length - 1] === '!important') {\n        cssRule.style.setProperty(prop, cssValue, 'important');\n        return true;\n      }\n    } // Support CSSTOM.\n\n\n    if (cssRule.attributeStyleMap) {\n      cssRule.attributeStyleMap.set(prop, cssValue);\n    } else {\n      cssRule.style.setProperty(prop, cssValue);\n    }\n  } catch (err) {\n    // IE may throw if property is unknown.\n    return false;\n  }\n\n  return true;\n}\n/**\n * Remove a style property.\n */\n\n\nfunction removeProperty(cssRule, prop) {\n  try {\n    // Support CSSTOM.\n    if (cssRule.attributeStyleMap) {\n      cssRule.attributeStyleMap.delete(prop);\n    } else {\n      cssRule.style.removeProperty(prop);\n    }\n  } catch (err) {\n     false ? undefined : void 0;\n  }\n}\n/**\n * Set the selector.\n */\n\n\nfunction setSelector(cssRule, selectorText) {\n  cssRule.selectorText = selectorText; // Return false if setter was not successful.\n  // Currently works in chrome only.\n\n  return cssRule.selectorText === selectorText;\n}\n/**\n * Gets the `head` element upon the first call and caches it.\n * We assume it can't be null.\n */\n\n\nvar getHead = memoize(function () {\n  return document.querySelector('head');\n});\n/**\n * Find attached sheet with an index higher than the passed one.\n */\n\nfunction findHigherSheet(registry, options) {\n  for (var i = 0; i < registry.length; i++) {\n    var sheet = registry[i];\n\n    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {\n      return sheet;\n    }\n  }\n\n  return null;\n}\n/**\n * Find attached sheet with the highest index.\n */\n\n\nfunction findHighestSheet(registry, options) {\n  for (var i = registry.length - 1; i >= 0; i--) {\n    var sheet = registry[i];\n\n    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {\n      return sheet;\n    }\n  }\n\n  return null;\n}\n/**\n * Find a comment with \"jss\" inside.\n */\n\n\nfunction findCommentNode(text) {\n  var head = getHead();\n\n  for (var i = 0; i < head.childNodes.length; i++) {\n    var node = head.childNodes[i];\n\n    if (node.nodeType === 8 && node.nodeValue.trim() === text) {\n      return node;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Find a node before which we can insert the sheet.\n */\nfunction findPrevNode(options) {\n  var registry = sheets.registry;\n\n  if (registry.length > 0) {\n    // Try to insert before the next higher sheet.\n    var sheet = findHigherSheet(registry, options);\n\n    if (sheet && sheet.renderer) {\n      return {\n        parent: sheet.renderer.element.parentNode,\n        node: sheet.renderer.element\n      };\n    } // Otherwise insert after the last attached.\n\n\n    sheet = findHighestSheet(registry, options);\n\n    if (sheet && sheet.renderer) {\n      return {\n        parent: sheet.renderer.element.parentNode,\n        node: sheet.renderer.element.nextSibling\n      };\n    }\n  } // Try to find a comment placeholder if registry is empty.\n\n\n  var insertionPoint = options.insertionPoint;\n\n  if (insertionPoint && typeof insertionPoint === 'string') {\n    var comment = findCommentNode(insertionPoint);\n\n    if (comment) {\n      return {\n        parent: comment.parentNode,\n        node: comment.nextSibling\n      };\n    } // If user specifies an insertion point and it can't be found in the document -\n    // bad specificity issues may appear.\n\n\n     false ? undefined : void 0;\n  }\n\n  return false;\n}\n/**\n * Insert style element into the DOM.\n */\n\n\nfunction insertStyle(style, options) {\n  var insertionPoint = options.insertionPoint;\n  var nextNode = findPrevNode(options);\n\n  if (nextNode !== false && nextNode.parent) {\n    nextNode.parent.insertBefore(style, nextNode.node);\n    return;\n  } // Works with iframes and any node types.\n\n\n  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {\n    // https://stackoverflow.com/questions/41328728/force-casting-in-flow\n    var insertionPointElement = insertionPoint;\n    var parentNode = insertionPointElement.parentNode;\n    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else  false ? undefined : void 0;\n    return;\n  }\n\n  getHead().appendChild(style);\n}\n/**\n * Read jss nonce setting from the page if the user has set it.\n */\n\n\nvar getNonce = memoize(function () {\n  var node = document.querySelector('meta[property=\"csp-nonce\"]');\n  return node ? node.getAttribute('content') : null;\n});\n\nvar _insertRule = function insertRule(container, rule, index) {\n  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong\n\n  if (index === undefined || index > maxIndex) {\n    // eslint-disable-next-line no-param-reassign\n    index = maxIndex;\n  }\n\n  try {\n    if ('insertRule' in container) {\n      var c = container;\n      c.insertRule(rule, index);\n    } // Keyframes rule.\n    else if ('appendRule' in container) {\n        var _c = container;\n\n        _c.appendRule(rule);\n      }\n  } catch (err) {\n     false ? undefined : void 0;\n    return false;\n  }\n\n  return container.cssRules[index];\n};\n\nvar createStyle = function createStyle() {\n  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we\n  // insert rules after we insert the style tag.\n  // It seems to kick-off the source order specificity algorithm.\n\n  el.textContent = '\\n';\n  return el;\n};\n\nvar DomRenderer =\n/*#__PURE__*/\nfunction () {\n  // HTMLStyleElement needs fixing https://github.com/facebook/flow/issues/2696\n  function DomRenderer(sheet) {\n    this.getPropertyValue = getPropertyValue;\n    this.setProperty = setProperty;\n    this.removeProperty = removeProperty;\n    this.setSelector = setSelector;\n    this.element = void 0;\n    this.sheet = void 0;\n    this.hasInsertedRules = false;\n    // There is no sheet when the renderer is used from a standalone StyleRule.\n    if (sheet) sheets.add(sheet);\n    this.sheet = sheet;\n\n    var _ref = this.sheet ? this.sheet.options : {},\n        media = _ref.media,\n        meta = _ref.meta,\n        element = _ref.element;\n\n    this.element = element || createStyle();\n    this.element.setAttribute('data-jss', '');\n    if (media) this.element.setAttribute('media', media);\n    if (meta) this.element.setAttribute('data-meta', meta);\n    var nonce = getNonce();\n    if (nonce) this.element.setAttribute('nonce', nonce);\n  }\n  /**\n   * Insert style element into render tree.\n   */\n\n\n  var _proto = DomRenderer.prototype;\n\n  _proto.attach = function attach() {\n    // In the case the element node is external and it is already in the DOM.\n    if (this.element.parentNode || !this.sheet) return;\n    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`\n    // most browsers create a new CSSStyleSheet, except of all IEs.\n\n    var deployed = Boolean(this.sheet && this.sheet.deployed);\n\n    if (this.hasInsertedRules && deployed) {\n      this.hasInsertedRules = false;\n      this.deploy();\n    }\n  }\n  /**\n   * Remove style element from render tree.\n   */\n  ;\n\n  _proto.detach = function detach() {\n    var parentNode = this.element.parentNode;\n    if (parentNode) parentNode.removeChild(this.element);\n  }\n  /**\n   * Inject CSS string into element.\n   */\n  ;\n\n  _proto.deploy = function deploy() {\n    var sheet = this.sheet;\n    if (!sheet) return;\n\n    if (sheet.options.link) {\n      this.insertRules(sheet.rules);\n      return;\n    }\n\n    this.element.textContent = \"\\n\" + sheet.toString() + \"\\n\";\n  }\n  /**\n   * Insert RuleList into an element.\n   */\n  ;\n\n  _proto.insertRules = function insertRules(rules, nativeParent) {\n    for (var i = 0; i < rules.index.length; i++) {\n      this.insertRule(rules.index[i], i, nativeParent);\n    }\n  }\n  /**\n   * Insert a rule into element.\n   */\n  ;\n\n  _proto.insertRule = function insertRule(rule, index, nativeParent) {\n    if (nativeParent === void 0) {\n      nativeParent = this.element.sheet;\n    }\n\n    if (rule.rules) {\n      var parent = rule;\n      var latestNativeParent = nativeParent;\n\n      if (rule.type === 'conditional' || rule.type === 'keyframes') {\n        // We need to render the container without children first.\n        latestNativeParent = _insertRule(nativeParent, parent.toString({\n          children: false\n        }), index);\n\n        if (latestNativeParent === false) {\n          return false;\n        }\n      }\n\n      this.insertRules(parent.rules, latestNativeParent);\n      return latestNativeParent;\n    } // IE keeps the CSSStyleSheet after style node has been reattached,\n    // so we need to check if the `renderable` reference the right style sheet and not\n    // rerender those rules.\n\n\n    if (rule.renderable && rule.renderable.parentStyleSheet === this.element.sheet) {\n      return rule.renderable;\n    }\n\n    var ruleStr = rule.toString();\n    if (!ruleStr) return false;\n\n    var nativeRule = _insertRule(nativeParent, ruleStr, index);\n\n    if (nativeRule === false) {\n      return false;\n    }\n\n    this.hasInsertedRules = true;\n    rule.renderable = nativeRule;\n    return nativeRule;\n  }\n  /**\n   * Delete a rule.\n   */\n  ;\n\n  _proto.deleteRule = function deleteRule(cssRule) {\n    var sheet = this.element.sheet;\n    var index = this.indexOf(cssRule);\n    if (index === -1) return false;\n    sheet.deleteRule(index);\n    return true;\n  }\n  /**\n   * Get index of a CSS Rule.\n   */\n  ;\n\n  _proto.indexOf = function indexOf(cssRule) {\n    var cssRules = this.element.sheet.cssRules;\n\n    for (var index = 0; index < cssRules.length; index++) {\n      if (cssRule === cssRules[index]) return index;\n    }\n\n    return -1;\n  }\n  /**\n   * Generate a new CSS rule and replace the existing one.\n   *\n   * Only used for some old browsers because they can't set a selector.\n   */\n  ;\n\n  _proto.replaceRule = function replaceRule(cssRule, rule) {\n    var index = this.indexOf(cssRule);\n    if (index === -1) return false;\n    this.element.sheet.deleteRule(index);\n    return this.insertRule(rule, index);\n  }\n  /**\n   * Get all rules elements.\n   */\n  ;\n\n  _proto.getRules = function getRules() {\n    return this.element.sheet.cssRules;\n  };\n\n  return DomRenderer;\n}();\n\nvar instanceCounter = 0;\n\nvar jss_esm_Jss =\n/*#__PURE__*/\nfunction () {\n  function Jss(options) {\n    this.id = instanceCounter++;\n    this.version = \"10.3.0\";\n    this.plugins = new PluginsRegistry();\n    this.options = {\n      id: {\n        minify: false\n      },\n      createGenerateId: createGenerateId,\n      Renderer: dist_module ? DomRenderer : null,\n      plugins: []\n    };\n    this.generateId = createGenerateId({\n      minify: false\n    });\n\n    for (var i = 0; i < plugins.length; i++) {\n      this.plugins.use(plugins[i], {\n        queue: 'internal'\n      });\n    }\n\n    this.setup(options);\n  }\n  /**\n   * Prepares various options, applies plugins.\n   * Should not be used twice on the same instance, because there is no plugins\n   * deduplication logic.\n   */\n\n\n  var _proto = Jss.prototype;\n\n  _proto.setup = function setup(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (options.createGenerateId) {\n      this.options.createGenerateId = options.createGenerateId;\n    }\n\n    if (options.id) {\n      this.options.id = _extends({}, this.options.id, options.id);\n    }\n\n    if (options.createGenerateId || options.id) {\n      this.generateId = this.options.createGenerateId(this.options.id);\n    }\n\n    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;\n\n    if ('Renderer' in options) {\n      this.options.Renderer = options.Renderer;\n    } // eslint-disable-next-line prefer-spread\n\n\n    if (options.plugins) this.use.apply(this, options.plugins);\n    return this;\n  }\n  /**\n   * Create a Style Sheet.\n   */\n  ;\n\n  _proto.createStyleSheet = function createStyleSheet(styles, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        index = _options.index;\n\n    if (typeof index !== 'number') {\n      index = sheets.index === 0 ? 0 : sheets.index + 1;\n    }\n\n    var sheet = new jss_esm_StyleSheet(styles, _extends({}, options, {\n      jss: this,\n      generateId: options.generateId || this.generateId,\n      insertionPoint: this.options.insertionPoint,\n      Renderer: this.options.Renderer,\n      index: index\n    }));\n    this.plugins.onProcessSheet(sheet);\n    return sheet;\n  }\n  /**\n   * Detach the Style Sheet and remove it from the registry.\n   */\n  ;\n\n  _proto.removeStyleSheet = function removeStyleSheet(sheet) {\n    sheet.detach();\n    sheets.remove(sheet);\n    return this;\n  }\n  /**\n   * Create a rule without a Style Sheet.\n   * [Deprecated] will be removed in the next major version.\n   */\n  ;\n\n  _proto.createRule = function createRule$1(name, style, options) {\n    if (style === void 0) {\n      style = {};\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    // Enable rule without name for inline styles.\n    if (typeof name === 'object') {\n      return this.createRule(undefined, name, style);\n    }\n\n    var ruleOptions = _extends({}, options, {\n      name: name,\n      jss: this,\n      Renderer: this.options.Renderer\n    });\n\n    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;\n    if (!ruleOptions.classes) ruleOptions.classes = {};\n    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};\n\n    var rule = createRule(name, style, ruleOptions);\n\n    if (rule) this.plugins.onProcessRule(rule);\n    return rule;\n  }\n  /**\n   * Register plugin. Passed function will be invoked with a rule instance.\n   */\n  ;\n\n  _proto.use = function use() {\n    var _this = this;\n\n    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n      plugins[_key] = arguments[_key];\n    }\n\n    plugins.forEach(function (plugin) {\n      _this.plugins.use(plugin);\n    });\n    return this;\n  };\n\n  return Jss;\n}();\n\n/**\n * Extracts a styles object with only props that contain function values.\n */\nfunction getDynamicStyles(styles) {\n  var to = null;\n\n  for (var key in styles) {\n    var value = styles[key];\n    var type = typeof value;\n\n    if (type === 'function') {\n      if (!to) to = {};\n      to[key] = value;\n    } else if (type === 'object' && value !== null && !Array.isArray(value)) {\n      var extracted = getDynamicStyles(value);\n\n      if (extracted) {\n        if (!to) to = {};\n        to[key] = extracted;\n      }\n    }\n  }\n\n  return to;\n}\n\n/**\n * SheetsManager is like a WeakMap which is designed to count StyleSheet\n * instances and attach/detach automatically.\n */\nvar jss_esm_SheetsManager =\n/*#__PURE__*/\nfunction () {\n  function SheetsManager() {\n    this.length = 0;\n    this.sheets = new WeakMap();\n  }\n\n  var _proto = SheetsManager.prototype;\n\n  _proto.get = function get(key) {\n    var entry = this.sheets.get(key);\n    return entry && entry.sheet;\n  };\n\n  _proto.add = function add(key, sheet) {\n    if (this.sheets.has(key)) return;\n    this.length++;\n    this.sheets.set(key, {\n      sheet: sheet,\n      refs: 0\n    });\n  };\n\n  _proto.manage = function manage(key) {\n    var entry = this.sheets.get(key);\n\n    if (entry) {\n      if (entry.refs === 0) {\n        entry.sheet.attach();\n      }\n\n      entry.refs++;\n      return entry.sheet;\n    }\n\n    tiny_warning_esm(false, \"[JSS] SheetsManager: can't find sheet to manage\");\n    return undefined;\n  };\n\n  _proto.unmanage = function unmanage(key) {\n    var entry = this.sheets.get(key);\n\n    if (entry) {\n      if (entry.refs > 0) {\n        entry.refs--;\n        if (entry.refs === 0) entry.sheet.detach();\n      }\n    } else {\n      tiny_warning_esm(false, \"SheetsManager: can't find sheet to unmanage\");\n    }\n  };\n\n  _createClass(SheetsManager, [{\n    key: \"size\",\n    get: function get() {\n      return this.length;\n    }\n  }]);\n\n  return SheetsManager;\n}();\n\n/**\n * A better abstraction over CSS.\n *\n * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present\n * @website https://github.com/cssinjs/jss\n * @license MIT\n */\n\n/**\n * Export a constant indicating if this browser has CSSTOM support.\n * https://developers.google.com/web/updates/2018/03/cssom\n */\nvar hasCSSTOMSupport = typeof CSS !== 'undefined' && CSS && 'number' in CSS;\n/**\n * Creates a new instance of Jss.\n */\n\nvar jss_esm_create = function create(options) {\n  return new jss_esm_Jss(options);\n};\n/**\n * A global Jss instance.\n */\n\nvar jss_esm_index = jss_esm_create();\n\n/* harmony default export */ var jss_esm = (jss_esm_index);\n\n\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/mergeClasses/mergeClasses.js\n\n\nfunction mergeClasses() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var baseClasses = options.baseClasses,\n      newClasses = options.newClasses,\n      Component = options.Component;\n\n  if (!newClasses) {\n    return baseClasses;\n  }\n\n  var nextClasses = _extends({}, baseClasses);\n\n  if (false) {}\n\n  Object.keys(newClasses).forEach(function (key) {\n    if (false) {}\n\n    if (newClasses[key]) {\n      nextClasses[key] = \"\".concat(baseClasses[key], \" \").concat(newClasses[key]);\n    }\n  });\n  return nextClasses;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/makeStyles/multiKeyStore.js\n// Used https://github.com/thinkloop/multi-key-cache as inspiration\nvar multiKeyStore = {\n  set: function set(cache, key1, key2, value) {\n    var subCache = cache.get(key1);\n\n    if (!subCache) {\n      subCache = new Map();\n      cache.set(key1, subCache);\n    }\n\n    subCache.set(key2, value);\n  },\n  get: function get(cache, key1, key2) {\n    var subCache = cache.get(key1);\n    return subCache ? subCache.get(key2) : undefined;\n  },\n  delete: function _delete(cache, key1, key2) {\n    var subCache = cache.get(key1);\n    subCache.delete(key2);\n  }\n};\n/* harmony default export */ var makeStyles_multiKeyStore = (multiKeyStore);\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/useTheme/ThemeContext.js\n\nvar ThemeContext = react_default.a.createContext(null);\n\nif (false) {}\n\n/* harmony default export */ var useTheme_ThemeContext = (ThemeContext);\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/useTheme/useTheme.js\n\n\nfunction useTheme() {\n  var theme = react_default.a.useContext(useTheme_ThemeContext);\n\n  if (false) {}\n\n  return theme;\n}\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/ThemeProvider/nested.js\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n/* harmony default export */ var nested = (hasSymbol ? Symbol.for('mui.nested') : '__THEME_NESTED__');\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/createGenerateClassName/createGenerateClassName.js\n\n/**\n * This is the list of the style rule name we use as drop in replacement for the built-in\n * pseudo classes (:checked, :disabled, :focused, etc.).\n *\n * Why do they exist in the first place?\n * These classes are used at a specificity of 2.\n * It allows them to override previously definied styles as well as\n * being untouched by simple user overrides.\n */\n\nvar createGenerateClassName_pseudoClasses = ['checked', 'disabled', 'error', 'focused', 'focusVisible', 'required', 'expanded', 'selected']; // Returns a function which generates unique class names based on counters.\n// When new generator function is created, rule counter is reset.\n// We need to reset the rule counter for SSR for each request.\n//\n// It's inspired by\n// https://github.com/cssinjs/jss/blob/4e6a05dd3f7b6572fdd3ab216861d9e446c20331/src/utils/createGenerateClassName.js\n\nfunction createGenerateClassName() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$disableGloba = options.disableGlobal,\n      disableGlobal = _options$disableGloba === void 0 ? false : _options$disableGloba,\n      _options$productionPr = options.productionPrefix,\n      productionPrefix = _options$productionPr === void 0 ? 'jss' : _options$productionPr,\n      _options$seed = options.seed,\n      seed = _options$seed === void 0 ? '' : _options$seed;\n  var seedPrefix = seed === '' ? '' : \"\".concat(seed, \"-\");\n  var ruleCounter = 0;\n\n  var getNextCounterId = function getNextCounterId() {\n    ruleCounter += 1;\n\n    if (false) {}\n\n    return ruleCounter;\n  };\n\n  return function (rule, styleSheet) {\n    var name = styleSheet.options.name; // Is a global static MUI style?\n\n    if (name && name.indexOf('Mui') === 0 && !styleSheet.options.link && !disableGlobal) {\n      // We can use a shorthand class name, we never use the keys to style the components.\n      if (createGenerateClassName_pseudoClasses.indexOf(rule.key) !== -1) {\n        return \"Mui-\".concat(rule.key);\n      }\n\n      var prefix = \"\".concat(seedPrefix).concat(name, \"-\").concat(rule.key);\n\n      if (!styleSheet.options.theme[nested] || seed !== '') {\n        return prefix;\n      }\n\n      return \"\".concat(prefix, \"-\").concat(getNextCounterId());\n    }\n\n    if (true) {\n      return \"\".concat(seedPrefix).concat(productionPrefix).concat(getNextCounterId());\n    }\n\n    var suffix = \"\".concat(rule.key, \"-\").concat(getNextCounterId()); // Help with debuggability.\n\n    if (styleSheet.options.classNamePrefix) {\n      return \"\".concat(seedPrefix).concat(styleSheet.options.classNamePrefix, \"-\").concat(suffix);\n    }\n\n    return \"\".concat(seedPrefix).concat(suffix);\n  };\n}\n// CONCATENATED MODULE: ./node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js\n\n\n\nvar now = Date.now();\nvar fnValuesNs = \"fnValues\" + now;\nvar fnRuleNs = \"fnStyle\" + ++now;\nfunction functionPlugin() {\n  return {\n    onCreateRule: function onCreateRule(name, decl, options) {\n      if (typeof decl !== 'function') return null;\n      var rule = createRule(name, {}, options);\n      rule[fnRuleNs] = decl;\n      return rule;\n    },\n    onProcessStyle: function onProcessStyle(style, rule) {\n      // We need to extract function values from the declaration, so that we can keep core unaware of them.\n      // We need to do that only once.\n      // We don't need to extract functions on each style update, since this can happen only once.\n      // We don't support function values inside of function rules.\n      if (fnValuesNs in rule || fnRuleNs in rule) return style;\n      var fnValues = {};\n\n      for (var prop in style) {\n        var value = style[prop];\n        if (typeof value !== 'function') continue;\n        delete style[prop];\n        fnValues[prop] = value;\n      } // $FlowFixMe\n\n\n      rule[fnValuesNs] = fnValues;\n      return style;\n    },\n    onUpdate: function onUpdate(data, rule, sheet, options) {\n      var styleRule = rule;\n      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object\n      // will be returned from that function.\n\n      if (fnRule) {\n        // Empty object will remove all currently defined props\n        // in case function rule returns a falsy value.\n        styleRule.style = fnRule(data) || {};\n\n        if (false) { var prop; }\n      }\n\n      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.\n\n      if (fnValues) {\n        for (var _prop in fnValues) {\n          styleRule.prop(_prop, fnValues[_prop](data), options);\n        }\n      }\n    }\n  };\n}\n\n/* harmony default export */ var jss_plugin_rule_value_function_esm = (functionPlugin);\n\n// CONCATENATED MODULE: ./node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js\n\n\n\nvar at = '@global';\nvar atPrefix = '@global ';\n\nvar jss_plugin_global_esm_GlobalContainerRule =\n/*#__PURE__*/\nfunction () {\n  function GlobalContainerRule(key, styles, options) {\n    this.type = 'global';\n    this.at = at;\n    this.rules = void 0;\n    this.options = void 0;\n    this.key = void 0;\n    this.isProcessed = false;\n    this.key = key;\n    this.options = options;\n    this.rules = new jss_esm_RuleList(_extends({}, options, {\n      parent: this\n    }));\n\n    for (var selector in styles) {\n      this.rules.add(selector, styles[selector]);\n    }\n\n    this.rules.process();\n  }\n  /**\n   * Get a rule.\n   */\n\n\n  var _proto = GlobalContainerRule.prototype;\n\n  _proto.getRule = function getRule(name) {\n    return this.rules.get(name);\n  }\n  /**\n   * Create and register rule, run plugins.\n   */\n  ;\n\n  _proto.addRule = function addRule(name, style, options) {\n    var rule = this.rules.add(name, style, options);\n    this.options.jss.plugins.onProcessRule(rule);\n    return rule;\n  }\n  /**\n   * Get index of a rule.\n   */\n  ;\n\n  _proto.indexOf = function indexOf(rule) {\n    return this.rules.indexOf(rule);\n  }\n  /**\n   * Generates a CSS string.\n   */\n  ;\n\n  _proto.toString = function toString() {\n    return this.rules.toString();\n  };\n\n  return GlobalContainerRule;\n}();\n\nvar jss_plugin_global_esm_GlobalPrefixedRule =\n/*#__PURE__*/\nfunction () {\n  function GlobalPrefixedRule(key, style, options) {\n    this.type = 'global';\n    this.at = at;\n    this.options = void 0;\n    this.rule = void 0;\n    this.isProcessed = false;\n    this.key = void 0;\n    this.key = key;\n    this.options = options;\n    var selector = key.substr(atPrefix.length);\n    this.rule = options.jss.createRule(selector, style, _extends({}, options, {\n      parent: this\n    }));\n  }\n\n  var _proto2 = GlobalPrefixedRule.prototype;\n\n  _proto2.toString = function toString(options) {\n    return this.rule ? this.rule.toString(options) : '';\n  };\n\n  return GlobalPrefixedRule;\n}();\n\nvar separatorRegExp = /\\s*,\\s*/g;\n\nfunction addScope(selector, scope) {\n  var parts = selector.split(separatorRegExp);\n  var scoped = '';\n\n  for (var i = 0; i < parts.length; i++) {\n    scoped += scope + \" \" + parts[i].trim();\n    if (parts[i + 1]) scoped += ', ';\n  }\n\n  return scoped;\n}\n\nfunction handleNestedGlobalContainerRule(rule) {\n  var options = rule.options,\n      style = rule.style;\n  var rules = style ? style[at] : null;\n  if (!rules) return;\n\n  for (var name in rules) {\n    options.sheet.addRule(name, rules[name], _extends({}, options, {\n      selector: addScope(name, rule.selector)\n    }));\n  }\n\n  delete style[at];\n}\n\nfunction handlePrefixedGlobalRule(rule) {\n  var options = rule.options,\n      style = rule.style;\n\n  for (var prop in style) {\n    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;\n    var selector = addScope(prop.substr(at.length), rule.selector);\n    options.sheet.addRule(selector, style[prop], _extends({}, options, {\n      selector: selector\n    }));\n    delete style[prop];\n  }\n}\n/**\n * Convert nested rules to separate, remove them from original styles.\n *\n * @param {Rule} rule\n * @api public\n */\n\n\nfunction jssGlobal() {\n  function onCreateRule(name, styles, options) {\n    if (!name) return null;\n\n    if (name === at) {\n      return new jss_plugin_global_esm_GlobalContainerRule(name, styles, options);\n    }\n\n    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {\n      return new jss_plugin_global_esm_GlobalPrefixedRule(name, styles, options);\n    }\n\n    var parent = options.parent;\n\n    if (parent) {\n      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {\n        options.scoped = false;\n      }\n    }\n\n    if (options.scoped === false) {\n      options.selector = name;\n    }\n\n    return null;\n  }\n\n  function onProcessRule(rule) {\n    if (rule.type !== 'style') return;\n    handleNestedGlobalContainerRule(rule);\n    handlePrefixedGlobalRule(rule);\n  }\n\n  return {\n    onCreateRule: onCreateRule,\n    onProcessRule: onProcessRule\n  };\n}\n\n/* harmony default export */ var jss_plugin_global_esm = (jssGlobal);\n\n// CONCATENATED MODULE: ./node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js\n\n\n\nvar jss_plugin_nested_esm_separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar jss_plugin_nested_esm_refRegExp = /\\$([\\w-]+)/g;\n/**\n * Convert nested rules to separate, remove them from original styles.\n *\n * @param {Rule} rule\n * @api public\n */\n\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container, sheet) {\n    return function (match, key) {\n      var rule = container.getRule(key) || sheet && sheet.getRule(key);\n\n      if (rule) {\n        rule = rule;\n        return rule.selector;\n      }\n\n       false ? undefined : void 0;\n      return key;\n    };\n  }\n\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(jss_plugin_nested_esm_separatorRegExp);\n    var nestedSelectors = nestedProp.split(jss_plugin_nested_esm_separatorRegExp);\n    var result = '';\n\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.\n\n        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + \" \" + nested;\n      }\n    }\n\n    return result;\n  }\n\n  function getOptions(rule, container, prevOptions) {\n    // Options has been already created, now we only increase index.\n    if (prevOptions) return _extends({}, prevOptions, {\n      index: prevOptions.index + 1\n    });\n    var nestingLevel = rule.options.nestingLevel;\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n\n    var options = _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.\n\n    });\n\n    delete options.name;\n    return options;\n  }\n\n  function onProcessStyle(style, rule, sheet) {\n    if (rule.type !== 'style') return style;\n    var styleRule = rule;\n    var container = styleRule.options.parent;\n    var options;\n    var replaceRef;\n\n    for (var prop in style) {\n      var isNested = prop.indexOf('&') !== -1;\n      var isNestedConditional = prop[0] === '@';\n      if (!isNested && !isNestedConditional) continue;\n      options = getOptions(styleRule, container, options);\n\n      if (isNested) {\n        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n\n        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.\n\n        selector = selector.replace(jss_plugin_nested_esm_refRegExp, replaceRef);\n        container.addRule(selector, style[prop], _extends({}, options, {\n          selector: selector\n        }));\n      } else if (isNestedConditional) {\n        // Place conditional right after the parent rule to ensure right ordering.\n        container.addRule(prop, {}, options) // Flow expects more options but they aren't required\n        // And flow doesn't know this will always be a StyleRule which has the addRule method\n        // $FlowFixMe\n        .addRule(styleRule.key, style[prop], {\n          selector: styleRule.selector\n        });\n      }\n\n      delete style[prop];\n    }\n\n    return style;\n  }\n\n  return {\n    onProcessStyle: onProcessStyle\n  };\n}\n\n/* harmony default export */ var jss_plugin_nested_esm = (jssNested);\n\n// CONCATENATED MODULE: ./node_modules/hyphenate-style-name/index.js\n/* eslint-disable no-var, prefer-template */\nvar uppercasePattern = /[A-Z]/g\nvar msPattern = /^ms-/\nvar hyphenate_style_name_cache = {}\n\nfunction toHyphenLower(match) {\n  return '-' + match.toLowerCase()\n}\n\nfunction hyphenateStyleName(name) {\n  if (hyphenate_style_name_cache.hasOwnProperty(name)) {\n    return hyphenate_style_name_cache[name]\n  }\n\n  var hName = name.replace(uppercasePattern, toHyphenLower)\n  return (hyphenate_style_name_cache[name] = msPattern.test(hName) ? '-' + hName : hName)\n}\n\n/* harmony default export */ var hyphenate_style_name = (hyphenateStyleName);\n\n// CONCATENATED MODULE: ./node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js\n\n\n/**\n * Convert camel cased property names to dash separated.\n *\n * @param {Object} style\n * @return {Object}\n */\n\nfunction convertCase(style) {\n  var converted = {};\n\n  for (var prop in style) {\n    var key = prop.indexOf('--') === 0 ? prop : hyphenate_style_name(prop);\n    converted[key] = style[prop];\n  }\n\n  if (style.fallbacks) {\n    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);\n  }\n\n  return converted;\n}\n/**\n * Allow camel cased property names by converting them back to dasherized.\n *\n * @param {Rule} rule\n */\n\n\nfunction camelCase() {\n  function onProcessStyle(style) {\n    if (Array.isArray(style)) {\n      // Handle rules like @font-face, which can have multiple styles in an array\n      for (var index = 0; index < style.length; index++) {\n        style[index] = convertCase(style[index]);\n      }\n\n      return style;\n    }\n\n    return convertCase(style);\n  }\n\n  function onChangeValue(value, prop, rule) {\n    if (prop.indexOf('--') === 0) {\n      return value;\n    }\n\n    var hyphenatedProp = hyphenate_style_name(prop); // There was no camel case in place\n\n    if (prop === hyphenatedProp) return value;\n    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.\n\n    return null;\n  }\n\n  return {\n    onProcessStyle: onProcessStyle,\n    onChangeValue: onChangeValue\n  };\n}\n\n/* harmony default export */ var jss_plugin_camel_case_esm = (camelCase);\n\n// CONCATENATED MODULE: ./node_modules/jss-plugin-default-unit/dist/jss-plugin-default-unit.esm.js\n\n\nvar px = hasCSSTOMSupport && CSS ? CSS.px : 'px';\nvar ms = hasCSSTOMSupport && CSS ? CSS.ms : 'ms';\nvar percent = hasCSSTOMSupport && CSS ? CSS.percent : '%';\n/**\n * Generated jss-plugin-default-unit CSS property units\n *\n * @type object\n */\n\nvar defaultUnits = {\n  // Animation properties\n  'animation-delay': ms,\n  'animation-duration': ms,\n  // Background properties\n  'background-position': px,\n  'background-position-x': px,\n  'background-position-y': px,\n  'background-size': px,\n  // Border Properties\n  border: px,\n  'border-bottom': px,\n  'border-bottom-left-radius': px,\n  'border-bottom-right-radius': px,\n  'border-bottom-width': px,\n  'border-left': px,\n  'border-left-width': px,\n  'border-radius': px,\n  'border-right': px,\n  'border-right-width': px,\n  'border-top': px,\n  'border-top-left-radius': px,\n  'border-top-right-radius': px,\n  'border-top-width': px,\n  'border-width': px,\n  // Margin properties\n  margin: px,\n  'margin-bottom': px,\n  'margin-left': px,\n  'margin-right': px,\n  'margin-top': px,\n  // Padding properties\n  padding: px,\n  'padding-bottom': px,\n  'padding-left': px,\n  'padding-right': px,\n  'padding-top': px,\n  // Mask properties\n  'mask-position-x': px,\n  'mask-position-y': px,\n  'mask-size': px,\n  // Width and height properties\n  height: px,\n  width: px,\n  'min-height': px,\n  'max-height': px,\n  'min-width': px,\n  'max-width': px,\n  // Position properties\n  bottom: px,\n  left: px,\n  top: px,\n  right: px,\n  // Shadow properties\n  'box-shadow': px,\n  'text-shadow': px,\n  // Column properties\n  'column-gap': px,\n  'column-rule': px,\n  'column-rule-width': px,\n  'column-width': px,\n  // Font and text properties\n  'font-size': px,\n  'font-size-delta': px,\n  'letter-spacing': px,\n  'text-indent': px,\n  'text-stroke': px,\n  'text-stroke-width': px,\n  'word-spacing': px,\n  // Motion properties\n  motion: px,\n  'motion-offset': px,\n  // Outline properties\n  outline: px,\n  'outline-offset': px,\n  'outline-width': px,\n  // Perspective properties\n  perspective: px,\n  'perspective-origin-x': percent,\n  'perspective-origin-y': percent,\n  // Transform properties\n  'transform-origin': percent,\n  'transform-origin-x': percent,\n  'transform-origin-y': percent,\n  'transform-origin-z': percent,\n  // Transition properties\n  'transition-delay': ms,\n  'transition-duration': ms,\n  // Alignment properties\n  'vertical-align': px,\n  'flex-basis': px,\n  // Some random properties\n  'shape-margin': px,\n  size: px,\n  // Grid properties\n  grid: px,\n  'grid-gap': px,\n  'grid-row-gap': px,\n  'grid-column-gap': px,\n  'grid-template-rows': px,\n  'grid-template-columns': px,\n  'grid-auto-rows': px,\n  'grid-auto-columns': px,\n  // Not existing properties.\n  // Used to avoid issues with jss-plugin-expand integration.\n  'box-shadow-x': px,\n  'box-shadow-y': px,\n  'box-shadow-blur': px,\n  'box-shadow-spread': px,\n  'font-line-height': px,\n  'text-shadow-x': px,\n  'text-shadow-y': px,\n  'text-shadow-blur': px\n};\n\n/**\n * Clones the object and adds a camel cased property version.\n */\nfunction addCamelCasedVersion(obj) {\n  var regExp = /(-[a-z])/g;\n\n  var replace = function replace(str) {\n    return str[1].toUpperCase();\n  };\n\n  var newObj = {};\n\n  for (var _key in obj) {\n    newObj[_key] = obj[_key];\n    newObj[_key.replace(regExp, replace)] = obj[_key];\n  }\n\n  return newObj;\n}\n\nvar units = addCamelCasedVersion(defaultUnits);\n/**\n * Recursive deep style passing function\n */\n\nfunction iterate(prop, value, options) {\n  if (!value) return value;\n\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) {\n      value[i] = iterate(prop, value[i], options);\n    }\n  } else if (typeof value === 'object') {\n    if (prop === 'fallbacks') {\n      for (var innerProp in value) {\n        value[innerProp] = iterate(innerProp, value[innerProp], options);\n      }\n    } else {\n      for (var _innerProp in value) {\n        value[_innerProp] = iterate(prop + \"-\" + _innerProp, value[_innerProp], options);\n      }\n    }\n  } else if (typeof value === 'number') {\n    var unit = options[prop] || units[prop];\n\n    if (unit) {\n      return typeof unit === 'function' ? unit(value).toString() : \"\" + value + unit;\n    }\n\n    return value.toString();\n  }\n\n  return value;\n}\n/**\n * Add unit to numeric values.\n */\n\n\nfunction defaultUnit(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var camelCasedOptions = addCamelCasedVersion(options);\n\n  function onProcessStyle(style, rule) {\n    if (rule.type !== 'style') return style;\n\n    for (var prop in style) {\n      style[prop] = iterate(prop, style[prop], camelCasedOptions);\n    }\n\n    return style;\n  }\n\n  function onChangeValue(value, prop) {\n    return iterate(prop, value, camelCasedOptions);\n  }\n\n  return {\n    onProcessStyle: onProcessStyle,\n    onChangeValue: onChangeValue\n  };\n}\n\n/* harmony default export */ var jss_plugin_default_unit_esm = (defaultUnit);\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\n\n\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n// CONCATENATED MODULE: ./node_modules/css-vendor/dist/css-vendor.esm.js\n\n\n\n// Export javascript style and css style vendor prefixes.\nvar js = '';\nvar css_vendor_esm_css = '';\nvar vendor = '';\nvar browser = '';\nvar isTouch = dist_module && 'ontouchstart' in document.documentElement; // We should not do anything if required serverside.\n\nif (dist_module) {\n  // Order matters. We need to check Webkit the last one because\n  // other vendors use to add Webkit prefixes to some properties\n  var jsCssMap = {\n    Moz: '-moz-',\n    ms: '-ms-',\n    O: '-o-',\n    Webkit: '-webkit-'\n  };\n\n  var _document$createEleme = document.createElement('p'),\n      css_vendor_esm_style = _document$createEleme.style;\n\n  var testProp = 'Transform';\n\n  for (var css_vendor_esm_key in jsCssMap) {\n    if (css_vendor_esm_key + testProp in css_vendor_esm_style) {\n      js = css_vendor_esm_key;\n      css_vendor_esm_css = jsCssMap[css_vendor_esm_key];\n      break;\n    }\n  } // Correctly detect the Edge browser.\n\n\n  if (js === 'Webkit' && 'msHyphens' in css_vendor_esm_style) {\n    js = 'ms';\n    css_vendor_esm_css = jsCssMap.ms;\n    browser = 'edge';\n  } // Correctly detect the Safari browser.\n\n\n  if (js === 'Webkit' && '-apple-trailing-word' in css_vendor_esm_style) {\n    vendor = 'apple';\n  }\n}\n/**\n * Vendor prefix string for the current browser.\n *\n * @type {{js: String, css: String, vendor: String, browser: String}}\n * @api public\n */\n\n\nvar css_vendor_esm_prefix = {\n  js: js,\n  css: css_vendor_esm_css,\n  vendor: vendor,\n  browser: browser,\n  isTouch: isTouch\n};\n\n/**\n * Test if a keyframe at-rule should be prefixed or not\n *\n * @param {String} vendor prefix string for the current browser.\n * @return {String}\n * @api public\n */\n\nfunction supportedKeyframes(key) {\n  // Keyframes is already prefixed. e.g. key = '@-webkit-keyframes a'\n  if (key[1] === '-') return key; // No need to prefix IE/Edge. Older browsers will ignore unsupported rules.\n  // https://caniuse.com/#search=keyframes\n\n  if (css_vendor_esm_prefix.js === 'ms') return key;\n  return \"@\" + css_vendor_esm_prefix.css + \"keyframes\" + key.substr(10);\n}\n\n// https://caniuse.com/#search=appearance\n\nvar appearence = {\n  noPrefill: ['appearance'],\n  supportedProperty: function supportedProperty(prop) {\n    if (prop !== 'appearance') return false;\n    if (css_vendor_esm_prefix.js === 'ms') return \"-webkit-\" + prop;\n    return css_vendor_esm_prefix.css + prop;\n  }\n};\n\n// https://caniuse.com/#search=color-adjust\n\nvar colorAdjust = {\n  noPrefill: ['color-adjust'],\n  supportedProperty: function supportedProperty(prop) {\n    if (prop !== 'color-adjust') return false;\n    if (css_vendor_esm_prefix.js === 'Webkit') return css_vendor_esm_prefix.css + \"print-\" + prop;\n    return prop;\n  }\n};\n\nvar regExp = /[-\\s]+(.)?/g;\n/**\n * Replaces the letter with the capital letter\n *\n * @param {String} match\n * @param {String} c\n * @return {String}\n * @api private\n */\n\nfunction toUpper(match, c) {\n  return c ? c.toUpperCase() : '';\n}\n/**\n * Convert dash separated strings to camel-cased.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\n\nfunction camelize(str) {\n  return str.replace(regExp, toUpper);\n}\n\n/**\n * Convert dash separated strings to pascal cased.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction pascalize(str) {\n  return camelize(\"-\" + str);\n}\n\n// but we can use a longhand property instead.\n// https://caniuse.com/#search=mask\n\nvar mask = {\n  noPrefill: ['mask'],\n  supportedProperty: function supportedProperty(prop, style) {\n    if (!/^mask/.test(prop)) return false;\n\n    if (css_vendor_esm_prefix.js === 'Webkit') {\n      var longhand = 'mask-image';\n\n      if (camelize(longhand) in style) {\n        return prop;\n      }\n\n      if (css_vendor_esm_prefix.js + pascalize(longhand) in style) {\n        return css_vendor_esm_prefix.css + prop;\n      }\n    }\n\n    return prop;\n  }\n};\n\n// https://caniuse.com/#search=text-orientation\n\nvar textOrientation = {\n  noPrefill: ['text-orientation'],\n  supportedProperty: function supportedProperty(prop) {\n    if (prop !== 'text-orientation') return false;\n\n    if (css_vendor_esm_prefix.vendor === 'apple' && !css_vendor_esm_prefix.isTouch) {\n      return css_vendor_esm_prefix.css + prop;\n    }\n\n    return prop;\n  }\n};\n\n// https://caniuse.com/#search=transform\n\nvar css_vendor_esm_transform = {\n  noPrefill: ['transform'],\n  supportedProperty: function supportedProperty(prop, style, options) {\n    if (prop !== 'transform') return false;\n\n    if (options.transform) {\n      return prop;\n    }\n\n    return css_vendor_esm_prefix.css + prop;\n  }\n};\n\n// https://caniuse.com/#search=transition\n\nvar transition = {\n  noPrefill: ['transition'],\n  supportedProperty: function supportedProperty(prop, style, options) {\n    if (prop !== 'transition') return false;\n\n    if (options.transition) {\n      return prop;\n    }\n\n    return css_vendor_esm_prefix.css + prop;\n  }\n};\n\n// https://caniuse.com/#search=writing-mode\n\nvar writingMode = {\n  noPrefill: ['writing-mode'],\n  supportedProperty: function supportedProperty(prop) {\n    if (prop !== 'writing-mode') return false;\n\n    if (css_vendor_esm_prefix.js === 'Webkit' || css_vendor_esm_prefix.js === 'ms' && css_vendor_esm_prefix.browser !== 'edge') {\n      return css_vendor_esm_prefix.css + prop;\n    }\n\n    return prop;\n  }\n};\n\n// https://caniuse.com/#search=user-select\n\nvar userSelect = {\n  noPrefill: ['user-select'],\n  supportedProperty: function supportedProperty(prop) {\n    if (prop !== 'user-select') return false;\n\n    if (css_vendor_esm_prefix.js === 'Moz' || css_vendor_esm_prefix.js === 'ms' || css_vendor_esm_prefix.vendor === 'apple') {\n      return css_vendor_esm_prefix.css + prop;\n    }\n\n    return prop;\n  }\n};\n\n// https://caniuse.com/#search=multicolumn\n// https://github.com/postcss/autoprefixer/issues/491\n// https://github.com/postcss/autoprefixer/issues/177\n\nvar breakPropsOld = {\n  supportedProperty: function supportedProperty(prop, style) {\n    if (!/^break-/.test(prop)) return false;\n\n    if (css_vendor_esm_prefix.js === 'Webkit') {\n      var jsProp = \"WebkitColumn\" + pascalize(prop);\n      return jsProp in style ? css_vendor_esm_prefix.css + \"column-\" + prop : false;\n    }\n\n    if (css_vendor_esm_prefix.js === 'Moz') {\n      var _jsProp = \"page\" + pascalize(prop);\n\n      return _jsProp in style ? \"page-\" + prop : false;\n    }\n\n    return false;\n  }\n};\n\n// See https://github.com/postcss/autoprefixer/issues/324.\n\nvar inlineLogicalOld = {\n  supportedProperty: function supportedProperty(prop, style) {\n    if (!/^(border|margin|padding)-inline/.test(prop)) return false;\n    if (css_vendor_esm_prefix.js === 'Moz') return prop;\n    var newProp = prop.replace('-inline', '');\n    return css_vendor_esm_prefix.js + pascalize(newProp) in style ? css_vendor_esm_prefix.css + newProp : false;\n  }\n};\n\n// Camelization is required because we can't test using.\n// CSS syntax for e.g. in FF.\n\nvar unprefixed = {\n  supportedProperty: function supportedProperty(prop, style) {\n    return camelize(prop) in style ? prop : false;\n  }\n};\n\nvar prefixed = {\n  supportedProperty: function supportedProperty(prop, style) {\n    var pascalized = pascalize(prop); // Return custom CSS variable without prefixing.\n\n    if (prop[0] === '-') return prop; // Return already prefixed value without prefixing.\n\n    if (prop[0] === '-' && prop[1] === '-') return prop;\n    if (css_vendor_esm_prefix.js + pascalized in style) return css_vendor_esm_prefix.css + prop; // Try webkit fallback.\n\n    if (css_vendor_esm_prefix.js !== 'Webkit' && \"Webkit\" + pascalized in style) return \"-webkit-\" + prop;\n    return false;\n  }\n};\n\n// https://caniuse.com/#search=scroll-snap\n\nvar scrollSnap = {\n  supportedProperty: function supportedProperty(prop) {\n    if (prop.substring(0, 11) !== 'scroll-snap') return false;\n\n    if (css_vendor_esm_prefix.js === 'ms') {\n      return \"\" + css_vendor_esm_prefix.css + prop;\n    }\n\n    return prop;\n  }\n};\n\n// https://caniuse.com/#search=overscroll-behavior\n\nvar overscrollBehavior = {\n  supportedProperty: function supportedProperty(prop) {\n    if (prop !== 'overscroll-behavior') return false;\n\n    if (css_vendor_esm_prefix.js === 'ms') {\n      return css_vendor_esm_prefix.css + \"scroll-chaining\";\n    }\n\n    return prop;\n  }\n};\n\nvar propMap = {\n  'flex-grow': 'flex-positive',\n  'flex-shrink': 'flex-negative',\n  'flex-basis': 'flex-preferred-size',\n  'justify-content': 'flex-pack',\n  order: 'flex-order',\n  'align-items': 'flex-align',\n  'align-content': 'flex-line-pack' // 'align-self' is handled by 'align-self' plugin.\n\n}; // Support old flex spec from 2012.\n\nvar flex2012 = {\n  supportedProperty: function supportedProperty(prop, style) {\n    var newProp = propMap[prop];\n    if (!newProp) return false;\n    return css_vendor_esm_prefix.js + pascalize(newProp) in style ? css_vendor_esm_prefix.css + newProp : false;\n  }\n};\n\nvar propMap$1 = {\n  flex: 'box-flex',\n  'flex-grow': 'box-flex',\n  'flex-direction': ['box-orient', 'box-direction'],\n  order: 'box-ordinal-group',\n  'align-items': 'box-align',\n  'flex-flow': ['box-orient', 'box-direction'],\n  'justify-content': 'box-pack'\n};\nvar propKeys = Object.keys(propMap$1);\n\nvar prefixCss = function prefixCss(p) {\n  return css_vendor_esm_prefix.css + p;\n}; // Support old flex spec from 2009.\n\n\nvar flex2009 = {\n  supportedProperty: function supportedProperty(prop, style, _ref) {\n    var multiple = _ref.multiple;\n\n    if (propKeys.indexOf(prop) > -1) {\n      var newProp = propMap$1[prop];\n\n      if (!Array.isArray(newProp)) {\n        return css_vendor_esm_prefix.js + pascalize(newProp) in style ? css_vendor_esm_prefix.css + newProp : false;\n      }\n\n      if (!multiple) return false;\n\n      for (var i = 0; i < newProp.length; i++) {\n        if (!(css_vendor_esm_prefix.js + pascalize(newProp[0]) in style)) {\n          return false;\n        }\n      }\n\n      return newProp.map(prefixCss);\n    }\n\n    return false;\n  }\n};\n\n// plugins = [\n//   ...plugins,\n//    breakPropsOld,\n//    inlineLogicalOld,\n//    unprefixed,\n//    prefixed,\n//    scrollSnap,\n//    flex2012,\n//    flex2009\n// ]\n// Plugins without 'noPrefill' value, going last.\n// 'flex-*' plugins should be at the bottom.\n// 'flex2009' going after 'flex2012'.\n// 'prefixed' going after 'unprefixed'\n\nvar css_vendor_esm_plugins = [appearence, colorAdjust, mask, textOrientation, css_vendor_esm_transform, transition, writingMode, userSelect, breakPropsOld, inlineLogicalOld, unprefixed, prefixed, scrollSnap, overscrollBehavior, flex2012, flex2009];\nvar propertyDetectors = css_vendor_esm_plugins.filter(function (p) {\n  return p.supportedProperty;\n}).map(function (p) {\n  return p.supportedProperty;\n});\nvar noPrefill = css_vendor_esm_plugins.filter(function (p) {\n  return p.noPrefill;\n}).reduce(function (a, p) {\n  a.push.apply(a, _toConsumableArray(p.noPrefill));\n  return a;\n}, []);\n\nvar el;\nvar css_vendor_esm_cache = {};\n\nif (dist_module) {\n  el = document.createElement('p'); // We test every property on vendor prefix requirement.\n  // Once tested, result is cached. It gives us up to 70% perf boost.\n  // http://jsperf.com/element-style-object-access-vs-plain-object\n  //\n  // Prefill cache with known css properties to reduce amount of\n  // properties we need to feature test at runtime.\n  // http://davidwalsh.name/vendor-prefix\n\n  var computed = window.getComputedStyle(document.documentElement, '');\n\n  for (var key$1 in computed) {\n    // eslint-disable-next-line no-restricted-globals\n    if (!isNaN(key$1)) css_vendor_esm_cache[computed[key$1]] = computed[key$1];\n  } // Properties that cannot be correctly detected using the\n  // cache prefill method.\n\n\n  noPrefill.forEach(function (x) {\n    return delete css_vendor_esm_cache[x];\n  });\n}\n/**\n * Test if a property is supported, returns supported property with vendor\n * prefix if required. Returns `false` if not supported.\n *\n * @param {String} prop dash separated\n * @param {Object} [options]\n * @return {String|Boolean}\n * @api public\n */\n\n\nfunction supportedProperty(prop, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  // For server-side rendering.\n  if (!el) return prop; // Remove cache for benchmark tests or return property from the cache.\n\n  if ( true && css_vendor_esm_cache[prop] != null) {\n    return css_vendor_esm_cache[prop];\n  } // Check if 'transition' or 'transform' natively supported in browser.\n\n\n  if (prop === 'transition' || prop === 'transform') {\n    options[prop] = prop in el.style;\n  } // Find a plugin for current prefix property.\n\n\n  for (var i = 0; i < propertyDetectors.length; i++) {\n    css_vendor_esm_cache[prop] = propertyDetectors[i](prop, el.style, options); // Break loop, if value found.\n\n    if (css_vendor_esm_cache[prop]) break;\n  } // Reset styles for current property.\n  // Firefox can even throw an error for invalid properties, e.g., \"0\".\n\n\n  try {\n    el.style[prop] = '';\n  } catch (err) {\n    return false;\n  }\n\n  return css_vendor_esm_cache[prop];\n}\n\nvar cache$1 = {};\nvar transitionProperties = {\n  transition: 1,\n  'transition-property': 1,\n  '-webkit-transition': 1,\n  '-webkit-transition-property': 1\n};\nvar transPropsRegExp = /(^\\s*[\\w-]+)|, (\\s*[\\w-]+)(?![^()]*\\))/g;\nvar el$1;\n/**\n * Returns prefixed value transition/transform if needed.\n *\n * @param {String} match\n * @param {String} p1\n * @param {String} p2\n * @return {String}\n * @api private\n */\n\nfunction prefixTransitionCallback(match, p1, p2) {\n  if (p1 === 'var') return 'var';\n  if (p1 === 'all') return 'all';\n  if (p2 === 'all') return ', all';\n  var prefixedValue = p1 ? supportedProperty(p1) : \", \" + supportedProperty(p2);\n  if (!prefixedValue) return p1 || p2;\n  return prefixedValue;\n}\n\nif (dist_module) el$1 = document.createElement('p');\n/**\n * Returns prefixed value if needed. Returns `false` if value is not supported.\n *\n * @param {String} property\n * @param {String} value\n * @return {String|Boolean}\n * @api public\n */\n\nfunction supportedValue(property, value) {\n  // For server-side rendering.\n  var prefixedValue = value;\n  if (!el$1 || property === 'content') return value; // It is a string or a number as a string like '1'.\n  // We want only prefixable values here.\n  // eslint-disable-next-line no-restricted-globals\n\n  if (typeof prefixedValue !== 'string' || !isNaN(parseInt(prefixedValue, 10))) {\n    return prefixedValue;\n  } // Create cache key for current value.\n\n\n  var cacheKey = property + prefixedValue; // Remove cache for benchmark tests or return value from cache.\n\n  if ( true && cache$1[cacheKey] != null) {\n    return cache$1[cacheKey];\n  } // IE can even throw an error in some cases, for e.g. style.content = 'bar'.\n\n\n  try {\n    // Test value as it is.\n    el$1.style[property] = prefixedValue;\n  } catch (err) {\n    // Return false if value not supported.\n    cache$1[cacheKey] = false;\n    return false;\n  } // If 'transition' or 'transition-property' property.\n\n\n  if (transitionProperties[property]) {\n    prefixedValue = prefixedValue.replace(transPropsRegExp, prefixTransitionCallback);\n  } else if (el$1.style[property] === '') {\n    // Value with a vendor prefix.\n    prefixedValue = css_vendor_esm_prefix.css + prefixedValue; // Hardcode test to convert \"flex\" to \"-ms-flexbox\" for IE10.\n\n    if (prefixedValue === '-ms-flex') el$1.style[property] = '-ms-flexbox'; // Test prefixed value.\n\n    el$1.style[property] = prefixedValue; // Return false if value not supported.\n\n    if (el$1.style[property] === '') {\n      cache$1[cacheKey] = false;\n      return false;\n    }\n  } // Reset styles for current property.\n\n\n  el$1.style[property] = ''; // Write current value to cache.\n\n  cache$1[cacheKey] = prefixedValue;\n  return cache$1[cacheKey];\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/jss-plugin-vendor-prefixer/dist/jss-plugin-vendor-prefixer.esm.js\n\n\n\n/**\n * Add vendor prefix to a property name when needed.\n *\n * @api public\n */\n\nfunction jssVendorPrefixer() {\n  function onProcessRule(rule) {\n    if (rule.type === 'keyframes') {\n      var atRule = rule;\n      atRule.at = supportedKeyframes(atRule.at);\n    }\n  }\n\n  function prefixStyle(style) {\n    for (var prop in style) {\n      var value = style[prop];\n\n      if (prop === 'fallbacks' && Array.isArray(value)) {\n        style[prop] = value.map(prefixStyle);\n        continue;\n      }\n\n      var changeProp = false;\n      var supportedProp = supportedProperty(prop);\n      if (supportedProp && supportedProp !== prop) changeProp = true;\n      var changeValue = false;\n      var supportedValue$1 = supportedValue(supportedProp, toCssValue(value));\n      if (supportedValue$1 && supportedValue$1 !== value) changeValue = true;\n\n      if (changeProp || changeValue) {\n        if (changeProp) delete style[prop];\n        style[supportedProp || prop] = supportedValue$1 || value;\n      }\n    }\n\n    return style;\n  }\n\n  function onProcessStyle(style, rule) {\n    if (rule.type !== 'style') return style;\n    return prefixStyle(style);\n  }\n\n  function onChangeValue(value, prop) {\n    return supportedValue(prop, toCssValue(value)) || value;\n  }\n\n  return {\n    onProcessRule: onProcessRule,\n    onProcessStyle: onProcessStyle,\n    onChangeValue: onChangeValue\n  };\n}\n\n/* harmony default export */ var jss_plugin_vendor_prefixer_esm = (jssVendorPrefixer);\n\n// CONCATENATED MODULE: ./node_modules/jss-plugin-props-sort/dist/jss-plugin-props-sort.esm.js\n/**\n * Sort props by length.\n */\nfunction jssPropsSort() {\n  var sort = function sort(prop0, prop1) {\n    if (prop0.length === prop1.length) {\n      return prop0 > prop1 ? 1 : -1;\n    }\n\n    return prop0.length - prop1.length;\n  };\n\n  return {\n    onProcessStyle: function onProcessStyle(style, rule) {\n      if (rule.type !== 'style') return style;\n      var newStyle = {};\n      var props = Object.keys(style).sort(sort);\n\n      for (var i = 0; i < props.length; i++) {\n        newStyle[props[i]] = style[props[i]];\n      }\n\n      return newStyle;\n    }\n  };\n}\n\n/* harmony default export */ var jss_plugin_props_sort_esm = (jssPropsSort);\n\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/jssPreset/jssPreset.js\n\n\n\n\n\n\n // Subset of jss-preset-default with only the plugins the Material-UI components are using.\n\nfunction jssPreset() {\n  return {\n    plugins: [jss_plugin_rule_value_function_esm(), jss_plugin_global_esm(), jss_plugin_nested_esm(), jss_plugin_camel_case_esm(), jss_plugin_default_unit_esm(), // Disable the vendor prefixer server-side, it does nothing.\n    // This way, we can get a performance boost.\n    // In the documentation, we are using `autoprefixer` to solve this problem.\n    typeof window === 'undefined' ? null : jss_plugin_vendor_prefixer_esm(), jss_plugin_props_sort_esm()]\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/StylesProvider/StylesProvider.js\n\n\n\n\n\n\n\n // Default JSS instance.\n\nvar StylesProvider_jss = jss_esm_create(jssPreset()); // Use a singleton or the provided one by the context.\n//\n// The counter-based approach doesn't tolerate any mistake.\n// It's much safer to use the same counter everywhere.\n\nvar generateClassName = createGenerateClassName(); // Exported for test purposes\n\nvar sheetsManager = new Map();\nvar StylesProvider_defaultOptions = {\n  disableGeneration: false,\n  generateClassName: generateClassName,\n  jss: StylesProvider_jss,\n  sheetsCache: null,\n  sheetsManager: sheetsManager,\n  sheetsRegistry: null\n};\nvar StylesContext = react_default.a.createContext(StylesProvider_defaultOptions);\n\nif (false) {}\n\nvar injectFirstNode;\nfunction StylesProvider(props) {\n  var children = props.children,\n      _props$injectFirst = props.injectFirst,\n      injectFirst = _props$injectFirst === void 0 ? false : _props$injectFirst,\n      _props$disableGenerat = props.disableGeneration,\n      disableGeneration = _props$disableGenerat === void 0 ? false : _props$disableGenerat,\n      localOptions = _objectWithoutProperties(props, [\"children\", \"injectFirst\", \"disableGeneration\"]);\n\n  var outerOptions = react_default.a.useContext(StylesContext);\n\n  var context = _extends(_extends({}, outerOptions), {}, {\n    disableGeneration: disableGeneration\n  }, localOptions);\n\n  if (false) {}\n\n  if (false) {}\n\n  if (false) {}\n\n  if (!context.jss.options.insertionPoint && injectFirst && typeof window !== 'undefined') {\n    if (!injectFirstNode) {\n      var head = document.head;\n      injectFirstNode = document.createComment('mui-inject-first');\n      head.insertBefore(injectFirstNode, head.firstChild);\n    }\n\n    context.jss = jss_esm_create({\n      plugins: jssPreset().plugins,\n      insertionPoint: injectFirstNode\n    });\n  }\n\n  return /*#__PURE__*/react_default.a.createElement(StylesContext.Provider, {\n    value: context\n  }, children);\n}\n false ? undefined : void 0;\n\nif (false) {}\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/makeStyles/indexCounter.js\n/* eslint-disable import/prefer-default-export */\n// Global index counter to preserve source order.\n// We create the style sheet during the creation of the component,\n// children are handled after the parents, so the order of style elements would be parent->child.\n// It is a problem though when a parent passes a className\n// which needs to override any child's styles.\n// StyleSheet of the child has a higher specificity, because of the source order.\n// So our solution is to render sheets them in the reverse order child->sheet, so\n// that parent has a higher specificity.\nvar indexCounter = -1e9;\nfunction increment() {\n  indexCounter += 1;\n\n  if (false) {}\n\n  return indexCounter;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js\nfunction typeof_typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    typeof_typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    typeof_typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return typeof_typeof(obj);\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/utils/esm/deepmerge.js\n\n\nfunction isPlainObject(item) {\n  return item && typeof_typeof(item) === 'object' && item.constructor === Object;\n}\nfunction deepmerge(target, source) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    clone: true\n  };\n  var output = options.clone ? _extends({}, target) : target;\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(function (key) {\n      // Avoid prototype pollution\n      if (key === '__proto__') {\n        return;\n      }\n\n      if (isPlainObject(source[key]) && key in target) {\n        output[key] = deepmerge(target[key], source[key], options);\n      } else {\n        output[key] = source[key];\n      }\n    });\n  }\n\n  return output;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/getStylesCreator/getStylesCreator.js\n\n\n\n\nfunction getStylesCreator(stylesOrCreator) {\n  var themingEnabled = typeof stylesOrCreator === 'function';\n\n  if (false) {}\n\n  return {\n    create: function create(theme, name) {\n      var styles;\n\n      try {\n        styles = themingEnabled ? stylesOrCreator(theme) : stylesOrCreator;\n      } catch (err) {\n        if (false) {}\n\n        throw err;\n      }\n\n      if (!name || !theme.overrides || !theme.overrides[name]) {\n        return styles;\n      }\n\n      var overrides = theme.overrides[name];\n\n      var stylesWithOverrides = _extends({}, styles);\n\n      Object.keys(overrides).forEach(function (key) {\n        if (false) {}\n\n        stylesWithOverrides[key] = deepmerge(stylesWithOverrides[key], overrides[key]);\n      });\n      return stylesWithOverrides;\n    },\n    options: {}\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/getStylesCreator/noopTheme.js\n// We use the same empty object to ref count the styles that don't need a theme object.\nvar noopTheme = {};\n/* harmony default export */ var getStylesCreator_noopTheme = (noopTheme);\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/makeStyles/makeStyles.js\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getClasses(_ref, classes, Component) {\n  var state = _ref.state,\n      stylesOptions = _ref.stylesOptions;\n\n  if (stylesOptions.disableGeneration) {\n    return classes || {};\n  }\n\n  if (!state.cacheClasses) {\n    state.cacheClasses = {\n      // Cache for the finalized classes value.\n      value: null,\n      // Cache for the last used classes prop pointer.\n      lastProp: null,\n      // Cache for the last used rendered classes pointer.\n      lastJSS: {}\n    };\n  } // Tracks if either the rendered classes or classes prop has changed,\n  // requiring the generation of a new finalized classes object.\n\n\n  var generate = false;\n\n  if (state.classes !== state.cacheClasses.lastJSS) {\n    state.cacheClasses.lastJSS = state.classes;\n    generate = true;\n  }\n\n  if (classes !== state.cacheClasses.lastProp) {\n    state.cacheClasses.lastProp = classes;\n    generate = true;\n  }\n\n  if (generate) {\n    state.cacheClasses.value = mergeClasses({\n      baseClasses: state.cacheClasses.lastJSS,\n      newClasses: classes,\n      Component: Component\n    });\n  }\n\n  return state.cacheClasses.value;\n}\n\nfunction attach(_ref2, props) {\n  var state = _ref2.state,\n      theme = _ref2.theme,\n      stylesOptions = _ref2.stylesOptions,\n      stylesCreator = _ref2.stylesCreator,\n      name = _ref2.name;\n\n  if (stylesOptions.disableGeneration) {\n    return;\n  }\n\n  var sheetManager = makeStyles_multiKeyStore.get(stylesOptions.sheetsManager, stylesCreator, theme);\n\n  if (!sheetManager) {\n    sheetManager = {\n      refs: 0,\n      staticSheet: null,\n      dynamicStyles: null\n    };\n    makeStyles_multiKeyStore.set(stylesOptions.sheetsManager, stylesCreator, theme, sheetManager);\n  }\n\n  var options = _extends(_extends(_extends({}, stylesCreator.options), stylesOptions), {}, {\n    theme: theme,\n    flip: typeof stylesOptions.flip === 'boolean' ? stylesOptions.flip : theme.direction === 'rtl'\n  });\n\n  options.generateId = options.serverGenerateClassName || options.generateClassName;\n  var sheetsRegistry = stylesOptions.sheetsRegistry;\n\n  if (sheetManager.refs === 0) {\n    var staticSheet;\n\n    if (stylesOptions.sheetsCache) {\n      staticSheet = makeStyles_multiKeyStore.get(stylesOptions.sheetsCache, stylesCreator, theme);\n    }\n\n    var styles = stylesCreator.create(theme, name);\n\n    if (!staticSheet) {\n      staticSheet = stylesOptions.jss.createStyleSheet(styles, _extends({\n        link: false\n      }, options));\n      staticSheet.attach();\n\n      if (stylesOptions.sheetsCache) {\n        makeStyles_multiKeyStore.set(stylesOptions.sheetsCache, stylesCreator, theme, staticSheet);\n      }\n    }\n\n    if (sheetsRegistry) {\n      sheetsRegistry.add(staticSheet);\n    }\n\n    sheetManager.staticSheet = staticSheet;\n    sheetManager.dynamicStyles = getDynamicStyles(styles);\n  }\n\n  if (sheetManager.dynamicStyles) {\n    var dynamicSheet = stylesOptions.jss.createStyleSheet(sheetManager.dynamicStyles, _extends({\n      link: true\n    }, options));\n    dynamicSheet.update(props);\n    dynamicSheet.attach();\n    state.dynamicSheet = dynamicSheet;\n    state.classes = mergeClasses({\n      baseClasses: sheetManager.staticSheet.classes,\n      newClasses: dynamicSheet.classes\n    });\n\n    if (sheetsRegistry) {\n      sheetsRegistry.add(dynamicSheet);\n    }\n  } else {\n    state.classes = sheetManager.staticSheet.classes;\n  }\n\n  sheetManager.refs += 1;\n}\n\nfunction makeStyles_update(_ref3, props) {\n  var state = _ref3.state;\n\n  if (state.dynamicSheet) {\n    state.dynamicSheet.update(props);\n  }\n}\n\nfunction detach(_ref4) {\n  var state = _ref4.state,\n      theme = _ref4.theme,\n      stylesOptions = _ref4.stylesOptions,\n      stylesCreator = _ref4.stylesCreator;\n\n  if (stylesOptions.disableGeneration) {\n    return;\n  }\n\n  var sheetManager = makeStyles_multiKeyStore.get(stylesOptions.sheetsManager, stylesCreator, theme);\n  sheetManager.refs -= 1;\n  var sheetsRegistry = stylesOptions.sheetsRegistry;\n\n  if (sheetManager.refs === 0) {\n    makeStyles_multiKeyStore.delete(stylesOptions.sheetsManager, stylesCreator, theme);\n    stylesOptions.jss.removeStyleSheet(sheetManager.staticSheet);\n\n    if (sheetsRegistry) {\n      sheetsRegistry.remove(sheetManager.staticSheet);\n    }\n  }\n\n  if (state.dynamicSheet) {\n    stylesOptions.jss.removeStyleSheet(state.dynamicSheet);\n\n    if (sheetsRegistry) {\n      sheetsRegistry.remove(state.dynamicSheet);\n    }\n  }\n}\n\nfunction useSynchronousEffect(func, values) {\n  var key = react_default.a.useRef([]);\n  var output; // Store \"generation\" key. Just returns a new object every time\n\n  var currentKey = react_default.a.useMemo(function () {\n    return {};\n  }, values); // eslint-disable-line react-hooks/exhaustive-deps\n  // \"the first render\", or \"memo dropped the value\"\n\n  if (key.current !== currentKey) {\n    key.current = currentKey;\n    output = func();\n  }\n\n  react_default.a.useEffect(function () {\n    return function () {\n      if (output) {\n        output();\n      }\n    };\n  }, [currentKey] // eslint-disable-line react-hooks/exhaustive-deps\n  );\n}\n\nfunction makeStyles(stylesOrCreator) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var name = options.name,\n      classNamePrefixOption = options.classNamePrefix,\n      Component = options.Component,\n      _options$defaultTheme = options.defaultTheme,\n      defaultTheme = _options$defaultTheme === void 0 ? getStylesCreator_noopTheme : _options$defaultTheme,\n      stylesOptions2 = _objectWithoutProperties(options, [\"name\", \"classNamePrefix\", \"Component\", \"defaultTheme\"]);\n\n  var stylesCreator = getStylesCreator(stylesOrCreator);\n  var classNamePrefix = name || classNamePrefixOption || 'makeStyles';\n  stylesCreator.options = {\n    index: increment(),\n    name: name,\n    meta: classNamePrefix,\n    classNamePrefix: classNamePrefix\n  };\n\n  var useStyles = function useStyles() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var theme = useTheme() || defaultTheme;\n\n    var stylesOptions = _extends(_extends({}, react_default.a.useContext(StylesContext)), stylesOptions2);\n\n    var instance = react_default.a.useRef();\n    var shouldUpdate = react_default.a.useRef();\n    useSynchronousEffect(function () {\n      var current = {\n        name: name,\n        state: {},\n        stylesCreator: stylesCreator,\n        stylesOptions: stylesOptions,\n        theme: theme\n      };\n      attach(current, props);\n      shouldUpdate.current = false;\n      instance.current = current;\n      return function () {\n        detach(current);\n      };\n    }, [theme, stylesCreator]);\n    react_default.a.useEffect(function () {\n      if (shouldUpdate.current) {\n        makeStyles_update(instance.current, props);\n      }\n\n      shouldUpdate.current = true;\n    });\n    var classes = getClasses(instance.current, props.classes, Component);\n\n    if (false) {}\n\n    return classes;\n  };\n\n  return useStyles;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/createBreakpoints.js\n\n\n// Sorted ASC by size. That's important.\n// It can't be configured as it's used statically for propTypes.\nvar keys = ['xs', 'sm', 'md', 'lg', 'xl']; // Keep in mind that @media is inclusive by the CSS specification.\n\nfunction createBreakpoints(breakpoints) {\n  var _breakpoints$values = breakpoints.values,\n      values = _breakpoints$values === void 0 ? {\n    xs: 0,\n    sm: 600,\n    md: 960,\n    lg: 1280,\n    xl: 1920\n  } : _breakpoints$values,\n      _breakpoints$unit = breakpoints.unit,\n      unit = _breakpoints$unit === void 0 ? 'px' : _breakpoints$unit,\n      _breakpoints$step = breakpoints.step,\n      step = _breakpoints$step === void 0 ? 5 : _breakpoints$step,\n      other = _objectWithoutProperties(breakpoints, [\"values\", \"unit\", \"step\"]);\n\n  function up(key) {\n    var value = typeof values[key] === 'number' ? values[key] : key;\n    return \"@media (min-width:\".concat(value).concat(unit, \")\");\n  }\n\n  function down(key) {\n    var endIndex = keys.indexOf(key) + 1;\n    var upperbound = values[keys[endIndex]];\n\n    if (endIndex === keys.length) {\n      // xl down applies to all sizes\n      return up('xs');\n    }\n\n    var value = typeof upperbound === 'number' && endIndex > 0 ? upperbound : key;\n    return \"@media (max-width:\".concat(value - step / 100).concat(unit, \")\");\n  }\n\n  function between(start, end) {\n    var endIndex = keys.indexOf(end);\n\n    if (endIndex === keys.length - 1) {\n      return up(start);\n    }\n\n    return \"@media (min-width:\".concat(typeof values[start] === 'number' ? values[start] : start).concat(unit, \") and \") + \"(max-width:\".concat((endIndex !== -1 && typeof values[keys[endIndex + 1]] === 'number' ? values[keys[endIndex + 1]] : end) - step / 100).concat(unit, \")\");\n  }\n\n  function only(key) {\n    return between(key, key);\n  }\n\n  function width(key) {\n    return values[key];\n  }\n\n  return _extends({\n    keys: keys,\n    values: values,\n    up: up,\n    down: down,\n    between: between,\n    only: only,\n    width: width\n  }, other);\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/createMixins.js\n\n\nfunction createMixins(breakpoints, spacing, mixins) {\n  var _toolbar;\n\n  return _extends({\n    gutters: function gutters() {\n      var styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // To deprecate in v4.1\n      //       warning(\n      //         false,\n      //         [\n      //           'Material-UI: Theme.mixins.gutters() is deprecated.',\n      //           'You can use the source of the mixin directly:',\n      //           `\n      // paddingLeft: theme.spacing(2),\n      // paddingRight: theme.spacing(2),\n      // [theme.breakpoints.up('sm')]: {\n      //   paddingLeft: theme.spacing(3),\n      //   paddingRight: theme.spacing(3),\n      // },\n      // `,\n      //         ].join('\\n'),\n      //       );\n      return _extends({\n        paddingLeft: spacing(2),\n        paddingRight: spacing(2)\n      }, styles, _defineProperty({}, breakpoints.up('sm'), _extends({\n        paddingLeft: spacing(3),\n        paddingRight: spacing(3)\n      }, styles[breakpoints.up('sm')])));\n    },\n    toolbar: (_toolbar = {\n      minHeight: 56\n    }, _defineProperty(_toolbar, \"\".concat(breakpoints.up('xs'), \" and (orientation: landscape)\"), {\n      minHeight: 48\n    }), _defineProperty(_toolbar, breakpoints.up('sm'), {\n      minHeight: 64\n    }), _toolbar)\n  }, mixins);\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/utils/esm/formatMuiErrorMessage.js\n/**\n * WARNING: Don't import this directly.\n * Use `MuiError` from `@material-ui/utils/macros/MuiError.macro` instead.\n * @param {number} code\n */\nfunction formatMuiErrorMessage(code) {\n  // Apply babel-plugin-transform-template-literals in loose mode\n  // loose mode is safe iff we're concatenating primitives\n  // see https://babeljs.io/docs/en/babel-plugin-transform-template-literals#loose\n\n  /* eslint-disable prefer-template */\n  var url = 'https://material-ui.com/production-error/?code=' + code;\n\n  for (var i = 1; i < arguments.length; i += 1) {\n    // rest params over-transpile for this case\n    // eslint-disable-next-line prefer-rest-params\n    url += '&args[]=' + encodeURIComponent(arguments[i]);\n  }\n\n  return 'Minified Material-UI error #' + code + '; visit ' + url + ' for the full message.';\n  /* eslint-enable prefer-template */\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/colors/common.js\nvar common = {\n  black: '#000',\n  white: '#fff'\n};\n/* harmony default export */ var colors_common = (common);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/colors/grey.js\nvar grey = {\n  50: '#fafafa',\n  100: '#f5f5f5',\n  200: '#eeeeee',\n  300: '#e0e0e0',\n  400: '#bdbdbd',\n  500: '#9e9e9e',\n  600: '#757575',\n  700: '#616161',\n  800: '#424242',\n  900: '#212121',\n  A100: '#d5d5d5',\n  A200: '#aaaaaa',\n  A400: '#303030',\n  A700: '#616161'\n};\n/* harmony default export */ var colors_grey = (grey);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/colors/indigo.js\nvar indigo = {\n  50: '#e8eaf6',\n  100: '#c5cae9',\n  200: '#9fa8da',\n  300: '#7986cb',\n  400: '#5c6bc0',\n  500: '#3f51b5',\n  600: '#3949ab',\n  700: '#303f9f',\n  800: '#283593',\n  900: '#1a237e',\n  A100: '#8c9eff',\n  A200: '#536dfe',\n  A400: '#3d5afe',\n  A700: '#304ffe'\n};\n/* harmony default export */ var colors_indigo = (indigo);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/colors/pink.js\nvar pink = {\n  50: '#fce4ec',\n  100: '#f8bbd0',\n  200: '#f48fb1',\n  300: '#f06292',\n  400: '#ec407a',\n  500: '#e91e63',\n  600: '#d81b60',\n  700: '#c2185b',\n  800: '#ad1457',\n  900: '#880e4f',\n  A100: '#ff80ab',\n  A200: '#ff4081',\n  A400: '#f50057',\n  A700: '#c51162'\n};\n/* harmony default export */ var colors_pink = (pink);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/colors/red.js\nvar red = {\n  50: '#ffebee',\n  100: '#ffcdd2',\n  200: '#ef9a9a',\n  300: '#e57373',\n  400: '#ef5350',\n  500: '#f44336',\n  600: '#e53935',\n  700: '#d32f2f',\n  800: '#c62828',\n  900: '#b71c1c',\n  A100: '#ff8a80',\n  A200: '#ff5252',\n  A400: '#ff1744',\n  A700: '#d50000'\n};\n/* harmony default export */ var colors_red = (red);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/colors/orange.js\nvar orange = {\n  50: '#fff3e0',\n  100: '#ffe0b2',\n  200: '#ffcc80',\n  300: '#ffb74d',\n  400: '#ffa726',\n  500: '#ff9800',\n  600: '#fb8c00',\n  700: '#f57c00',\n  800: '#ef6c00',\n  900: '#e65100',\n  A100: '#ffd180',\n  A200: '#ffab40',\n  A400: '#ff9100',\n  A700: '#ff6d00'\n};\n/* harmony default export */ var colors_orange = (orange);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/colors/blue.js\nvar blue = {\n  50: '#e3f2fd',\n  100: '#bbdefb',\n  200: '#90caf9',\n  300: '#64b5f6',\n  400: '#42a5f5',\n  500: '#2196f3',\n  600: '#1e88e5',\n  700: '#1976d2',\n  800: '#1565c0',\n  900: '#0d47a1',\n  A100: '#82b1ff',\n  A200: '#448aff',\n  A400: '#2979ff',\n  A700: '#2962ff'\n};\n/* harmony default export */ var colors_blue = (blue);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/colors/green.js\nvar green = {\n  50: '#e8f5e9',\n  100: '#c8e6c9',\n  200: '#a5d6a7',\n  300: '#81c784',\n  400: '#66bb6a',\n  500: '#4caf50',\n  600: '#43a047',\n  700: '#388e3c',\n  800: '#2e7d32',\n  900: '#1b5e20',\n  A100: '#b9f6ca',\n  A200: '#69f0ae',\n  A400: '#00e676',\n  A700: '#00c853'\n};\n/* harmony default export */ var colors_green = (green);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/colorManipulator.js\n\n\n/* eslint-disable no-use-before-define */\n\n/**\n * Returns a number whose value is limited to the given range.\n *\n * @param {number} value The value to be clamped\n * @param {number} min The lower boundary of the output range\n * @param {number} max The upper boundary of the output range\n * @returns {number} A number in the range [min, max]\n */\nfunction clamp(value) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  if (false) {}\n\n  return Math.min(Math.max(min, value), max);\n}\n/**\n * Converts a color from CSS hex format to CSS rgb format.\n *\n * @param {string} color - Hex color, i.e. #nnn or #nnnnnn\n * @returns {string} A CSS rgb color string\n */\n\n\nfunction hexToRgb(color) {\n  color = color.substr(1);\n  var re = new RegExp(\".{1,\".concat(color.length >= 6 ? 2 : 1, \"}\"), 'g');\n  var colors = color.match(re);\n\n  if (colors && colors[0].length === 1) {\n    colors = colors.map(function (n) {\n      return n + n;\n    });\n  }\n\n  return colors ? \"rgb\".concat(colors.length === 4 ? 'a' : '', \"(\").concat(colors.map(function (n, index) {\n    return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;\n  }).join(', '), \")\") : '';\n}\n\nfunction intToHex(int) {\n  var hex = int.toString(16);\n  return hex.length === 1 ? \"0\".concat(hex) : hex;\n}\n/**\n * Converts a color from CSS rgb format to CSS hex format.\n *\n * @param {string} color - RGB color, i.e. rgb(n, n, n)\n * @returns {string} A CSS rgb color string, i.e. #nnnnnn\n */\n\n\nfunction rgbToHex(color) {\n  // Idempotent\n  if (color.indexOf('#') === 0) {\n    return color;\n  }\n\n  var _decomposeColor = decomposeColor(color),\n      values = _decomposeColor.values;\n\n  return \"#\".concat(values.map(function (n) {\n    return intToHex(n);\n  }).join(''));\n}\n/**\n * Converts a color from hsl format to rgb format.\n *\n * @param {string} color - HSL color values\n * @returns {string} rgb color values\n */\n\nfunction hslToRgb(color) {\n  color = decomposeColor(color);\n  var _color = color,\n      values = _color.values;\n  var h = values[0];\n  var s = values[1] / 100;\n  var l = values[2] / 100;\n  var a = s * Math.min(l, 1 - l);\n\n  var f = function f(n) {\n    var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + h / 30) % 12;\n    return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  };\n\n  var type = 'rgb';\n  var rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];\n\n  if (color.type === 'hsla') {\n    type += 'a';\n    rgb.push(values[3]);\n  }\n\n  return recomposeColor({\n    type: type,\n    values: rgb\n  });\n}\n/**\n * Returns an object with the type and values of a color.\n *\n * Note: Does not support rgb % values.\n *\n * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()\n * @returns {object} - A MUI color object: {type: string, values: number[]}\n */\n\nfunction decomposeColor(color) {\n  // Idempotent\n  if (color.type) {\n    return color;\n  }\n\n  if (color.charAt(0) === '#') {\n    return decomposeColor(hexToRgb(color));\n  }\n\n  var marker = color.indexOf('(');\n  var type = color.substring(0, marker);\n\n  if (['rgb', 'rgba', 'hsl', 'hsla'].indexOf(type) === -1) {\n    throw new Error( false ? undefined : formatMuiErrorMessage(3, color));\n  }\n\n  var values = color.substring(marker + 1, color.length - 1).split(',');\n  values = values.map(function (value) {\n    return parseFloat(value);\n  });\n  return {\n    type: type,\n    values: values\n  };\n}\n/**\n * Converts a color object with type and values to a string.\n *\n * @param {object} color - Decomposed color\n * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla'\n * @param {array} color.values - [n,n,n] or [n,n,n,n]\n * @returns {string} A CSS color string\n */\n\nfunction recomposeColor(color) {\n  var type = color.type;\n  var values = color.values;\n\n  if (type.indexOf('rgb') !== -1) {\n    // Only convert the first 3 values to int (i.e. not alpha)\n    values = values.map(function (n, i) {\n      return i < 3 ? parseInt(n, 10) : n;\n    });\n  } else if (type.indexOf('hsl') !== -1) {\n    values[1] = \"\".concat(values[1], \"%\");\n    values[2] = \"\".concat(values[2], \"%\");\n  }\n\n  return \"\".concat(type, \"(\").concat(values.join(', '), \")\");\n}\n/**\n * Calculates the contrast ratio between two colors.\n *\n * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests\n *\n * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()\n * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()\n * @returns {number} A contrast ratio value in the range 0 - 21.\n */\n\nfunction getContrastRatio(foreground, background) {\n  var lumA = getLuminance(foreground);\n  var lumB = getLuminance(background);\n  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);\n}\n/**\n * The relative brightness of any point in a color space,\n * normalized to 0 for darkest black and 1 for lightest white.\n *\n * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests\n *\n * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()\n * @returns {number} The relative brightness of the color in the range 0 - 1\n */\n\nfunction getLuminance(color) {\n  color = decomposeColor(color);\n  var rgb = color.type === 'hsl' ? decomposeColor(hslToRgb(color)).values : color.values;\n  rgb = rgb.map(function (val) {\n    val /= 255; // normalized\n\n    return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);\n  }); // Truncate at 3 digits\n\n  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));\n}\n/**\n * Darken or lighten a color, depending on its luminance.\n * Light colors are darkened, dark colors are lightened.\n *\n * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()\n * @param {number} coefficient=0.15 - multiplier in the range 0 - 1\n * @returns {string} A CSS color string. Hex input values are returned as rgb\n */\n\nfunction emphasize(color) {\n  var coefficient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.15;\n  return getLuminance(color) > 0.5 ? darken(color, coefficient) : lighten(color, coefficient);\n}\n/**\n * Set the absolute transparency of a color.\n * Any existing alpha values are overwritten.\n *\n * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()\n * @param {number} value - value to set the alpha channel to in the range 0 -1\n * @returns {string} A CSS color string. Hex input values are returned as rgb\n */\n\nfunction fade(color, value) {\n  color = decomposeColor(color);\n  value = clamp(value);\n\n  if (color.type === 'rgb' || color.type === 'hsl') {\n    color.type += 'a';\n  }\n\n  color.values[3] = value;\n  return recomposeColor(color);\n}\n/**\n * Darkens a color.\n *\n * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()\n * @param {number} coefficient - multiplier in the range 0 - 1\n * @returns {string} A CSS color string. Hex input values are returned as rgb\n */\n\nfunction darken(color, coefficient) {\n  color = decomposeColor(color);\n  coefficient = clamp(coefficient);\n\n  if (color.type.indexOf('hsl') !== -1) {\n    color.values[2] *= 1 - coefficient;\n  } else if (color.type.indexOf('rgb') !== -1) {\n    for (var i = 0; i < 3; i += 1) {\n      color.values[i] *= 1 - coefficient;\n    }\n  }\n\n  return recomposeColor(color);\n}\n/**\n * Lightens a color.\n *\n * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()\n * @param {number} coefficient - multiplier in the range 0 - 1\n * @returns {string} A CSS color string. Hex input values are returned as rgb\n */\n\nfunction lighten(color, coefficient) {\n  color = decomposeColor(color);\n  coefficient = clamp(coefficient);\n\n  if (color.type.indexOf('hsl') !== -1) {\n    color.values[2] += (100 - color.values[2]) * coefficient;\n  } else if (color.type.indexOf('rgb') !== -1) {\n    for (var i = 0; i < 3; i += 1) {\n      color.values[i] += (255 - color.values[i]) * coefficient;\n    }\n  }\n\n  return recomposeColor(color);\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/createPalette.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar createPalette_light = {\n  // The colors used to style the text.\n  text: {\n    // The most important text.\n    primary: 'rgba(0, 0, 0, 0.87)',\n    // Secondary text.\n    secondary: 'rgba(0, 0, 0, 0.54)',\n    // Disabled text have even lower visual prominence.\n    disabled: 'rgba(0, 0, 0, 0.38)',\n    // Text hints.\n    hint: 'rgba(0, 0, 0, 0.38)'\n  },\n  // The color used to divide different elements.\n  divider: 'rgba(0, 0, 0, 0.12)',\n  // The background colors used to style the surfaces.\n  // Consistency between these values is important.\n  background: {\n    paper: colors_common.white,\n    default: colors_grey[50]\n  },\n  // The colors used to style the action elements.\n  action: {\n    // The color of an active action like an icon button.\n    active: 'rgba(0, 0, 0, 0.54)',\n    // The color of an hovered action.\n    hover: 'rgba(0, 0, 0, 0.04)',\n    hoverOpacity: 0.04,\n    // The color of a selected action.\n    selected: 'rgba(0, 0, 0, 0.08)',\n    selectedOpacity: 0.08,\n    // The color of a disabled action.\n    disabled: 'rgba(0, 0, 0, 0.26)',\n    // The background color of a disabled action.\n    disabledBackground: 'rgba(0, 0, 0, 0.12)',\n    disabledOpacity: 0.38,\n    focus: 'rgba(0, 0, 0, 0.12)',\n    focusOpacity: 0.12,\n    activatedOpacity: 0.12\n  }\n};\nvar dark = {\n  text: {\n    primary: colors_common.white,\n    secondary: 'rgba(255, 255, 255, 0.7)',\n    disabled: 'rgba(255, 255, 255, 0.5)',\n    hint: 'rgba(255, 255, 255, 0.5)',\n    icon: 'rgba(255, 255, 255, 0.5)'\n  },\n  divider: 'rgba(255, 255, 255, 0.12)',\n  background: {\n    paper: colors_grey[800],\n    default: '#303030'\n  },\n  action: {\n    active: colors_common.white,\n    hover: 'rgba(255, 255, 255, 0.08)',\n    hoverOpacity: 0.08,\n    selected: 'rgba(255, 255, 255, 0.16)',\n    selectedOpacity: 0.16,\n    disabled: 'rgba(255, 255, 255, 0.3)',\n    disabledBackground: 'rgba(255, 255, 255, 0.12)',\n    disabledOpacity: 0.38,\n    focus: 'rgba(255, 255, 255, 0.12)',\n    focusOpacity: 0.12,\n    activatedOpacity: 0.24\n  }\n};\n\nfunction addLightOrDark(intent, direction, shade, tonalOffset) {\n  var tonalOffsetLight = tonalOffset.light || tonalOffset;\n  var tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;\n\n  if (!intent[direction]) {\n    if (intent.hasOwnProperty(shade)) {\n      intent[direction] = intent[shade];\n    } else if (direction === 'light') {\n      intent.light = lighten(intent.main, tonalOffsetLight);\n    } else if (direction === 'dark') {\n      intent.dark = darken(intent.main, tonalOffsetDark);\n    }\n  }\n}\n\nfunction createPalette(palette) {\n  var _palette$primary = palette.primary,\n      primary = _palette$primary === void 0 ? {\n    light: colors_indigo[300],\n    main: colors_indigo[500],\n    dark: colors_indigo[700]\n  } : _palette$primary,\n      _palette$secondary = palette.secondary,\n      secondary = _palette$secondary === void 0 ? {\n    light: colors_pink.A200,\n    main: colors_pink.A400,\n    dark: colors_pink.A700\n  } : _palette$secondary,\n      _palette$error = palette.error,\n      error = _palette$error === void 0 ? {\n    light: colors_red[300],\n    main: colors_red[500],\n    dark: colors_red[700]\n  } : _palette$error,\n      _palette$warning = palette.warning,\n      warning = _palette$warning === void 0 ? {\n    light: colors_orange[300],\n    main: colors_orange[500],\n    dark: colors_orange[700]\n  } : _palette$warning,\n      _palette$info = palette.info,\n      info = _palette$info === void 0 ? {\n    light: colors_blue[300],\n    main: colors_blue[500],\n    dark: colors_blue[700]\n  } : _palette$info,\n      _palette$success = palette.success,\n      success = _palette$success === void 0 ? {\n    light: colors_green[300],\n    main: colors_green[500],\n    dark: colors_green[700]\n  } : _palette$success,\n      _palette$type = palette.type,\n      type = _palette$type === void 0 ? 'light' : _palette$type,\n      _palette$contrastThre = palette.contrastThreshold,\n      contrastThreshold = _palette$contrastThre === void 0 ? 3 : _palette$contrastThre,\n      _palette$tonalOffset = palette.tonalOffset,\n      tonalOffset = _palette$tonalOffset === void 0 ? 0.2 : _palette$tonalOffset,\n      other = _objectWithoutProperties(palette, [\"primary\", \"secondary\", \"error\", \"warning\", \"info\", \"success\", \"type\", \"contrastThreshold\", \"tonalOffset\"]); // Use the same logic as\n  // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59\n  // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54\n\n\n  function getContrastText(background) {\n    var contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : createPalette_light.text.primary;\n\n    if (false) { var contrast; }\n\n    return contrastText;\n  }\n\n  var augmentColor = function augmentColor(color) {\n    var mainShade = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n    var lightShade = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;\n    var darkShade = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 700;\n    color = _extends({}, color);\n\n    if (!color.main && color[mainShade]) {\n      color.main = color[mainShade];\n    }\n\n    if (!color.main) {\n      throw new Error( false ? undefined : formatMuiErrorMessage(4, mainShade));\n    }\n\n    if (typeof color.main !== 'string') {\n      throw new Error( false ? undefined : formatMuiErrorMessage(5, JSON.stringify(color.main)));\n    }\n\n    addLightOrDark(color, 'light', lightShade, tonalOffset);\n    addLightOrDark(color, 'dark', darkShade, tonalOffset);\n\n    if (!color.contrastText) {\n      color.contrastText = getContrastText(color.main);\n    }\n\n    return color;\n  };\n\n  var types = {\n    dark: dark,\n    light: createPalette_light\n  };\n\n  if (false) {}\n\n  var paletteOutput = deepmerge(_extends({\n    // A collection of common colors.\n    common: colors_common,\n    // The palette type, can be light or dark.\n    type: type,\n    // The colors used to represent primary interface elements for a user.\n    primary: augmentColor(primary),\n    // The colors used to represent secondary interface elements for a user.\n    secondary: augmentColor(secondary, 'A400', 'A200', 'A700'),\n    // The colors used to represent interface elements that the user should be made aware of.\n    error: augmentColor(error),\n    // The colors used to represent potentially dangerous actions or important messages.\n    warning: augmentColor(warning),\n    // The colors used to present information to the user that is neutral and not necessarily important.\n    info: augmentColor(info),\n    // The colors used to indicate the successful completion of an action that user triggered.\n    success: augmentColor(success),\n    // The grey colors.\n    grey: colors_grey,\n    // Used by `getContrastText()` to maximize the contrast between\n    // the background and the text.\n    contrastThreshold: contrastThreshold,\n    // Takes a background color and returns the text color that maximizes the contrast.\n    getContrastText: getContrastText,\n    // Generate a rich color object.\n    augmentColor: augmentColor,\n    // Used by the functions below to shift a color's luminance by approximately\n    // two indexes within its tonal palette.\n    // E.g., shift from Red 500 to Red 300 or Red 700.\n    tonalOffset: tonalOffset\n  }, types[type]), other);\n  return paletteOutput;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/createTypography.js\n\n\n\n\nfunction round(value) {\n  return Math.round(value * 1e5) / 1e5;\n}\n\nvar caseAllCaps = {\n  textTransform: 'uppercase'\n};\nvar defaultFontFamily = '\"Roboto\", \"Helvetica\", \"Arial\", sans-serif';\n/**\n * @see @link{https://material.io/design/typography/the-type-system.html}\n * @see @link{https://material.io/design/typography/understanding-typography.html}\n */\n\nfunction createTypography(palette, typography) {\n  var _ref = typeof typography === 'function' ? typography(palette) : typography,\n      _ref$fontFamily = _ref.fontFamily,\n      fontFamily = _ref$fontFamily === void 0 ? defaultFontFamily : _ref$fontFamily,\n      _ref$fontSize = _ref.fontSize,\n      fontSize = _ref$fontSize === void 0 ? 14 : _ref$fontSize,\n      _ref$fontWeightLight = _ref.fontWeightLight,\n      fontWeightLight = _ref$fontWeightLight === void 0 ? 300 : _ref$fontWeightLight,\n      _ref$fontWeightRegula = _ref.fontWeightRegular,\n      fontWeightRegular = _ref$fontWeightRegula === void 0 ? 400 : _ref$fontWeightRegula,\n      _ref$fontWeightMedium = _ref.fontWeightMedium,\n      fontWeightMedium = _ref$fontWeightMedium === void 0 ? 500 : _ref$fontWeightMedium,\n      _ref$fontWeightBold = _ref.fontWeightBold,\n      fontWeightBold = _ref$fontWeightBold === void 0 ? 700 : _ref$fontWeightBold,\n      _ref$htmlFontSize = _ref.htmlFontSize,\n      htmlFontSize = _ref$htmlFontSize === void 0 ? 16 : _ref$htmlFontSize,\n      allVariants = _ref.allVariants,\n      pxToRem2 = _ref.pxToRem,\n      other = _objectWithoutProperties(_ref, [\"fontFamily\", \"fontSize\", \"fontWeightLight\", \"fontWeightRegular\", \"fontWeightMedium\", \"fontWeightBold\", \"htmlFontSize\", \"allVariants\", \"pxToRem\"]);\n\n  if (false) {}\n\n  var coef = fontSize / 14;\n\n  var pxToRem = pxToRem2 || function (size) {\n    return \"\".concat(size / htmlFontSize * coef, \"rem\");\n  };\n\n  var buildVariant = function buildVariant(fontWeight, size, lineHeight, letterSpacing, casing) {\n    return _extends({\n      fontFamily: fontFamily,\n      fontWeight: fontWeight,\n      fontSize: pxToRem(size),\n      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/\n      lineHeight: lineHeight\n    }, fontFamily === defaultFontFamily ? {\n      letterSpacing: \"\".concat(round(letterSpacing / size), \"em\")\n    } : {}, casing, allVariants);\n  };\n\n  var variants = {\n    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),\n    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),\n    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),\n    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),\n    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),\n    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),\n    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),\n    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),\n    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),\n    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),\n    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),\n    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),\n    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)\n  };\n  return deepmerge(_extends({\n    htmlFontSize: htmlFontSize,\n    pxToRem: pxToRem,\n    round: round,\n    // TODO v5: remove\n    fontFamily: fontFamily,\n    fontSize: fontSize,\n    fontWeightLight: fontWeightLight,\n    fontWeightRegular: fontWeightRegular,\n    fontWeightMedium: fontWeightMedium,\n    fontWeightBold: fontWeightBold\n  }, variants), other, {\n    clone: false // No need to clone deep\n\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/shadows.js\nvar shadowKeyUmbraOpacity = 0.2;\nvar shadowKeyPenumbraOpacity = 0.14;\nvar shadowAmbientShadowOpacity = 0.12;\n\nfunction createShadow() {\n  return [\"\".concat(arguments.length <= 0 ? undefined : arguments[0], \"px \").concat(arguments.length <= 1 ? undefined : arguments[1], \"px \").concat(arguments.length <= 2 ? undefined : arguments[2], \"px \").concat(arguments.length <= 3 ? undefined : arguments[3], \"px rgba(0,0,0,\").concat(shadowKeyUmbraOpacity, \")\"), \"\".concat(arguments.length <= 4 ? undefined : arguments[4], \"px \").concat(arguments.length <= 5 ? undefined : arguments[5], \"px \").concat(arguments.length <= 6 ? undefined : arguments[6], \"px \").concat(arguments.length <= 7 ? undefined : arguments[7], \"px rgba(0,0,0,\").concat(shadowKeyPenumbraOpacity, \")\"), \"\".concat(arguments.length <= 8 ? undefined : arguments[8], \"px \").concat(arguments.length <= 9 ? undefined : arguments[9], \"px \").concat(arguments.length <= 10 ? undefined : arguments[10], \"px \").concat(arguments.length <= 11 ? undefined : arguments[11], \"px rgba(0,0,0,\").concat(shadowAmbientShadowOpacity, \")\")].join(',');\n} // Values from https://github.com/material-components/material-components-web/blob/be8747f94574669cb5e7add1a7c54fa41a89cec7/packages/mdc-elevation/_variables.scss\n\n\nvar shadows = ['none', createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];\n/* harmony default export */ var styles_shadows = (shadows);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/shape.js\nvar shape = {\n  borderRadius: 4\n};\n/* harmony default export */ var styles_shape = (shape);\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\n\n\n\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/system/esm/merge.js\n\n\nfunction merge(acc, item) {\n  if (!item) {\n    return acc;\n  }\n\n  return deepmerge(acc, item, {\n    clone: false // No need to clone deep, it's way faster.\n\n  });\n}\n\n/* harmony default export */ var esm_merge = (merge);\n// CONCATENATED MODULE: ./node_modules/@material-ui/system/esm/breakpoints.js\n\n\n\n\n // The breakpoint **start** at this value.\n// For instance with the first breakpoint xs: [xs, sm[.\n\nvar breakpoints_values = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920\n};\nvar defaultBreakpoints = {\n  // Sorted ASC by size. That's important.\n  // It can't be configured as it's used statically for propTypes.\n  keys: ['xs', 'sm', 'md', 'lg', 'xl'],\n  up: function up(key) {\n    return \"@media (min-width:\".concat(breakpoints_values[key], \"px)\");\n  }\n};\nfunction handleBreakpoints(props, propValue, styleFromPropValue) {\n  if (false) {}\n\n  if (Array.isArray(propValue)) {\n    var themeBreakpoints = props.theme.breakpoints || defaultBreakpoints;\n    return propValue.reduce(function (acc, item, index) {\n      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);\n      return acc;\n    }, {});\n  }\n\n  if (typeof_typeof(propValue) === 'object') {\n    var _themeBreakpoints = props.theme.breakpoints || defaultBreakpoints;\n\n    return Object.keys(propValue).reduce(function (acc, breakpoint) {\n      acc[_themeBreakpoints.up(breakpoint)] = styleFromPropValue(propValue[breakpoint]);\n      return acc;\n    }, {});\n  }\n\n  var output = styleFromPropValue(propValue);\n  return output;\n}\n\nfunction breakpoints_breakpoints(styleFunction) {\n  var newStyleFunction = function newStyleFunction(props) {\n    var base = styleFunction(props);\n    var themeBreakpoints = props.theme.breakpoints || defaultBreakpoints;\n    var extended = themeBreakpoints.keys.reduce(function (acc, key) {\n      if (props[key]) {\n        acc = acc || {};\n        acc[themeBreakpoints.up(key)] = styleFunction(_extends({\n          theme: props.theme\n        }, props[key]));\n      }\n\n      return acc;\n    }, null);\n    return esm_merge(base, extended);\n  };\n\n  newStyleFunction.propTypes =  false ? undefined : {};\n  newStyleFunction.filterProps = ['xs', 'sm', 'md', 'lg', 'xl'].concat(_toConsumableArray(styleFunction.filterProps));\n  return newStyleFunction;\n}\n\n/* harmony default export */ var esm_breakpoints = (breakpoints_breakpoints);\n// CONCATENATED MODULE: ./node_modules/@material-ui/system/esm/memoize.js\nfunction memoize_memoize(fn) {\n  var cache = {};\n  return function (arg) {\n    if (cache[arg] === undefined) {\n      cache[arg] = fn(arg);\n    }\n\n    return cache[arg];\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/system/esm/spacing.js\n\n\n\n\n\nvar properties = {\n  m: 'margin',\n  p: 'padding'\n};\nvar directions = {\n  t: 'Top',\n  r: 'Right',\n  b: 'Bottom',\n  l: 'Left',\n  x: ['Left', 'Right'],\n  y: ['Top', 'Bottom']\n};\nvar aliases = {\n  marginX: 'mx',\n  marginY: 'my',\n  paddingX: 'px',\n  paddingY: 'py'\n}; // memoize() impact:\n// From 300,000 ops/sec\n// To 350,000 ops/sec\n\nvar getCssProperties = memoize_memoize(function (prop) {\n  // It's not a shorthand notation.\n  if (prop.length > 2) {\n    if (aliases[prop]) {\n      prop = aliases[prop];\n    } else {\n      return [prop];\n    }\n  }\n\n  var _prop$split = prop.split(''),\n      _prop$split2 = _slicedToArray(_prop$split, 2),\n      a = _prop$split2[0],\n      b = _prop$split2[1];\n\n  var property = properties[a];\n  var direction = directions[b] || '';\n  return Array.isArray(direction) ? direction.map(function (dir) {\n    return property + dir;\n  }) : [property + direction];\n});\nvar spacingKeys = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY'];\nfunction createUnarySpacing(theme) {\n  var themeSpacing = theme.spacing || 8;\n\n  if (typeof themeSpacing === 'number') {\n    return function (abs) {\n      if (false) {}\n\n      return themeSpacing * abs;\n    };\n  }\n\n  if (Array.isArray(themeSpacing)) {\n    return function (abs) {\n      if (false) {}\n\n      return themeSpacing[abs];\n    };\n  }\n\n  if (typeof themeSpacing === 'function') {\n    return themeSpacing;\n  }\n\n  if (false) {}\n\n  return function () {\n    return undefined;\n  };\n}\n\nfunction getValue(transformer, propValue) {\n  if (typeof propValue === 'string') {\n    return propValue;\n  }\n\n  var abs = Math.abs(propValue);\n  var transformed = transformer(abs);\n\n  if (propValue >= 0) {\n    return transformed;\n  }\n\n  if (typeof transformed === 'number') {\n    return -transformed;\n  }\n\n  return \"-\".concat(transformed);\n}\n\nfunction getStyleFromPropValue(cssProperties, transformer) {\n  return function (propValue) {\n    return cssProperties.reduce(function (acc, cssProperty) {\n      acc[cssProperty] = getValue(transformer, propValue);\n      return acc;\n    }, {});\n  };\n}\n\nfunction spacing_spacing(props) {\n  var theme = props.theme;\n  var transformer = createUnarySpacing(theme);\n  return Object.keys(props).map(function (prop) {\n    // Using a hash computation over an array iteration could be faster, but with only 28 items,\n    // it's doesn't worth the bundle size.\n    if (spacingKeys.indexOf(prop) === -1) {\n      return null;\n    }\n\n    var cssProperties = getCssProperties(prop);\n    var styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);\n    var propValue = props[prop];\n    return handleBreakpoints(props, propValue, styleFromPropValue);\n  }).reduce(esm_merge, {});\n}\n\nspacing_spacing.propTypes =  false ? undefined : {};\nspacing_spacing.filterProps = spacingKeys;\n/* harmony default export */ var esm_spacing = (spacing_spacing);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/createSpacing.js\n\nvar warnOnce;\nfunction createSpacing() {\n  var spacingInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n\n  // Already transformed.\n  if (spacingInput.mui) {\n    return spacingInput;\n  } // Material Design layouts are visually balanced. Most measurements align to an 8dp grid applied, which aligns both spacing and the overall layout.\n  // Smaller components, such as icons and type, can align to a 4dp grid.\n  // https://material.io/design/layout/understanding-layout.html#usage\n\n\n  var transform = createUnarySpacing({\n    spacing: spacingInput\n  });\n\n  var spacing = function spacing() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (false) {}\n\n    if (args.length === 0) {\n      return transform(1);\n    }\n\n    if (args.length === 1) {\n      return transform(args[0]);\n    }\n\n    return args.map(function (argument) {\n      if (typeof argument === 'string') {\n        return argument;\n      }\n\n      var output = transform(argument);\n      return typeof output === 'number' ? \"\".concat(output, \"px\") : output;\n    }).join(' ');\n  }; // Backward compatibility, to remove in v5.\n\n\n  Object.defineProperty(spacing, 'unit', {\n    get: function get() {\n      if (false) {}\n\n      return spacingInput;\n    }\n  });\n  spacing.mui = true;\n  return spacing;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/transitions.js\n\n// Follow https://material.google.com/motion/duration-easing.html#duration-easing-natural-easing-curves\n// to learn the context in which each easing should be used.\nvar easing = {\n  // This is the most common easing curve.\n  easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',\n  // Objects enter the screen at full velocity from off-screen and\n  // slowly decelerate to a resting point.\n  easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',\n  // Objects leave the screen at full velocity. They do not decelerate when off-screen.\n  easeIn: 'cubic-bezier(0.4, 0, 1, 1)',\n  // The sharp curve is used by objects that may return to the screen at any time.\n  sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'\n}; // Follow https://material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations\n// to learn when use what timing\n\nvar transitions_duration = {\n  shortest: 150,\n  shorter: 200,\n  short: 250,\n  // most basic recommended timing\n  standard: 300,\n  // this is to be used in complex animations\n  complex: 375,\n  // recommended when something is entering screen\n  enteringScreen: 225,\n  // recommended when something is leaving screen\n  leavingScreen: 195\n};\n\nfunction formatMs(milliseconds) {\n  return \"\".concat(Math.round(milliseconds), \"ms\");\n}\n/**\n * @param {string|Array} props\n * @param {object} param\n * @param {string} param.prop\n * @param {number} param.duration\n * @param {string} param.easing\n * @param {number} param.delay\n */\n\n\n/* harmony default export */ var transitions = ({\n  easing: easing,\n  duration: transitions_duration,\n  create: function create() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['all'];\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _options$duration = options.duration,\n        durationOption = _options$duration === void 0 ? transitions_duration.standard : _options$duration,\n        _options$easing = options.easing,\n        easingOption = _options$easing === void 0 ? easing.easeInOut : _options$easing,\n        _options$delay = options.delay,\n        delay = _options$delay === void 0 ? 0 : _options$delay,\n        other = _objectWithoutProperties(options, [\"duration\", \"easing\", \"delay\"]);\n\n    if (false) { var isNumber, isString; }\n\n    return (Array.isArray(props) ? props : [props]).map(function (animatedProp) {\n      return \"\".concat(animatedProp, \" \").concat(typeof durationOption === 'string' ? durationOption : formatMs(durationOption), \" \").concat(easingOption, \" \").concat(typeof delay === 'string' ? delay : formatMs(delay));\n    }).join(',');\n  },\n  getAutoHeightDuration: function getAutoHeightDuration(height) {\n    if (!height) {\n      return 0;\n    }\n\n    var constant = height / 36; // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10\n\n    return Math.round((4 + 15 * Math.pow(constant, 0.25) + constant / 5) * 10);\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/zIndex.js\n// We need to centralize the zIndex definitions as they work\n// like global values in the browser.\nvar zIndex = {\n  mobileStepper: 1000,\n  speedDial: 1050,\n  appBar: 1100,\n  drawer: 1200,\n  modal: 1300,\n  snackbar: 1400,\n  tooltip: 1500\n};\n/* harmony default export */ var styles_zIndex = (zIndex);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/createMuiTheme.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction createMuiTheme() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _options$breakpoints = options.breakpoints,\n      breakpointsInput = _options$breakpoints === void 0 ? {} : _options$breakpoints,\n      _options$mixins = options.mixins,\n      mixinsInput = _options$mixins === void 0 ? {} : _options$mixins,\n      _options$palette = options.palette,\n      paletteInput = _options$palette === void 0 ? {} : _options$palette,\n      spacingInput = options.spacing,\n      _options$typography = options.typography,\n      typographyInput = _options$typography === void 0 ? {} : _options$typography,\n      other = _objectWithoutProperties(options, [\"breakpoints\", \"mixins\", \"palette\", \"spacing\", \"typography\"]);\n\n  var palette = createPalette(paletteInput);\n  var breakpoints = createBreakpoints(breakpointsInput);\n  var spacing = createSpacing(spacingInput);\n  var muiTheme = deepmerge({\n    breakpoints: breakpoints,\n    direction: 'ltr',\n    mixins: createMixins(breakpoints, spacing, mixinsInput),\n    overrides: {},\n    // Inject custom styles\n    palette: palette,\n    props: {},\n    // Provide default props\n    shadows: styles_shadows,\n    typography: createTypography(palette, typographyInput),\n    spacing: spacing,\n    shape: styles_shape,\n    transitions: transitions,\n    zIndex: styles_zIndex\n  }, other);\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  muiTheme = args.reduce(function (acc, argument) {\n    return deepmerge(acc, argument);\n  }, muiTheme);\n\n  if (false) { var traverse, pseudoClasses; }\n\n  return muiTheme;\n}\n\n/* harmony default export */ var styles_createMuiTheme = (createMuiTheme);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/defaultTheme.js\n\nvar defaultTheme_defaultTheme = styles_createMuiTheme();\n/* harmony default export */ var styles_defaultTheme = (defaultTheme_defaultTheme);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/makeStyles.js\n\n\n\n\nfunction makeStyles_makeStyles(stylesOrCreator) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return makeStyles(stylesOrCreator, _extends({\n    defaultTheme: styles_defaultTheme\n  }, options));\n}\n\n/* harmony default export */ var styles_makeStyles = (makeStyles_makeStyles);\n// CONCATENATED MODULE: ./node_modules/clsx/dist/clsx.m.js\nfunction toVal(mix) {\n\tvar k, y, str='';\n\n\tif (typeof mix === 'string' || typeof mix === 'number') {\n\t\tstr += mix;\n\t} else if (typeof mix === 'object') {\n\t\tif (Array.isArray(mix)) {\n\t\t\tfor (k=0; k < mix.length; k++) {\n\t\t\t\tif (mix[k]) {\n\t\t\t\t\tif (y = toVal(mix[k])) {\n\t\t\t\t\t\tstr && (str += ' ');\n\t\t\t\t\t\tstr += y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (k in mix) {\n\t\t\t\tif (mix[k]) {\n\t\t\t\t\tstr && (str += ' ');\n\t\t\t\t\tstr += k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/* harmony default export */ var clsx_m = (function () {\n\tvar i=0, tmp, x, str='';\n\twhile (i < arguments.length) {\n\t\tif (tmp = arguments[i++]) {\n\t\t\tif (x = toVal(tmp)) {\n\t\t\t\tstr && (str += ' ');\n\t\t\t\tstr += x\n\t\t\t}\n\t\t}\n\t}\n\treturn str;\n});\n\n// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\nvar hoist_non_react_statics_cjs = __webpack_require__(19);\nvar hoist_non_react_statics_cjs_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics_cjs);\n\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/getThemeProps/getThemeProps.js\n/* eslint-disable no-restricted-syntax */\nfunction getThemeProps(params) {\n  var theme = params.theme,\n      name = params.name,\n      props = params.props;\n\n  if (!theme || !theme.props || !theme.props[name]) {\n    return props;\n  } // Resolve default props, code borrow from React source.\n  // https://github.com/facebook/react/blob/15a8f031838a553e41c0b66eb1bcf1da8448104d/packages/react/src/ReactElement.js#L221\n\n\n  var defaultProps = theme.props[name];\n  var propName;\n\n  for (propName in defaultProps) {\n    if (props[propName] === undefined) {\n      props[propName] = defaultProps[propName];\n    }\n  }\n\n  return props;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/styles/esm/withStyles/withStyles.js\n\n\n\n\n\n\n\n\n // Link a style sheet with a component.\n// It does not modify the component passed to it;\n// instead, it returns a new component, with a `classes` property.\n\nvar withStyles_withStyles = function withStyles(stylesOrCreator) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (Component) {\n    var defaultTheme = options.defaultTheme,\n        _options$withTheme = options.withTheme,\n        withTheme = _options$withTheme === void 0 ? false : _options$withTheme,\n        name = options.name,\n        stylesOptions = _objectWithoutProperties(options, [\"defaultTheme\", \"withTheme\", \"name\"]);\n\n    if (false) {}\n\n    var classNamePrefix = name;\n\n    if (false) { var displayName; }\n\n    var useStyles = makeStyles(stylesOrCreator, _extends({\n      defaultTheme: defaultTheme,\n      Component: Component,\n      name: name || Component.displayName,\n      classNamePrefix: classNamePrefix\n    }, stylesOptions));\n    var WithStyles = react_default.a.forwardRef(function WithStyles(props, ref) {\n      var classesProp = props.classes,\n          innerRef = props.innerRef,\n          other = _objectWithoutProperties(props, [\"classes\", \"innerRef\"]); // The wrapper receives only user supplied props, which could be a subset of\n      // the actual props Component might receive due to merging with defaultProps.\n      // So copying it here would give us the same result in the wrapper as well.\n\n\n      var classes = useStyles(_extends(_extends({}, Component.defaultProps), props));\n      var theme;\n      var more = other;\n\n      if (typeof name === 'string' || withTheme) {\n        // name and withTheme are invariant in the outer scope\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        theme = useTheme() || defaultTheme;\n\n        if (name) {\n          more = getThemeProps({\n            theme: theme,\n            name: name,\n            props: other\n          });\n        } // Provide the theme to the wrapped component.\n        // So we don't have to use the `withTheme()` Higher-order Component.\n\n\n        if (withTheme && !more.theme) {\n          more.theme = theme;\n        }\n      }\n\n      return /*#__PURE__*/react_default.a.createElement(Component, _extends({\n        ref: innerRef || ref,\n        classes: classes\n      }, more));\n    });\n     false ? undefined : void 0;\n\n    if (false) {}\n\n    hoist_non_react_statics_cjs_default()(WithStyles, Component);\n\n    if (false) {}\n\n    return WithStyles;\n  };\n};\n\n/* harmony default export */ var esm_withStyles_withStyles = (withStyles_withStyles);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/withStyles.js\n\n\n\n\nfunction styles_withStyles_withStyles(stylesOrCreator, options) {\n  return esm_withStyles_withStyles(stylesOrCreator, _extends({\n    defaultTheme: styles_defaultTheme\n  }, options));\n}\n\n/* harmony default export */ var styles_withStyles = (styles_withStyles_withStyles);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Paper/Paper.js\n\n\n\n\n\n\n\nvar Paper_styles = function styles(theme) {\n  var elevations = {};\n  theme.shadows.forEach(function (shadow, index) {\n    elevations[\"elevation\".concat(index)] = {\n      boxShadow: shadow\n    };\n  });\n  return _extends({\n    /* Styles applied to the root element. */\n    root: {\n      backgroundColor: theme.palette.background.paper,\n      color: theme.palette.text.primary,\n      transition: theme.transitions.create('box-shadow')\n    },\n\n    /* Styles applied to the root element if `square={false}`. */\n    rounded: {\n      borderRadius: theme.shape.borderRadius\n    },\n\n    /* Styles applied to the root element if `variant=\"outlined\"`. */\n    outlined: {\n      border: \"1px solid \".concat(theme.palette.divider)\n    }\n  }, elevations);\n};\nvar Paper_Paper = /*#__PURE__*/react[\"forwardRef\"](function Paper(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'div' : _props$component,\n      _props$square = props.square,\n      square = _props$square === void 0 ? false : _props$square,\n      _props$elevation = props.elevation,\n      elevation = _props$elevation === void 0 ? 1 : _props$elevation,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'elevation' : _props$variant,\n      other = _objectWithoutProperties(props, [\"classes\", \"className\", \"component\", \"square\", \"elevation\", \"variant\"]);\n\n  return /*#__PURE__*/react[\"createElement\"](Component, _extends({\n    className: clsx_m(classes.root, className, variant === 'outlined' ? classes.outlined : classes[\"elevation\".concat(elevation)], !square && classes.rounded),\n    ref: ref\n  }, other));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_Paper_Paper = (styles_withStyles(Paper_styles, {\n  name: 'MuiPaper'\n})(Paper_Paper));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Card/Card.js\n\n\n\n\n\n\n\nvar Card_styles = {\n  /* Styles applied to the root element. */\n  root: {\n    overflow: 'hidden'\n  }\n};\nvar Card_Card = /*#__PURE__*/react[\"forwardRef\"](function Card(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      _props$raised = props.raised,\n      raised = _props$raised === void 0 ? false : _props$raised,\n      other = _objectWithoutProperties(props, [\"classes\", \"className\", \"raised\"]);\n\n  return /*#__PURE__*/react[\"createElement\"](esm_Paper_Paper, _extends({\n    className: clsx_m(classes.root, className),\n    elevation: raised ? 8 : 1,\n    ref: ref\n  }, other));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_Card_Card = (styles_withStyles(Card_styles, {\n  name: 'MuiCard'\n})(Card_Card));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/CardContent/CardContent.js\n\n\n\n\n\n\nvar CardContent_styles = {\n  /* Styles applied to the root element. */\n  root: {\n    padding: 16,\n    '&:last-child': {\n      paddingBottom: 24\n    }\n  }\n};\nvar CardContent_CardContent = /*#__PURE__*/react[\"forwardRef\"](function CardContent(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'div' : _props$component,\n      other = _objectWithoutProperties(props, [\"classes\", \"className\", \"component\"]);\n\n  return /*#__PURE__*/react[\"createElement\"](Component, _extends({\n    className: clsx_m(classes.root, className),\n    ref: ref\n  }, other));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_CardContent_CardContent = (styles_withStyles(CardContent_styles, {\n  name: 'MuiCardContent'\n})(CardContent_CardContent));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/capitalize.js\n\n// It should to be noted that this function isn't equivalent to `text-transform: capitalize`.\n//\n// A strict capitalization should uppercase the first letter of each word a the sentence.\n// We only handle the first word.\nfunction capitalize(string) {\n  if (typeof string !== 'string') {\n    throw new Error( false ? undefined : formatMuiErrorMessage(7));\n  }\n\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Typography/Typography.js\n\n\n\n\n\n\n\nvar Typography_styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      margin: 0\n    },\n\n    /* Styles applied to the root element if `variant=\"body2\"`. */\n    body2: theme.typography.body2,\n\n    /* Styles applied to the root element if `variant=\"body1\"`. */\n    body1: theme.typography.body1,\n\n    /* Styles applied to the root element if `variant=\"caption\"`. */\n    caption: theme.typography.caption,\n\n    /* Styles applied to the root element if `variant=\"button\"`. */\n    button: theme.typography.button,\n\n    /* Styles applied to the root element if `variant=\"h1\"`. */\n    h1: theme.typography.h1,\n\n    /* Styles applied to the root element if `variant=\"h2\"`. */\n    h2: theme.typography.h2,\n\n    /* Styles applied to the root element if `variant=\"h3\"`. */\n    h3: theme.typography.h3,\n\n    /* Styles applied to the root element if `variant=\"h4\"`. */\n    h4: theme.typography.h4,\n\n    /* Styles applied to the root element if `variant=\"h5\"`. */\n    h5: theme.typography.h5,\n\n    /* Styles applied to the root element if `variant=\"h6\"`. */\n    h6: theme.typography.h6,\n\n    /* Styles applied to the root element if `variant=\"subtitle1\"`. */\n    subtitle1: theme.typography.subtitle1,\n\n    /* Styles applied to the root element if `variant=\"subtitle2\"`. */\n    subtitle2: theme.typography.subtitle2,\n\n    /* Styles applied to the root element if `variant=\"overline\"`. */\n    overline: theme.typography.overline,\n\n    /* Styles applied to the root element if `variant=\"srOnly\"`. Only accessible to screen readers. */\n    srOnly: {\n      position: 'absolute',\n      height: 1,\n      width: 1,\n      overflow: 'hidden'\n    },\n\n    /* Styles applied to the root element if `align=\"left\"`. */\n    alignLeft: {\n      textAlign: 'left'\n    },\n\n    /* Styles applied to the root element if `align=\"center\"`. */\n    alignCenter: {\n      textAlign: 'center'\n    },\n\n    /* Styles applied to the root element if `align=\"right\"`. */\n    alignRight: {\n      textAlign: 'right'\n    },\n\n    /* Styles applied to the root element if `align=\"justify\"`. */\n    alignJustify: {\n      textAlign: 'justify'\n    },\n\n    /* Styles applied to the root element if `nowrap={true}`. */\n    noWrap: {\n      overflow: 'hidden',\n      textOverflow: 'ellipsis',\n      whiteSpace: 'nowrap'\n    },\n\n    /* Styles applied to the root element if `gutterBottom={true}`. */\n    gutterBottom: {\n      marginBottom: '0.35em'\n    },\n\n    /* Styles applied to the root element if `paragraph={true}`. */\n    paragraph: {\n      marginBottom: 16\n    },\n\n    /* Styles applied to the root element if `color=\"inherit\"`. */\n    colorInherit: {\n      color: 'inherit'\n    },\n\n    /* Styles applied to the root element if `color=\"primary\"`. */\n    colorPrimary: {\n      color: theme.palette.primary.main\n    },\n\n    /* Styles applied to the root element if `color=\"secondary\"`. */\n    colorSecondary: {\n      color: theme.palette.secondary.main\n    },\n\n    /* Styles applied to the root element if `color=\"textPrimary\"`. */\n    colorTextPrimary: {\n      color: theme.palette.text.primary\n    },\n\n    /* Styles applied to the root element if `color=\"textSecondary\"`. */\n    colorTextSecondary: {\n      color: theme.palette.text.secondary\n    },\n\n    /* Styles applied to the root element if `color=\"error\"`. */\n    colorError: {\n      color: theme.palette.error.main\n    },\n\n    /* Styles applied to the root element if `display=\"inline\"`. */\n    displayInline: {\n      display: 'inline'\n    },\n\n    /* Styles applied to the root element if `display=\"block\"`. */\n    displayBlock: {\n      display: 'block'\n    }\n  };\n};\nvar defaultVariantMapping = {\n  h1: 'h1',\n  h2: 'h2',\n  h3: 'h3',\n  h4: 'h4',\n  h5: 'h5',\n  h6: 'h6',\n  subtitle1: 'h6',\n  subtitle2: 'h6',\n  body1: 'p',\n  body2: 'p'\n};\nvar Typography_Typography = /*#__PURE__*/react[\"forwardRef\"](function Typography(props, ref) {\n  var _props$align = props.align,\n      align = _props$align === void 0 ? 'inherit' : _props$align,\n      classes = props.classes,\n      className = props.className,\n      _props$color = props.color,\n      color = _props$color === void 0 ? 'initial' : _props$color,\n      component = props.component,\n      _props$display = props.display,\n      display = _props$display === void 0 ? 'initial' : _props$display,\n      _props$gutterBottom = props.gutterBottom,\n      gutterBottom = _props$gutterBottom === void 0 ? false : _props$gutterBottom,\n      _props$noWrap = props.noWrap,\n      noWrap = _props$noWrap === void 0 ? false : _props$noWrap,\n      _props$paragraph = props.paragraph,\n      paragraph = _props$paragraph === void 0 ? false : _props$paragraph,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'body1' : _props$variant,\n      _props$variantMapping = props.variantMapping,\n      variantMapping = _props$variantMapping === void 0 ? defaultVariantMapping : _props$variantMapping,\n      other = _objectWithoutProperties(props, [\"align\", \"classes\", \"className\", \"color\", \"component\", \"display\", \"gutterBottom\", \"noWrap\", \"paragraph\", \"variant\", \"variantMapping\"]);\n\n  var Component = component || (paragraph ? 'p' : variantMapping[variant] || defaultVariantMapping[variant]) || 'span';\n  return /*#__PURE__*/react[\"createElement\"](Component, _extends({\n    className: clsx_m(classes.root, className, variant !== 'inherit' && classes[variant], color !== 'initial' && classes[\"color\".concat(capitalize(color))], noWrap && classes.noWrap, gutterBottom && classes.gutterBottom, paragraph && classes.paragraph, align !== 'inherit' && classes[\"align\".concat(capitalize(align))], display !== 'initial' && classes[\"display\".concat(capitalize(display))]),\n    ref: ref\n  }, other));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_Typography_Typography = (styles_withStyles(Typography_styles, {\n  name: 'MuiTypography'\n})(Typography_Typography));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/CardHeader/CardHeader.js\n\n\n\n\n\n\n\nvar CardHeader_styles = {\n  /* Styles applied to the root element. */\n  root: {\n    display: 'flex',\n    alignItems: 'center',\n    padding: 16\n  },\n\n  /* Styles applied to the avatar element. */\n  avatar: {\n    flex: '0 0 auto',\n    marginRight: 16\n  },\n\n  /* Styles applied to the action element. */\n  action: {\n    flex: '0 0 auto',\n    alignSelf: 'flex-start',\n    marginTop: -8,\n    marginRight: -8\n  },\n\n  /* Styles applied to the content wrapper element. */\n  content: {\n    flex: '1 1 auto'\n  },\n\n  /* Styles applied to the title Typography element. */\n  title: {},\n\n  /* Styles applied to the subheader Typography element. */\n  subheader: {}\n};\nvar CardHeader_CardHeader = /*#__PURE__*/react[\"forwardRef\"](function CardHeader(props, ref) {\n  var action = props.action,\n      avatar = props.avatar,\n      classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'div' : _props$component,\n      _props$disableTypogra = props.disableTypography,\n      disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra,\n      subheaderProp = props.subheader,\n      subheaderTypographyProps = props.subheaderTypographyProps,\n      titleProp = props.title,\n      titleTypographyProps = props.titleTypographyProps,\n      other = _objectWithoutProperties(props, [\"action\", \"avatar\", \"classes\", \"className\", \"component\", \"disableTypography\", \"subheader\", \"subheaderTypographyProps\", \"title\", \"titleTypographyProps\"]);\n\n  var title = titleProp;\n\n  if (title != null && title.type !== esm_Typography_Typography && !disableTypography) {\n    title = /*#__PURE__*/react[\"createElement\"](esm_Typography_Typography, _extends({\n      variant: avatar ? 'body2' : 'h5',\n      className: classes.title,\n      component: \"span\",\n      display: \"block\"\n    }, titleTypographyProps), title);\n  }\n\n  var subheader = subheaderProp;\n\n  if (subheader != null && subheader.type !== esm_Typography_Typography && !disableTypography) {\n    subheader = /*#__PURE__*/react[\"createElement\"](esm_Typography_Typography, _extends({\n      variant: avatar ? 'body2' : 'body1',\n      className: classes.subheader,\n      color: \"textSecondary\",\n      component: \"span\",\n      display: \"block\"\n    }, subheaderTypographyProps), subheader);\n  }\n\n  return /*#__PURE__*/react[\"createElement\"](Component, _extends({\n    className: clsx_m(classes.root, className),\n    ref: ref\n  }, other), avatar && /*#__PURE__*/react[\"createElement\"](\"div\", {\n    className: classes.avatar\n  }, avatar), /*#__PURE__*/react[\"createElement\"](\"div\", {\n    className: classes.content\n  }, title, subheader), action && /*#__PURE__*/react[\"createElement\"](\"div\", {\n    className: classes.action\n  }, action));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_CardHeader_CardHeader = (styles_withStyles(CardHeader_styles, {\n  name: 'MuiCardHeader'\n})(CardHeader_CardHeader));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/List/ListContext.js\n\n/**\n * @ignore - internal component.\n */\n\nvar ListContext = react[\"createContext\"]({});\n\nif (false) {}\n\n/* harmony default export */ var List_ListContext = (ListContext);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/List/List.js\n\n\n\n\n\n\n\nvar List_styles = {\n  /* Styles applied to the root element. */\n  root: {\n    listStyle: 'none',\n    margin: 0,\n    padding: 0,\n    position: 'relative'\n  },\n\n  /* Styles applied to the root element if `disablePadding={false}`. */\n  padding: {\n    paddingTop: 8,\n    paddingBottom: 8\n  },\n\n  /* Styles applied to the root element if dense. */\n  dense: {},\n\n  /* Styles applied to the root element if a `subheader` is provided. */\n  subheader: {\n    paddingTop: 0\n  }\n};\nvar List_List = /*#__PURE__*/react[\"forwardRef\"](function List(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'ul' : _props$component,\n      _props$dense = props.dense,\n      dense = _props$dense === void 0 ? false : _props$dense,\n      _props$disablePadding = props.disablePadding,\n      disablePadding = _props$disablePadding === void 0 ? false : _props$disablePadding,\n      subheader = props.subheader,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"component\", \"dense\", \"disablePadding\", \"subheader\"]);\n\n  var context = react[\"useMemo\"](function () {\n    return {\n      dense: dense\n    };\n  }, [dense]);\n  return /*#__PURE__*/react[\"createElement\"](List_ListContext.Provider, {\n    value: context\n  }, /*#__PURE__*/react[\"createElement\"](Component, _extends({\n    className: clsx_m(classes.root, className, dense && classes.dense, !disablePadding && classes.padding, subheader && classes.subheader),\n    ref: ref\n  }, other), subheader, children));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_List_List = (styles_withStyles(List_styles, {\n  name: 'MuiList'\n})(List_List));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/setRef.js\n// TODO v5: consider to make it private\nfunction setRef(ref, value) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/useForkRef.js\n\n\nfunction useForkRef(refA, refB) {\n  /**\n   * This will create a new function if the ref props change and are defined.\n   * This means react will call the old forkRef with `null` and the new forkRef\n   * with the ref. Cleanup naturally emerges from this behavior\n   */\n  return react[\"useMemo\"](function () {\n    if (refA == null && refB == null) {\n      return null;\n    }\n\n    return function (refValue) {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/useEventCallback.js\n\nvar useEnhancedEffect = typeof window !== 'undefined' ? react[\"useLayoutEffect\"] : react[\"useEffect\"];\n/**\n * https://github.com/facebook/react/issues/14099#issuecomment-440013892\n *\n * @param {function} fn\n */\n\nfunction useEventCallback(fn) {\n  var ref = react[\"useRef\"](fn);\n  useEnhancedEffect(function () {\n    ref.current = fn;\n  });\n  return react[\"useCallback\"](function () {\n    return (0, ref.current).apply(void 0, arguments);\n  }, []);\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/useIsFocusVisible.js\n// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\n\n\nvar hadKeyboardEvent = true;\nvar hadFocusVisibleRecently = false;\nvar hadFocusVisibleRecentlyTimeout = null;\nvar inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  'datetime-local': true\n};\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} node\n * @return {boolean}\n */\n\nfunction focusTriggersKeyboardModality(node) {\n  var type = node.type,\n      tagName = node.tagName;\n\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\n    return true;\n  }\n\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\n    return true;\n  }\n\n  if (node.isContentEditable) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\n * If the most recent user interaction was via the keyboard;\n * and the key press did not include a meta, alt/option, or control key;\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\n * @param {KeyboardEvent} event\n */\n\n\nfunction useIsFocusVisible_handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n\n  hadKeyboardEvent = true;\n}\n/**\n * If at any point a user clicks with a pointing device, ensure that we change\n * the modality away from keyboard.\n * This avoids the situation where a user presses a key on an already focused\n * element, and then clicks on a different element, focusing it with a\n * pointing device, while we still think we're in keyboard modality.\n */\n\n\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\n\nfunction handleVisibilityChange() {\n  if (this.visibilityState === 'hidden') {\n    // If the tab becomes active again, the browser will handle calling focus\n    // on the element (Safari actually calls it twice).\n    // If this tab change caused a blur on an element with focus-visible,\n    // re-apply the class when the user switches back to the tab.\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\n\nfunction prepare(doc) {\n  doc.addEventListener('keydown', useIsFocusVisible_handleKeyDown, true);\n  doc.addEventListener('mousedown', handlePointerDown, true);\n  doc.addEventListener('pointerdown', handlePointerDown, true);\n  doc.addEventListener('touchstart', handlePointerDown, true);\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\n}\n\nfunction teardown(doc) {\n  doc.removeEventListener('keydown', useIsFocusVisible_handleKeyDown, true);\n  doc.removeEventListener('mousedown', handlePointerDown, true);\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\n  doc.removeEventListener('touchstart', handlePointerDown, true);\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\n}\n\nfunction useIsFocusVisible_isFocusVisible(event) {\n  var target = event.target;\n\n  try {\n    return target.matches(':focus-visible');\n  } catch (error) {} // browsers not implementing :focus-visible will throw a SyntaxError\n  // we use our own heuristic for those browsers\n  // rethrow might be better if it's not the expected error but do we really\n  // want to crash if focus-visible malfunctioned?\n  // no need for validFocusTarget check. the user does that by attaching it to\n  // focusable events only\n\n\n  return hadKeyboardEvent || focusTriggersKeyboardModality(target);\n}\n/**\n * Should be called if a blur event is fired on a focus-visible element\n */\n\n\nfunction handleBlurVisible() {\n  // To detect a tab/window switch, we look for a blur event followed\n  // rapidly by a visibility change.\n  // If we don't see a visibility change within 100ms, it's probably a\n  // regular focus change.\n  hadFocusVisibleRecently = true;\n  window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n  hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {\n    hadFocusVisibleRecently = false;\n  }, 100);\n}\n\nfunction useIsFocusVisible() {\n  var ref = react[\"useCallback\"](function (instance) {\n    var node = react_dom[\"findDOMNode\"](instance);\n\n    if (node != null) {\n      prepare(node.ownerDocument);\n    }\n  }, []);\n\n  if (false) {}\n\n  return {\n    isFocusVisible: useIsFocusVisible_isFocusVisible,\n    onBlurVisible: handleBlurVisible,\n    ref: ref\n  };\n}\n// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/TransitionGroupContext.js\n\n/* harmony default export */ var TransitionGroupContext = (react_default.a.createContext(null));\n// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/utils/ChildMapping.js\n\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\n\nfunction getChildMapping(children, mapFn) {\n  var mapper = function mapper(child) {\n    return mapFn && Object(react[\"isValidElement\"])(child) ? mapFn(child) : child;\n  };\n\n  var result = Object.create(null);\n  if (children) react[\"Children\"].map(children, function (c) {\n    return c;\n  }).forEach(function (child) {\n    // run the map function here instead so that the key is the computed one\n    result[child.key] = mapper(child);\n  });\n  return result;\n}\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\n\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    return key in next ? next[key] : prev[key];\n  } // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  var nextKeysPending = Object.create(null);\n  var pendingKeys = [];\n\n  for (var prevKey in prev) {\n    if (prevKey in next) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i;\n  var childMapping = {};\n\n  for (var nextKey in next) {\n    if (nextKeysPending[nextKey]) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nfunction getProp(child, prop, props) {\n  return props[prop] != null ? props[prop] : child.props[prop];\n}\n\nfunction getInitialChildMapping(props, onExited) {\n  return getChildMapping(props.children, function (child) {\n    return Object(react[\"cloneElement\"])(child, {\n      onExited: onExited.bind(null, child),\n      in: true,\n      appear: getProp(child, 'appear', props),\n      enter: getProp(child, 'enter', props),\n      exit: getProp(child, 'exit', props)\n    });\n  });\n}\nfunction getNextChildMapping(nextProps, prevChildMapping, onExited) {\n  var nextChildMapping = getChildMapping(nextProps.children);\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\n  Object.keys(children).forEach(function (key) {\n    var child = children[key];\n    if (!Object(react[\"isValidElement\"])(child)) return;\n    var hasPrev = (key in prevChildMapping);\n    var hasNext = (key in nextChildMapping);\n    var prevChild = prevChildMapping[key];\n    var isLeaving = Object(react[\"isValidElement\"])(prevChild) && !prevChild.props.in; // item is new (entering)\n\n    if (hasNext && (!hasPrev || isLeaving)) {\n      // console.log('entering', key)\n      children[key] = Object(react[\"cloneElement\"])(child, {\n        onExited: onExited.bind(null, child),\n        in: true,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    } else if (!hasNext && hasPrev && !isLeaving) {\n      // item is old (exiting)\n      // console.log('leaving', key)\n      children[key] = Object(react[\"cloneElement\"])(child, {\n        in: false\n      });\n    } else if (hasNext && hasPrev && Object(react[\"isValidElement\"])(prevChild)) {\n      // item hasn't changed transition states\n      // copy over the last transition props;\n      // console.log('unchanged', key)\n      children[key] = Object(react[\"cloneElement\"])(child, {\n        onExited: onExited.bind(null, child),\n        in: prevChild.props.in,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    }\n  });\n  return children;\n}\n// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/TransitionGroup.js\n\n\n\n\n\n\n\n\n\nvar TransitionGroup_values = Object.values || function (obj) {\n  return Object.keys(obj).map(function (k) {\n    return obj[k];\n  });\n};\n\nvar defaultProps = {\n  component: 'div',\n  childFactory: function childFactory(child) {\n    return child;\n  }\n};\n/**\n * The `<TransitionGroup>` component manages a set of transition components\n * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition\n * components, `<TransitionGroup>` is a state machine for managing the mounting\n * and unmounting of components over time.\n *\n * Consider the example below. As items are removed or added to the TodoList the\n * `in` prop is toggled automatically by the `<TransitionGroup>`.\n *\n * Note that `<TransitionGroup>`  does not define any animation behavior!\n * Exactly _how_ a list item animates is up to the individual transition\n * component. This means you can mix and match animations across different list\n * items.\n */\n\nvar TransitionGroup_TransitionGroup = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(TransitionGroup, _React$Component);\n\n  function TransitionGroup(props, context) {\n    var _this;\n\n    _this = _React$Component.call(this, props, context) || this;\n\n    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this)); // Initial children should all be entering, dependent on appear\n\n\n    _this.state = {\n      contextValue: {\n        isMounting: true\n      },\n      handleExited: handleExited,\n      firstRender: true\n    };\n    return _this;\n  }\n\n  var _proto = TransitionGroup.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.mounted = true;\n    this.setState({\n      contextValue: {\n        isMounting: false\n      }\n    });\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.mounted = false;\n  };\n\n  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {\n    var prevChildMapping = _ref.children,\n        handleExited = _ref.handleExited,\n        firstRender = _ref.firstRender;\n    return {\n      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),\n      firstRender: false\n    };\n  } // node is `undefined` when user provided `nodeRef` prop\n  ;\n\n  _proto.handleExited = function handleExited(child, node) {\n    var currentChildMapping = getChildMapping(this.props.children);\n    if (child.key in currentChildMapping) return;\n\n    if (child.props.onExited) {\n      child.props.onExited(node);\n    }\n\n    if (this.mounted) {\n      this.setState(function (state) {\n        var children = _extends({}, state.children);\n\n        delete children[child.key];\n        return {\n          children: children\n        };\n      });\n    }\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        Component = _this$props.component,\n        childFactory = _this$props.childFactory,\n        props = _objectWithoutPropertiesLoose(_this$props, [\"component\", \"childFactory\"]);\n\n    var contextValue = this.state.contextValue;\n    var children = TransitionGroup_values(this.state.children).map(childFactory);\n    delete props.appear;\n    delete props.enter;\n    delete props.exit;\n\n    if (Component === null) {\n      return /*#__PURE__*/react_default.a.createElement(TransitionGroupContext.Provider, {\n        value: contextValue\n      }, children);\n    }\n\n    return /*#__PURE__*/react_default.a.createElement(TransitionGroupContext.Provider, {\n      value: contextValue\n    }, /*#__PURE__*/react_default.a.createElement(Component, props, children));\n  };\n\n  return TransitionGroup;\n}(react_default.a.Component);\n\nTransitionGroup_TransitionGroup.propTypes =  false ? undefined : {};\nTransitionGroup_TransitionGroup.defaultProps = defaultProps;\n/* harmony default export */ var esm_TransitionGroup = (TransitionGroup_TransitionGroup);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/ButtonBase/Ripple.js\n\n\n\n\nvar Ripple_useEnhancedEffect = typeof window === 'undefined' ? react[\"useEffect\"] : react[\"useLayoutEffect\"];\n/**\n * @ignore - internal component.\n */\n\nfunction Ripple(props) {\n  var classes = props.classes,\n      _props$pulsate = props.pulsate,\n      pulsate = _props$pulsate === void 0 ? false : _props$pulsate,\n      rippleX = props.rippleX,\n      rippleY = props.rippleY,\n      rippleSize = props.rippleSize,\n      inProp = props.in,\n      _props$onExited = props.onExited,\n      onExited = _props$onExited === void 0 ? function () {} : _props$onExited,\n      timeout = props.timeout;\n\n  var _React$useState = react[\"useState\"](false),\n      leaving = _React$useState[0],\n      setLeaving = _React$useState[1];\n\n  var rippleClassName = clsx_m(classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);\n  var rippleStyles = {\n    width: rippleSize,\n    height: rippleSize,\n    top: -(rippleSize / 2) + rippleY,\n    left: -(rippleSize / 2) + rippleX\n  };\n  var childClassName = clsx_m(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);\n  var handleExited = useEventCallback(onExited); // Ripple is used for user feedback (e.g. click or press) so we want to apply styles with the highest priority\n\n  Ripple_useEnhancedEffect(function () {\n    if (!inProp) {\n      // react-transition-group#onExit\n      setLeaving(true); // react-transition-group#onExited\n\n      var timeoutId = setTimeout(handleExited, timeout);\n      return function () {\n        clearTimeout(timeoutId);\n      };\n    }\n\n    return undefined;\n  }, [handleExited, inProp, timeout]);\n  return /*#__PURE__*/react[\"createElement\"](\"span\", {\n    className: rippleClassName,\n    style: rippleStyles\n  }, /*#__PURE__*/react[\"createElement\"](\"span\", {\n    className: childClassName\n  }));\n}\n\n false ? undefined : void 0;\n/* harmony default export */ var ButtonBase_Ripple = (Ripple);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/ButtonBase/TouchRipple.js\n\n\n\n\n\n\n\n\n\nvar DURATION = 550;\nvar DELAY_RIPPLE = 80;\nvar TouchRipple_styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      position: 'absolute',\n      zIndex: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      borderRadius: 'inherit'\n    },\n\n    /* Styles applied to the internal `Ripple` components `ripple` class. */\n    ripple: {\n      opacity: 0,\n      position: 'absolute'\n    },\n\n    /* Styles applied to the internal `Ripple` components `rippleVisible` class. */\n    rippleVisible: {\n      opacity: 0.3,\n      transform: 'scale(1)',\n      animation: \"$enter \".concat(DURATION, \"ms \").concat(theme.transitions.easing.easeInOut)\n    },\n\n    /* Styles applied to the internal `Ripple` components `ripplePulsate` class. */\n    ripplePulsate: {\n      animationDuration: \"\".concat(theme.transitions.duration.shorter, \"ms\")\n    },\n\n    /* Styles applied to the internal `Ripple` components `child` class. */\n    child: {\n      opacity: 1,\n      display: 'block',\n      width: '100%',\n      height: '100%',\n      borderRadius: '50%',\n      backgroundColor: 'currentColor'\n    },\n\n    /* Styles applied to the internal `Ripple` components `childLeaving` class. */\n    childLeaving: {\n      opacity: 0,\n      animation: \"$exit \".concat(DURATION, \"ms \").concat(theme.transitions.easing.easeInOut)\n    },\n\n    /* Styles applied to the internal `Ripple` components `childPulsate` class. */\n    childPulsate: {\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      animation: \"$pulsate 2500ms \".concat(theme.transitions.easing.easeInOut, \" 200ms infinite\")\n    },\n    '@keyframes enter': {\n      '0%': {\n        transform: 'scale(0)',\n        opacity: 0.1\n      },\n      '100%': {\n        transform: 'scale(1)',\n        opacity: 0.3\n      }\n    },\n    '@keyframes exit': {\n      '0%': {\n        opacity: 1\n      },\n      '100%': {\n        opacity: 0\n      }\n    },\n    '@keyframes pulsate': {\n      '0%': {\n        transform: 'scale(1)'\n      },\n      '50%': {\n        transform: 'scale(0.92)'\n      },\n      '100%': {\n        transform: 'scale(1)'\n      }\n    }\n  };\n};\n/**\n * @ignore - internal component.\n *\n * TODO v5: Make private\n */\n\nvar TouchRipple_TouchRipple = /*#__PURE__*/react[\"forwardRef\"](function TouchRipple(props, ref) {\n  var _props$center = props.center,\n      centerProp = _props$center === void 0 ? false : _props$center,\n      classes = props.classes,\n      className = props.className,\n      other = _objectWithoutProperties(props, [\"center\", \"classes\", \"className\"]);\n\n  var _React$useState = react[\"useState\"]([]),\n      ripples = _React$useState[0],\n      setRipples = _React$useState[1];\n\n  var nextKey = react[\"useRef\"](0);\n  var rippleCallback = react[\"useRef\"](null);\n  react[\"useEffect\"](function () {\n    if (rippleCallback.current) {\n      rippleCallback.current();\n      rippleCallback.current = null;\n    }\n  }, [ripples]); // Used to filter out mouse emulated events on mobile.\n\n  var ignoringMouseDown = react[\"useRef\"](false); // We use a timer in order to only show the ripples for touch \"click\" like events.\n  // We don't want to display the ripple for touch scroll events.\n\n  var startTimer = react[\"useRef\"](null); // This is the hook called once the previous timeout is ready.\n\n  var startTimerCommit = react[\"useRef\"](null);\n  var container = react[\"useRef\"](null);\n  react[\"useEffect\"](function () {\n    return function () {\n      clearTimeout(startTimer.current);\n    };\n  }, []);\n  var startCommit = react[\"useCallback\"](function (params) {\n    var pulsate = params.pulsate,\n        rippleX = params.rippleX,\n        rippleY = params.rippleY,\n        rippleSize = params.rippleSize,\n        cb = params.cb;\n    setRipples(function (oldRipples) {\n      return [].concat(_toConsumableArray(oldRipples), [/*#__PURE__*/react[\"createElement\"](ButtonBase_Ripple, {\n        key: nextKey.current,\n        classes: classes,\n        timeout: DURATION,\n        pulsate: pulsate,\n        rippleX: rippleX,\n        rippleY: rippleY,\n        rippleSize: rippleSize\n      })]);\n    });\n    nextKey.current += 1;\n    rippleCallback.current = cb;\n  }, [classes]);\n  var start = react[\"useCallback\"](function () {\n    var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var cb = arguments.length > 2 ? arguments[2] : undefined;\n    var _options$pulsate = options.pulsate,\n        pulsate = _options$pulsate === void 0 ? false : _options$pulsate,\n        _options$center = options.center,\n        center = _options$center === void 0 ? centerProp || options.pulsate : _options$center,\n        _options$fakeElement = options.fakeElement,\n        fakeElement = _options$fakeElement === void 0 ? false : _options$fakeElement;\n\n    if (event.type === 'mousedown' && ignoringMouseDown.current) {\n      ignoringMouseDown.current = false;\n      return;\n    }\n\n    if (event.type === 'touchstart') {\n      ignoringMouseDown.current = true;\n    }\n\n    var element = fakeElement ? null : container.current;\n    var rect = element ? element.getBoundingClientRect() : {\n      width: 0,\n      height: 0,\n      left: 0,\n      top: 0\n    }; // Get the size of the ripple\n\n    var rippleX;\n    var rippleY;\n    var rippleSize;\n\n    if (center || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {\n      rippleX = Math.round(rect.width / 2);\n      rippleY = Math.round(rect.height / 2);\n    } else {\n      var _ref = event.touches ? event.touches[0] : event,\n          clientX = _ref.clientX,\n          clientY = _ref.clientY;\n\n      rippleX = Math.round(clientX - rect.left);\n      rippleY = Math.round(clientY - rect.top);\n    }\n\n    if (center) {\n      rippleSize = Math.sqrt((2 * Math.pow(rect.width, 2) + Math.pow(rect.height, 2)) / 3); // For some reason the animation is broken on Mobile Chrome if the size if even.\n\n      if (rippleSize % 2 === 0) {\n        rippleSize += 1;\n      }\n    } else {\n      var sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;\n      var sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;\n      rippleSize = Math.sqrt(Math.pow(sizeX, 2) + Math.pow(sizeY, 2));\n    } // Touche devices\n\n\n    if (event.touches) {\n      // check that this isn't another touchstart due to multitouch\n      // otherwise we will only clear a single timer when unmounting while two\n      // are running\n      if (startTimerCommit.current === null) {\n        // Prepare the ripple effect.\n        startTimerCommit.current = function () {\n          startCommit({\n            pulsate: pulsate,\n            rippleX: rippleX,\n            rippleY: rippleY,\n            rippleSize: rippleSize,\n            cb: cb\n          });\n        }; // Delay the execution of the ripple effect.\n\n\n        startTimer.current = setTimeout(function () {\n          if (startTimerCommit.current) {\n            startTimerCommit.current();\n            startTimerCommit.current = null;\n          }\n        }, DELAY_RIPPLE); // We have to make a tradeoff with this value.\n      }\n    } else {\n      startCommit({\n        pulsate: pulsate,\n        rippleX: rippleX,\n        rippleY: rippleY,\n        rippleSize: rippleSize,\n        cb: cb\n      });\n    }\n  }, [centerProp, startCommit]);\n  var pulsate = react[\"useCallback\"](function () {\n    start({}, {\n      pulsate: true\n    });\n  }, [start]);\n  var stop = react[\"useCallback\"](function (event, cb) {\n    clearTimeout(startTimer.current); // The touch interaction occurs too quickly.\n    // We still want to show ripple effect.\n\n    if (event.type === 'touchend' && startTimerCommit.current) {\n      event.persist();\n      startTimerCommit.current();\n      startTimerCommit.current = null;\n      startTimer.current = setTimeout(function () {\n        stop(event, cb);\n      });\n      return;\n    }\n\n    startTimerCommit.current = null;\n    setRipples(function (oldRipples) {\n      if (oldRipples.length > 0) {\n        return oldRipples.slice(1);\n      }\n\n      return oldRipples;\n    });\n    rippleCallback.current = cb;\n  }, []);\n  react[\"useImperativeHandle\"](ref, function () {\n    return {\n      pulsate: pulsate,\n      start: start,\n      stop: stop\n    };\n  }, [pulsate, start, stop]);\n  return /*#__PURE__*/react[\"createElement\"](\"span\", _extends({\n    className: clsx_m(classes.root, className),\n    ref: container\n  }, other), /*#__PURE__*/react[\"createElement\"](esm_TransitionGroup, {\n    component: null,\n    exit: true\n  }, ripples));\n});\n false ? undefined : void 0;\n/* harmony default export */ var ButtonBase_TouchRipple = (styles_withStyles(TouchRipple_styles, {\n  flip: false,\n  name: 'MuiTouchRipple'\n})( /*#__PURE__*/react[\"memo\"](TouchRipple_TouchRipple)));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/ButtonBase/ButtonBase.js\n\n\n\n\n\n\n\n\n\n\n\n\nvar ButtonBase_styles = {\n  /* Styles applied to the root element. */\n  root: {\n    display: 'inline-flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    position: 'relative',\n    WebkitTapHighlightColor: 'transparent',\n    backgroundColor: 'transparent',\n    // Reset default value\n    // We disable the focus ring for mouse, touch and keyboard users.\n    outline: 0,\n    border: 0,\n    margin: 0,\n    // Remove the margin in Safari\n    borderRadius: 0,\n    padding: 0,\n    // Remove the padding in Firefox\n    cursor: 'pointer',\n    userSelect: 'none',\n    verticalAlign: 'middle',\n    '-moz-appearance': 'none',\n    // Reset\n    '-webkit-appearance': 'none',\n    // Reset\n    textDecoration: 'none',\n    // So we take precedent over the style of a native <a /> element.\n    color: 'inherit',\n    '&::-moz-focus-inner': {\n      borderStyle: 'none' // Remove Firefox dotted outline.\n\n    },\n    '&$disabled': {\n      pointerEvents: 'none',\n      // Disable link interactions\n      cursor: 'default'\n    },\n    '@media print': {\n      colorAdjust: 'exact'\n    }\n  },\n\n  /* Pseudo-class applied to the root element if `disabled={true}`. */\n  disabled: {},\n\n  /* Pseudo-class applied to the root element if keyboard focused. */\n  focusVisible: {}\n};\n/**\n * `ButtonBase` contains as few styles as possible.\n * It aims to be a simple building block for creating a button.\n * It contains a load of style reset and some focus/ripple logic.\n */\n\nvar ButtonBase_ButtonBase = /*#__PURE__*/react[\"forwardRef\"](function ButtonBase(props, ref) {\n  var action = props.action,\n      buttonRefProp = props.buttonRef,\n      _props$centerRipple = props.centerRipple,\n      centerRipple = _props$centerRipple === void 0 ? false : _props$centerRipple,\n      children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      component = _props$component === void 0 ? 'button' : _props$component,\n      _props$disabled = props.disabled,\n      disabled = _props$disabled === void 0 ? false : _props$disabled,\n      _props$disableRipple = props.disableRipple,\n      disableRipple = _props$disableRipple === void 0 ? false : _props$disableRipple,\n      _props$disableTouchRi = props.disableTouchRipple,\n      disableTouchRipple = _props$disableTouchRi === void 0 ? false : _props$disableTouchRi,\n      _props$focusRipple = props.focusRipple,\n      focusRipple = _props$focusRipple === void 0 ? false : _props$focusRipple,\n      focusVisibleClassName = props.focusVisibleClassName,\n      onBlur = props.onBlur,\n      onClick = props.onClick,\n      onFocus = props.onFocus,\n      onFocusVisible = props.onFocusVisible,\n      onKeyDown = props.onKeyDown,\n      onKeyUp = props.onKeyUp,\n      onMouseDown = props.onMouseDown,\n      onMouseLeave = props.onMouseLeave,\n      onMouseUp = props.onMouseUp,\n      onTouchEnd = props.onTouchEnd,\n      onTouchMove = props.onTouchMove,\n      onTouchStart = props.onTouchStart,\n      onDragLeave = props.onDragLeave,\n      _props$tabIndex = props.tabIndex,\n      tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex,\n      TouchRippleProps = props.TouchRippleProps,\n      _props$type = props.type,\n      type = _props$type === void 0 ? 'button' : _props$type,\n      other = _objectWithoutProperties(props, [\"action\", \"buttonRef\", \"centerRipple\", \"children\", \"classes\", \"className\", \"component\", \"disabled\", \"disableRipple\", \"disableTouchRipple\", \"focusRipple\", \"focusVisibleClassName\", \"onBlur\", \"onClick\", \"onFocus\", \"onFocusVisible\", \"onKeyDown\", \"onKeyUp\", \"onMouseDown\", \"onMouseLeave\", \"onMouseUp\", \"onTouchEnd\", \"onTouchMove\", \"onTouchStart\", \"onDragLeave\", \"tabIndex\", \"TouchRippleProps\", \"type\"]);\n\n  var buttonRef = react[\"useRef\"](null);\n\n  function getButtonNode() {\n    // #StrictMode ready\n    return react_dom[\"findDOMNode\"](buttonRef.current);\n  }\n\n  var rippleRef = react[\"useRef\"](null);\n\n  var _React$useState = react[\"useState\"](false),\n      focusVisible = _React$useState[0],\n      setFocusVisible = _React$useState[1];\n\n  if (disabled && focusVisible) {\n    setFocusVisible(false);\n  }\n\n  var _useIsFocusVisible = useIsFocusVisible(),\n      isFocusVisible = _useIsFocusVisible.isFocusVisible,\n      onBlurVisible = _useIsFocusVisible.onBlurVisible,\n      focusVisibleRef = _useIsFocusVisible.ref;\n\n  react[\"useImperativeHandle\"](action, function () {\n    return {\n      focusVisible: function focusVisible() {\n        setFocusVisible(true);\n        buttonRef.current.focus();\n      }\n    };\n  }, []);\n  react[\"useEffect\"](function () {\n    if (focusVisible && focusRipple && !disableRipple) {\n      rippleRef.current.pulsate();\n    }\n  }, [disableRipple, focusRipple, focusVisible]);\n\n  function useRippleHandler(rippleAction, eventCallback) {\n    var skipRippleAction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : disableTouchRipple;\n    return useEventCallback(function (event) {\n      if (eventCallback) {\n        eventCallback(event);\n      }\n\n      var ignore = skipRippleAction;\n\n      if (!ignore && rippleRef.current) {\n        rippleRef.current[rippleAction](event);\n      }\n\n      return true;\n    });\n  }\n\n  var handleMouseDown = useRippleHandler('start', onMouseDown);\n  var handleDragLeave = useRippleHandler('stop', onDragLeave);\n  var handleMouseUp = useRippleHandler('stop', onMouseUp);\n  var handleMouseLeave = useRippleHandler('stop', function (event) {\n    if (focusVisible) {\n      event.preventDefault();\n    }\n\n    if (onMouseLeave) {\n      onMouseLeave(event);\n    }\n  });\n  var handleTouchStart = useRippleHandler('start', onTouchStart);\n  var handleTouchEnd = useRippleHandler('stop', onTouchEnd);\n  var handleTouchMove = useRippleHandler('stop', onTouchMove);\n  var handleBlur = useRippleHandler('stop', function (event) {\n    if (focusVisible) {\n      onBlurVisible(event);\n      setFocusVisible(false);\n    }\n\n    if (onBlur) {\n      onBlur(event);\n    }\n  }, false);\n  var handleFocus = useEventCallback(function (event) {\n    // Fix for https://github.com/facebook/react/issues/7769\n    if (!buttonRef.current) {\n      buttonRef.current = event.currentTarget;\n    }\n\n    if (isFocusVisible(event)) {\n      setFocusVisible(true);\n\n      if (onFocusVisible) {\n        onFocusVisible(event);\n      }\n    }\n\n    if (onFocus) {\n      onFocus(event);\n    }\n  });\n\n  var isNonNativeButton = function isNonNativeButton() {\n    var button = getButtonNode();\n    return component && component !== 'button' && !(button.tagName === 'A' && button.href);\n  };\n  /**\n   * IE 11 shim for https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat\n   */\n\n\n  var keydownRef = react[\"useRef\"](false);\n  var handleKeyDown = useEventCallback(function (event) {\n    // Check if key is already down to avoid repeats being counted as multiple activations\n    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === ' ') {\n      keydownRef.current = true;\n      event.persist();\n      rippleRef.current.stop(event, function () {\n        rippleRef.current.start(event);\n      });\n    }\n\n    if (event.target === event.currentTarget && isNonNativeButton() && event.key === ' ') {\n      event.preventDefault();\n    }\n\n    if (onKeyDown) {\n      onKeyDown(event);\n    } // Keyboard accessibility for non interactive elements\n\n\n    if (event.target === event.currentTarget && isNonNativeButton() && event.key === 'Enter' && !disabled) {\n      event.preventDefault();\n\n      if (onClick) {\n        onClick(event);\n      }\n    }\n  });\n  var handleKeyUp = useEventCallback(function (event) {\n    // calling preventDefault in keyUp on a <button> will not dispatch a click event if Space is pressed\n    // https://codesandbox.io/s/button-keyup-preventdefault-dn7f0\n    if (focusRipple && event.key === ' ' && rippleRef.current && focusVisible && !event.defaultPrevented) {\n      keydownRef.current = false;\n      event.persist();\n      rippleRef.current.stop(event, function () {\n        rippleRef.current.pulsate(event);\n      });\n    }\n\n    if (onKeyUp) {\n      onKeyUp(event);\n    } // Keyboard accessibility for non interactive elements\n\n\n    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === ' ' && !event.defaultPrevented) {\n      onClick(event);\n    }\n  });\n  var ComponentProp = component;\n\n  if (ComponentProp === 'button' && other.href) {\n    ComponentProp = 'a';\n  }\n\n  var buttonProps = {};\n\n  if (ComponentProp === 'button') {\n    buttonProps.type = type;\n    buttonProps.disabled = disabled;\n  } else {\n    if (ComponentProp !== 'a' || !other.href) {\n      buttonProps.role = 'button';\n    }\n\n    buttonProps['aria-disabled'] = disabled;\n  }\n\n  var handleUserRef = useForkRef(buttonRefProp, ref);\n  var handleOwnRef = useForkRef(focusVisibleRef, buttonRef);\n  var handleRef = useForkRef(handleUserRef, handleOwnRef);\n\n  var _React$useState2 = react[\"useState\"](false),\n      mountedState = _React$useState2[0],\n      setMountedState = _React$useState2[1];\n\n  react[\"useEffect\"](function () {\n    setMountedState(true);\n  }, []);\n  var enableTouchRipple = mountedState && !disableRipple && !disabled;\n\n  if (false) {}\n\n  return /*#__PURE__*/react[\"createElement\"](ComponentProp, _extends({\n    className: clsx_m(classes.root, className, focusVisible && [classes.focusVisible, focusVisibleClassName], disabled && classes.disabled),\n    onBlur: handleBlur,\n    onClick: onClick,\n    onFocus: handleFocus,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    onMouseDown: handleMouseDown,\n    onMouseLeave: handleMouseLeave,\n    onMouseUp: handleMouseUp,\n    onDragLeave: handleDragLeave,\n    onTouchEnd: handleTouchEnd,\n    onTouchMove: handleTouchMove,\n    onTouchStart: handleTouchStart,\n    ref: handleRef,\n    tabIndex: disabled ? -1 : tabIndex\n  }, buttonProps, other), children, enableTouchRipple ?\n  /*#__PURE__*/\n\n  /* TouchRipple is only needed client-side, x2 boost on the server. */\n  react[\"createElement\"](ButtonBase_TouchRipple, _extends({\n    ref: rippleRef,\n    center: centerRipple\n  }, TouchRippleProps)) : null);\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_ButtonBase_ButtonBase = (styles_withStyles(ButtonBase_styles, {\n  name: 'MuiButtonBase'\n})(ButtonBase_ButtonBase));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/isMuiElement.js\n\nfunction isMuiElement(element, muiNames) {\n  return /*#__PURE__*/react[\"isValidElement\"](element) && muiNames.indexOf(element.type.muiName) !== -1;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/ListItem/ListItem.js\n\n\n\n\n\n\n\n\n\n\n\n\nvar ListItem_styles = function styles(theme) {\n  return {\n    /* Styles applied to the (normally root) `component` element. May be wrapped by a `container`. */\n    root: {\n      display: 'flex',\n      justifyContent: 'flex-start',\n      alignItems: 'center',\n      position: 'relative',\n      textDecoration: 'none',\n      width: '100%',\n      boxSizing: 'border-box',\n      textAlign: 'left',\n      paddingTop: 8,\n      paddingBottom: 8,\n      '&$focusVisible': {\n        backgroundColor: theme.palette.action.selected\n      },\n      '&$selected, &$selected:hover': {\n        backgroundColor: theme.palette.action.selected\n      },\n      '&$disabled': {\n        opacity: 0.5\n      }\n    },\n\n    /* Styles applied to the `container` element if `children` includes `ListItemSecondaryAction`. */\n    container: {\n      position: 'relative'\n    },\n\n    /* Pseudo-class applied to the `component`'s `focusVisibleClassName` prop if `button={true}`. */\n    focusVisible: {},\n\n    /* Styles applied to the `component` element if dense. */\n    dense: {\n      paddingTop: 4,\n      paddingBottom: 4\n    },\n\n    /* Styles applied to the `component` element if `alignItems=\"flex-start\"`. */\n    alignItemsFlexStart: {\n      alignItems: 'flex-start'\n    },\n\n    /* Pseudo-class applied to the inner `component` element if `disabled={true}`. */\n    disabled: {},\n\n    /* Styles applied to the inner `component` element if `divider={true}`. */\n    divider: {\n      borderBottom: \"1px solid \".concat(theme.palette.divider),\n      backgroundClip: 'padding-box'\n    },\n\n    /* Styles applied to the inner `component` element if `disableGutters={false}`. */\n    gutters: {\n      paddingLeft: 16,\n      paddingRight: 16\n    },\n\n    /* Styles applied to the inner `component` element if `button={true}`. */\n    button: {\n      transition: theme.transitions.create('background-color', {\n        duration: theme.transitions.duration.shortest\n      }),\n      '&:hover': {\n        textDecoration: 'none',\n        backgroundColor: theme.palette.action.hover,\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: 'transparent'\n        }\n      }\n    },\n\n    /* Styles applied to the `component` element if `children` includes `ListItemSecondaryAction`. */\n    secondaryAction: {\n      // Add some space to avoid collision as `ListItemSecondaryAction`\n      // is absolutely positioned.\n      paddingRight: 48\n    },\n\n    /* Pseudo-class applied to the root element if `selected={true}`. */\n    selected: {}\n  };\n};\nvar ListItem_useEnhancedEffect = typeof window === 'undefined' ? react[\"useEffect\"] : react[\"useLayoutEffect\"];\n/**\n * Uses an additional container component if `ListItemSecondaryAction` is the last child.\n */\n\nvar ListItem_ListItem = /*#__PURE__*/react[\"forwardRef\"](function ListItem(props, ref) {\n  var _props$alignItems = props.alignItems,\n      alignItems = _props$alignItems === void 0 ? 'center' : _props$alignItems,\n      _props$autoFocus = props.autoFocus,\n      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,\n      _props$button = props.button,\n      button = _props$button === void 0 ? false : _props$button,\n      childrenProp = props.children,\n      classes = props.classes,\n      className = props.className,\n      componentProp = props.component,\n      _props$ContainerCompo = props.ContainerComponent,\n      ContainerComponent = _props$ContainerCompo === void 0 ? 'li' : _props$ContainerCompo,\n      _props$ContainerProps = props.ContainerProps;\n  _props$ContainerProps = _props$ContainerProps === void 0 ? {} : _props$ContainerProps;\n\n  var ContainerClassName = _props$ContainerProps.className,\n      ContainerProps = _objectWithoutProperties(_props$ContainerProps, [\"className\"]),\n      _props$dense = props.dense,\n      dense = _props$dense === void 0 ? false : _props$dense,\n      _props$disabled = props.disabled,\n      disabled = _props$disabled === void 0 ? false : _props$disabled,\n      _props$disableGutters = props.disableGutters,\n      disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters,\n      _props$divider = props.divider,\n      divider = _props$divider === void 0 ? false : _props$divider,\n      focusVisibleClassName = props.focusVisibleClassName,\n      _props$selected = props.selected,\n      selected = _props$selected === void 0 ? false : _props$selected,\n      other = _objectWithoutProperties(props, [\"alignItems\", \"autoFocus\", \"button\", \"children\", \"classes\", \"className\", \"component\", \"ContainerComponent\", \"ContainerProps\", \"dense\", \"disabled\", \"disableGutters\", \"divider\", \"focusVisibleClassName\", \"selected\"]);\n\n  var context = react[\"useContext\"](List_ListContext);\n  var childContext = {\n    dense: dense || context.dense || false,\n    alignItems: alignItems\n  };\n  var listItemRef = react[\"useRef\"](null);\n  ListItem_useEnhancedEffect(function () {\n    if (autoFocus) {\n      if (listItemRef.current) {\n        listItemRef.current.focus();\n      } else if (false) {}\n    }\n  }, [autoFocus]);\n  var children = react[\"Children\"].toArray(childrenProp);\n  var hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ['ListItemSecondaryAction']);\n  var handleOwnRef = react[\"useCallback\"](function (instance) {\n    // #StrictMode ready\n    listItemRef.current = react_dom[\"findDOMNode\"](instance);\n  }, []);\n  var handleRef = useForkRef(handleOwnRef, ref);\n\n  var componentProps = _extends({\n    className: clsx_m(classes.root, className, childContext.dense && classes.dense, !disableGutters && classes.gutters, divider && classes.divider, disabled && classes.disabled, button && classes.button, alignItems !== \"center\" && classes.alignItemsFlexStart, hasSecondaryAction && classes.secondaryAction, selected && classes.selected),\n    disabled: disabled\n  }, other);\n\n  var Component = componentProp || 'li';\n\n  if (button) {\n    componentProps.component = componentProp || 'div';\n    componentProps.focusVisibleClassName = clsx_m(classes.focusVisible, focusVisibleClassName);\n    Component = esm_ButtonBase_ButtonBase;\n  }\n\n  if (hasSecondaryAction) {\n    // Use div by default.\n    Component = !componentProps.component && !componentProp ? 'div' : Component; // Avoid nesting of li > li.\n\n    if (ContainerComponent === 'li') {\n      if (Component === 'li') {\n        Component = 'div';\n      } else if (componentProps.component === 'li') {\n        componentProps.component = 'div';\n      }\n    }\n\n    return /*#__PURE__*/react[\"createElement\"](List_ListContext.Provider, {\n      value: childContext\n    }, /*#__PURE__*/react[\"createElement\"](ContainerComponent, _extends({\n      className: clsx_m(classes.container, ContainerClassName),\n      ref: handleRef\n    }, ContainerProps), /*#__PURE__*/react[\"createElement\"](Component, componentProps, children), children.pop()));\n  }\n\n  return /*#__PURE__*/react[\"createElement\"](List_ListContext.Provider, {\n    value: childContext\n  }, /*#__PURE__*/react[\"createElement\"](Component, _extends({\n    ref: handleRef\n  }, componentProps), children));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_ListItem_ListItem = (styles_withStyles(ListItem_styles, {\n  name: 'MuiListItem'\n})(ListItem_ListItem));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/ListItemText/ListItemText.js\n\n\n\n\n\n\n\n\nvar ListItemText_styles = {\n  /* Styles applied to the root element. */\n  root: {\n    flex: '1 1 auto',\n    minWidth: 0,\n    marginTop: 4,\n    marginBottom: 4\n  },\n\n  /* Styles applied to the `Typography` components if primary and secondary are set. */\n  multiline: {\n    marginTop: 6,\n    marginBottom: 6\n  },\n\n  /* Styles applied to the `Typography` components if dense. */\n  dense: {},\n\n  /* Styles applied to the root element if `inset={true}`. */\n  inset: {\n    paddingLeft: 56\n  },\n\n  /* Styles applied to the primary `Typography` component. */\n  primary: {},\n\n  /* Styles applied to the secondary `Typography` component. */\n  secondary: {}\n};\nvar ListItemText_ListItemText = /*#__PURE__*/react[\"forwardRef\"](function ListItemText(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$disableTypogra = props.disableTypography,\n      disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra,\n      _props$inset = props.inset,\n      inset = _props$inset === void 0 ? false : _props$inset,\n      primaryProp = props.primary,\n      primaryTypographyProps = props.primaryTypographyProps,\n      secondaryProp = props.secondary,\n      secondaryTypographyProps = props.secondaryTypographyProps,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"disableTypography\", \"inset\", \"primary\", \"primaryTypographyProps\", \"secondary\", \"secondaryTypographyProps\"]);\n\n  var _React$useContext = react[\"useContext\"](List_ListContext),\n      dense = _React$useContext.dense;\n\n  var primary = primaryProp != null ? primaryProp : children;\n\n  if (primary != null && primary.type !== esm_Typography_Typography && !disableTypography) {\n    primary = /*#__PURE__*/react[\"createElement\"](esm_Typography_Typography, _extends({\n      variant: dense ? 'body2' : 'body1',\n      className: classes.primary,\n      component: \"span\",\n      display: \"block\"\n    }, primaryTypographyProps), primary);\n  }\n\n  var secondary = secondaryProp;\n\n  if (secondary != null && secondary.type !== esm_Typography_Typography && !disableTypography) {\n    secondary = /*#__PURE__*/react[\"createElement\"](esm_Typography_Typography, _extends({\n      variant: \"body2\",\n      className: classes.secondary,\n      color: \"textSecondary\",\n      display: \"block\"\n    }, secondaryTypographyProps), secondary);\n  }\n\n  return /*#__PURE__*/react[\"createElement\"](\"div\", _extends({\n    className: clsx_m(classes.root, className, dense && classes.dense, inset && classes.inset, primary && secondary && classes.multiline),\n    ref: ref\n  }, other), primary, secondary);\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_ListItemText_ListItemText = (styles_withStyles(ListItemText_styles, {\n  name: 'MuiListItemText'\n})(ListItemText_ListItemText));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Divider/Divider.js\n\n\n\n\n\n\n\nvar Divider_styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      height: 1,\n      margin: 0,\n      // Reset browser default style.\n      border: 'none',\n      flexShrink: 0,\n      backgroundColor: theme.palette.divider\n    },\n\n    /* Styles applied to the root element if `absolute={true}`. */\n    absolute: {\n      position: 'absolute',\n      bottom: 0,\n      left: 0,\n      width: '100%'\n    },\n\n    /* Styles applied to the root element if `variant=\"inset\"`. */\n    inset: {\n      marginLeft: 72\n    },\n\n    /* Styles applied to the root element if `light={true}`. */\n    light: {\n      backgroundColor: fade(theme.palette.divider, 0.08)\n    },\n\n    /* Styles applied to the root element if `variant=\"middle\"`. */\n    middle: {\n      marginLeft: theme.spacing(2),\n      marginRight: theme.spacing(2)\n    },\n\n    /* Styles applied to the root element if `orientation=\"vertical\"`. */\n    vertical: {\n      height: '100%',\n      width: 1\n    },\n\n    /* Styles applied to the root element if `flexItem={true}`. */\n    flexItem: {\n      alignSelf: 'stretch',\n      height: 'auto'\n    }\n  };\n};\nvar Divider_Divider = /*#__PURE__*/react[\"forwardRef\"](function Divider(props, ref) {\n  var _props$absolute = props.absolute,\n      absolute = _props$absolute === void 0 ? false : _props$absolute,\n      classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'hr' : _props$component,\n      _props$flexItem = props.flexItem,\n      flexItem = _props$flexItem === void 0 ? false : _props$flexItem,\n      _props$light = props.light,\n      light = _props$light === void 0 ? false : _props$light,\n      _props$orientation = props.orientation,\n      orientation = _props$orientation === void 0 ? 'horizontal' : _props$orientation,\n      _props$role = props.role,\n      role = _props$role === void 0 ? Component !== 'hr' ? 'separator' : undefined : _props$role,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'fullWidth' : _props$variant,\n      other = _objectWithoutProperties(props, [\"absolute\", \"classes\", \"className\", \"component\", \"flexItem\", \"light\", \"orientation\", \"role\", \"variant\"]);\n\n  return /*#__PURE__*/react[\"createElement\"](Component, _extends({\n    className: clsx_m(classes.root, className, variant !== 'fullWidth' && classes[variant], absolute && classes.absolute, flexItem && classes.flexItem, light && classes.light, orientation === 'vertical' && classes.vertical),\n    role: role,\n    ref: ref\n  }, other));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_Divider_Divider = (styles_withStyles(Divider_styles, {\n  name: 'MuiDivider'\n})(Divider_Divider));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/ListItemIcon/ListItemIcon.js\n\n\n\n\n\n\n\nvar ListItemIcon_styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      minWidth: 56,\n      color: theme.palette.action.active,\n      flexShrink: 0,\n      display: 'inline-flex'\n    },\n\n    /* Styles applied to the root element when the parent `ListItem` uses `alignItems=\"flex-start\"`. */\n    alignItemsFlexStart: {\n      marginTop: 8\n    }\n  };\n};\n/**\n * A simple wrapper to apply `List` styles to an `Icon` or `SvgIcon`.\n */\n\nvar ListItemIcon_ListItemIcon = /*#__PURE__*/react[\"forwardRef\"](function ListItemIcon(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      other = _objectWithoutProperties(props, [\"classes\", \"className\"]);\n\n  var context = react[\"useContext\"](List_ListContext);\n  return /*#__PURE__*/react[\"createElement\"](\"div\", _extends({\n    className: clsx_m(classes.root, className, context.alignItems === 'flex-start' && classes.alignItemsFlexStart),\n    ref: ref\n  }, other));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_ListItemIcon_ListItemIcon = (styles_withStyles(ListItemIcon_styles, {\n  name: 'MuiListItemIcon'\n})(ListItemIcon_ListItemIcon));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/FormControl/formControlState.js\nfunction formControlState(_ref) {\n  var props = _ref.props,\n      states = _ref.states,\n      muiFormControl = _ref.muiFormControl;\n  return states.reduce(function (acc, state) {\n    acc[state] = props[state];\n\n    if (muiFormControl) {\n      if (typeof props[state] === 'undefined') {\n        acc[state] = muiFormControl[state];\n      }\n    }\n\n    return acc;\n  }, {});\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/FormControl/FormControlContext.js\n\n/**\n * @ignore - internal component.\n */\n\nvar FormControlContext = react[\"createContext\"]();\n\nif (false) {}\n\nfunction useFormControl() {\n  return react[\"useContext\"](FormControlContext);\n}\n/* harmony default export */ var FormControl_FormControlContext = (FormControlContext);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/debounce.js\n// Corresponds to 10 frames at 60 Hz.\n// A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.\nfunction debounce(func) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 166;\n  var timeout;\n\n  function debounced() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // eslint-disable-next-line consistent-this\n    var that = this;\n\n    var later = function later() {\n      func.apply(that, args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  }\n\n  debounced.clear = function () {\n    clearTimeout(timeout);\n  };\n\n  return debounced;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/TextareaAutosize/TextareaAutosize.js\n\n\n\n\n\n\n\nfunction getStyleValue(computedStyle, property) {\n  return parseInt(computedStyle[property], 10) || 0;\n}\n\nvar TextareaAutosize_useEnhancedEffect = typeof window !== 'undefined' ? react[\"useLayoutEffect\"] : react[\"useEffect\"];\nvar TextareaAutosize_styles = {\n  /* Styles applied to the shadow textarea element. */\n  shadow: {\n    // Visibility needed to hide the extra text area on iPads\n    visibility: 'hidden',\n    // Remove from the content flow\n    position: 'absolute',\n    // Ignore the scrollbar width\n    overflow: 'hidden',\n    height: 0,\n    top: 0,\n    left: 0,\n    // Create a new layer, increase the isolation of the computed values\n    transform: 'translateZ(0)'\n  }\n};\nvar TextareaAutosize_TextareaAutosize = /*#__PURE__*/react[\"forwardRef\"](function TextareaAutosize(props, ref) {\n  var onChange = props.onChange,\n      rows = props.rows,\n      rowsMax = props.rowsMax,\n      _props$rowsMin = props.rowsMin,\n      rowsMinProp = _props$rowsMin === void 0 ? 1 : _props$rowsMin,\n      style = props.style,\n      value = props.value,\n      other = _objectWithoutProperties(props, [\"onChange\", \"rows\", \"rowsMax\", \"rowsMin\", \"style\", \"value\"]);\n\n  var rowsMin = rows || rowsMinProp;\n\n  var _React$useRef = react[\"useRef\"](value != null),\n      isControlled = _React$useRef.current;\n\n  var inputRef = react[\"useRef\"](null);\n  var handleRef = useForkRef(ref, inputRef);\n  var shadowRef = react[\"useRef\"](null);\n  var renders = react[\"useRef\"](0);\n\n  var _React$useState = react[\"useState\"]({}),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  var syncHeight = react[\"useCallback\"](function () {\n    var input = inputRef.current;\n    var computedStyle = window.getComputedStyle(input);\n    var inputShallow = shadowRef.current;\n    inputShallow.style.width = computedStyle.width;\n    inputShallow.value = input.value || props.placeholder || 'x';\n\n    if (inputShallow.value.slice(-1) === '\\n') {\n      // Certain fonts which overflow the line height will cause the textarea\n      // to report a different scrollHeight depending on whether the last line\n      // is empty. Make it non-empty to avoid this issue.\n      inputShallow.value += ' ';\n    }\n\n    var boxSizing = computedStyle['box-sizing'];\n    var padding = getStyleValue(computedStyle, 'padding-bottom') + getStyleValue(computedStyle, 'padding-top');\n    var border = getStyleValue(computedStyle, 'border-bottom-width') + getStyleValue(computedStyle, 'border-top-width'); // The height of the inner content\n\n    var innerHeight = inputShallow.scrollHeight - padding; // Measure height of a textarea with a single row\n\n    inputShallow.value = 'x';\n    var singleRowHeight = inputShallow.scrollHeight - padding; // The height of the outer content\n\n    var outerHeight = innerHeight;\n\n    if (rowsMin) {\n      outerHeight = Math.max(Number(rowsMin) * singleRowHeight, outerHeight);\n    }\n\n    if (rowsMax) {\n      outerHeight = Math.min(Number(rowsMax) * singleRowHeight, outerHeight);\n    }\n\n    outerHeight = Math.max(outerHeight, singleRowHeight); // Take the box sizing into account for applying this value as a style.\n\n    var outerHeightStyle = outerHeight + (boxSizing === 'border-box' ? padding + border : 0);\n    var overflow = Math.abs(outerHeight - innerHeight) <= 1;\n    setState(function (prevState) {\n      // Need a large enough difference to update the height.\n      // This prevents infinite rendering loop.\n      if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {\n        renders.current += 1;\n        return {\n          overflow: overflow,\n          outerHeightStyle: outerHeightStyle\n        };\n      }\n\n      if (false) {}\n\n      return prevState;\n    });\n  }, [rowsMax, rowsMin, props.placeholder]);\n  react[\"useEffect\"](function () {\n    var handleResize = debounce(function () {\n      renders.current = 0;\n      syncHeight();\n    });\n    window.addEventListener('resize', handleResize);\n    return function () {\n      handleResize.clear();\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [syncHeight]);\n  TextareaAutosize_useEnhancedEffect(function () {\n    syncHeight();\n  });\n  react[\"useEffect\"](function () {\n    renders.current = 0;\n  }, [value]);\n\n  var handleChange = function handleChange(event) {\n    renders.current = 0;\n\n    if (!isControlled) {\n      syncHeight();\n    }\n\n    if (onChange) {\n      onChange(event);\n    }\n  };\n\n  return /*#__PURE__*/react[\"createElement\"](react[\"Fragment\"], null, /*#__PURE__*/react[\"createElement\"](\"textarea\", _extends({\n    value: value,\n    onChange: handleChange,\n    ref: handleRef // Apply the rows prop to get a \"correct\" first SSR paint\n    ,\n    rows: rowsMin,\n    style: _extends({\n      height: state.outerHeightStyle,\n      // Need a large enough difference to allow scrolling.\n      // This prevents infinite rendering loop.\n      overflow: state.overflow ? 'hidden' : null\n    }, style)\n  }, other)), /*#__PURE__*/react[\"createElement\"](\"textarea\", {\n    \"aria-hidden\": true,\n    className: props.className,\n    readOnly: true,\n    ref: shadowRef,\n    tabIndex: -1,\n    style: _extends({}, TextareaAutosize_styles.shadow, style)\n  }));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_TextareaAutosize_TextareaAutosize = (TextareaAutosize_TextareaAutosize);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/InputBase/utils.js\n// Supports determination of isControlled().\n// Controlled input accepts its current value as a prop.\n//\n// @see https://facebook.github.io/react/docs/forms.html#controlled-components\n// @param value\n// @returns {boolean} true if string (including '') or number (including zero)\nfunction hasValue(value) {\n  return value != null && !(Array.isArray(value) && value.length === 0);\n} // Determine if field is empty or filled.\n// Response determines if label is presented above field or as placeholder.\n//\n// @param obj\n// @param SSR\n// @returns {boolean} False when not present or empty string.\n//                    True when any number or string with length.\n\nfunction isFilled(obj) {\n  var SSR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return obj && (hasValue(obj.value) && obj.value !== '' || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== '');\n} // Determine if an Input is adorned on start.\n// It's corresponding to the left with LTR.\n//\n// @param obj\n// @returns {boolean} False when no adornments.\n//                    True when adorned at the start.\n\nfunction isAdornedStart(obj) {\n  return obj.startAdornment;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/InputBase/InputBase.js\n\n\n\n\n/* eslint-disable jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions */\n\n\n\n\n\n\n\n\n\n\n\nvar InputBase_styles = function styles(theme) {\n  var light = theme.palette.type === 'light';\n  var placeholder = {\n    color: 'currentColor',\n    opacity: light ? 0.42 : 0.5,\n    transition: theme.transitions.create('opacity', {\n      duration: theme.transitions.duration.shorter\n    })\n  };\n  var placeholderHidden = {\n    opacity: '0 !important'\n  };\n  var placeholderVisible = {\n    opacity: light ? 0.42 : 0.5\n  };\n  return {\n    '@global': {\n      '@keyframes mui-auto-fill': {},\n      '@keyframes mui-auto-fill-cancel': {}\n    },\n\n    /* Styles applied to the root element. */\n    root: _extends({}, theme.typography.body1, {\n      color: theme.palette.text.primary,\n      lineHeight: '1.1876em',\n      // Reset (19px), match the native input line-height\n      boxSizing: 'border-box',\n      // Prevent padding issue with fullWidth.\n      position: 'relative',\n      cursor: 'text',\n      display: 'inline-flex',\n      alignItems: 'center',\n      '&$disabled': {\n        color: theme.palette.text.disabled,\n        cursor: 'default'\n      }\n    }),\n\n    /* Styles applied to the root element if the component is a descendant of `FormControl`. */\n    formControl: {},\n\n    /* Styles applied to the root element if the component is focused. */\n    focused: {},\n\n    /* Styles applied to the root element if `disabled={true}`. */\n    disabled: {},\n\n    /* Styles applied to the root element if `startAdornment` is provided. */\n    adornedStart: {},\n\n    /* Styles applied to the root element if `endAdornment` is provided. */\n    adornedEnd: {},\n\n    /* Pseudo-class applied to the root element if `error={true}`. */\n    error: {},\n\n    /* Styles applied to the `input` element if `margin=\"dense\"`. */\n    marginDense: {},\n\n    /* Styles applied to the root element if `multiline={true}`. */\n    multiline: {\n      padding: \"\".concat(8 - 2, \"px 0 \").concat(8 - 1, \"px\"),\n      '&$marginDense': {\n        paddingTop: 4 - 1\n      }\n    },\n\n    /* Styles applied to the root element if the color is secondary. */\n    colorSecondary: {},\n\n    /* Styles applied to the root element if `fullWidth={true}`. */\n    fullWidth: {\n      width: '100%'\n    },\n\n    /* Styles applied to the `input` element. */\n    input: {\n      font: 'inherit',\n      letterSpacing: 'inherit',\n      color: 'currentColor',\n      padding: \"\".concat(8 - 2, \"px 0 \").concat(8 - 1, \"px\"),\n      border: 0,\n      boxSizing: 'content-box',\n      background: 'none',\n      height: '1.1876em',\n      // Reset (19px), match the native input line-height\n      margin: 0,\n      // Reset for Safari\n      WebkitTapHighlightColor: 'transparent',\n      display: 'block',\n      // Make the flex item shrink with Firefox\n      minWidth: 0,\n      width: '100%',\n      // Fix IE 11 width issue\n      animationName: 'mui-auto-fill-cancel',\n      animationDuration: '10ms',\n      '&::-webkit-input-placeholder': placeholder,\n      '&::-moz-placeholder': placeholder,\n      // Firefox 19+\n      '&:-ms-input-placeholder': placeholder,\n      // IE 11\n      '&::-ms-input-placeholder': placeholder,\n      // Edge\n      '&:focus': {\n        outline: 0\n      },\n      // Reset Firefox invalid required input style\n      '&:invalid': {\n        boxShadow: 'none'\n      },\n      '&::-webkit-search-decoration': {\n        // Remove the padding when type=search.\n        '-webkit-appearance': 'none'\n      },\n      // Show and hide the placeholder logic\n      'label[data-shrink=false] + $formControl &': {\n        '&::-webkit-input-placeholder': placeholderHidden,\n        '&::-moz-placeholder': placeholderHidden,\n        // Firefox 19+\n        '&:-ms-input-placeholder': placeholderHidden,\n        // IE 11\n        '&::-ms-input-placeholder': placeholderHidden,\n        // Edge\n        '&:focus::-webkit-input-placeholder': placeholderVisible,\n        '&:focus::-moz-placeholder': placeholderVisible,\n        // Firefox 19+\n        '&:focus:-ms-input-placeholder': placeholderVisible,\n        // IE 11\n        '&:focus::-ms-input-placeholder': placeholderVisible // Edge\n\n      },\n      '&$disabled': {\n        opacity: 1 // Reset iOS opacity\n\n      },\n      '&:-webkit-autofill': {\n        animationDuration: '5000s',\n        animationName: 'mui-auto-fill'\n      }\n    },\n\n    /* Styles applied to the `input` element if `margin=\"dense\"`. */\n    inputMarginDense: {\n      paddingTop: 4 - 1\n    },\n\n    /* Styles applied to the `input` element if `multiline={true}`. */\n    inputMultiline: {\n      height: 'auto',\n      resize: 'none',\n      padding: 0\n    },\n\n    /* Styles applied to the `input` element if `type=\"search\"`. */\n    inputTypeSearch: {\n      // Improve type search style.\n      '-moz-appearance': 'textfield',\n      '-webkit-appearance': 'textfield'\n    },\n\n    /* Styles applied to the `input` element if `startAdornment` is provided. */\n    inputAdornedStart: {},\n\n    /* Styles applied to the `input` element if `endAdornment` is provided. */\n    inputAdornedEnd: {},\n\n    /* Styles applied to the `input` element if `hiddenLabel={true}`. */\n    inputHiddenLabel: {}\n  };\n};\nvar InputBase_useEnhancedEffect = typeof window === 'undefined' ? react[\"useEffect\"] : react[\"useLayoutEffect\"];\n/**\n * `InputBase` contains as few styles as possible.\n * It aims to be a simple building block for creating an input.\n * It contains a load of style reset and some state logic.\n */\n\nvar InputBase_InputBase = /*#__PURE__*/react[\"forwardRef\"](function InputBase(props, ref) {\n  var ariaDescribedby = props['aria-describedby'],\n      autoComplete = props.autoComplete,\n      autoFocus = props.autoFocus,\n      classes = props.classes,\n      className = props.className,\n      color = props.color,\n      defaultValue = props.defaultValue,\n      disabled = props.disabled,\n      endAdornment = props.endAdornment,\n      error = props.error,\n      _props$fullWidth = props.fullWidth,\n      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,\n      id = props.id,\n      _props$inputComponent = props.inputComponent,\n      inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,\n      _props$inputProps = props.inputProps,\n      inputPropsProp = _props$inputProps === void 0 ? {} : _props$inputProps,\n      inputRefProp = props.inputRef,\n      margin = props.margin,\n      _props$multiline = props.multiline,\n      multiline = _props$multiline === void 0 ? false : _props$multiline,\n      name = props.name,\n      onBlur = props.onBlur,\n      onChange = props.onChange,\n      onClick = props.onClick,\n      onFocus = props.onFocus,\n      onKeyDown = props.onKeyDown,\n      onKeyUp = props.onKeyUp,\n      placeholder = props.placeholder,\n      readOnly = props.readOnly,\n      renderSuffix = props.renderSuffix,\n      rows = props.rows,\n      rowsMax = props.rowsMax,\n      rowsMin = props.rowsMin,\n      startAdornment = props.startAdornment,\n      _props$type = props.type,\n      type = _props$type === void 0 ? 'text' : _props$type,\n      valueProp = props.value,\n      other = _objectWithoutProperties(props, [\"aria-describedby\", \"autoComplete\", \"autoFocus\", \"classes\", \"className\", \"color\", \"defaultValue\", \"disabled\", \"endAdornment\", \"error\", \"fullWidth\", \"id\", \"inputComponent\", \"inputProps\", \"inputRef\", \"margin\", \"multiline\", \"name\", \"onBlur\", \"onChange\", \"onClick\", \"onFocus\", \"onKeyDown\", \"onKeyUp\", \"placeholder\", \"readOnly\", \"renderSuffix\", \"rows\", \"rowsMax\", \"rowsMin\", \"startAdornment\", \"type\", \"value\"]);\n\n  var value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;\n\n  var _React$useRef = react[\"useRef\"](value != null),\n      isControlled = _React$useRef.current;\n\n  var inputRef = react[\"useRef\"]();\n  var handleInputRefWarning = react[\"useCallback\"](function (instance) {\n    if (false) {}\n  }, []);\n  var handleInputPropsRefProp = useForkRef(inputPropsProp.ref, handleInputRefWarning);\n  var handleInputRefProp = useForkRef(inputRefProp, handleInputPropsRefProp);\n  var handleInputRef = useForkRef(inputRef, handleInputRefProp);\n\n  var _React$useState = react[\"useState\"](false),\n      focused = _React$useState[0],\n      setFocused = _React$useState[1];\n\n  var muiFormControl = useFormControl();\n\n  if (false) {}\n\n  var fcs = formControlState({\n    props: props,\n    muiFormControl: muiFormControl,\n    states: ['color', 'disabled', 'error', 'hiddenLabel', 'margin', 'required', 'filled']\n  });\n  fcs.focused = muiFormControl ? muiFormControl.focused : focused; // The blur won't fire when the disabled state is set on a focused input.\n  // We need to book keep the focused state manually.\n\n  react[\"useEffect\"](function () {\n    if (!muiFormControl && disabled && focused) {\n      setFocused(false);\n\n      if (onBlur) {\n        onBlur();\n      }\n    }\n  }, [muiFormControl, disabled, focused, onBlur]);\n  var onFilled = muiFormControl && muiFormControl.onFilled;\n  var onEmpty = muiFormControl && muiFormControl.onEmpty;\n  var checkDirty = react[\"useCallback\"](function (obj) {\n    if (isFilled(obj)) {\n      if (onFilled) {\n        onFilled();\n      }\n    } else if (onEmpty) {\n      onEmpty();\n    }\n  }, [onFilled, onEmpty]);\n  InputBase_useEnhancedEffect(function () {\n    if (isControlled) {\n      checkDirty({\n        value: value\n      });\n    }\n  }, [value, checkDirty, isControlled]);\n\n  var handleFocus = function handleFocus(event) {\n    // Fix a bug with IE 11 where the focus/blur events are triggered\n    // while the input is disabled.\n    if (fcs.disabled) {\n      event.stopPropagation();\n      return;\n    }\n\n    if (onFocus) {\n      onFocus(event);\n    }\n\n    if (inputPropsProp.onFocus) {\n      inputPropsProp.onFocus(event);\n    }\n\n    if (muiFormControl && muiFormControl.onFocus) {\n      muiFormControl.onFocus(event);\n    } else {\n      setFocused(true);\n    }\n  };\n\n  var handleBlur = function handleBlur(event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n\n    if (inputPropsProp.onBlur) {\n      inputPropsProp.onBlur(event);\n    }\n\n    if (muiFormControl && muiFormControl.onBlur) {\n      muiFormControl.onBlur(event);\n    } else {\n      setFocused(false);\n    }\n  };\n\n  var handleChange = function handleChange(event) {\n    if (!isControlled) {\n      var element = event.target || inputRef.current;\n\n      if (element == null) {\n        throw new Error( false ? undefined : formatMuiErrorMessage(1));\n      }\n\n      checkDirty({\n        value: element.value\n      });\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (inputPropsProp.onChange) {\n      inputPropsProp.onChange.apply(inputPropsProp, [event].concat(args));\n    } // Perform in the willUpdate\n\n\n    if (onChange) {\n      onChange.apply(void 0, [event].concat(args));\n    }\n  }; // Check the input state on mount, in case it was filled by the user\n  // or auto filled by the browser before the hydration (for SSR).\n\n\n  react[\"useEffect\"](function () {\n    checkDirty(inputRef.current);\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  var handleClick = function handleClick(event) {\n    if (inputRef.current && event.currentTarget === event.target) {\n      inputRef.current.focus();\n    }\n\n    if (onClick) {\n      onClick(event);\n    }\n  };\n\n  var InputComponent = inputComponent;\n\n  var inputProps = _extends({}, inputPropsProp, {\n    ref: handleInputRef\n  });\n\n  if (typeof InputComponent !== 'string') {\n    inputProps = _extends({\n      // Rename ref to inputRef as we don't know the\n      // provided `inputComponent` structure.\n      inputRef: handleInputRef,\n      type: type\n    }, inputProps, {\n      ref: null\n    });\n  } else if (multiline) {\n    if (rows && !rowsMax && !rowsMin) {\n      InputComponent = 'textarea';\n    } else {\n      inputProps = _extends({\n        rows: rows,\n        rowsMax: rowsMax\n      }, inputProps);\n      InputComponent = esm_TextareaAutosize_TextareaAutosize;\n    }\n  } else {\n    inputProps = _extends({\n      type: type\n    }, inputProps);\n  }\n\n  var handleAutoFill = function handleAutoFill(event) {\n    // Provide a fake value as Chrome might not let you access it for security reasons.\n    checkDirty(event.animationName === 'mui-auto-fill-cancel' ? inputRef.current : {\n      value: 'x'\n    });\n  };\n\n  react[\"useEffect\"](function () {\n    if (muiFormControl) {\n      muiFormControl.setAdornedStart(Boolean(startAdornment));\n    }\n  }, [muiFormControl, startAdornment]);\n  return /*#__PURE__*/react[\"createElement\"](\"div\", _extends({\n    className: clsx_m(classes.root, classes[\"color\".concat(capitalize(fcs.color || 'primary'))], className, fcs.disabled && classes.disabled, fcs.error && classes.error, fullWidth && classes.fullWidth, fcs.focused && classes.focused, muiFormControl && classes.formControl, multiline && classes.multiline, startAdornment && classes.adornedStart, endAdornment && classes.adornedEnd, fcs.margin === 'dense' && classes.marginDense),\n    onClick: handleClick,\n    ref: ref\n  }, other), startAdornment, /*#__PURE__*/react[\"createElement\"](FormControl_FormControlContext.Provider, {\n    value: null\n  }, /*#__PURE__*/react[\"createElement\"](InputComponent, _extends({\n    \"aria-invalid\": fcs.error,\n    \"aria-describedby\": ariaDescribedby,\n    autoComplete: autoComplete,\n    autoFocus: autoFocus,\n    defaultValue: defaultValue,\n    disabled: fcs.disabled,\n    id: id,\n    onAnimationStart: handleAutoFill,\n    name: name,\n    placeholder: placeholder,\n    readOnly: readOnly,\n    required: fcs.required,\n    rows: rows,\n    value: value,\n    onKeyDown: onKeyDown,\n    onKeyUp: onKeyUp\n  }, inputProps, {\n    className: clsx_m(classes.input, inputPropsProp.className, fcs.disabled && classes.disabled, multiline && classes.inputMultiline, fcs.hiddenLabel && classes.inputHiddenLabel, startAdornment && classes.inputAdornedStart, endAdornment && classes.inputAdornedEnd, type === 'search' && classes.inputTypeSearch, fcs.margin === 'dense' && classes.inputMarginDense),\n    onBlur: handleBlur,\n    onChange: handleChange,\n    onFocus: handleFocus\n  }))), endAdornment, renderSuffix ? renderSuffix(_extends({}, fcs, {\n    startAdornment: startAdornment\n  })) : null);\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_InputBase_InputBase = (styles_withStyles(InputBase_styles, {\n  name: 'MuiInputBase'\n})(InputBase_InputBase));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Input/Input.js\n\n\n\n\n\n\n\n\nvar Input_styles = function styles(theme) {\n  var light = theme.palette.type === 'light';\n  var bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      position: 'relative'\n    },\n\n    /* Styles applied to the root element if the component is a descendant of `FormControl`. */\n    formControl: {\n      'label + &': {\n        marginTop: 16\n      }\n    },\n\n    /* Styles applied to the root element if the component is focused. */\n    focused: {},\n\n    /* Styles applied to the root element if `disabled={true}`. */\n    disabled: {},\n\n    /* Styles applied to the root element if color secondary. */\n    colorSecondary: {\n      '&$underline:after': {\n        borderBottomColor: theme.palette.secondary.main\n      }\n    },\n\n    /* Styles applied to the root element if `disableUnderline={false}`. */\n    underline: {\n      '&:after': {\n        borderBottom: \"2px solid \".concat(theme.palette.primary.main),\n        left: 0,\n        bottom: 0,\n        // Doing the other way around crash on IE 11 \"''\" https://github.com/cssinjs/jss/issues/242\n        content: '\"\"',\n        position: 'absolute',\n        right: 0,\n        transform: 'scaleX(0)',\n        transition: theme.transitions.create('transform', {\n          duration: theme.transitions.duration.shorter,\n          easing: theme.transitions.easing.easeOut\n        }),\n        pointerEvents: 'none' // Transparent to the hover style.\n\n      },\n      '&$focused:after': {\n        transform: 'scaleX(1)'\n      },\n      '&$error:after': {\n        borderBottomColor: theme.palette.error.main,\n        transform: 'scaleX(1)' // error is always underlined in red\n\n      },\n      '&:before': {\n        borderBottom: \"1px solid \".concat(bottomLineColor),\n        left: 0,\n        bottom: 0,\n        // Doing the other way around crash on IE 11 \"''\" https://github.com/cssinjs/jss/issues/242\n        content: '\"\\\\00a0\"',\n        position: 'absolute',\n        right: 0,\n        transition: theme.transitions.create('border-bottom-color', {\n          duration: theme.transitions.duration.shorter\n        }),\n        pointerEvents: 'none' // Transparent to the hover style.\n\n      },\n      '&:hover:not($disabled):before': {\n        borderBottom: \"2px solid \".concat(theme.palette.text.primary),\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          borderBottom: \"1px solid \".concat(bottomLineColor)\n        }\n      },\n      '&$disabled:before': {\n        borderBottomStyle: 'dotted'\n      }\n    },\n\n    /* Pseudo-class applied to the root element if `error={true}`. */\n    error: {},\n\n    /* Styles applied to the `input` element if `margin=\"dense\"`. */\n    marginDense: {},\n\n    /* Styles applied to the root element if `multiline={true}`. */\n    multiline: {},\n\n    /* Styles applied to the root element if `fullWidth={true}`. */\n    fullWidth: {},\n\n    /* Styles applied to the `input` element. */\n    input: {},\n\n    /* Styles applied to the `input` element if `margin=\"dense\"`. */\n    inputMarginDense: {},\n\n    /* Styles applied to the `input` element if `multiline={true}`. */\n    inputMultiline: {},\n\n    /* Styles applied to the `input` element if `type=\"search\"`. */\n    inputTypeSearch: {}\n  };\n};\nvar Input_Input = /*#__PURE__*/react[\"forwardRef\"](function Input(props, ref) {\n  var disableUnderline = props.disableUnderline,\n      classes = props.classes,\n      _props$fullWidth = props.fullWidth,\n      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,\n      _props$inputComponent = props.inputComponent,\n      inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,\n      _props$multiline = props.multiline,\n      multiline = _props$multiline === void 0 ? false : _props$multiline,\n      _props$type = props.type,\n      type = _props$type === void 0 ? 'text' : _props$type,\n      other = _objectWithoutProperties(props, [\"disableUnderline\", \"classes\", \"fullWidth\", \"inputComponent\", \"multiline\", \"type\"]);\n\n  return /*#__PURE__*/react[\"createElement\"](esm_InputBase_InputBase, _extends({\n    classes: _extends({}, classes, {\n      root: clsx_m(classes.root, !disableUnderline && classes.underline),\n      underline: null\n    }),\n    fullWidth: fullWidth,\n    inputComponent: inputComponent,\n    multiline: multiline,\n    ref: ref,\n    type: type\n  }, other));\n});\n false ? undefined : void 0;\nInput_Input.muiName = 'Input';\n/* harmony default export */ var esm_Input_Input = (styles_withStyles(Input_styles, {\n  name: 'MuiInput'\n})(Input_Input));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/FilledInput/FilledInput.js\n\n\n\n\n\n\n\n\nvar FilledInput_styles = function styles(theme) {\n  var light = theme.palette.type === 'light';\n  var bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';\n  var backgroundColor = light ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.09)';\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      position: 'relative',\n      backgroundColor: backgroundColor,\n      borderTopLeftRadius: theme.shape.borderRadius,\n      borderTopRightRadius: theme.shape.borderRadius,\n      transition: theme.transitions.create('background-color', {\n        duration: theme.transitions.duration.shorter,\n        easing: theme.transitions.easing.easeOut\n      }),\n      '&:hover': {\n        backgroundColor: light ? 'rgba(0, 0, 0, 0.13)' : 'rgba(255, 255, 255, 0.13)',\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: backgroundColor\n        }\n      },\n      '&$focused': {\n        backgroundColor: light ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.09)'\n      },\n      '&$disabled': {\n        backgroundColor: light ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.12)'\n      }\n    },\n\n    /* Styles applied to the root element if color secondary. */\n    colorSecondary: {\n      '&$underline:after': {\n        borderBottomColor: theme.palette.secondary.main\n      }\n    },\n\n    /* Styles applied to the root element if `disableUnderline={false}`. */\n    underline: {\n      '&:after': {\n        borderBottom: \"2px solid \".concat(theme.palette.primary.main),\n        left: 0,\n        bottom: 0,\n        // Doing the other way around crash on IE 11 \"''\" https://github.com/cssinjs/jss/issues/242\n        content: '\"\"',\n        position: 'absolute',\n        right: 0,\n        transform: 'scaleX(0)',\n        transition: theme.transitions.create('transform', {\n          duration: theme.transitions.duration.shorter,\n          easing: theme.transitions.easing.easeOut\n        }),\n        pointerEvents: 'none' // Transparent to the hover style.\n\n      },\n      '&$focused:after': {\n        transform: 'scaleX(1)'\n      },\n      '&$error:after': {\n        borderBottomColor: theme.palette.error.main,\n        transform: 'scaleX(1)' // error is always underlined in red\n\n      },\n      '&:before': {\n        borderBottom: \"1px solid \".concat(bottomLineColor),\n        left: 0,\n        bottom: 0,\n        // Doing the other way around crash on IE 11 \"''\" https://github.com/cssinjs/jss/issues/242\n        content: '\"\\\\00a0\"',\n        position: 'absolute',\n        right: 0,\n        transition: theme.transitions.create('border-bottom-color', {\n          duration: theme.transitions.duration.shorter\n        }),\n        pointerEvents: 'none' // Transparent to the hover style.\n\n      },\n      '&:hover:before': {\n        borderBottom: \"1px solid \".concat(theme.palette.text.primary)\n      },\n      '&$disabled:before': {\n        borderBottomStyle: 'dotted'\n      }\n    },\n\n    /* Pseudo-class applied to the root element if the component is focused. */\n    focused: {},\n\n    /* Pseudo-class applied to the root element if `disabled={true}`. */\n    disabled: {},\n\n    /* Styles applied to the root element if `startAdornment` is provided. */\n    adornedStart: {\n      paddingLeft: 12\n    },\n\n    /* Styles applied to the root element if `endAdornment` is provided. */\n    adornedEnd: {\n      paddingRight: 12\n    },\n\n    /* Pseudo-class applied to the root element if `error={true}`. */\n    error: {},\n\n    /* Styles applied to the `input` element if `margin=\"dense\"`. */\n    marginDense: {},\n\n    /* Styles applied to the root element if `multiline={true}`. */\n    multiline: {\n      padding: '27px 12px 10px',\n      '&$marginDense': {\n        paddingTop: 23,\n        paddingBottom: 6\n      }\n    },\n\n    /* Styles applied to the `input` element. */\n    input: {\n      padding: '27px 12px 10px',\n      '&:-webkit-autofill': {\n        WebkitBoxShadow: theme.palette.type === 'light' ? null : '0 0 0 100px #266798 inset',\n        WebkitTextFillColor: theme.palette.type === 'light' ? null : '#fff',\n        caretColor: theme.palette.type === 'light' ? null : '#fff',\n        borderTopLeftRadius: 'inherit',\n        borderTopRightRadius: 'inherit'\n      }\n    },\n\n    /* Styles applied to the `input` element if `margin=\"dense\"`. */\n    inputMarginDense: {\n      paddingTop: 23,\n      paddingBottom: 6\n    },\n\n    /* Styles applied to the `input` if in `<FormControl hiddenLabel />`. */\n    inputHiddenLabel: {\n      paddingTop: 18,\n      paddingBottom: 19,\n      '&$inputMarginDense': {\n        paddingTop: 10,\n        paddingBottom: 11\n      }\n    },\n\n    /* Styles applied to the `input` element if `multiline={true}`. */\n    inputMultiline: {\n      padding: 0\n    },\n\n    /* Styles applied to the `input` element if `startAdornment` is provided. */\n    inputAdornedStart: {\n      paddingLeft: 0\n    },\n\n    /* Styles applied to the `input` element if `endAdornment` is provided. */\n    inputAdornedEnd: {\n      paddingRight: 0\n    }\n  };\n};\nvar FilledInput_FilledInput = /*#__PURE__*/react[\"forwardRef\"](function FilledInput(props, ref) {\n  var disableUnderline = props.disableUnderline,\n      classes = props.classes,\n      _props$fullWidth = props.fullWidth,\n      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,\n      _props$inputComponent = props.inputComponent,\n      inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,\n      _props$multiline = props.multiline,\n      multiline = _props$multiline === void 0 ? false : _props$multiline,\n      _props$type = props.type,\n      type = _props$type === void 0 ? 'text' : _props$type,\n      other = _objectWithoutProperties(props, [\"disableUnderline\", \"classes\", \"fullWidth\", \"inputComponent\", \"multiline\", \"type\"]);\n\n  return /*#__PURE__*/react[\"createElement\"](esm_InputBase_InputBase, _extends({\n    classes: _extends({}, classes, {\n      root: clsx_m(classes.root, !disableUnderline && classes.underline),\n      underline: null\n    }),\n    fullWidth: fullWidth,\n    inputComponent: inputComponent,\n    multiline: multiline,\n    ref: ref,\n    type: type\n  }, other));\n});\n false ? undefined : void 0;\nFilledInput_FilledInput.muiName = 'Input';\n/* harmony default export */ var esm_FilledInput_FilledInput = (styles_withStyles(FilledInput_styles, {\n  name: 'MuiFilledInput'\n})(FilledInput_FilledInput));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/styles/useTheme.js\n\n\n\nfunction useTheme_useTheme() {\n  var theme = useTheme() || styles_defaultTheme;\n\n  if (false) {}\n\n  return theme;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/OutlinedInput/NotchedOutline.js\n\n\n\n\n\n\n\n\n\nvar NotchedOutline_styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      position: 'absolute',\n      bottom: 0,\n      right: 0,\n      top: -5,\n      left: 0,\n      margin: 0,\n      padding: '0 8px',\n      pointerEvents: 'none',\n      borderRadius: 'inherit',\n      borderStyle: 'solid',\n      borderWidth: 1,\n      overflow: 'hidden'\n    },\n\n    /* Styles applied to the legend element when `labelWidth` is provided. */\n    legend: {\n      textAlign: 'left',\n      padding: 0,\n      lineHeight: '11px',\n      // sync with `height` in `legend` styles\n      transition: theme.transitions.create('width', {\n        duration: 150,\n        easing: theme.transitions.easing.easeOut\n      })\n    },\n\n    /* Styles applied to the legend element. */\n    legendLabelled: {\n      display: 'block',\n      width: 'auto',\n      textAlign: 'left',\n      padding: 0,\n      height: 11,\n      // sync with `lineHeight` in `legend` styles\n      fontSize: '0.75em',\n      visibility: 'hidden',\n      maxWidth: 0.01,\n      transition: theme.transitions.create('max-width', {\n        duration: 50,\n        easing: theme.transitions.easing.easeOut\n      }),\n      '& > span': {\n        paddingLeft: 5,\n        paddingRight: 5,\n        display: 'inline-block'\n      }\n    },\n\n    /* Styles applied to the legend element is notched. */\n    legendNotched: {\n      maxWidth: 1000,\n      transition: theme.transitions.create('max-width', {\n        duration: 100,\n        easing: theme.transitions.easing.easeOut,\n        delay: 50\n      })\n    }\n  };\n};\n/**\n * @ignore - internal component.\n */\n\nvar NotchedOutline_NotchedOutline = /*#__PURE__*/react[\"forwardRef\"](function NotchedOutline(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      label = props.label,\n      labelWidthProp = props.labelWidth,\n      notched = props.notched,\n      style = props.style,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"label\", \"labelWidth\", \"notched\", \"style\"]);\n\n  var theme = useTheme_useTheme();\n  var align = theme.direction === 'rtl' ? 'right' : 'left';\n\n  if (label !== undefined) {\n    return /*#__PURE__*/react[\"createElement\"](\"fieldset\", _extends({\n      \"aria-hidden\": true,\n      className: clsx_m(classes.root, className),\n      ref: ref,\n      style: style\n    }, other), /*#__PURE__*/react[\"createElement\"](\"legend\", {\n      className: clsx_m(classes.legendLabelled, notched && classes.legendNotched)\n    }, label ? /*#__PURE__*/react[\"createElement\"](\"span\", null, label) : /*#__PURE__*/react[\"createElement\"](\"span\", {\n      dangerouslySetInnerHTML: {\n        __html: '&#8203;'\n      }\n    })));\n  }\n\n  var labelWidth = labelWidthProp > 0 ? labelWidthProp * 0.75 + 8 : 0.01;\n  return /*#__PURE__*/react[\"createElement\"](\"fieldset\", _extends({\n    \"aria-hidden\": true,\n    style: _extends(_defineProperty({}, \"padding\".concat(capitalize(align)), 8), style),\n    className: clsx_m(classes.root, className),\n    ref: ref\n  }, other), /*#__PURE__*/react[\"createElement\"](\"legend\", {\n    className: classes.legend,\n    style: {\n      // IE 11: fieldset with legend does not render\n      // a border radius. This maintains consistency\n      // by always having a legend rendered\n      width: notched ? labelWidth : 0.01\n    }\n  }, /*#__PURE__*/react[\"createElement\"](\"span\", {\n    dangerouslySetInnerHTML: {\n      __html: '&#8203;'\n    }\n  })));\n});\n false ? undefined : void 0;\n/* harmony default export */ var OutlinedInput_NotchedOutline = (styles_withStyles(NotchedOutline_styles, {\n  name: 'PrivateNotchedOutline'\n})(NotchedOutline_NotchedOutline));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/OutlinedInput/OutlinedInput.js\n\n\n\n\n\n\n\n\n\nvar OutlinedInput_styles = function styles(theme) {\n  var borderColor = theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)';\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      position: 'relative',\n      borderRadius: theme.shape.borderRadius,\n      '&:hover $notchedOutline': {\n        borderColor: theme.palette.text.primary\n      },\n      // Reset on touch devices, it doesn't add specificity\n      '@media (hover: none)': {\n        '&:hover $notchedOutline': {\n          borderColor: borderColor\n        }\n      },\n      '&$focused $notchedOutline': {\n        borderColor: theme.palette.primary.main,\n        borderWidth: 2\n      },\n      '&$error $notchedOutline': {\n        borderColor: theme.palette.error.main\n      },\n      '&$disabled $notchedOutline': {\n        borderColor: theme.palette.action.disabled\n      }\n    },\n\n    /* Styles applied to the root element if the color is secondary. */\n    colorSecondary: {\n      '&$focused $notchedOutline': {\n        borderColor: theme.palette.secondary.main\n      }\n    },\n\n    /* Styles applied to the root element if the component is focused. */\n    focused: {},\n\n    /* Styles applied to the root element if `disabled={true}`. */\n    disabled: {},\n\n    /* Styles applied to the root element if `startAdornment` is provided. */\n    adornedStart: {\n      paddingLeft: 14\n    },\n\n    /* Styles applied to the root element if `endAdornment` is provided. */\n    adornedEnd: {\n      paddingRight: 14\n    },\n\n    /* Pseudo-class applied to the root element if `error={true}`. */\n    error: {},\n\n    /* Styles applied to the `input` element if `margin=\"dense\"`. */\n    marginDense: {},\n\n    /* Styles applied to the root element if `multiline={true}`. */\n    multiline: {\n      padding: '18.5px 14px',\n      '&$marginDense': {\n        paddingTop: 10.5,\n        paddingBottom: 10.5\n      }\n    },\n\n    /* Styles applied to the `NotchedOutline` element. */\n    notchedOutline: {\n      borderColor: borderColor\n    },\n\n    /* Styles applied to the `input` element. */\n    input: {\n      padding: '18.5px 14px',\n      '&:-webkit-autofill': {\n        WebkitBoxShadow: theme.palette.type === 'light' ? null : '0 0 0 100px #266798 inset',\n        WebkitTextFillColor: theme.palette.type === 'light' ? null : '#fff',\n        caretColor: theme.palette.type === 'light' ? null : '#fff',\n        borderRadius: 'inherit'\n      }\n    },\n\n    /* Styles applied to the `input` element if `margin=\"dense\"`. */\n    inputMarginDense: {\n      paddingTop: 10.5,\n      paddingBottom: 10.5\n    },\n\n    /* Styles applied to the `input` element if `multiline={true}`. */\n    inputMultiline: {\n      padding: 0\n    },\n\n    /* Styles applied to the `input` element if `startAdornment` is provided. */\n    inputAdornedStart: {\n      paddingLeft: 0\n    },\n\n    /* Styles applied to the `input` element if `endAdornment` is provided. */\n    inputAdornedEnd: {\n      paddingRight: 0\n    }\n  };\n};\nvar OutlinedInput_OutlinedInput = /*#__PURE__*/react[\"forwardRef\"](function OutlinedInput(props, ref) {\n  var classes = props.classes,\n      _props$fullWidth = props.fullWidth,\n      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,\n      _props$inputComponent = props.inputComponent,\n      inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,\n      label = props.label,\n      _props$labelWidth = props.labelWidth,\n      labelWidth = _props$labelWidth === void 0 ? 0 : _props$labelWidth,\n      _props$multiline = props.multiline,\n      multiline = _props$multiline === void 0 ? false : _props$multiline,\n      notched = props.notched,\n      _props$type = props.type,\n      type = _props$type === void 0 ? 'text' : _props$type,\n      other = _objectWithoutProperties(props, [\"classes\", \"fullWidth\", \"inputComponent\", \"label\", \"labelWidth\", \"multiline\", \"notched\", \"type\"]);\n\n  return /*#__PURE__*/react[\"createElement\"](esm_InputBase_InputBase, _extends({\n    renderSuffix: function renderSuffix(state) {\n      return /*#__PURE__*/react[\"createElement\"](OutlinedInput_NotchedOutline, {\n        className: classes.notchedOutline,\n        label: label,\n        labelWidth: labelWidth,\n        notched: typeof notched !== 'undefined' ? notched : Boolean(state.startAdornment || state.filled || state.focused)\n      });\n    },\n    classes: _extends({}, classes, {\n      root: clsx_m(classes.root, classes.underline),\n      notchedOutline: null\n    }),\n    fullWidth: fullWidth,\n    inputComponent: inputComponent,\n    multiline: multiline,\n    ref: ref,\n    type: type\n  }, other));\n});\n false ? undefined : void 0;\nOutlinedInput_OutlinedInput.muiName = 'Input';\n/* harmony default export */ var esm_OutlinedInput_OutlinedInput = (styles_withStyles(OutlinedInput_styles, {\n  name: 'MuiOutlinedInput'\n})(OutlinedInput_OutlinedInput));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/FormControl/useFormControl.js\n\n\nfunction useFormControl_useFormControl() {\n  return react[\"useContext\"](FormControl_FormControlContext);\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/FormLabel/FormLabel.js\n\n\n\n\n\n\n\n\n\nvar FormLabel_styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: _extends({\n      color: theme.palette.text.secondary\n    }, theme.typography.body1, {\n      lineHeight: 1,\n      padding: 0,\n      '&$focused': {\n        color: theme.palette.primary.main\n      },\n      '&$disabled': {\n        color: theme.palette.text.disabled\n      },\n      '&$error': {\n        color: theme.palette.error.main\n      }\n    }),\n\n    /* Styles applied to the root element if the color is secondary. */\n    colorSecondary: {\n      '&$focused': {\n        color: theme.palette.secondary.main\n      }\n    },\n\n    /* Pseudo-class applied to the root element if `focused={true}`. */\n    focused: {},\n\n    /* Pseudo-class applied to the root element if `disabled={true}`. */\n    disabled: {},\n\n    /* Pseudo-class applied to the root element if `error={true}`. */\n    error: {},\n\n    /* Pseudo-class applied to the root element if `filled={true}`. */\n    filled: {},\n\n    /* Pseudo-class applied to the root element if `required={true}`. */\n    required: {},\n\n    /* Styles applied to the asterisk element. */\n    asterisk: {\n      '&$error': {\n        color: theme.palette.error.main\n      }\n    }\n  };\n};\nvar FormLabel_FormLabel = /*#__PURE__*/react[\"forwardRef\"](function FormLabel(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      color = props.color,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'label' : _props$component,\n      disabled = props.disabled,\n      error = props.error,\n      filled = props.filled,\n      focused = props.focused,\n      required = props.required,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"color\", \"component\", \"disabled\", \"error\", \"filled\", \"focused\", \"required\"]);\n\n  var muiFormControl = useFormControl_useFormControl();\n  var fcs = formControlState({\n    props: props,\n    muiFormControl: muiFormControl,\n    states: ['color', 'required', 'focused', 'disabled', 'error', 'filled']\n  });\n  return /*#__PURE__*/react[\"createElement\"](Component, _extends({\n    className: clsx_m(classes.root, classes[\"color\".concat(capitalize(fcs.color || 'primary'))], className, fcs.disabled && classes.disabled, fcs.error && classes.error, fcs.filled && classes.filled, fcs.focused && classes.focused, fcs.required && classes.required),\n    ref: ref\n  }, other), children, fcs.required && /*#__PURE__*/react[\"createElement\"](\"span\", {\n    \"aria-hidden\": true,\n    className: clsx_m(classes.asterisk, fcs.error && classes.error)\n  }, \"\\u2009\", '*'));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_FormLabel_FormLabel = (styles_withStyles(FormLabel_styles, {\n  name: 'MuiFormLabel'\n})(FormLabel_FormLabel));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/InputLabel/InputLabel.js\n\n\n\n\n\n\n\n\n\nvar InputLabel_styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      display: 'block',\n      transformOrigin: 'top left'\n    },\n\n    /* Pseudo-class applied to the root element if `focused={true}`. */\n    focused: {},\n\n    /* Pseudo-class applied to the root element if `disabled={true}`. */\n    disabled: {},\n\n    /* Pseudo-class applied to the root element if `error={true}`. */\n    error: {},\n\n    /* Pseudo-class applied to the root element if `required={true}`. */\n    required: {},\n\n    /* Pseudo-class applied to the asterisk element. */\n    asterisk: {},\n\n    /* Styles applied to the root element if the component is a descendant of `FormControl`. */\n    formControl: {\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      // slight alteration to spec spacing to match visual spec result\n      transform: 'translate(0, 24px) scale(1)'\n    },\n\n    /* Styles applied to the root element if `margin=\"dense\"`. */\n    marginDense: {\n      // Compensation for the `Input.inputDense` style.\n      transform: 'translate(0, 21px) scale(1)'\n    },\n\n    /* Styles applied to the `input` element if `shrink={true}`. */\n    shrink: {\n      transform: 'translate(0, 1.5px) scale(0.75)',\n      transformOrigin: 'top left'\n    },\n\n    /* Styles applied to the `input` element if `disableAnimation={false}`. */\n    animated: {\n      transition: theme.transitions.create(['color', 'transform'], {\n        duration: theme.transitions.duration.shorter,\n        easing: theme.transitions.easing.easeOut\n      })\n    },\n\n    /* Styles applied to the root element if `variant=\"filled\"`. */\n    filled: {\n      // Chrome's autofill feature gives the input field a yellow background.\n      // Since the input field is behind the label in the HTML tree,\n      // the input field is drawn last and hides the label with an opaque background color.\n      // zIndex: 1 will raise the label above opaque background-colors of input.\n      zIndex: 1,\n      pointerEvents: 'none',\n      transform: 'translate(12px, 20px) scale(1)',\n      '&$marginDense': {\n        transform: 'translate(12px, 17px) scale(1)'\n      },\n      '&$shrink': {\n        transform: 'translate(12px, 10px) scale(0.75)',\n        '&$marginDense': {\n          transform: 'translate(12px, 7px) scale(0.75)'\n        }\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"outlined\"`. */\n    outlined: {\n      // see comment above on filled.zIndex\n      zIndex: 1,\n      pointerEvents: 'none',\n      transform: 'translate(14px, 20px) scale(1)',\n      '&$marginDense': {\n        transform: 'translate(14px, 12px) scale(1)'\n      },\n      '&$shrink': {\n        transform: 'translate(14px, -6px) scale(0.75)'\n      }\n    }\n  };\n};\nvar InputLabel_InputLabel = /*#__PURE__*/react[\"forwardRef\"](function InputLabel(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      _props$disableAnimati = props.disableAnimation,\n      disableAnimation = _props$disableAnimati === void 0 ? false : _props$disableAnimati,\n      margin = props.margin,\n      shrinkProp = props.shrink,\n      variant = props.variant,\n      other = _objectWithoutProperties(props, [\"classes\", \"className\", \"disableAnimation\", \"margin\", \"shrink\", \"variant\"]);\n\n  var muiFormControl = useFormControl_useFormControl();\n  var shrink = shrinkProp;\n\n  if (typeof shrink === 'undefined' && muiFormControl) {\n    shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;\n  }\n\n  var fcs = formControlState({\n    props: props,\n    muiFormControl: muiFormControl,\n    states: ['margin', 'variant']\n  });\n  return /*#__PURE__*/react[\"createElement\"](esm_FormLabel_FormLabel, _extends({\n    \"data-shrink\": shrink,\n    className: clsx_m(classes.root, className, muiFormControl && classes.formControl, !disableAnimation && classes.animated, shrink && classes.shrink, fcs.margin === 'dense' && classes.marginDense, {\n      'filled': classes.filled,\n      'outlined': classes.outlined\n    }[fcs.variant]),\n    classes: {\n      focused: classes.focused,\n      disabled: classes.disabled,\n      error: classes.error,\n      required: classes.required,\n      asterisk: classes.asterisk\n    },\n    ref: ref\n  }, other));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_InputLabel_InputLabel = (styles_withStyles(InputLabel_styles, {\n  name: 'MuiInputLabel'\n})(InputLabel_InputLabel));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/FormControl/FormControl.js\n\n\n\n\n\n\n\n\n\n\nvar FormControl_styles = {\n  /* Styles applied to the root element. */\n  root: {\n    display: 'inline-flex',\n    flexDirection: 'column',\n    position: 'relative',\n    // Reset fieldset default style.\n    minWidth: 0,\n    padding: 0,\n    margin: 0,\n    border: 0,\n    verticalAlign: 'top' // Fix alignment issue on Safari.\n\n  },\n\n  /* Styles applied to the root element if `margin=\"normal\"`. */\n  marginNormal: {\n    marginTop: 16,\n    marginBottom: 8\n  },\n\n  /* Styles applied to the root element if `margin=\"dense\"`. */\n  marginDense: {\n    marginTop: 8,\n    marginBottom: 4\n  },\n\n  /* Styles applied to the root element if `fullWidth={true}`. */\n  fullWidth: {\n    width: '100%'\n  }\n};\n/**\n * Provides context such as filled/focused/error/required for form inputs.\n * Relying on the context provides high flexibility and ensures that the state always stays\n * consistent across the children of the `FormControl`.\n * This context is used by the following components:\n *\n *  - FormLabel\n *  - FormHelperText\n *  - Input\n *  - InputLabel\n *\n * You can find one composition example below and more going to [the demos](/components/text-fields/#components).\n *\n * ```jsx\n * <FormControl>\n *   <InputLabel htmlFor=\"my-input\">Email address</InputLabel>\n *   <Input id=\"my-input\" aria-describedby=\"my-helper-text\" />\n *   <FormHelperText id=\"my-helper-text\">We'll never share your email.</FormHelperText>\n * </FormControl>\n * ```\n *\n * ⚠️Only one input can be used within a FormControl.\n */\n\nvar FormControl_FormControl = /*#__PURE__*/react[\"forwardRef\"](function FormControl(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$color = props.color,\n      color = _props$color === void 0 ? 'primary' : _props$color,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'div' : _props$component,\n      _props$disabled = props.disabled,\n      disabled = _props$disabled === void 0 ? false : _props$disabled,\n      _props$error = props.error,\n      error = _props$error === void 0 ? false : _props$error,\n      _props$fullWidth = props.fullWidth,\n      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,\n      visuallyFocused = props.focused,\n      _props$hiddenLabel = props.hiddenLabel,\n      hiddenLabel = _props$hiddenLabel === void 0 ? false : _props$hiddenLabel,\n      _props$margin = props.margin,\n      margin = _props$margin === void 0 ? 'none' : _props$margin,\n      _props$required = props.required,\n      required = _props$required === void 0 ? false : _props$required,\n      size = props.size,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'standard' : _props$variant,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"color\", \"component\", \"disabled\", \"error\", \"fullWidth\", \"focused\", \"hiddenLabel\", \"margin\", \"required\", \"size\", \"variant\"]);\n\n  var _React$useState = react[\"useState\"](function () {\n    // We need to iterate through the children and find the Input in order\n    // to fully support server-side rendering.\n    var initialAdornedStart = false;\n\n    if (children) {\n      react[\"Children\"].forEach(children, function (child) {\n        if (!isMuiElement(child, ['Input', 'Select'])) {\n          return;\n        }\n\n        var input = isMuiElement(child, ['Select']) ? child.props.input : child;\n\n        if (input && isAdornedStart(input.props)) {\n          initialAdornedStart = true;\n        }\n      });\n    }\n\n    return initialAdornedStart;\n  }),\n      adornedStart = _React$useState[0],\n      setAdornedStart = _React$useState[1];\n\n  var _React$useState2 = react[\"useState\"](function () {\n    // We need to iterate through the children and find the Input in order\n    // to fully support server-side rendering.\n    var initialFilled = false;\n\n    if (children) {\n      react[\"Children\"].forEach(children, function (child) {\n        if (!isMuiElement(child, ['Input', 'Select'])) {\n          return;\n        }\n\n        if (isFilled(child.props, true)) {\n          initialFilled = true;\n        }\n      });\n    }\n\n    return initialFilled;\n  }),\n      filled = _React$useState2[0],\n      setFilled = _React$useState2[1];\n\n  var _React$useState3 = react[\"useState\"](false),\n      _focused = _React$useState3[0],\n      setFocused = _React$useState3[1];\n\n  var focused = visuallyFocused !== undefined ? visuallyFocused : _focused;\n\n  if (disabled && focused) {\n    setFocused(false);\n  }\n\n  var registerEffect;\n\n  if (false) { var registeredInput; }\n\n  var onFilled = react[\"useCallback\"](function () {\n    setFilled(true);\n  }, []);\n  var onEmpty = react[\"useCallback\"](function () {\n    setFilled(false);\n  }, []);\n  var childContext = {\n    adornedStart: adornedStart,\n    setAdornedStart: setAdornedStart,\n    color: color,\n    disabled: disabled,\n    error: error,\n    filled: filled,\n    focused: focused,\n    fullWidth: fullWidth,\n    hiddenLabel: hiddenLabel,\n    margin: (size === 'small' ? 'dense' : undefined) || margin,\n    onBlur: function onBlur() {\n      setFocused(false);\n    },\n    onEmpty: onEmpty,\n    onFilled: onFilled,\n    onFocus: function onFocus() {\n      setFocused(true);\n    },\n    registerEffect: registerEffect,\n    required: required,\n    variant: variant\n  };\n  return /*#__PURE__*/react[\"createElement\"](FormControl_FormControlContext.Provider, {\n    value: childContext\n  }, /*#__PURE__*/react[\"createElement\"](Component, _extends({\n    className: clsx_m(classes.root, className, margin !== 'none' && classes[\"margin\".concat(capitalize(margin))], fullWidth && classes.fullWidth),\n    ref: ref\n  }, other), children));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_FormControl_FormControl = (styles_withStyles(FormControl_styles, {\n  name: 'MuiFormControl'\n})(FormControl_FormControl));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/FormHelperText/FormHelperText.js\n\n\n\n\n\n\n\n\nvar FormHelperText_styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: _extends({\n      color: theme.palette.text.secondary\n    }, theme.typography.caption, {\n      textAlign: 'left',\n      marginTop: 3,\n      margin: 0,\n      '&$disabled': {\n        color: theme.palette.text.disabled\n      },\n      '&$error': {\n        color: theme.palette.error.main\n      }\n    }),\n\n    /* Pseudo-class applied to the root element if `error={true}`. */\n    error: {},\n\n    /* Pseudo-class applied to the root element if `disabled={true}`. */\n    disabled: {},\n\n    /* Styles applied to the root element if `margin=\"dense\"`. */\n    marginDense: {\n      marginTop: 4\n    },\n\n    /* Styles applied to the root element if `variant=\"filled\"` or `variant=\"outlined\"`. */\n    contained: {\n      marginLeft: 14,\n      marginRight: 14\n    },\n\n    /* Pseudo-class applied to the root element if `focused={true}`. */\n    focused: {},\n\n    /* Pseudo-class applied to the root element if `filled={true}`. */\n    filled: {},\n\n    /* Pseudo-class applied to the root element if `required={true}`. */\n    required: {}\n  };\n};\nvar FormHelperText_FormHelperText = /*#__PURE__*/react[\"forwardRef\"](function FormHelperText(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'p' : _props$component,\n      disabled = props.disabled,\n      error = props.error,\n      filled = props.filled,\n      focused = props.focused,\n      margin = props.margin,\n      required = props.required,\n      variant = props.variant,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"component\", \"disabled\", \"error\", \"filled\", \"focused\", \"margin\", \"required\", \"variant\"]);\n\n  var muiFormControl = useFormControl_useFormControl();\n  var fcs = formControlState({\n    props: props,\n    muiFormControl: muiFormControl,\n    states: ['variant', 'margin', 'disabled', 'error', 'filled', 'focused', 'required']\n  });\n  return /*#__PURE__*/react[\"createElement\"](Component, _extends({\n    className: clsx_m(classes.root, (fcs.variant === 'filled' || fcs.variant === 'outlined') && classes.contained, className, fcs.disabled && classes.disabled, fcs.error && classes.error, fcs.filled && classes.filled, fcs.focused && classes.focused, fcs.required && classes.required, fcs.margin === 'dense' && classes.marginDense),\n    ref: ref\n  }, other), children === ' ' ?\n  /*#__PURE__*/\n  // eslint-disable-next-line react/no-danger\n  react[\"createElement\"](\"span\", {\n    dangerouslySetInnerHTML: {\n      __html: '&#8203;'\n    }\n  }) : children);\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_FormHelperText_FormHelperText = (styles_withStyles(FormHelperText_styles, {\n  name: 'MuiFormHelperText'\n})(FormHelperText_FormHelperText));\n// EXTERNAL MODULE: ./node_modules/react-is/index.js\nvar react_is = __webpack_require__(12);\n\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/ownerDocument.js\nfunction ownerDocument(node) {\n  return node && node.ownerDocument || document;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/ownerWindow.js\n\nfunction ownerWindow(node) {\n  var doc = ownerDocument(node);\n  return doc.defaultView || window;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/createChainedFunction.js\n/**\n * Safe chained function\n *\n * Will only create a new function if needed,\n * otherwise will pass back existing functions or null.\n *\n * @param {function} functions to chain\n * @returns {function|null}\n */\nfunction createChainedFunction() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  return funcs.reduce(function (acc, func) {\n    if (func == null) {\n      return acc;\n    }\n\n    if (false) {}\n\n    return function chainedFunction() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      acc.apply(this, args);\n      func.apply(this, args);\n    };\n  }, function () {});\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Portal/Portal.js\n\n\n\n\n\n\n\nfunction getContainer(container) {\n  container = typeof container === 'function' ? container() : container; // #StrictMode ready\n\n  return react_dom[\"findDOMNode\"](container);\n}\n\nvar Portal_useEnhancedEffect = typeof window !== 'undefined' ? react[\"useLayoutEffect\"] : react[\"useEffect\"];\n/**\n * Portals provide a first-class way to render children into a DOM node\n * that exists outside the DOM hierarchy of the parent component.\n */\n\nvar Portal_Portal = /*#__PURE__*/react[\"forwardRef\"](function Portal(props, ref) {\n  var children = props.children,\n      container = props.container,\n      _props$disablePortal = props.disablePortal,\n      disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,\n      onRendered = props.onRendered;\n\n  var _React$useState = react[\"useState\"](null),\n      mountNode = _React$useState[0],\n      setMountNode = _React$useState[1];\n\n  var handleRef = useForkRef( /*#__PURE__*/react[\"isValidElement\"](children) ? children.ref : null, ref);\n  Portal_useEnhancedEffect(function () {\n    if (!disablePortal) {\n      setMountNode(getContainer(container) || document.body);\n    }\n  }, [container, disablePortal]);\n  Portal_useEnhancedEffect(function () {\n    if (mountNode && !disablePortal) {\n      setRef(ref, mountNode);\n      return function () {\n        setRef(ref, null);\n      };\n    }\n\n    return undefined;\n  }, [ref, mountNode, disablePortal]);\n  Portal_useEnhancedEffect(function () {\n    if (onRendered && (mountNode || disablePortal)) {\n      onRendered();\n    }\n  }, [onRendered, mountNode, disablePortal]);\n\n  if (disablePortal) {\n    if ( /*#__PURE__*/react[\"isValidElement\"](children)) {\n      return /*#__PURE__*/react[\"cloneElement\"](children, {\n        ref: handleRef\n      });\n    }\n\n    return children;\n  }\n\n  return mountNode ? /*#__PURE__*/react_dom[\"createPortal\"](children, mountNode) : mountNode;\n});\n false ? undefined : void 0;\n\nif (false) {}\n\n/* harmony default export */ var esm_Portal_Portal = (Portal_Portal);\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/getScrollbarSize.js\n// A change of the browser zoom change the scrollbar size.\n// Credit https://github.com/twbs/bootstrap/blob/3ffe3a5d82f6f561b82ff78d82b32a7d14aed558/js/src/modal.js#L512-L519\nfunction getScrollbarSize() {\n  var scrollDiv = document.createElement('div');\n  scrollDiv.style.width = '99px';\n  scrollDiv.style.height = '99px';\n  scrollDiv.style.position = 'absolute';\n  scrollDiv.style.top = '-9999px';\n  scrollDiv.style.overflow = 'scroll';\n  document.body.appendChild(scrollDiv);\n  var scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n  document.body.removeChild(scrollDiv);\n  return scrollbarSize;\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Modal/ModalManager.js\n\n\n\n\n\n // Is a vertical scrollbar displayed?\n\nfunction isOverflowing(container) {\n  var doc = ownerDocument(container);\n\n  if (doc.body === container) {\n    return ownerWindow(doc).innerWidth > doc.documentElement.clientWidth;\n  }\n\n  return container.scrollHeight > container.clientHeight;\n}\n\nfunction ariaHidden(node, show) {\n  if (show) {\n    node.setAttribute('aria-hidden', 'true');\n  } else {\n    node.removeAttribute('aria-hidden');\n  }\n}\n\nfunction getPaddingRight(node) {\n  return parseInt(window.getComputedStyle(node)['padding-right'], 10) || 0;\n}\n\nfunction ariaHiddenSiblings(container, mountNode, currentNode) {\n  var nodesToExclude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var show = arguments.length > 4 ? arguments[4] : undefined;\n  var blacklist = [mountNode, currentNode].concat(_toConsumableArray(nodesToExclude));\n  var blacklistTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE'];\n  [].forEach.call(container.children, function (node) {\n    if (node.nodeType === 1 && blacklist.indexOf(node) === -1 && blacklistTagNames.indexOf(node.tagName) === -1) {\n      ariaHidden(node, show);\n    }\n  });\n}\n\nfunction findIndexOf(containerInfo, callback) {\n  var idx = -1;\n  containerInfo.some(function (item, index) {\n    if (callback(item)) {\n      idx = index;\n      return true;\n    }\n\n    return false;\n  });\n  return idx;\n}\n\nfunction handleContainer(containerInfo, props) {\n  var restoreStyle = [];\n  var restorePaddings = [];\n  var container = containerInfo.container;\n  var fixedNodes;\n\n  if (!props.disableScrollLock) {\n    if (isOverflowing(container)) {\n      // Compute the size before applying overflow hidden to avoid any scroll jumps.\n      var scrollbarSize = getScrollbarSize();\n      restoreStyle.push({\n        value: container.style.paddingRight,\n        key: 'padding-right',\n        el: container\n      }); // Use computed style, here to get the real padding to add our scrollbar width.\n\n      container.style['padding-right'] = \"\".concat(getPaddingRight(container) + scrollbarSize, \"px\"); // .mui-fixed is a global helper.\n\n      fixedNodes = ownerDocument(container).querySelectorAll('.mui-fixed');\n      [].forEach.call(fixedNodes, function (node) {\n        restorePaddings.push(node.style.paddingRight);\n        node.style.paddingRight = \"\".concat(getPaddingRight(node) + scrollbarSize, \"px\");\n      });\n    } // Improve Gatsby support\n    // https://css-tricks.com/snippets/css/force-vertical-scrollbar/\n\n\n    var parent = container.parentElement;\n    var scrollContainer = parent.nodeName === 'HTML' && window.getComputedStyle(parent)['overflow-y'] === 'scroll' ? parent : container; // Block the scroll even if no scrollbar is visible to account for mobile keyboard\n    // screensize shrink.\n\n    restoreStyle.push({\n      value: scrollContainer.style.overflow,\n      key: 'overflow',\n      el: scrollContainer\n    });\n    scrollContainer.style.overflow = 'hidden';\n  }\n\n  var restore = function restore() {\n    if (fixedNodes) {\n      [].forEach.call(fixedNodes, function (node, i) {\n        if (restorePaddings[i]) {\n          node.style.paddingRight = restorePaddings[i];\n        } else {\n          node.style.removeProperty('padding-right');\n        }\n      });\n    }\n\n    restoreStyle.forEach(function (_ref) {\n      var value = _ref.value,\n          el = _ref.el,\n          key = _ref.key;\n\n      if (value) {\n        el.style.setProperty(key, value);\n      } else {\n        el.style.removeProperty(key);\n      }\n    });\n  };\n\n  return restore;\n}\n\nfunction getHiddenSiblings(container) {\n  var hiddenSiblings = [];\n  [].forEach.call(container.children, function (node) {\n    if (node.getAttribute && node.getAttribute('aria-hidden') === 'true') {\n      hiddenSiblings.push(node);\n    }\n  });\n  return hiddenSiblings;\n}\n/**\n * @ignore - do not document.\n *\n * Proper state management for containers and the modals in those containers.\n * Simplified, but inspired by react-overlay's ModalManager class.\n * Used by the Modal to ensure proper styling of containers.\n */\n\n\nvar ModalManager_ModalManager = /*#__PURE__*/function () {\n  function ModalManager() {\n    _classCallCheck(this, ModalManager);\n\n    // this.modals[modalIndex] = modal\n    this.modals = []; // this.containers[containerIndex] = {\n    //   modals: [],\n    //   container,\n    //   restore: null,\n    // }\n\n    this.containers = [];\n  }\n\n  _createClass(ModalManager, [{\n    key: \"add\",\n    value: function add(modal, container) {\n      var modalIndex = this.modals.indexOf(modal);\n\n      if (modalIndex !== -1) {\n        return modalIndex;\n      }\n\n      modalIndex = this.modals.length;\n      this.modals.push(modal); // If the modal we are adding is already in the DOM.\n\n      if (modal.modalRef) {\n        ariaHidden(modal.modalRef, false);\n      }\n\n      var hiddenSiblingNodes = getHiddenSiblings(container);\n      ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, hiddenSiblingNodes, true);\n      var containerIndex = findIndexOf(this.containers, function (item) {\n        return item.container === container;\n      });\n\n      if (containerIndex !== -1) {\n        this.containers[containerIndex].modals.push(modal);\n        return modalIndex;\n      }\n\n      this.containers.push({\n        modals: [modal],\n        container: container,\n        restore: null,\n        hiddenSiblingNodes: hiddenSiblingNodes\n      });\n      return modalIndex;\n    }\n  }, {\n    key: \"mount\",\n    value: function mount(modal, props) {\n      var containerIndex = findIndexOf(this.containers, function (item) {\n        return item.modals.indexOf(modal) !== -1;\n      });\n      var containerInfo = this.containers[containerIndex];\n\n      if (!containerInfo.restore) {\n        containerInfo.restore = handleContainer(containerInfo, props);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(modal) {\n      var modalIndex = this.modals.indexOf(modal);\n\n      if (modalIndex === -1) {\n        return modalIndex;\n      }\n\n      var containerIndex = findIndexOf(this.containers, function (item) {\n        return item.modals.indexOf(modal) !== -1;\n      });\n      var containerInfo = this.containers[containerIndex];\n      containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);\n      this.modals.splice(modalIndex, 1); // If that was the last modal in a container, clean up the container.\n\n      if (containerInfo.modals.length === 0) {\n        // The modal might be closed before it had the chance to be mounted in the DOM.\n        if (containerInfo.restore) {\n          containerInfo.restore();\n        }\n\n        if (modal.modalRef) {\n          // In case the modal wasn't in the DOM yet.\n          ariaHidden(modal.modalRef, true);\n        }\n\n        ariaHiddenSiblings(containerInfo.container, modal.mountNode, modal.modalRef, containerInfo.hiddenSiblingNodes, false);\n        this.containers.splice(containerIndex, 1);\n      } else {\n        // Otherwise make sure the next top modal is visible to a screen reader.\n        var nextTop = containerInfo.modals[containerInfo.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set\n        // aria-hidden because the dom element doesn't exist either\n        // when modal was unmounted before modalRef gets null\n\n        if (nextTop.modalRef) {\n          ariaHidden(nextTop.modalRef, false);\n        }\n      }\n\n      return modalIndex;\n    }\n  }, {\n    key: \"isTopModal\",\n    value: function isTopModal(modal) {\n      return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;\n    }\n  }]);\n\n  return ModalManager;\n}();\n\n\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Unstable_TrapFocus/Unstable_TrapFocus.js\n/* eslint-disable consistent-return, jsx-a11y/no-noninteractive-tabindex, camelcase */\n\n\n\n\n\n\n/**\n * Utility component that locks focus inside the component.\n */\n\nfunction Unstable_TrapFocus(props) {\n  var children = props.children,\n      _props$disableAutoFoc = props.disableAutoFocus,\n      disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,\n      _props$disableEnforce = props.disableEnforceFocus,\n      disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce,\n      _props$disableRestore = props.disableRestoreFocus,\n      disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore,\n      getDoc = props.getDoc,\n      isEnabled = props.isEnabled,\n      open = props.open;\n  var ignoreNextEnforceFocus = react[\"useRef\"]();\n  var sentinelStart = react[\"useRef\"](null);\n  var sentinelEnd = react[\"useRef\"](null);\n  var nodeToRestore = react[\"useRef\"]();\n  var rootRef = react[\"useRef\"](null); // can be removed once we drop support for non ref forwarding class components\n\n  var handleOwnRef = react[\"useCallback\"](function (instance) {\n    // #StrictMode ready\n    rootRef.current = react_dom[\"findDOMNode\"](instance);\n  }, []);\n  var handleRef = useForkRef(children.ref, handleOwnRef);\n  var prevOpenRef = react[\"useRef\"]();\n  react[\"useEffect\"](function () {\n    prevOpenRef.current = open;\n  }, [open]);\n\n  if (!prevOpenRef.current && open && typeof window !== 'undefined') {\n    // WARNING: Potentially unsafe in concurrent mode.\n    // The way the read on `nodeToRestore` is setup could make this actually safe.\n    // Say we render `open={false}` -> `open={true}` but never commit.\n    // We have now written a state that wasn't committed. But no committed effect\n    // will read this wrong value. We only read from `nodeToRestore` in effects\n    // that were committed on `open={true}`\n    // WARNING: Prevents the instance from being garbage collected. Should only\n    // hold a weak ref.\n    nodeToRestore.current = getDoc().activeElement;\n  }\n\n  react[\"useEffect\"](function () {\n    if (!open) {\n      return;\n    }\n\n    var doc = ownerDocument(rootRef.current); // We might render an empty child.\n\n    if (!disableAutoFocus && rootRef.current && !rootRef.current.contains(doc.activeElement)) {\n      if (!rootRef.current.hasAttribute('tabIndex')) {\n        if (false) {}\n\n        rootRef.current.setAttribute('tabIndex', -1);\n      }\n\n      rootRef.current.focus();\n    }\n\n    var contain = function contain() {\n      if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {\n        ignoreNextEnforceFocus.current = false;\n        return;\n      }\n\n      if (rootRef.current && !rootRef.current.contains(doc.activeElement)) {\n        rootRef.current.focus();\n      }\n    };\n\n    var loopFocus = function loopFocus(event) {\n      // 9 = Tab\n      if (disableEnforceFocus || !isEnabled() || event.keyCode !== 9) {\n        return;\n      } // Make sure the next tab starts from the right place.\n\n\n      if (doc.activeElement === rootRef.current) {\n        // We need to ignore the next contain as\n        // it will try to move the focus back to the rootRef element.\n        ignoreNextEnforceFocus.current = true;\n\n        if (event.shiftKey) {\n          sentinelEnd.current.focus();\n        } else {\n          sentinelStart.current.focus();\n        }\n      }\n    };\n\n    doc.addEventListener('focus', contain, true);\n    doc.addEventListener('keydown', loopFocus, true); // With Edge, Safari and Firefox, no focus related events are fired when the focused area stops being a focused area\n    // e.g. https://bugzilla.mozilla.org/show_bug.cgi?id=559561.\n    //\n    // The whatwg spec defines how the browser should behave but does not explicitly mention any events:\n    // https://html.spec.whatwg.org/multipage/interaction.html#focus-fixup-rule.\n\n    var interval = setInterval(function () {\n      contain();\n    }, 50);\n    return function () {\n      clearInterval(interval);\n      doc.removeEventListener('focus', contain, true);\n      doc.removeEventListener('keydown', loopFocus, true); // restoreLastFocus()\n\n      if (!disableRestoreFocus) {\n        // In IE 11 it is possible for document.activeElement to be null resulting\n        // in nodeToRestore.current being null.\n        // Not all elements in IE 11 have a focus method.\n        // Once IE 11 support is dropped the focus() call can be unconditional.\n        if (nodeToRestore.current && nodeToRestore.current.focus) {\n          nodeToRestore.current.focus();\n        }\n\n        nodeToRestore.current = null;\n      }\n    };\n  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open]);\n  return /*#__PURE__*/react[\"createElement\"](react[\"Fragment\"], null, /*#__PURE__*/react[\"createElement\"](\"div\", {\n    tabIndex: 0,\n    ref: sentinelStart,\n    \"data-test\": \"sentinelStart\"\n  }), /*#__PURE__*/react[\"cloneElement\"](children, {\n    ref: handleRef\n  }), /*#__PURE__*/react[\"createElement\"](\"div\", {\n    tabIndex: 0,\n    ref: sentinelEnd,\n    \"data-test\": \"sentinelEnd\"\n  }));\n}\n\n false ? undefined : void 0;\n\nif (false) {}\n\n/* harmony default export */ var Unstable_TrapFocus_Unstable_TrapFocus = (Unstable_TrapFocus);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Modal/SimpleBackdrop.js\n\n\n\n\nvar SimpleBackdrop_styles = {\n  /* Styles applied to the root element. */\n  root: {\n    zIndex: -1,\n    position: 'fixed',\n    right: 0,\n    bottom: 0,\n    top: 0,\n    left: 0,\n    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n    WebkitTapHighlightColor: 'transparent'\n  },\n\n  /* Styles applied to the root element if `invisible={true}`. */\n  invisible: {\n    backgroundColor: 'transparent'\n  }\n};\n/**\n * @ignore - internal component.\n */\n\nvar SimpleBackdrop_SimpleBackdrop = /*#__PURE__*/react[\"forwardRef\"](function SimpleBackdrop(props, ref) {\n  var _props$invisible = props.invisible,\n      invisible = _props$invisible === void 0 ? false : _props$invisible,\n      open = props.open,\n      other = _objectWithoutProperties(props, [\"invisible\", \"open\"]);\n\n  return open ? /*#__PURE__*/react[\"createElement\"](\"div\", _extends({\n    \"aria-hidden\": true,\n    ref: ref\n  }, other, {\n    style: _extends({}, SimpleBackdrop_styles.root, invisible ? SimpleBackdrop_styles.invisible : {}, other.style)\n  })) : null;\n});\n false ? undefined : void 0;\n/* harmony default export */ var Modal_SimpleBackdrop = (SimpleBackdrop_SimpleBackdrop);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Modal/Modal.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Modal_getContainer(container) {\n  container = typeof container === 'function' ? container() : container;\n  return react_dom[\"findDOMNode\"](container);\n}\n\nfunction getHasTransition(props) {\n  return props.children ? props.children.props.hasOwnProperty('in') : false;\n} // A modal manager used to track and manage the state of open Modals.\n// Modals don't open on the server so this won't conflict with concurrent requests.\n\n\nvar defaultManager = new ModalManager_ModalManager();\nvar Modal_styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      position: 'fixed',\n      zIndex: theme.zIndex.modal,\n      right: 0,\n      bottom: 0,\n      top: 0,\n      left: 0\n    },\n\n    /* Styles applied to the root element if the `Modal` has exited. */\n    hidden: {\n      visibility: 'hidden'\n    }\n  };\n};\n/**\n * Modal is a lower-level construct that is leveraged by the following components:\n *\n * - [Dialog](/api/dialog/)\n * - [Drawer](/api/drawer/)\n * - [Menu](/api/menu/)\n * - [Popover](/api/popover/)\n *\n * If you are creating a modal dialog, you probably want to use the [Dialog](/api/dialog/) component\n * rather than directly using Modal.\n *\n * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).\n */\n\nvar Modal_Modal = /*#__PURE__*/react[\"forwardRef\"](function Modal(inProps, ref) {\n  var theme = useTheme();\n  var props = getThemeProps({\n    name: 'MuiModal',\n    props: _extends({}, inProps),\n    theme: theme\n  });\n\n  var _props$BackdropCompon = props.BackdropComponent,\n      BackdropComponent = _props$BackdropCompon === void 0 ? Modal_SimpleBackdrop : _props$BackdropCompon,\n      BackdropProps = props.BackdropProps,\n      children = props.children,\n      _props$closeAfterTran = props.closeAfterTransition,\n      closeAfterTransition = _props$closeAfterTran === void 0 ? false : _props$closeAfterTran,\n      container = props.container,\n      _props$disableAutoFoc = props.disableAutoFocus,\n      disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,\n      _props$disableBackdro = props.disableBackdropClick,\n      disableBackdropClick = _props$disableBackdro === void 0 ? false : _props$disableBackdro,\n      _props$disableEnforce = props.disableEnforceFocus,\n      disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce,\n      _props$disableEscapeK = props.disableEscapeKeyDown,\n      disableEscapeKeyDown = _props$disableEscapeK === void 0 ? false : _props$disableEscapeK,\n      _props$disablePortal = props.disablePortal,\n      disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,\n      _props$disableRestore = props.disableRestoreFocus,\n      disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore,\n      _props$disableScrollL = props.disableScrollLock,\n      disableScrollLock = _props$disableScrollL === void 0 ? false : _props$disableScrollL,\n      _props$hideBackdrop = props.hideBackdrop,\n      hideBackdrop = _props$hideBackdrop === void 0 ? false : _props$hideBackdrop,\n      _props$keepMounted = props.keepMounted,\n      keepMounted = _props$keepMounted === void 0 ? false : _props$keepMounted,\n      _props$manager = props.manager,\n      manager = _props$manager === void 0 ? defaultManager : _props$manager,\n      onBackdropClick = props.onBackdropClick,\n      onClose = props.onClose,\n      onEscapeKeyDown = props.onEscapeKeyDown,\n      onRendered = props.onRendered,\n      open = props.open,\n      other = _objectWithoutProperties(props, [\"BackdropComponent\", \"BackdropProps\", \"children\", \"closeAfterTransition\", \"container\", \"disableAutoFocus\", \"disableBackdropClick\", \"disableEnforceFocus\", \"disableEscapeKeyDown\", \"disablePortal\", \"disableRestoreFocus\", \"disableScrollLock\", \"hideBackdrop\", \"keepMounted\", \"manager\", \"onBackdropClick\", \"onClose\", \"onEscapeKeyDown\", \"onRendered\", \"open\"]);\n\n  var _React$useState = react[\"useState\"](true),\n      exited = _React$useState[0],\n      setExited = _React$useState[1];\n\n  var modal = react[\"useRef\"]({});\n  var mountNodeRef = react[\"useRef\"](null);\n  var modalRef = react[\"useRef\"](null);\n  var handleRef = useForkRef(modalRef, ref);\n  var hasTransition = getHasTransition(props);\n\n  var getDoc = function getDoc() {\n    return ownerDocument(mountNodeRef.current);\n  };\n\n  var getModal = function getModal() {\n    modal.current.modalRef = modalRef.current;\n    modal.current.mountNode = mountNodeRef.current;\n    return modal.current;\n  };\n\n  var handleMounted = function handleMounted() {\n    manager.mount(getModal(), {\n      disableScrollLock: disableScrollLock\n    }); // Fix a bug on Chrome where the scroll isn't initially 0.\n\n    modalRef.current.scrollTop = 0;\n  };\n\n  var handleOpen = useEventCallback(function () {\n    var resolvedContainer = Modal_getContainer(container) || getDoc().body;\n    manager.add(getModal(), resolvedContainer); // The element was already mounted.\n\n    if (modalRef.current) {\n      handleMounted();\n    }\n  });\n  var isTopModal = react[\"useCallback\"](function () {\n    return manager.isTopModal(getModal());\n  }, [manager]);\n  var handlePortalRef = useEventCallback(function (node) {\n    mountNodeRef.current = node;\n\n    if (!node) {\n      return;\n    }\n\n    if (onRendered) {\n      onRendered();\n    }\n\n    if (open && isTopModal()) {\n      handleMounted();\n    } else {\n      ariaHidden(modalRef.current, true);\n    }\n  });\n  var handleClose = react[\"useCallback\"](function () {\n    manager.remove(getModal());\n  }, [manager]);\n  react[\"useEffect\"](function () {\n    return function () {\n      handleClose();\n    };\n  }, [handleClose]);\n  react[\"useEffect\"](function () {\n    if (open) {\n      handleOpen();\n    } else if (!hasTransition || !closeAfterTransition) {\n      handleClose();\n    }\n  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);\n\n  if (!keepMounted && !open && (!hasTransition || exited)) {\n    return null;\n  }\n\n  var handleEnter = function handleEnter() {\n    setExited(false);\n  };\n\n  var handleExited = function handleExited() {\n    setExited(true);\n\n    if (closeAfterTransition) {\n      handleClose();\n    }\n  };\n\n  var handleBackdropClick = function handleBackdropClick(event) {\n    if (event.target !== event.currentTarget) {\n      return;\n    }\n\n    if (onBackdropClick) {\n      onBackdropClick(event);\n    }\n\n    if (!disableBackdropClick && onClose) {\n      onClose(event, 'backdropClick');\n    }\n  };\n\n  var handleKeyDown = function handleKeyDown(event) {\n    // The handler doesn't take event.defaultPrevented into account:\n    //\n    // event.preventDefault() is meant to stop default behaviours like\n    // clicking a checkbox to check it, hitting a button to submit a form,\n    // and hitting left arrow to move the cursor in a text input etc.\n    // Only special HTML elements have these default behaviors.\n    if (event.key !== 'Escape' || !isTopModal()) {\n      return;\n    }\n\n    if (onEscapeKeyDown) {\n      onEscapeKeyDown(event);\n    }\n\n    if (!disableEscapeKeyDown) {\n      // Swallow the event, in case someone is listening for the escape key on the body.\n      event.stopPropagation();\n\n      if (onClose) {\n        onClose(event, 'escapeKeyDown');\n      }\n    }\n  };\n\n  var inlineStyle = Modal_styles(theme || {\n    zIndex: styles_zIndex\n  });\n  var childProps = {};\n\n  if (children.props.tabIndex === undefined) {\n    childProps.tabIndex = children.props.tabIndex || '-1';\n  } // It's a Transition like component\n\n\n  if (hasTransition) {\n    childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);\n    childProps.onExited = createChainedFunction(handleExited, children.props.onExited);\n  }\n\n  return /*#__PURE__*/react[\"createElement\"](esm_Portal_Portal, {\n    ref: handlePortalRef,\n    container: container,\n    disablePortal: disablePortal\n  }, /*#__PURE__*/react[\"createElement\"](\"div\", _extends({\n    ref: handleRef,\n    onKeyDown: handleKeyDown,\n    role: \"presentation\"\n  }, other, {\n    style: _extends({}, inlineStyle.root, !open && exited ? inlineStyle.hidden : {}, other.style)\n  }), hideBackdrop ? null : /*#__PURE__*/react[\"createElement\"](BackdropComponent, _extends({\n    open: open,\n    onClick: handleBackdropClick\n  }, BackdropProps)), /*#__PURE__*/react[\"createElement\"](Unstable_TrapFocus_Unstable_TrapFocus, {\n    disableEnforceFocus: disableEnforceFocus,\n    disableAutoFocus: disableAutoFocus,\n    disableRestoreFocus: disableRestoreFocus,\n    getDoc: getDoc,\n    isEnabled: isTopModal,\n    open: open\n  }, /*#__PURE__*/react[\"cloneElement\"](children, childProps))));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_Modal_Modal = (Modal_Modal);\n// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/config.js\n/* harmony default export */ var esm_config = ({\n  disabled: false\n});\n// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/Transition.js\n\n\n\n\n\n\n\n\nvar UNMOUNTED = 'unmounted';\nvar EXITED = 'exited';\nvar ENTERING = 'entering';\nvar ENTERED = 'entered';\nvar EXITING = 'exiting';\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it's used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * ---\n *\n * **Note**: `Transition` is a platform-agnostic base component. If you're using\n * transitions in CSS, you'll probably want to use\n * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)\n * instead. It inherits all the features of `Transition`, but contains\n * additional features necessary to play nice with CSS transitions (hence the\n * name of the component).\n *\n * ---\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks \"enter\" and \"exit\" states for the\n * components. It's up to you to give meaning and effect to those states. For\n * example we can add styles to a component when it enters or exits:\n *\n * ```jsx\n * import { Transition } from 'react-transition-group';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 1 },\n *   entered:  { opacity: 1 },\n *   exiting:  { opacity: 0 },\n *   exited:  { opacity: 0 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {state => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I'm a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * There are 4 main states a Transition can be in:\n *  - `'entering'`\n *  - `'entered'`\n *  - `'exiting'`\n *  - `'exited'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component\n * begins the \"Enter\" stage. During this stage, the component will shift from\n * its current transition state, to `'entering'` for the duration of the\n * transition and then to the `'entered'` stage once it's complete. Let's take\n * the following example (we'll use the\n * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):\n *\n * ```jsx\n * function App() {\n *   const [inProp, setInProp] = useState(false);\n *   return (\n *     <div>\n *       <Transition in={inProp} timeout={500}>\n *         {state => (\n *           // ...\n *         )}\n *       </Transition>\n *       <button onClick={() => setInProp(true)}>\n *         Click to Enter\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `'entering'` state\n * and stay there for 500ms (the value of `timeout`) before it finally switches\n * to `'entered'`.\n *\n * When `in` is `false` the same thing happens except the state moves from\n * `'exiting'` to `'exited'`.\n */\n\nvar Transition_Transition = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Transition, _React$Component);\n\n  function Transition(props, context) {\n    var _this;\n\n    _this = _React$Component.call(this, props, context) || this;\n    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears\n\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n    var initialStatus;\n    _this.appearStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref.in;\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return {\n        status: EXITED\n      };\n    }\n\n    return null;\n  } // getSnapshotBeforeUpdate(prevProps) {\n  //   let nextStatus = null\n  //   if (prevProps !== this.props) {\n  //     const { status } = this.state\n  //     if (this.props.in) {\n  //       if (status !== ENTERING && status !== ENTERED) {\n  //         nextStatus = ENTERING\n  //       }\n  //     } else {\n  //       if (status === ENTERING || status === ENTERED) {\n  //         nextStatus = EXITING\n  //       }\n  //     }\n  //   }\n  //   return { nextStatus }\n  // }\n  ;\n\n  var _proto = Transition.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n      if (this.props.in) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else {\n        if (status === ENTERING || status === ENTERED) {\n          nextStatus = EXITING;\n        }\n      }\n    }\n\n    this.updateStatus(false, nextStatus);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  _proto.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var exit, enter, appear;\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== 'number') {\n      exit = timeout.exit;\n      enter = timeout.enter; // TODO: remove fallback for next major\n\n      appear = timeout.appear !== undefined ? timeout.appear : enter;\n    }\n\n    return {\n      exit: exit,\n      enter: enter,\n      appear: appear\n    };\n  };\n\n  _proto.updateStatus = function updateStatus(mounting, nextStatus) {\n    if (mounting === void 0) {\n      mounting = false;\n    }\n\n    if (nextStatus !== null) {\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(mounting);\n      } else {\n        this.performExit();\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n\n  _proto.performEnter = function performEnter(mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n    var appearing = this.context ? this.context.isMounting : mounting;\n\n    var _ref2 = this.props.nodeRef ? [appearing] : [react_dom_default.a.findDOMNode(this), appearing],\n        maybeNode = _ref2[0],\n        maybeAppearing = _ref2[1];\n\n    var timeouts = this.getTimeouts();\n    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n\n    if (!mounting && !enter || esm_config.disabled) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        _this2.props.onEntered(maybeNode);\n      });\n      return;\n    }\n\n    this.props.onEnter(maybeNode, maybeAppearing);\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      _this2.props.onEntering(maybeNode, maybeAppearing);\n\n      _this2.onTransitionEnd(enterTimeout, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          _this2.props.onEntered(maybeNode, maybeAppearing);\n        });\n      });\n    });\n  };\n\n  _proto.performExit = function performExit() {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts();\n    var maybeNode = this.props.nodeRef ? undefined : react_dom_default.a.findDOMNode(this); // no exit animation skip right to EXITED\n\n    if (!exit || esm_config.disabled) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        _this3.props.onExited(maybeNode);\n      });\n      return;\n    }\n\n    this.props.onExit(maybeNode);\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      _this3.props.onExiting(maybeNode);\n\n      _this3.onTransitionEnd(timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          _this3.props.onExited(maybeNode);\n        });\n      });\n    });\n  };\n\n  _proto.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  _proto.safeSetState = function safeSetState(nextState, callback) {\n    // This shouldn't be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  _proto.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {\n    this.setNextCallback(handler);\n    var node = this.props.nodeRef ? this.props.nodeRef.current : react_dom_default.a.findDOMNode(this);\n    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;\n\n    if (!node || doesNotHaveTimeoutOrListener) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n\n    if (this.props.addEndListener) {\n      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],\n          maybeNode = _ref3[0],\n          maybeNextCallback = _ref3[1];\n\n      this.props.addEndListener(maybeNode, maybeNextCallback);\n    }\n\n    if (timeout != null) {\n      setTimeout(this.nextCallback, timeout);\n    }\n  };\n\n  _proto.render = function render() {\n    var status = this.state.status;\n\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _this$props = this.props,\n        children = _this$props.children,\n        _in = _this$props.in,\n        _mountOnEnter = _this$props.mountOnEnter,\n        _unmountOnExit = _this$props.unmountOnExit,\n        _appear = _this$props.appear,\n        _enter = _this$props.enter,\n        _exit = _this$props.exit,\n        _timeout = _this$props.timeout,\n        _addEndListener = _this$props.addEndListener,\n        _onEnter = _this$props.onEnter,\n        _onEntering = _this$props.onEntering,\n        _onEntered = _this$props.onEntered,\n        _onExit = _this$props.onExit,\n        _onExiting = _this$props.onExiting,\n        _onExited = _this$props.onExited,\n        _nodeRef = _this$props.nodeRef,\n        childProps = _objectWithoutPropertiesLoose(_this$props, [\"children\", \"in\", \"mountOnEnter\", \"unmountOnExit\", \"appear\", \"enter\", \"exit\", \"timeout\", \"addEndListener\", \"onEnter\", \"onEntering\", \"onEntered\", \"onExit\", \"onExiting\", \"onExited\", \"nodeRef\"]);\n\n    return (\n      /*#__PURE__*/\n      // allows for nested Transitions\n      react_default.a.createElement(TransitionGroupContext.Provider, {\n        value: null\n      }, typeof children === 'function' ? children(status, childProps) : react_default.a.cloneElement(react_default.a.Children.only(children), childProps))\n    );\n  };\n\n  return Transition;\n}(react_default.a.Component);\n\nTransition_Transition.contextType = TransitionGroupContext;\nTransition_Transition.propTypes =  false ? undefined : {}; // Name the function so it is clearer in the documentation\n\nfunction noop() {}\n\nTransition_Transition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\nTransition_Transition.UNMOUNTED = UNMOUNTED;\nTransition_Transition.EXITED = EXITED;\nTransition_Transition.ENTERING = ENTERING;\nTransition_Transition.ENTERED = ENTERED;\nTransition_Transition.EXITING = EXITING;\n/* harmony default export */ var esm_Transition = (Transition_Transition);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/transitions/utils.js\nvar reflow = function reflow(node) {\n  return node.scrollTop;\n};\nfunction getTransitionProps(props, options) {\n  var timeout = props.timeout,\n      _props$style = props.style,\n      style = _props$style === void 0 ? {} : _props$style;\n  return {\n    duration: style.transitionDuration || typeof timeout === 'number' ? timeout : timeout[options.mode] || 0,\n    delay: style.transitionDelay\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Grow/Grow.js\n\n\n\n\n\n\n\n\n\n\nfunction getScale(value) {\n  return \"scale(\".concat(value, \", \").concat(Math.pow(value, 2), \")\");\n}\n\nvar Grow_styles = {\n  entering: {\n    opacity: 1,\n    transform: getScale(1)\n  },\n  entered: {\n    opacity: 1,\n    transform: 'none'\n  }\n};\n/**\n * The Grow transition is used by the [Tooltip](/components/tooltips/) and\n * [Popover](/components/popover/) components.\n * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.\n */\n\nvar Grow_Grow = /*#__PURE__*/react[\"forwardRef\"](function Grow(props, ref) {\n  var children = props.children,\n      _props$disableStrictM = props.disableStrictModeCompat,\n      disableStrictModeCompat = _props$disableStrictM === void 0 ? false : _props$disableStrictM,\n      inProp = props.in,\n      onEnter = props.onEnter,\n      onEntered = props.onEntered,\n      onEntering = props.onEntering,\n      onExit = props.onExit,\n      onExited = props.onExited,\n      onExiting = props.onExiting,\n      style = props.style,\n      _props$timeout = props.timeout,\n      timeout = _props$timeout === void 0 ? 'auto' : _props$timeout,\n      _props$TransitionComp = props.TransitionComponent,\n      TransitionComponent = _props$TransitionComp === void 0 ? esm_Transition : _props$TransitionComp,\n      other = _objectWithoutProperties(props, [\"children\", \"disableStrictModeCompat\", \"in\", \"onEnter\", \"onEntered\", \"onEntering\", \"onExit\", \"onExited\", \"onExiting\", \"style\", \"timeout\", \"TransitionComponent\"]);\n\n  var timer = react[\"useRef\"]();\n  var autoTimeout = react[\"useRef\"]();\n  var theme = useTheme_useTheme();\n  var enableStrictModeCompat = theme.unstable_strictMode && !disableStrictModeCompat;\n  var nodeRef = react[\"useRef\"](null);\n  var foreignRef = useForkRef(children.ref, ref);\n  var handleRef = useForkRef(enableStrictModeCompat ? nodeRef : undefined, foreignRef);\n\n  var normalizedTransitionCallback = function normalizedTransitionCallback(callback) {\n    return function (nodeOrAppearing, maybeAppearing) {\n      if (callback) {\n        var _ref = enableStrictModeCompat ? [nodeRef.current, nodeOrAppearing] : [nodeOrAppearing, maybeAppearing],\n            _ref2 = _slicedToArray(_ref, 2),\n            node = _ref2[0],\n            isAppearing = _ref2[1]; // onEnterXxx and onExitXxx callbacks have a different arguments.length value.\n\n\n        if (isAppearing === undefined) {\n          callback(node);\n        } else {\n          callback(node, isAppearing);\n        }\n      }\n    };\n  };\n\n  var handleEntering = normalizedTransitionCallback(onEntering);\n  var handleEnter = normalizedTransitionCallback(function (node, isAppearing) {\n    reflow(node); // So the animation always start from the start.\n\n    var _getTransitionProps = getTransitionProps({\n      style: style,\n      timeout: timeout\n    }, {\n      mode: 'enter'\n    }),\n        transitionDuration = _getTransitionProps.duration,\n        delay = _getTransitionProps.delay;\n\n    var duration;\n\n    if (timeout === 'auto') {\n      duration = theme.transitions.getAutoHeightDuration(node.clientHeight);\n      autoTimeout.current = duration;\n    } else {\n      duration = transitionDuration;\n    }\n\n    node.style.transition = [theme.transitions.create('opacity', {\n      duration: duration,\n      delay: delay\n    }), theme.transitions.create('transform', {\n      duration: duration * 0.666,\n      delay: delay\n    })].join(',');\n\n    if (onEnter) {\n      onEnter(node, isAppearing);\n    }\n  });\n  var handleEntered = normalizedTransitionCallback(onEntered);\n  var handleExiting = normalizedTransitionCallback(onExiting);\n  var handleExit = normalizedTransitionCallback(function (node) {\n    var _getTransitionProps2 = getTransitionProps({\n      style: style,\n      timeout: timeout\n    }, {\n      mode: 'exit'\n    }),\n        transitionDuration = _getTransitionProps2.duration,\n        delay = _getTransitionProps2.delay;\n\n    var duration;\n\n    if (timeout === 'auto') {\n      duration = theme.transitions.getAutoHeightDuration(node.clientHeight);\n      autoTimeout.current = duration;\n    } else {\n      duration = transitionDuration;\n    }\n\n    node.style.transition = [theme.transitions.create('opacity', {\n      duration: duration,\n      delay: delay\n    }), theme.transitions.create('transform', {\n      duration: duration * 0.666,\n      delay: delay || duration * 0.333\n    })].join(',');\n    node.style.opacity = '0';\n    node.style.transform = getScale(0.75);\n\n    if (onExit) {\n      onExit(node);\n    }\n  });\n  var handleExited = normalizedTransitionCallback(onExited);\n\n  var addEndListener = function addEndListener(nodeOrNext, maybeNext) {\n    var next = enableStrictModeCompat ? nodeOrNext : maybeNext;\n\n    if (timeout === 'auto') {\n      timer.current = setTimeout(next, autoTimeout.current || 0);\n    }\n  };\n\n  react[\"useEffect\"](function () {\n    return function () {\n      clearTimeout(timer.current);\n    };\n  }, []);\n  return /*#__PURE__*/react[\"createElement\"](TransitionComponent, _extends({\n    appear: true,\n    in: inProp,\n    nodeRef: enableStrictModeCompat ? nodeRef : undefined,\n    onEnter: handleEnter,\n    onEntered: handleEntered,\n    onEntering: handleEntering,\n    onExit: handleExit,\n    onExited: handleExited,\n    onExiting: handleExiting,\n    addEndListener: addEndListener,\n    timeout: timeout === 'auto' ? null : timeout\n  }, other), function (state, childProps) {\n    return /*#__PURE__*/react[\"cloneElement\"](children, _extends({\n      style: _extends({\n        opacity: 0,\n        transform: getScale(0.75),\n        visibility: state === 'exited' && !inProp ? 'hidden' : undefined\n      }, Grow_styles[state], style, children.props.style),\n      ref: handleRef\n    }, childProps));\n  });\n});\n false ? undefined : void 0;\nGrow_Grow.muiSupportAuto = true;\n/* harmony default export */ var esm_Grow_Grow = (Grow_Grow);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Popover/Popover.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getOffsetTop(rect, vertical) {\n  var offset = 0;\n\n  if (typeof vertical === 'number') {\n    offset = vertical;\n  } else if (vertical === 'center') {\n    offset = rect.height / 2;\n  } else if (vertical === 'bottom') {\n    offset = rect.height;\n  }\n\n  return offset;\n}\nfunction getOffsetLeft(rect, horizontal) {\n  var offset = 0;\n\n  if (typeof horizontal === 'number') {\n    offset = horizontal;\n  } else if (horizontal === 'center') {\n    offset = rect.width / 2;\n  } else if (horizontal === 'right') {\n    offset = rect.width;\n  }\n\n  return offset;\n}\n\nfunction getTransformOriginValue(transformOrigin) {\n  return [transformOrigin.horizontal, transformOrigin.vertical].map(function (n) {\n    return typeof n === 'number' ? \"\".concat(n, \"px\") : n;\n  }).join(' ');\n} // Sum the scrollTop between two elements.\n\n\nfunction getScrollParent(parent, child) {\n  var element = child;\n  var scrollTop = 0;\n\n  while (element && element !== parent) {\n    element = element.parentElement;\n    scrollTop += element.scrollTop;\n  }\n\n  return scrollTop;\n}\n\nfunction getAnchorEl(anchorEl) {\n  return typeof anchorEl === 'function' ? anchorEl() : anchorEl;\n}\n\nvar Popover_styles = {\n  /* Styles applied to the root element. */\n  root: {},\n\n  /* Styles applied to the `Paper` component. */\n  paper: {\n    position: 'absolute',\n    overflowY: 'auto',\n    overflowX: 'hidden',\n    // So we see the popover when it's empty.\n    // It's most likely on issue on userland.\n    minWidth: 16,\n    minHeight: 16,\n    maxWidth: 'calc(100% - 32px)',\n    maxHeight: 'calc(100% - 32px)',\n    // We disable the focus ring for mouse, touch and keyboard users.\n    outline: 0\n  }\n};\nvar Popover_Popover = /*#__PURE__*/react[\"forwardRef\"](function Popover(props, ref) {\n  var action = props.action,\n      anchorEl = props.anchorEl,\n      _props$anchorOrigin = props.anchorOrigin,\n      anchorOrigin = _props$anchorOrigin === void 0 ? {\n    vertical: 'top',\n    horizontal: 'left'\n  } : _props$anchorOrigin,\n      anchorPosition = props.anchorPosition,\n      _props$anchorReferenc = props.anchorReference,\n      anchorReference = _props$anchorReferenc === void 0 ? 'anchorEl' : _props$anchorReferenc,\n      children = props.children,\n      classes = props.classes,\n      className = props.className,\n      containerProp = props.container,\n      _props$elevation = props.elevation,\n      elevation = _props$elevation === void 0 ? 8 : _props$elevation,\n      getContentAnchorEl = props.getContentAnchorEl,\n      _props$marginThreshol = props.marginThreshold,\n      marginThreshold = _props$marginThreshol === void 0 ? 16 : _props$marginThreshol,\n      onEnter = props.onEnter,\n      onEntered = props.onEntered,\n      onEntering = props.onEntering,\n      onExit = props.onExit,\n      onExited = props.onExited,\n      onExiting = props.onExiting,\n      open = props.open,\n      _props$PaperProps = props.PaperProps,\n      PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,\n      _props$transformOrigi = props.transformOrigin,\n      transformOrigin = _props$transformOrigi === void 0 ? {\n    vertical: 'top',\n    horizontal: 'left'\n  } : _props$transformOrigi,\n      _props$TransitionComp = props.TransitionComponent,\n      TransitionComponent = _props$TransitionComp === void 0 ? esm_Grow_Grow : _props$TransitionComp,\n      _props$transitionDura = props.transitionDuration,\n      transitionDurationProp = _props$transitionDura === void 0 ? 'auto' : _props$transitionDura,\n      _props$TransitionProp = props.TransitionProps,\n      TransitionProps = _props$TransitionProp === void 0 ? {} : _props$TransitionProp,\n      other = _objectWithoutProperties(props, [\"action\", \"anchorEl\", \"anchorOrigin\", \"anchorPosition\", \"anchorReference\", \"children\", \"classes\", \"className\", \"container\", \"elevation\", \"getContentAnchorEl\", \"marginThreshold\", \"onEnter\", \"onEntered\", \"onEntering\", \"onExit\", \"onExited\", \"onExiting\", \"open\", \"PaperProps\", \"transformOrigin\", \"TransitionComponent\", \"transitionDuration\", \"TransitionProps\"]);\n\n  var paperRef = react[\"useRef\"](); // Returns the top/left offset of the position\n  // to attach to on the anchor element (or body if none is provided)\n\n  var getAnchorOffset = react[\"useCallback\"](function (contentAnchorOffset) {\n    if (anchorReference === 'anchorPosition') {\n      if (false) {}\n\n      return anchorPosition;\n    }\n\n    var resolvedAnchorEl = getAnchorEl(anchorEl); // If an anchor element wasn't provided, just use the parent body element of this Popover\n\n    var anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;\n    var anchorRect = anchorElement.getBoundingClientRect();\n\n    if (false) { var box; }\n\n    var anchorVertical = contentAnchorOffset === 0 ? anchorOrigin.vertical : 'center';\n    return {\n      top: anchorRect.top + getOffsetTop(anchorRect, anchorVertical),\n      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)\n    };\n  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]); // Returns the vertical offset of inner content to anchor the transform on if provided\n\n  var getContentAnchorOffset = react[\"useCallback\"](function (element) {\n    var contentAnchorOffset = 0;\n\n    if (getContentAnchorEl && anchorReference === 'anchorEl') {\n      var contentAnchorEl = getContentAnchorEl(element);\n\n      if (contentAnchorEl && element.contains(contentAnchorEl)) {\n        var scrollTop = getScrollParent(element, contentAnchorEl);\n        contentAnchorOffset = contentAnchorEl.offsetTop + contentAnchorEl.clientHeight / 2 - scrollTop || 0;\n      } // != the default value\n\n\n      if (false) {}\n    }\n\n    return contentAnchorOffset;\n  }, [anchorOrigin.vertical, anchorReference, getContentAnchorEl]); // Return the base transform origin using the element\n  // and taking the content anchor offset into account if in use\n\n  var getTransformOrigin = react[\"useCallback\"](function (elemRect) {\n    var contentAnchorOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return {\n      vertical: getOffsetTop(elemRect, transformOrigin.vertical) + contentAnchorOffset,\n      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)\n    };\n  }, [transformOrigin.horizontal, transformOrigin.vertical]);\n  var getPositioningStyle = react[\"useCallback\"](function (element) {\n    // Check if the parent has requested anchoring on an inner content node\n    var contentAnchorOffset = getContentAnchorOffset(element);\n    var elemRect = {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    }; // Get the transform origin point on the element itself\n\n    var elemTransformOrigin = getTransformOrigin(elemRect, contentAnchorOffset);\n\n    if (anchorReference === 'none') {\n      return {\n        top: null,\n        left: null,\n        transformOrigin: getTransformOriginValue(elemTransformOrigin)\n      };\n    } // Get the offset of of the anchoring element\n\n\n    var anchorOffset = getAnchorOffset(contentAnchorOffset); // Calculate element positioning\n\n    var top = anchorOffset.top - elemTransformOrigin.vertical;\n    var left = anchorOffset.left - elemTransformOrigin.horizontal;\n    var bottom = top + elemRect.height;\n    var right = left + elemRect.width; // Use the parent window of the anchorEl if provided\n\n    var containerWindow = ownerWindow(getAnchorEl(anchorEl)); // Window thresholds taking required margin into account\n\n    var heightThreshold = containerWindow.innerHeight - marginThreshold;\n    var widthThreshold = containerWindow.innerWidth - marginThreshold; // Check if the vertical axis needs shifting\n\n    if (top < marginThreshold) {\n      var diff = top - marginThreshold;\n      top -= diff;\n      elemTransformOrigin.vertical += diff;\n    } else if (bottom > heightThreshold) {\n      var _diff = bottom - heightThreshold;\n\n      top -= _diff;\n      elemTransformOrigin.vertical += _diff;\n    }\n\n    if (false) {} // Check if the horizontal axis needs shifting\n\n\n    if (left < marginThreshold) {\n      var _diff2 = left - marginThreshold;\n\n      left -= _diff2;\n      elemTransformOrigin.horizontal += _diff2;\n    } else if (right > widthThreshold) {\n      var _diff3 = right - widthThreshold;\n\n      left -= _diff3;\n      elemTransformOrigin.horizontal += _diff3;\n    }\n\n    return {\n      top: \"\".concat(Math.round(top), \"px\"),\n      left: \"\".concat(Math.round(left), \"px\"),\n      transformOrigin: getTransformOriginValue(elemTransformOrigin)\n    };\n  }, [anchorEl, anchorReference, getAnchorOffset, getContentAnchorOffset, getTransformOrigin, marginThreshold]);\n  var setPositioningStyles = react[\"useCallback\"](function () {\n    var element = paperRef.current;\n\n    if (!element) {\n      return;\n    }\n\n    var positioning = getPositioningStyle(element);\n\n    if (positioning.top !== null) {\n      element.style.top = positioning.top;\n    }\n\n    if (positioning.left !== null) {\n      element.style.left = positioning.left;\n    }\n\n    element.style.transformOrigin = positioning.transformOrigin;\n  }, [getPositioningStyle]);\n\n  var handleEntering = function handleEntering(element, isAppearing) {\n    if (onEntering) {\n      onEntering(element, isAppearing);\n    }\n\n    setPositioningStyles();\n  };\n\n  var handlePaperRef = react[\"useCallback\"](function (instance) {\n    // #StrictMode ready\n    paperRef.current = react_dom[\"findDOMNode\"](instance);\n  }, []);\n  react[\"useEffect\"](function () {\n    if (open) {\n      setPositioningStyles();\n    }\n  });\n  react[\"useImperativeHandle\"](action, function () {\n    return open ? {\n      updatePosition: function updatePosition() {\n        setPositioningStyles();\n      }\n    } : null;\n  }, [open, setPositioningStyles]);\n  react[\"useEffect\"](function () {\n    if (!open) {\n      return undefined;\n    }\n\n    var handleResize = debounce(function () {\n      setPositioningStyles();\n    });\n    window.addEventListener('resize', handleResize);\n    return function () {\n      handleResize.clear();\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [open, setPositioningStyles]);\n  var transitionDuration = transitionDurationProp;\n\n  if (transitionDurationProp === 'auto' && !TransitionComponent.muiSupportAuto) {\n    transitionDuration = undefined;\n  } // If the container prop is provided, use that\n  // If the anchorEl prop is provided, use its parent body element as the container\n  // If neither are provided let the Modal take care of choosing the container\n\n\n  var container = containerProp || (anchorEl ? ownerDocument(getAnchorEl(anchorEl)).body : undefined);\n  return /*#__PURE__*/react[\"createElement\"](esm_Modal_Modal, _extends({\n    container: container,\n    open: open,\n    ref: ref,\n    BackdropProps: {\n      invisible: true\n    },\n    className: clsx_m(classes.root, className)\n  }, other), /*#__PURE__*/react[\"createElement\"](TransitionComponent, _extends({\n    appear: true,\n    in: open,\n    onEnter: onEnter,\n    onEntered: onEntered,\n    onExit: onExit,\n    onExited: onExited,\n    onExiting: onExiting,\n    timeout: transitionDuration\n  }, TransitionProps, {\n    onEntering: createChainedFunction(handleEntering, TransitionProps.onEntering)\n  }), /*#__PURE__*/react[\"createElement\"](esm_Paper_Paper, _extends({\n    elevation: elevation,\n    ref: handlePaperRef\n  }, PaperProps, {\n    className: clsx_m(classes.paper, PaperProps.className)\n  }), children)));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_Popover_Popover = (styles_withStyles(Popover_styles, {\n  name: 'MuiPopover'\n})(Popover_Popover));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/MenuList/MenuList.js\n\n\n\n\n\n\n\n\n\n\n\nfunction nextItem(list, item, disableListWrap) {\n  if (list === item) {\n    return list.firstChild;\n  }\n\n  if (item && item.nextElementSibling) {\n    return item.nextElementSibling;\n  }\n\n  return disableListWrap ? null : list.firstChild;\n}\n\nfunction previousItem(list, item, disableListWrap) {\n  if (list === item) {\n    return disableListWrap ? list.firstChild : list.lastChild;\n  }\n\n  if (item && item.previousElementSibling) {\n    return item.previousElementSibling;\n  }\n\n  return disableListWrap ? null : list.lastChild;\n}\n\nfunction textCriteriaMatches(nextFocus, textCriteria) {\n  if (textCriteria === undefined) {\n    return true;\n  }\n\n  var text = nextFocus.innerText;\n\n  if (text === undefined) {\n    // jsdom doesn't support innerText\n    text = nextFocus.textContent;\n  }\n\n  text = text.trim().toLowerCase();\n\n  if (text.length === 0) {\n    return false;\n  }\n\n  if (textCriteria.repeating) {\n    return text[0] === textCriteria.keys[0];\n  }\n\n  return text.indexOf(textCriteria.keys.join('')) === 0;\n}\n\nfunction moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {\n  var wrappedOnce = false;\n  var nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);\n\n  while (nextFocus) {\n    // Prevent infinite loop.\n    if (nextFocus === list.firstChild) {\n      if (wrappedOnce) {\n        return;\n      }\n\n      wrappedOnce = true;\n    } // Same logic as useAutocomplete.js\n\n\n    var nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';\n\n    if (!nextFocus.hasAttribute('tabindex') || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {\n      // Move to the next element.\n      nextFocus = traversalFunction(list, nextFocus, disableListWrap);\n    } else {\n      nextFocus.focus();\n      return;\n    }\n  }\n}\n\nvar MenuList_useEnhancedEffect = typeof window === 'undefined' ? react[\"useEffect\"] : react[\"useLayoutEffect\"];\n/**\n * A permanently displayed menu following https://www.w3.org/TR/wai-aria-practices/#menubutton.\n * It's exposed to help customization of the [`Menu`](/api/menu/) component. If you\n * use it separately you need to move focus into the component manually. Once\n * the focus is placed inside the component it is fully keyboard accessible.\n */\n\nvar MenuList_MenuList = /*#__PURE__*/react[\"forwardRef\"](function MenuList(props, ref) {\n  var actions = props.actions,\n      _props$autoFocus = props.autoFocus,\n      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,\n      _props$autoFocusItem = props.autoFocusItem,\n      autoFocusItem = _props$autoFocusItem === void 0 ? false : _props$autoFocusItem,\n      children = props.children,\n      className = props.className,\n      _props$disabledItemsF = props.disabledItemsFocusable,\n      disabledItemsFocusable = _props$disabledItemsF === void 0 ? false : _props$disabledItemsF,\n      _props$disableListWra = props.disableListWrap,\n      disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra,\n      onKeyDown = props.onKeyDown,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'selectedMenu' : _props$variant,\n      other = _objectWithoutProperties(props, [\"actions\", \"autoFocus\", \"autoFocusItem\", \"children\", \"className\", \"disabledItemsFocusable\", \"disableListWrap\", \"onKeyDown\", \"variant\"]);\n\n  var listRef = react[\"useRef\"](null);\n  var textCriteriaRef = react[\"useRef\"]({\n    keys: [],\n    repeating: true,\n    previousKeyMatched: true,\n    lastTime: null\n  });\n  MenuList_useEnhancedEffect(function () {\n    if (autoFocus) {\n      listRef.current.focus();\n    }\n  }, [autoFocus]);\n  react[\"useImperativeHandle\"](actions, function () {\n    return {\n      adjustStyleForScrollbar: function adjustStyleForScrollbar(containerElement, theme) {\n        // Let's ignore that piece of logic if users are already overriding the width\n        // of the menu.\n        var noExplicitWidth = !listRef.current.style.width;\n\n        if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {\n          var scrollbarSize = \"\".concat(getScrollbarSize(true), \"px\");\n          listRef.current.style[theme.direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;\n          listRef.current.style.width = \"calc(100% + \".concat(scrollbarSize, \")\");\n        }\n\n        return listRef.current;\n      }\n    };\n  }, []);\n\n  var handleKeyDown = function handleKeyDown(event) {\n    var list = listRef.current;\n    var key = event.key;\n    /**\n     * @type {Element} - will always be defined since we are in a keydown handler\n     * attached to an element. A keydown event is either dispatched to the activeElement\n     * or document.body or document.documentElement. Only the first case will\n     * trigger this specific handler.\n     */\n\n    var currentFocus = ownerDocument(list).activeElement;\n\n    if (key === 'ArrowDown') {\n      // Prevent scroll of the page\n      event.preventDefault();\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);\n    } else if (key === 'ArrowUp') {\n      event.preventDefault();\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);\n    } else if (key === 'Home') {\n      event.preventDefault();\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);\n    } else if (key === 'End') {\n      event.preventDefault();\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);\n    } else if (key.length === 1) {\n      var criteria = textCriteriaRef.current;\n      var lowerKey = key.toLowerCase();\n      var currTime = performance.now();\n\n      if (criteria.keys.length > 0) {\n        // Reset\n        if (currTime - criteria.lastTime > 500) {\n          criteria.keys = [];\n          criteria.repeating = true;\n          criteria.previousKeyMatched = true;\n        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {\n          criteria.repeating = false;\n        }\n      }\n\n      criteria.lastTime = currTime;\n      criteria.keys.push(lowerKey);\n      var keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);\n\n      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {\n        event.preventDefault();\n      } else {\n        criteria.previousKeyMatched = false;\n      }\n    }\n\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n\n  var handleOwnRef = react[\"useCallback\"](function (instance) {\n    // #StrictMode ready\n    listRef.current = react_dom[\"findDOMNode\"](instance);\n  }, []);\n  var handleRef = useForkRef(handleOwnRef, ref);\n  /**\n   * the index of the item should receive focus\n   * in a `variant=\"selectedMenu\"` it's the first `selected` item\n   * otherwise it's the very first item.\n   */\n\n  var activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead\n  // to check if there is a `selected` item. We're looking for the last `selected`\n  // item and use the first valid item as a fallback\n\n  react[\"Children\"].forEach(children, function (child, index) {\n    if (! /*#__PURE__*/react[\"isValidElement\"](child)) {\n      return;\n    }\n\n    if (false) {}\n\n    if (!child.props.disabled) {\n      if (variant === 'selectedMenu' && child.props.selected) {\n        activeItemIndex = index;\n      } else if (activeItemIndex === -1) {\n        activeItemIndex = index;\n      }\n    }\n  });\n  var items = react[\"Children\"].map(children, function (child, index) {\n    if (index === activeItemIndex) {\n      var newChildProps = {};\n\n      if (autoFocusItem) {\n        newChildProps.autoFocus = true;\n      }\n\n      if (child.props.tabIndex === undefined && variant === 'selectedMenu') {\n        newChildProps.tabIndex = 0;\n      }\n\n      return /*#__PURE__*/react[\"cloneElement\"](child, newChildProps);\n    }\n\n    return child;\n  });\n  return /*#__PURE__*/react[\"createElement\"](esm_List_List, _extends({\n    role: \"menu\",\n    ref: handleRef,\n    className: className,\n    onKeyDown: handleKeyDown,\n    tabIndex: autoFocus ? 0 : -1\n  }, other), items);\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_MenuList_MenuList = (MenuList_MenuList);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Menu/Menu.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar RTL_ORIGIN = {\n  vertical: 'top',\n  horizontal: 'right'\n};\nvar LTR_ORIGIN = {\n  vertical: 'top',\n  horizontal: 'left'\n};\nvar Menu_styles = {\n  /* Styles applied to the `Paper` component. */\n  paper: {\n    // specZ: The maximum height of a simple menu should be one or more rows less than the view\n    // height. This ensures a tapable area outside of the simple menu with which to dismiss\n    // the menu.\n    maxHeight: 'calc(100% - 96px)',\n    // Add iOS momentum scrolling.\n    WebkitOverflowScrolling: 'touch'\n  },\n\n  /* Styles applied to the `List` component via `MenuList`. */\n  list: {\n    // We disable the focus ring for mouse, touch and keyboard users.\n    outline: 0\n  }\n};\nvar Menu_Menu = /*#__PURE__*/react[\"forwardRef\"](function Menu(props, ref) {\n  var _props$autoFocus = props.autoFocus,\n      autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus,\n      children = props.children,\n      classes = props.classes,\n      _props$disableAutoFoc = props.disableAutoFocusItem,\n      disableAutoFocusItem = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,\n      _props$MenuListProps = props.MenuListProps,\n      MenuListProps = _props$MenuListProps === void 0 ? {} : _props$MenuListProps,\n      onClose = props.onClose,\n      onEntering = props.onEntering,\n      open = props.open,\n      _props$PaperProps = props.PaperProps,\n      PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,\n      PopoverClasses = props.PopoverClasses,\n      _props$transitionDura = props.transitionDuration,\n      transitionDuration = _props$transitionDura === void 0 ? 'auto' : _props$transitionDura,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'selectedMenu' : _props$variant,\n      other = _objectWithoutProperties(props, [\"autoFocus\", \"children\", \"classes\", \"disableAutoFocusItem\", \"MenuListProps\", \"onClose\", \"onEntering\", \"open\", \"PaperProps\", \"PopoverClasses\", \"transitionDuration\", \"variant\"]);\n\n  var theme = useTheme_useTheme();\n  var autoFocusItem = autoFocus && !disableAutoFocusItem && open;\n  var menuListActionsRef = react[\"useRef\"](null);\n  var contentAnchorRef = react[\"useRef\"](null);\n\n  var getContentAnchorEl = function getContentAnchorEl() {\n    return contentAnchorRef.current;\n  };\n\n  var handleEntering = function handleEntering(element, isAppearing) {\n    if (menuListActionsRef.current) {\n      menuListActionsRef.current.adjustStyleForScrollbar(element, theme);\n    }\n\n    if (onEntering) {\n      onEntering(element, isAppearing);\n    }\n  };\n\n  var handleListKeyDown = function handleListKeyDown(event) {\n    if (event.key === 'Tab') {\n      event.preventDefault();\n\n      if (onClose) {\n        onClose(event, 'tabKeyDown');\n      }\n    }\n  };\n  /**\n   * the index of the item should receive focus\n   * in a `variant=\"selectedMenu\"` it's the first `selected` item\n   * otherwise it's the very first item.\n   */\n\n\n  var activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead\n  // to check if there is a `selected` item. We're looking for the last `selected`\n  // item and use the first valid item as a fallback\n\n  react[\"Children\"].map(children, function (child, index) {\n    if (! /*#__PURE__*/react[\"isValidElement\"](child)) {\n      return;\n    }\n\n    if (false) {}\n\n    if (!child.props.disabled) {\n      if (variant !== \"menu\" && child.props.selected) {\n        activeItemIndex = index;\n      } else if (activeItemIndex === -1) {\n        activeItemIndex = index;\n      }\n    }\n  });\n  var items = react[\"Children\"].map(children, function (child, index) {\n    if (index === activeItemIndex) {\n      return /*#__PURE__*/react[\"cloneElement\"](child, {\n        ref: function ref(instance) {\n          // #StrictMode ready\n          contentAnchorRef.current = react_dom[\"findDOMNode\"](instance);\n          setRef(child.ref, instance);\n        }\n      });\n    }\n\n    return child;\n  });\n  return /*#__PURE__*/react[\"createElement\"](esm_Popover_Popover, _extends({\n    getContentAnchorEl: getContentAnchorEl,\n    classes: PopoverClasses,\n    onClose: onClose,\n    onEntering: handleEntering,\n    anchorOrigin: theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN,\n    transformOrigin: theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN,\n    PaperProps: _extends({}, PaperProps, {\n      classes: _extends({}, PaperProps.classes, {\n        root: classes.paper\n      })\n    }),\n    open: open,\n    ref: ref,\n    transitionDuration: transitionDuration\n  }, other), /*#__PURE__*/react[\"createElement\"](esm_MenuList_MenuList, _extends({\n    onKeyDown: handleListKeyDown,\n    actions: menuListActionsRef,\n    autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),\n    autoFocusItem: autoFocusItem,\n    variant: variant\n  }, MenuListProps, {\n    className: clsx_m(classes.list, MenuListProps.className)\n  }), items));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_Menu_Menu = (styles_withStyles(Menu_styles, {\n  name: 'MuiMenu'\n})(Menu_Menu));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/useControlled.js\n/* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */\n\nfunction useControlled(_ref) {\n  var controlled = _ref.controlled,\n      defaultProp = _ref.default,\n      name = _ref.name,\n      _ref$state = _ref.state,\n      state = _ref$state === void 0 ? 'value' : _ref$state;\n\n  var _React$useRef = react[\"useRef\"](controlled !== undefined),\n      isControlled = _React$useRef.current;\n\n  var _React$useState = react[\"useState\"](defaultProp),\n      valueState = _React$useState[0],\n      setValue = _React$useState[1];\n\n  var value = isControlled ? controlled : valueState;\n\n  if (false) { var _React$useRef2, defaultValue; }\n\n  var setValueIfUncontrolled = react[\"useCallback\"](function (newValue) {\n    if (!isControlled) {\n      setValue(newValue);\n    }\n  }, []);\n  return [value, setValueIfUncontrolled];\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Select/SelectInput.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction areEqualValues(a, b) {\n  if (typeof_typeof(b) === 'object' && b !== null) {\n    return a === b;\n  }\n\n  return String(a) === String(b);\n}\n\nfunction isEmpty(display) {\n  return display == null || typeof display === 'string' && !display.trim();\n}\n/**\n * @ignore - internal component.\n */\n\n\nvar SelectInput_SelectInput = /*#__PURE__*/react[\"forwardRef\"](function SelectInput(props, ref) {\n  var ariaLabel = props['aria-label'],\n      autoFocus = props.autoFocus,\n      autoWidth = props.autoWidth,\n      children = props.children,\n      classes = props.classes,\n      className = props.className,\n      defaultValue = props.defaultValue,\n      disabled = props.disabled,\n      displayEmpty = props.displayEmpty,\n      IconComponent = props.IconComponent,\n      inputRefProp = props.inputRef,\n      labelId = props.labelId,\n      _props$MenuProps = props.MenuProps,\n      MenuProps = _props$MenuProps === void 0 ? {} : _props$MenuProps,\n      multiple = props.multiple,\n      name = props.name,\n      onBlur = props.onBlur,\n      onChange = props.onChange,\n      onClose = props.onClose,\n      onFocus = props.onFocus,\n      onOpen = props.onOpen,\n      openProp = props.open,\n      readOnly = props.readOnly,\n      renderValue = props.renderValue,\n      _props$SelectDisplayP = props.SelectDisplayProps,\n      SelectDisplayProps = _props$SelectDisplayP === void 0 ? {} : _props$SelectDisplayP,\n      tabIndexProp = props.tabIndex,\n      type = props.type,\n      valueProp = props.value,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'standard' : _props$variant,\n      other = _objectWithoutProperties(props, [\"aria-label\", \"autoFocus\", \"autoWidth\", \"children\", \"classes\", \"className\", \"defaultValue\", \"disabled\", \"displayEmpty\", \"IconComponent\", \"inputRef\", \"labelId\", \"MenuProps\", \"multiple\", \"name\", \"onBlur\", \"onChange\", \"onClose\", \"onFocus\", \"onOpen\", \"open\", \"readOnly\", \"renderValue\", \"SelectDisplayProps\", \"tabIndex\", \"type\", \"value\", \"variant\"]);\n\n  var _useControlled = useControlled({\n    controlled: valueProp,\n    default: defaultValue,\n    name: 'Select'\n  }),\n      _useControlled2 = _slicedToArray(_useControlled, 2),\n      value = _useControlled2[0],\n      setValue = _useControlled2[1];\n\n  var inputRef = react[\"useRef\"](null);\n\n  var _React$useState = react[\"useState\"](null),\n      displayNode = _React$useState[0],\n      setDisplayNode = _React$useState[1];\n\n  var _React$useRef = react[\"useRef\"](openProp != null),\n      isOpenControlled = _React$useRef.current;\n\n  var _React$useState2 = react[\"useState\"](),\n      menuMinWidthState = _React$useState2[0],\n      setMenuMinWidthState = _React$useState2[1];\n\n  var _React$useState3 = react[\"useState\"](false),\n      openState = _React$useState3[0],\n      setOpenState = _React$useState3[1];\n\n  var handleRef = useForkRef(ref, inputRefProp);\n  react[\"useImperativeHandle\"](handleRef, function () {\n    return {\n      focus: function focus() {\n        displayNode.focus();\n      },\n      node: inputRef.current,\n      value: value\n    };\n  }, [displayNode, value]);\n  react[\"useEffect\"](function () {\n    if (autoFocus && displayNode) {\n      displayNode.focus();\n    }\n  }, [autoFocus, displayNode]);\n  react[\"useEffect\"](function () {\n    if (displayNode) {\n      var label = ownerDocument(displayNode).getElementById(labelId);\n\n      if (label) {\n        var handler = function handler() {\n          if (getSelection().isCollapsed) {\n            displayNode.focus();\n          }\n        };\n\n        label.addEventListener('click', handler);\n        return function () {\n          label.removeEventListener('click', handler);\n        };\n      }\n    }\n\n    return undefined;\n  }, [labelId, displayNode]);\n\n  var update = function update(open, event) {\n    if (open) {\n      if (onOpen) {\n        onOpen(event);\n      }\n    } else if (onClose) {\n      onClose(event);\n    }\n\n    if (!isOpenControlled) {\n      setMenuMinWidthState(autoWidth ? null : displayNode.clientWidth);\n      setOpenState(open);\n    }\n  };\n\n  var handleMouseDown = function handleMouseDown(event) {\n    // Ignore everything but left-click\n    if (event.button !== 0) {\n      return;\n    } // Hijack the default focus behavior.\n\n\n    event.preventDefault();\n    displayNode.focus();\n    update(true, event);\n  };\n\n  var handleClose = function handleClose(event) {\n    update(false, event);\n  };\n\n  var childrenArray = react[\"Children\"].toArray(children); // Support autofill.\n\n  var handleChange = function handleChange(event) {\n    var index = childrenArray.map(function (child) {\n      return child.props.value;\n    }).indexOf(event.target.value);\n\n    if (index === -1) {\n      return;\n    }\n\n    var child = childrenArray[index];\n    setValue(child.props.value);\n\n    if (onChange) {\n      onChange(event, child);\n    }\n  };\n\n  var handleItemClick = function handleItemClick(child) {\n    return function (event) {\n      if (!multiple) {\n        update(false, event);\n      }\n\n      var newValue;\n\n      if (multiple) {\n        newValue = Array.isArray(value) ? value.slice() : [];\n        var itemIndex = value.indexOf(child.props.value);\n\n        if (itemIndex === -1) {\n          newValue.push(child.props.value);\n        } else {\n          newValue.splice(itemIndex, 1);\n        }\n      } else {\n        newValue = child.props.value;\n      }\n\n      if (child.props.onClick) {\n        child.props.onClick(event);\n      }\n\n      if (value === newValue) {\n        return;\n      }\n\n      setValue(newValue);\n\n      if (onChange) {\n        event.persist(); // Preact support, target is read only property on a native event.\n\n        Object.defineProperty(event, 'target', {\n          writable: true,\n          value: {\n            value: newValue,\n            name: name\n          }\n        });\n        onChange(event, child);\n      }\n    };\n  };\n\n  var handleKeyDown = function handleKeyDown(event) {\n    if (!readOnly) {\n      var validKeys = [' ', 'ArrowUp', 'ArrowDown', // The native select doesn't respond to enter on MacOS, but it's recommended by\n      // https://www.w3.org/TR/wai-aria-practices/examples/listbox/listbox-collapsible.html\n      'Enter'];\n\n      if (validKeys.indexOf(event.key) !== -1) {\n        event.preventDefault();\n        update(true, event);\n      }\n    }\n  };\n\n  var open = displayNode !== null && (isOpenControlled ? openProp : openState);\n\n  var handleBlur = function handleBlur(event) {\n    // if open event.stopImmediatePropagation\n    if (!open && onBlur) {\n      event.persist(); // Preact support, target is read only property on a native event.\n\n      Object.defineProperty(event, 'target', {\n        writable: true,\n        value: {\n          value: value,\n          name: name\n        }\n      });\n      onBlur(event);\n    }\n  };\n\n  delete other['aria-invalid'];\n  var display;\n  var displaySingle;\n  var displayMultiple = [];\n  var computeDisplay = false;\n  var foundMatch = false; // No need to display any value if the field is empty.\n\n  if (isFilled({\n    value: value\n  }) || displayEmpty) {\n    if (renderValue) {\n      display = renderValue(value);\n    } else {\n      computeDisplay = true;\n    }\n  }\n\n  var items = childrenArray.map(function (child) {\n    if (! /*#__PURE__*/react[\"isValidElement\"](child)) {\n      return null;\n    }\n\n    if (false) {}\n\n    var selected;\n\n    if (multiple) {\n      if (!Array.isArray(value)) {\n        throw new Error( false ? undefined : formatMuiErrorMessage(2));\n      }\n\n      selected = value.some(function (v) {\n        return areEqualValues(v, child.props.value);\n      });\n\n      if (selected && computeDisplay) {\n        displayMultiple.push(child.props.children);\n      }\n    } else {\n      selected = areEqualValues(value, child.props.value);\n\n      if (selected && computeDisplay) {\n        displaySingle = child.props.children;\n      }\n    }\n\n    if (selected) {\n      foundMatch = true;\n    }\n\n    return /*#__PURE__*/react[\"cloneElement\"](child, {\n      'aria-selected': selected ? 'true' : undefined,\n      onClick: handleItemClick(child),\n      onKeyUp: function onKeyUp(event) {\n        if (event.key === ' ') {\n          // otherwise our MenuItems dispatches a click event\n          // it's not behavior of the native <option> and causes\n          // the select to close immediately since we open on space keydown\n          event.preventDefault();\n        }\n\n        if (child.props.onKeyUp) {\n          child.props.onKeyUp(event);\n        }\n      },\n      role: 'option',\n      selected: selected,\n      value: undefined,\n      // The value is most likely not a valid HTML attribute.\n      'data-value': child.props.value // Instead, we provide it as a data attribute.\n\n    });\n  });\n\n  if (false) {}\n\n  if (computeDisplay) {\n    display = multiple ? displayMultiple.join(', ') : displaySingle;\n  } // Avoid performing a layout computation in the render method.\n\n\n  var menuMinWidth = menuMinWidthState;\n\n  if (!autoWidth && isOpenControlled && displayNode) {\n    menuMinWidth = displayNode.clientWidth;\n  }\n\n  var tabIndex;\n\n  if (typeof tabIndexProp !== 'undefined') {\n    tabIndex = tabIndexProp;\n  } else {\n    tabIndex = disabled ? null : 0;\n  }\n\n  var buttonId = SelectDisplayProps.id || (name ? \"mui-component-select-\".concat(name) : undefined);\n  return /*#__PURE__*/react[\"createElement\"](react[\"Fragment\"], null, /*#__PURE__*/react[\"createElement\"](\"div\", _extends({\n    className: clsx_m(classes.root, // TODO v5: merge root and select\n    classes.select, classes.selectMenu, classes[variant], className, disabled && classes.disabled),\n    ref: setDisplayNode,\n    tabIndex: tabIndex,\n    role: \"button\",\n    \"aria-disabled\": disabled ? 'true' : undefined,\n    \"aria-expanded\": open ? 'true' : undefined,\n    \"aria-haspopup\": \"listbox\",\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": [labelId, buttonId].filter(Boolean).join(' ') || undefined,\n    onKeyDown: handleKeyDown,\n    onMouseDown: disabled || readOnly ? null : handleMouseDown,\n    onBlur: handleBlur,\n    onFocus: onFocus\n  }, SelectDisplayProps, {\n    // The id is required for proper a11y\n    id: buttonId\n  }), isEmpty(display) ?\n  /*#__PURE__*/\n  // eslint-disable-next-line react/no-danger\n  react[\"createElement\"](\"span\", {\n    dangerouslySetInnerHTML: {\n      __html: '&#8203;'\n    }\n  }) : display), /*#__PURE__*/react[\"createElement\"](\"input\", _extends({\n    value: Array.isArray(value) ? value.join(',') : value,\n    name: name,\n    ref: inputRef,\n    \"aria-hidden\": true,\n    onChange: handleChange,\n    tabIndex: -1,\n    className: classes.nativeInput,\n    autoFocus: autoFocus\n  }, other)), /*#__PURE__*/react[\"createElement\"](IconComponent, {\n    className: clsx_m(classes.icon, classes[\"icon\".concat(capitalize(variant))], open && classes.iconOpen, disabled && classes.disabled)\n  }), /*#__PURE__*/react[\"createElement\"](esm_Menu_Menu, _extends({\n    id: \"menu-\".concat(name || ''),\n    anchorEl: displayNode,\n    open: open,\n    onClose: handleClose\n  }, MenuProps, {\n    MenuListProps: _extends({\n      'aria-labelledby': labelId,\n      role: 'listbox',\n      disableListWrap: true\n    }, MenuProps.MenuListProps),\n    PaperProps: _extends({}, MenuProps.PaperProps, {\n      style: _extends({\n        minWidth: menuMinWidth\n      }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)\n    })\n  }), items));\n});\n false ? undefined : void 0;\n/* harmony default export */ var Select_SelectInput = (SelectInput_SelectInput);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/SvgIcon/SvgIcon.js\n\n\n\n\n\n\n\nvar SvgIcon_styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      userSelect: 'none',\n      width: '1em',\n      height: '1em',\n      display: 'inline-block',\n      fill: 'currentColor',\n      flexShrink: 0,\n      fontSize: theme.typography.pxToRem(24),\n      transition: theme.transitions.create('fill', {\n        duration: theme.transitions.duration.shorter\n      })\n    },\n\n    /* Styles applied to the root element if `color=\"primary\"`. */\n    colorPrimary: {\n      color: theme.palette.primary.main\n    },\n\n    /* Styles applied to the root element if `color=\"secondary\"`. */\n    colorSecondary: {\n      color: theme.palette.secondary.main\n    },\n\n    /* Styles applied to the root element if `color=\"action\"`. */\n    colorAction: {\n      color: theme.palette.action.active\n    },\n\n    /* Styles applied to the root element if `color=\"error\"`. */\n    colorError: {\n      color: theme.palette.error.main\n    },\n\n    /* Styles applied to the root element if `color=\"disabled\"`. */\n    colorDisabled: {\n      color: theme.palette.action.disabled\n    },\n\n    /* Styles applied to the root element if `fontSize=\"inherit\"`. */\n    fontSizeInherit: {\n      fontSize: 'inherit'\n    },\n\n    /* Styles applied to the root element if `fontSize=\"small\"`. */\n    fontSizeSmall: {\n      fontSize: theme.typography.pxToRem(20)\n    },\n\n    /* Styles applied to the root element if `fontSize=\"large\"`. */\n    fontSizeLarge: {\n      fontSize: theme.typography.pxToRem(35)\n    }\n  };\n};\nvar SvgIcon_SvgIcon = /*#__PURE__*/react[\"forwardRef\"](function SvgIcon(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$color = props.color,\n      color = _props$color === void 0 ? 'inherit' : _props$color,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'svg' : _props$component,\n      _props$fontSize = props.fontSize,\n      fontSize = _props$fontSize === void 0 ? 'default' : _props$fontSize,\n      htmlColor = props.htmlColor,\n      titleAccess = props.titleAccess,\n      _props$viewBox = props.viewBox,\n      viewBox = _props$viewBox === void 0 ? '0 0 24 24' : _props$viewBox,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"color\", \"component\", \"fontSize\", \"htmlColor\", \"titleAccess\", \"viewBox\"]);\n\n  return /*#__PURE__*/react[\"createElement\"](Component, _extends({\n    className: clsx_m(classes.root, className, color !== 'inherit' && classes[\"color\".concat(capitalize(color))], fontSize !== 'default' && classes[\"fontSize\".concat(capitalize(fontSize))]),\n    focusable: \"false\",\n    viewBox: viewBox,\n    color: htmlColor,\n    \"aria-hidden\": titleAccess ? undefined : true,\n    role: titleAccess ? 'img' : undefined,\n    ref: ref\n  }, other), children, titleAccess ? /*#__PURE__*/react[\"createElement\"](\"title\", null, titleAccess) : null);\n});\n false ? undefined : void 0;\nSvgIcon_SvgIcon.muiName = 'SvgIcon';\n/* harmony default export */ var esm_SvgIcon_SvgIcon = (styles_withStyles(SvgIcon_styles, {\n  name: 'MuiSvgIcon'\n})(SvgIcon_SvgIcon));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/utils/createSvgIcon.js\n\n\n\n/**\n * Private module reserved for @material-ui/x packages.\n */\n\nfunction createSvgIcon(path, displayName) {\n  var Component = function Component(props, ref) {\n    return /*#__PURE__*/react_default.a.createElement(esm_SvgIcon_SvgIcon, _extends({\n      ref: ref\n    }, props), path);\n  };\n\n  if (false) {}\n\n  Component.muiName = esm_SvgIcon_SvgIcon.muiName;\n  return /*#__PURE__*/react_default.a.memo( /*#__PURE__*/react_default.a.forwardRef(Component));\n}\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/internal/svg-icons/ArrowDropDown.js\n\n\n/**\n * @ignore - internal component.\n */\n\n/* harmony default export */ var ArrowDropDown = (createSvgIcon( /*#__PURE__*/react[\"createElement\"](\"path\", {\n  d: \"M7 10l5 5 5-5z\"\n}), 'ArrowDropDown'));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/NativeSelect/NativeSelectInput.js\n\n\n\n\n\n\n\n/**\n * @ignore - internal component.\n */\n\nvar NativeSelectInput_NativeSelectInput = /*#__PURE__*/react[\"forwardRef\"](function NativeSelectInput(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      disabled = props.disabled,\n      IconComponent = props.IconComponent,\n      inputRef = props.inputRef,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'standard' : _props$variant,\n      other = _objectWithoutProperties(props, [\"classes\", \"className\", \"disabled\", \"IconComponent\", \"inputRef\", \"variant\"]);\n\n  return /*#__PURE__*/react[\"createElement\"](react[\"Fragment\"], null, /*#__PURE__*/react[\"createElement\"](\"select\", _extends({\n    className: clsx_m(classes.root, // TODO v5: merge root and select\n    classes.select, classes[variant], className, disabled && classes.disabled),\n    disabled: disabled,\n    ref: inputRef || ref\n  }, other)), props.multiple ? null : /*#__PURE__*/react[\"createElement\"](IconComponent, {\n    className: clsx_m(classes.icon, classes[\"icon\".concat(capitalize(variant))], disabled && classes.disabled)\n  }));\n});\n false ? undefined : void 0;\n/* harmony default export */ var NativeSelect_NativeSelectInput = (NativeSelectInput_NativeSelectInput);\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/NativeSelect/NativeSelect.js\n\n\n\n\n\n\n\n\n\n\nvar NativeSelect_styles = function styles(theme) {\n  return {\n    /* Styles applied to the select component `root` class. */\n    root: {},\n\n    /* Styles applied to the select component `select` class. */\n    select: {\n      '-moz-appearance': 'none',\n      // Reset\n      '-webkit-appearance': 'none',\n      // Reset\n      // When interacting quickly, the text can end up selected.\n      // Native select can't be selected either.\n      userSelect: 'none',\n      borderRadius: 0,\n      // Reset\n      minWidth: 16,\n      // So it doesn't collapse.\n      cursor: 'pointer',\n      '&:focus': {\n        // Show that it's not an text input\n        backgroundColor: theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)',\n        borderRadius: 0 // Reset Chrome style\n\n      },\n      // Remove IE 11 arrow\n      '&::-ms-expand': {\n        display: 'none'\n      },\n      '&$disabled': {\n        cursor: 'default'\n      },\n      '&[multiple]': {\n        height: 'auto'\n      },\n      '&:not([multiple]) option, &:not([multiple]) optgroup': {\n        backgroundColor: theme.palette.background.paper\n      },\n      '&&': {\n        paddingRight: 24\n      }\n    },\n\n    /* Styles applied to the select component if `variant=\"filled\"`. */\n    filled: {\n      '&&': {\n        paddingRight: 32\n      }\n    },\n\n    /* Styles applied to the select component if `variant=\"outlined\"`. */\n    outlined: {\n      borderRadius: theme.shape.borderRadius,\n      '&&': {\n        paddingRight: 32\n      }\n    },\n\n    /* Styles applied to the select component `selectMenu` class. */\n    selectMenu: {\n      height: 'auto',\n      // Resets for multpile select with chips\n      minHeight: '1.1876em',\n      // Required for select\\text-field height consistency\n      textOverflow: 'ellipsis',\n      whiteSpace: 'nowrap',\n      overflow: 'hidden'\n    },\n\n    /* Pseudo-class applied to the select component `disabled` class. */\n    disabled: {},\n\n    /* Styles applied to the icon component. */\n    icon: {\n      // We use a position absolute over a flexbox in order to forward the pointer events\n      // to the input and to support wrapping tags..\n      position: 'absolute',\n      right: 0,\n      top: 'calc(50% - 12px)',\n      // Center vertically\n      pointerEvents: 'none',\n      // Don't block pointer events on the select under the icon.\n      color: theme.palette.action.active,\n      '&$disabled': {\n        color: theme.palette.action.disabled\n      }\n    },\n\n    /* Styles applied to the icon component if the popup is open. */\n    iconOpen: {\n      transform: 'rotate(180deg)'\n    },\n\n    /* Styles applied to the icon component if `variant=\"filled\"`. */\n    iconFilled: {\n      right: 7\n    },\n\n    /* Styles applied to the icon component if `variant=\"outlined\"`. */\n    iconOutlined: {\n      right: 7\n    },\n\n    /* Styles applied to the underlying native input component. */\n    nativeInput: {\n      bottom: 0,\n      left: 0,\n      position: 'absolute',\n      opacity: 0,\n      pointerEvents: 'none',\n      width: '100%'\n    }\n  };\n};\nvar defaultInput = /*#__PURE__*/react[\"createElement\"](esm_Input_Input, null);\n/**\n * An alternative to `<Select native />` with a much smaller bundle size footprint.\n */\n\nvar NativeSelect_NativeSelect = /*#__PURE__*/react[\"forwardRef\"](function NativeSelect(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      _props$IconComponent = props.IconComponent,\n      IconComponent = _props$IconComponent === void 0 ? ArrowDropDown : _props$IconComponent,\n      _props$input = props.input,\n      input = _props$input === void 0 ? defaultInput : _props$input,\n      inputProps = props.inputProps,\n      variant = props.variant,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"IconComponent\", \"input\", \"inputProps\", \"variant\"]);\n\n  var muiFormControl = useFormControl_useFormControl();\n  var fcs = formControlState({\n    props: props,\n    muiFormControl: muiFormControl,\n    states: ['variant']\n  });\n  return /*#__PURE__*/react[\"cloneElement\"](input, _extends({\n    // Most of the logic is implemented in `NativeSelectInput`.\n    // The `Select` component is a simple API wrapper to expose something better to play with.\n    inputComponent: NativeSelect_NativeSelectInput,\n    inputProps: _extends({\n      children: children,\n      classes: classes,\n      IconComponent: IconComponent,\n      variant: fcs.variant,\n      type: undefined\n    }, inputProps, input ? input.props.inputProps : {}),\n    ref: ref\n  }, other));\n});\n false ? undefined : void 0;\nNativeSelect_NativeSelect.muiName = 'Select';\n/* harmony default export */ var esm_NativeSelect_NativeSelect = (styles_withStyles(NativeSelect_styles, {\n  name: 'MuiNativeSelect'\n})(NativeSelect_NativeSelect));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Select/Select.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Select_styles = NativeSelect_styles;\n\nvar Select_ref = /*#__PURE__*/react[\"createElement\"](esm_Input_Input, null);\n\nvar Select_ref2 = /*#__PURE__*/react[\"createElement\"](esm_FilledInput_FilledInput, null);\n\nvar Select_Select = /*#__PURE__*/react[\"forwardRef\"](function Select(props, ref) {\n  var _props$autoWidth = props.autoWidth,\n      autoWidth = _props$autoWidth === void 0 ? false : _props$autoWidth,\n      children = props.children,\n      classes = props.classes,\n      _props$displayEmpty = props.displayEmpty,\n      displayEmpty = _props$displayEmpty === void 0 ? false : _props$displayEmpty,\n      _props$IconComponent = props.IconComponent,\n      IconComponent = _props$IconComponent === void 0 ? ArrowDropDown : _props$IconComponent,\n      id = props.id,\n      input = props.input,\n      inputProps = props.inputProps,\n      label = props.label,\n      labelId = props.labelId,\n      _props$labelWidth = props.labelWidth,\n      labelWidth = _props$labelWidth === void 0 ? 0 : _props$labelWidth,\n      MenuProps = props.MenuProps,\n      _props$multiple = props.multiple,\n      multiple = _props$multiple === void 0 ? false : _props$multiple,\n      _props$native = props.native,\n      native = _props$native === void 0 ? false : _props$native,\n      onClose = props.onClose,\n      onOpen = props.onOpen,\n      open = props.open,\n      renderValue = props.renderValue,\n      SelectDisplayProps = props.SelectDisplayProps,\n      _props$variant = props.variant,\n      variantProps = _props$variant === void 0 ? 'standard' : _props$variant,\n      other = _objectWithoutProperties(props, [\"autoWidth\", \"children\", \"classes\", \"displayEmpty\", \"IconComponent\", \"id\", \"input\", \"inputProps\", \"label\", \"labelId\", \"labelWidth\", \"MenuProps\", \"multiple\", \"native\", \"onClose\", \"onOpen\", \"open\", \"renderValue\", \"SelectDisplayProps\", \"variant\"]);\n\n  var inputComponent = native ? NativeSelect_NativeSelectInput : Select_SelectInput;\n  var muiFormControl = useFormControl_useFormControl();\n  var fcs = formControlState({\n    props: props,\n    muiFormControl: muiFormControl,\n    states: ['variant']\n  });\n  var variant = fcs.variant || variantProps;\n  var InputComponent = input || {\n    standard: Select_ref,\n    outlined: /*#__PURE__*/react[\"createElement\"](esm_OutlinedInput_OutlinedInput, {\n      label: label,\n      labelWidth: labelWidth\n    }),\n    filled: Select_ref2\n  }[variant];\n  return /*#__PURE__*/react[\"cloneElement\"](InputComponent, _extends({\n    // Most of the logic is implemented in `SelectInput`.\n    // The `Select` component is a simple API wrapper to expose something better to play with.\n    inputComponent: inputComponent,\n    inputProps: _extends({\n      children: children,\n      IconComponent: IconComponent,\n      variant: variant,\n      type: undefined,\n      // We render a select. We can ignore the type provided by the `Input`.\n      multiple: multiple\n    }, native ? {\n      id: id\n    } : {\n      autoWidth: autoWidth,\n      displayEmpty: displayEmpty,\n      labelId: labelId,\n      MenuProps: MenuProps,\n      onClose: onClose,\n      onOpen: onOpen,\n      open: open,\n      renderValue: renderValue,\n      SelectDisplayProps: _extends({\n        id: id\n      }, SelectDisplayProps)\n    }, inputProps, {\n      classes: inputProps ? mergeClasses({\n        baseClasses: classes,\n        newClasses: inputProps.classes,\n        Component: Select\n      }) : classes\n    }, input ? input.props.inputProps : {}),\n    ref: ref\n  }, other));\n});\n false ? undefined : void 0;\nSelect_Select.muiName = 'Select';\n/* harmony default export */ var esm_Select_Select = (styles_withStyles(Select_styles, {\n  name: 'MuiSelect'\n})(Select_Select));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/TextField/TextField.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar variantComponent = {\n  standard: esm_Input_Input,\n  filled: esm_FilledInput_FilledInput,\n  outlined: esm_OutlinedInput_OutlinedInput\n};\nvar TextField_styles = {\n  /* Styles applied to the root element. */\n  root: {}\n};\n/**\n * The `TextField` is a convenience wrapper for the most common cases (80%).\n * It cannot be all things to all people, otherwise the API would grow out of control.\n *\n * ## Advanced Configuration\n *\n * It's important to understand that the text field is a simple abstraction\n * on top of the following components:\n *\n * - [FormControl](/api/form-control/)\n * - [InputLabel](/api/input-label/)\n * - [FilledInput](/api/filled-input/)\n * - [OutlinedInput](/api/outlined-input/)\n * - [Input](/api/input/)\n * - [FormHelperText](/api/form-helper-text/)\n *\n * If you wish to alter the props applied to the `input` element, you can do so as follows:\n *\n * ```jsx\n * const inputProps = {\n *   step: 300,\n * };\n *\n * return <TextField id=\"time\" type=\"time\" inputProps={inputProps} />;\n * ```\n *\n * For advanced cases, please look at the source of TextField by clicking on the\n * \"Edit this page\" button above. Consider either:\n *\n * - using the upper case props for passing values directly to the components\n * - using the underlying components directly as shown in the demos\n */\n\nvar TextField_TextField = /*#__PURE__*/react[\"forwardRef\"](function TextField(props, ref) {\n  var autoComplete = props.autoComplete,\n      _props$autoFocus = props.autoFocus,\n      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,\n      children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$color = props.color,\n      color = _props$color === void 0 ? 'primary' : _props$color,\n      defaultValue = props.defaultValue,\n      _props$disabled = props.disabled,\n      disabled = _props$disabled === void 0 ? false : _props$disabled,\n      _props$error = props.error,\n      error = _props$error === void 0 ? false : _props$error,\n      FormHelperTextProps = props.FormHelperTextProps,\n      _props$fullWidth = props.fullWidth,\n      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,\n      helperText = props.helperText,\n      hiddenLabel = props.hiddenLabel,\n      id = props.id,\n      InputLabelProps = props.InputLabelProps,\n      inputProps = props.inputProps,\n      InputProps = props.InputProps,\n      inputRef = props.inputRef,\n      label = props.label,\n      _props$multiline = props.multiline,\n      multiline = _props$multiline === void 0 ? false : _props$multiline,\n      name = props.name,\n      onBlur = props.onBlur,\n      onChange = props.onChange,\n      onFocus = props.onFocus,\n      placeholder = props.placeholder,\n      _props$required = props.required,\n      required = _props$required === void 0 ? false : _props$required,\n      rows = props.rows,\n      rowsMax = props.rowsMax,\n      _props$select = props.select,\n      select = _props$select === void 0 ? false : _props$select,\n      SelectProps = props.SelectProps,\n      type = props.type,\n      value = props.value,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'standard' : _props$variant,\n      other = _objectWithoutProperties(props, [\"autoComplete\", \"autoFocus\", \"children\", \"classes\", \"className\", \"color\", \"defaultValue\", \"disabled\", \"error\", \"FormHelperTextProps\", \"fullWidth\", \"helperText\", \"hiddenLabel\", \"id\", \"InputLabelProps\", \"inputProps\", \"InputProps\", \"inputRef\", \"label\", \"multiline\", \"name\", \"onBlur\", \"onChange\", \"onFocus\", \"placeholder\", \"required\", \"rows\", \"rowsMax\", \"select\", \"SelectProps\", \"type\", \"value\", \"variant\"]);\n\n  if (false) {}\n\n  var InputMore = {};\n\n  if (variant === 'outlined') {\n    if (InputLabelProps && typeof InputLabelProps.shrink !== 'undefined') {\n      InputMore.notched = InputLabelProps.shrink;\n    }\n\n    if (label) {\n      var _InputLabelProps$requ;\n\n      var displayRequired = (_InputLabelProps$requ = InputLabelProps === null || InputLabelProps === void 0 ? void 0 : InputLabelProps.required) !== null && _InputLabelProps$requ !== void 0 ? _InputLabelProps$requ : required;\n      InputMore.label = /*#__PURE__*/react[\"createElement\"](react[\"Fragment\"], null, label, displayRequired && \"\\xA0*\");\n    }\n  }\n\n  if (select) {\n    // unset defaults from textbox inputs\n    if (!SelectProps || !SelectProps.native) {\n      InputMore.id = undefined;\n    }\n\n    InputMore['aria-describedby'] = undefined;\n  }\n\n  var helperTextId = helperText && id ? \"\".concat(id, \"-helper-text\") : undefined;\n  var inputLabelId = label && id ? \"\".concat(id, \"-label\") : undefined;\n  var InputComponent = variantComponent[variant];\n  var InputElement = /*#__PURE__*/react[\"createElement\"](InputComponent, _extends({\n    \"aria-describedby\": helperTextId,\n    autoComplete: autoComplete,\n    autoFocus: autoFocus,\n    defaultValue: defaultValue,\n    fullWidth: fullWidth,\n    multiline: multiline,\n    name: name,\n    rows: rows,\n    rowsMax: rowsMax,\n    type: type,\n    value: value,\n    id: id,\n    inputRef: inputRef,\n    onBlur: onBlur,\n    onChange: onChange,\n    onFocus: onFocus,\n    placeholder: placeholder,\n    inputProps: inputProps\n  }, InputMore, InputProps));\n  return /*#__PURE__*/react[\"createElement\"](esm_FormControl_FormControl, _extends({\n    className: clsx_m(classes.root, className),\n    disabled: disabled,\n    error: error,\n    fullWidth: fullWidth,\n    hiddenLabel: hiddenLabel,\n    ref: ref,\n    required: required,\n    color: color,\n    variant: variant\n  }, other), label && /*#__PURE__*/react[\"createElement\"](esm_InputLabel_InputLabel, _extends({\n    htmlFor: id,\n    id: inputLabelId\n  }, InputLabelProps), label), select ? /*#__PURE__*/react[\"createElement\"](esm_Select_Select, _extends({\n    \"aria-describedby\": helperTextId,\n    id: id,\n    labelId: inputLabelId,\n    value: value,\n    input: InputElement\n  }, SelectProps), children) : InputElement, helperText && /*#__PURE__*/react[\"createElement\"](esm_FormHelperText_FormHelperText, _extends({\n    id: helperTextId\n  }, FormHelperTextProps), helperText));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_TextField_TextField = (styles_withStyles(TextField_styles, {\n  name: 'MuiTextField'\n})(TextField_TextField));\n// CONCATENATED MODULE: ./node_modules/@material-ui/core/esm/Button/Button.js\n\n\n\n\n\n\n\n\n\nvar Button_styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: _extends({}, theme.typography.button, {\n      boxSizing: 'border-box',\n      minWidth: 64,\n      padding: '6px 16px',\n      borderRadius: theme.shape.borderRadius,\n      color: theme.palette.text.primary,\n      transition: theme.transitions.create(['background-color', 'box-shadow', 'border'], {\n        duration: theme.transitions.duration.short\n      }),\n      '&:hover': {\n        textDecoration: 'none',\n        backgroundColor: fade(theme.palette.text.primary, theme.palette.action.hoverOpacity),\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: 'transparent'\n        },\n        '&$disabled': {\n          backgroundColor: 'transparent'\n        }\n      },\n      '&$disabled': {\n        color: theme.palette.action.disabled\n      }\n    }),\n\n    /* Styles applied to the span element that wraps the children. */\n    label: {\n      width: '100%',\n      // Ensure the correct width for iOS Safari\n      display: 'inherit',\n      alignItems: 'inherit',\n      justifyContent: 'inherit'\n    },\n\n    /* Styles applied to the root element if `variant=\"text\"`. */\n    text: {\n      padding: '6px 8px'\n    },\n\n    /* Styles applied to the root element if `variant=\"text\"` and `color=\"primary\"`. */\n    textPrimary: {\n      color: theme.palette.primary.main,\n      '&:hover': {\n        backgroundColor: fade(theme.palette.primary.main, theme.palette.action.hoverOpacity),\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: 'transparent'\n        }\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"text\"` and `color=\"secondary\"`. */\n    textSecondary: {\n      color: theme.palette.secondary.main,\n      '&:hover': {\n        backgroundColor: fade(theme.palette.secondary.main, theme.palette.action.hoverOpacity),\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: 'transparent'\n        }\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"outlined\"`. */\n    outlined: {\n      padding: '5px 15px',\n      border: \"1px solid \".concat(theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'),\n      '&$disabled': {\n        border: \"1px solid \".concat(theme.palette.action.disabledBackground)\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"outlined\"` and `color=\"primary\"`. */\n    outlinedPrimary: {\n      color: theme.palette.primary.main,\n      border: \"1px solid \".concat(fade(theme.palette.primary.main, 0.5)),\n      '&:hover': {\n        border: \"1px solid \".concat(theme.palette.primary.main),\n        backgroundColor: fade(theme.palette.primary.main, theme.palette.action.hoverOpacity),\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: 'transparent'\n        }\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"outlined\"` and `color=\"secondary\"`. */\n    outlinedSecondary: {\n      color: theme.palette.secondary.main,\n      border: \"1px solid \".concat(fade(theme.palette.secondary.main, 0.5)),\n      '&:hover': {\n        border: \"1px solid \".concat(theme.palette.secondary.main),\n        backgroundColor: fade(theme.palette.secondary.main, theme.palette.action.hoverOpacity),\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: 'transparent'\n        }\n      },\n      '&$disabled': {\n        border: \"1px solid \".concat(theme.palette.action.disabled)\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"contained\"`. */\n    contained: {\n      color: theme.palette.getContrastText(theme.palette.grey[300]),\n      backgroundColor: theme.palette.grey[300],\n      boxShadow: theme.shadows[2],\n      '&:hover': {\n        backgroundColor: theme.palette.grey.A100,\n        boxShadow: theme.shadows[4],\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          boxShadow: theme.shadows[2],\n          backgroundColor: theme.palette.grey[300]\n        },\n        '&$disabled': {\n          backgroundColor: theme.palette.action.disabledBackground\n        }\n      },\n      '&$focusVisible': {\n        boxShadow: theme.shadows[6]\n      },\n      '&:active': {\n        boxShadow: theme.shadows[8]\n      },\n      '&$disabled': {\n        color: theme.palette.action.disabled,\n        boxShadow: theme.shadows[0],\n        backgroundColor: theme.palette.action.disabledBackground\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"contained\"` and `color=\"primary\"`. */\n    containedPrimary: {\n      color: theme.palette.primary.contrastText,\n      backgroundColor: theme.palette.primary.main,\n      '&:hover': {\n        backgroundColor: theme.palette.primary.dark,\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: theme.palette.primary.main\n        }\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"contained\"` and `color=\"secondary\"`. */\n    containedSecondary: {\n      color: theme.palette.secondary.contrastText,\n      backgroundColor: theme.palette.secondary.main,\n      '&:hover': {\n        backgroundColor: theme.palette.secondary.dark,\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: theme.palette.secondary.main\n        }\n      }\n    },\n\n    /* Styles applied to the root element if `disableElevation={true}`. */\n    disableElevation: {\n      boxShadow: 'none',\n      '&:hover': {\n        boxShadow: 'none'\n      },\n      '&$focusVisible': {\n        boxShadow: 'none'\n      },\n      '&:active': {\n        boxShadow: 'none'\n      },\n      '&$disabled': {\n        boxShadow: 'none'\n      }\n    },\n\n    /* Pseudo-class applied to the ButtonBase root element if the button is keyboard focused. */\n    focusVisible: {},\n\n    /* Pseudo-class applied to the root element if `disabled={true}`. */\n    disabled: {},\n\n    /* Styles applied to the root element if `color=\"inherit\"`. */\n    colorInherit: {\n      color: 'inherit',\n      borderColor: 'currentColor'\n    },\n\n    /* Styles applied to the root element if `size=\"small\"` and `variant=\"text\"`. */\n    textSizeSmall: {\n      padding: '4px 5px',\n      fontSize: theme.typography.pxToRem(13)\n    },\n\n    /* Styles applied to the root element if `size=\"large\"` and `variant=\"text\"`. */\n    textSizeLarge: {\n      padding: '8px 11px',\n      fontSize: theme.typography.pxToRem(15)\n    },\n\n    /* Styles applied to the root element if `size=\"small\"` and `variant=\"outlined\"`. */\n    outlinedSizeSmall: {\n      padding: '3px 9px',\n      fontSize: theme.typography.pxToRem(13)\n    },\n\n    /* Styles applied to the root element if `size=\"large\"` and `variant=\"outlined\"`. */\n    outlinedSizeLarge: {\n      padding: '7px 21px',\n      fontSize: theme.typography.pxToRem(15)\n    },\n\n    /* Styles applied to the root element if `size=\"small\"` and `variant=\"contained\"`. */\n    containedSizeSmall: {\n      padding: '4px 10px',\n      fontSize: theme.typography.pxToRem(13)\n    },\n\n    /* Styles applied to the root element if `size=\"large\"` and `variant=\"contained\"`. */\n    containedSizeLarge: {\n      padding: '8px 22px',\n      fontSize: theme.typography.pxToRem(15)\n    },\n\n    /* Styles applied to the root element if `size=\"small\"`. */\n    sizeSmall: {},\n\n    /* Styles applied to the root element if `size=\"large\"`. */\n    sizeLarge: {},\n\n    /* Styles applied to the root element if `fullWidth={true}`. */\n    fullWidth: {\n      width: '100%'\n    },\n\n    /* Styles applied to the startIcon element if supplied. */\n    startIcon: {\n      display: 'inherit',\n      marginRight: 8,\n      marginLeft: -4,\n      '&$iconSizeSmall': {\n        marginLeft: -2\n      }\n    },\n\n    /* Styles applied to the endIcon element if supplied. */\n    endIcon: {\n      display: 'inherit',\n      marginRight: -4,\n      marginLeft: 8,\n      '&$iconSizeSmall': {\n        marginRight: -2\n      }\n    },\n\n    /* Styles applied to the icon element if supplied and `size=\"small\"`. */\n    iconSizeSmall: {\n      '& > *:first-child': {\n        fontSize: 18\n      }\n    },\n\n    /* Styles applied to the icon element if supplied and `size=\"medium\"`. */\n    iconSizeMedium: {\n      '& > *:first-child': {\n        fontSize: 20\n      }\n    },\n\n    /* Styles applied to the icon element if supplied and `size=\"large\"`. */\n    iconSizeLarge: {\n      '& > *:first-child': {\n        fontSize: 22\n      }\n    }\n  };\n};\nvar Button_Button = /*#__PURE__*/react[\"forwardRef\"](function Button(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$color = props.color,\n      color = _props$color === void 0 ? 'default' : _props$color,\n      _props$component = props.component,\n      component = _props$component === void 0 ? 'button' : _props$component,\n      _props$disabled = props.disabled,\n      disabled = _props$disabled === void 0 ? false : _props$disabled,\n      _props$disableElevati = props.disableElevation,\n      disableElevation = _props$disableElevati === void 0 ? false : _props$disableElevati,\n      _props$disableFocusRi = props.disableFocusRipple,\n      disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi,\n      endIconProp = props.endIcon,\n      focusVisibleClassName = props.focusVisibleClassName,\n      _props$fullWidth = props.fullWidth,\n      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,\n      _props$size = props.size,\n      size = _props$size === void 0 ? 'medium' : _props$size,\n      startIconProp = props.startIcon,\n      _props$type = props.type,\n      type = _props$type === void 0 ? 'button' : _props$type,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'text' : _props$variant,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"color\", \"component\", \"disabled\", \"disableElevation\", \"disableFocusRipple\", \"endIcon\", \"focusVisibleClassName\", \"fullWidth\", \"size\", \"startIcon\", \"type\", \"variant\"]);\n\n  var startIcon = startIconProp && /*#__PURE__*/react[\"createElement\"](\"span\", {\n    className: clsx_m(classes.startIcon, classes[\"iconSize\".concat(capitalize(size))])\n  }, startIconProp);\n  var endIcon = endIconProp && /*#__PURE__*/react[\"createElement\"](\"span\", {\n    className: clsx_m(classes.endIcon, classes[\"iconSize\".concat(capitalize(size))])\n  }, endIconProp);\n  return /*#__PURE__*/react[\"createElement\"](esm_ButtonBase_ButtonBase, _extends({\n    className: clsx_m(classes.root, classes[variant], className, color === 'inherit' ? classes.colorInherit : color !== 'default' && classes[\"\".concat(variant).concat(capitalize(color))], size !== 'medium' && [classes[\"\".concat(variant, \"Size\").concat(capitalize(size))], classes[\"size\".concat(capitalize(size))]], disableElevation && classes.disableElevation, disabled && classes.disabled, fullWidth && classes.fullWidth),\n    component: component,\n    disabled: disabled,\n    focusRipple: !disableFocusRipple,\n    focusVisibleClassName: clsx_m(classes.focusVisible, focusVisibleClassName),\n    ref: ref,\n    type: type\n  }, other), /*#__PURE__*/react[\"createElement\"](\"span\", {\n    className: classes.label\n  }, startIcon, children, endIcon));\n});\n false ? undefined : void 0;\n/* harmony default export */ var esm_Button_Button = (styles_withStyles(Button_styles, {\n  name: 'MuiButton'\n})(Button_Button));\n// CONCATENATED MODULE: ./client/containers/List.jsx\n\n\n\n\n\n\n\n\n\n\n\nfunction reItemList(props) {\n  //TODO: retrieving todoitems from db\n  var {\n    data,\n    createTodo,\n    removeTodo,\n    refetch\n  } = props;\n  var [checked, setChecked] = Object(react[\"useState\"])([0]);\n  var [text, setText] = Object(react[\"useState\"])(\"\");\n\n  var handleToggle = value => () => {\n    var currentIndex = checked.indexOf(value);\n    var newChecked = [...checked];\n\n    if (currentIndex === -1) {\n      newChecked.push(value);\n    } else {\n      newChecked.splice(currentIndex, 1);\n    }\n\n    setChecked(newChecked);\n  };\n\n  var handleValue = event => {\n    setText(event.target.value);\n  };\n\n  var addTodoItem = newItem => {\n    createTodo({\n      variables: {\n        name: newItem\n      },\n      optimisticResponse: {\n        __typename: \"Mutation\",\n        createTodo: {\n          __typename: \"Todo\",\n          id: Math.round(Math.random() * -1000000),\n          name: \"LALALA\",\n          completed: false\n        }\n      },\n\n      update(cache, _ref) {\n        var {\n          data: {\n            createTodo\n          }\n        } = _ref;\n        var {\n          todos\n        } = cache.readQuery({\n          query: READ_TODOS\n        });\n        cache.writeQuery({\n          query: READ_TODOS,\n          data: {\n            todos: todos.concat([createTodo])\n          }\n        });\n      }\n\n    }); // let list = todoItems.slice();\n    // list.push({ name: newItem, done: false });\n    // setToDoItems(list);\n    // createTodo({ variables: { name: newItem } });\n    // refetch();\n\n    setText(\"\");\n  };\n\n  return /*#__PURE__*/react_default.a.createElement(esm_List_List, null, data && data.todos && data.todos.map((item, index) => {\n    var labelId = \"checkbox-list-label-\".concat(index);\n    return /*#__PURE__*/react_default.a.createElement(react_default.a.Fragment, null, /*#__PURE__*/react_default.a.createElement(esm_Divider_Divider, null), /*#__PURE__*/react_default.a.createElement(esm_ListItem_ListItem, {\n      key: \"item-\".concat(item.name, \"-\").concat(index),\n      onClick: handleToggle(index)\n    }, /*#__PURE__*/react_default.a.createElement(esm_ListItemIcon_ListItemIcon, null), /*#__PURE__*/react_default.a.createElement(esm_ListItemText_ListItemText, {\n      primary: \"\".concat(item.name)\n    }), /*#__PURE__*/react_default.a.createElement(\"button\", {\n      onClick: () => {\n        removeTodo({\n          variables: {\n            id: item.id\n          }\n        });\n        refetch();\n      }\n    }, \"X\")));\n  }), /*#__PURE__*/react_default.a.createElement(esm_TextField_TextField, {\n    id: \"standard-name\",\n    label: \"Add To Do\",\n    value: text,\n    onChange: handleValue\n  }), /*#__PURE__*/react_default.a.createElement(esm_Button_Button, {\n    onClick: () => addTodoItem(text)\n  }, \"Save To Do\"));\n}\n// CONCATENATED MODULE: ./client/components/ToDoList.jsx\n\n\n\n\n\n // import Typography from \"@material-ui/core/Typography\";\n\nvar ToDoList_useStyles = styles_makeStyles(theme => ({\n  root: {\n    maxWidth: 345\n  }\n}));\nfunction ToDoList(props) {\n  var {\n    data,\n    createTodo,\n    removeTodo,\n    refetch\n  } = props;\n  console.log(\"data\", data);\n  var classes = ToDoList_useStyles();\n  return /*#__PURE__*/react_default.a.createElement(esm_Card_Card, {\n    className: classes.root\n  }, /*#__PURE__*/react_default.a.createElement(esm_CardHeader_CardHeader, {\n    title: \"To Do List\",\n    subheader: \"September 14, 2016\"\n  }), /*#__PURE__*/react_default.a.createElement(esm_CardContent_CardContent, null, /*#__PURE__*/react_default.a.createElement(reItemList, {\n    data: data,\n    refetch: refetch,\n    createTodo: createTodo,\n    removeTodo: removeTodo\n  })));\n}\n// EXTERNAL MODULE: ./node_modules/ts-invariant/lib/invariant.esm.js\nvar invariant_esm = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./node_modules/@apollo/react-common/lib/react-common.esm.js\n\n\n\nvar apolloContext;\nfunction getApolloContext() {\n    if (!apolloContext) {\n        apolloContext = react_default.a.createContext({});\n    }\n    return apolloContext;\n}\nfunction resetApolloContext() {\n    apolloContext = react_default.a.createContext({});\n}\n\nvar ApolloProvider = function (_a) {\n    var client = _a.client, children = _a.children;\n    var ApolloContext = getApolloContext();\n    return react_default.a.createElement(ApolloContext.Consumer, null, function (context) {\n        if (context === void 0) { context = {}; }\n        if (client && context.client !== client) {\n            context = Object.assign({}, context, { client: client });\n        }\n         true ? Object(invariant_esm[\"b\" /* invariant */])(context.client, 5) : undefined;\n        return (react_default.a.createElement(ApolloContext.Provider, { value: context }, children));\n    });\n};\n\nvar ApolloConsumer = function (props) {\n    var ApolloContext = getApolloContext();\n    return react_default.a.createElement(ApolloContext.Consumer, null, function (context) {\n         true ? Object(invariant_esm[\"b\" /* invariant */])(context && context.client, 6) : undefined;\n        return props.children(context.client);\n    });\n};\n\nvar DocumentType;\n(function (DocumentType) {\n    DocumentType[DocumentType[\"Query\"] = 0] = \"Query\";\n    DocumentType[DocumentType[\"Mutation\"] = 1] = \"Mutation\";\n    DocumentType[DocumentType[\"Subscription\"] = 2] = \"Subscription\";\n})(DocumentType || (DocumentType = {}));\nvar react_common_esm_cache = new Map();\nfunction react_common_esm_operationName(type) {\n    var name;\n    switch (type) {\n        case DocumentType.Query:\n            name = 'Query';\n            break;\n        case DocumentType.Mutation:\n            name = 'Mutation';\n            break;\n        case DocumentType.Subscription:\n            name = 'Subscription';\n            break;\n    }\n    return name;\n}\nfunction parser(document) {\n    var cached = react_common_esm_cache.get(document);\n    if (cached)\n        return cached;\n    var variables, type, name;\n     true ? Object(invariant_esm[\"b\" /* invariant */])(!!document && !!document.kind, 1) : undefined;\n    var fragments = document.definitions.filter(function (x) { return x.kind === 'FragmentDefinition'; });\n    var queries = document.definitions.filter(function (x) {\n        return x.kind === 'OperationDefinition' && x.operation === 'query';\n    });\n    var mutations = document.definitions.filter(function (x) {\n        return x.kind === 'OperationDefinition' && x.operation === 'mutation';\n    });\n    var subscriptions = document.definitions.filter(function (x) {\n        return x.kind === 'OperationDefinition' && x.operation === 'subscription';\n    });\n     true ? Object(invariant_esm[\"b\" /* invariant */])(!fragments.length ||\n        (queries.length || mutations.length || subscriptions.length), 2) : undefined;\n     true ? Object(invariant_esm[\"b\" /* invariant */])(queries.length + mutations.length + subscriptions.length <= 1, 3) : undefined;\n    type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n    if (!queries.length && !mutations.length)\n        type = DocumentType.Subscription;\n    var definitions = queries.length\n        ? queries\n        : mutations.length\n            ? mutations\n            : subscriptions;\n     true ? Object(invariant_esm[\"b\" /* invariant */])(definitions.length === 1, 4) : undefined;\n    var definition = definitions[0];\n    variables = definition.variableDefinitions || [];\n    if (definition.name && definition.name.kind === 'Name') {\n        name = definition.name.value;\n    }\n    else {\n        name = 'data';\n    }\n    var payload = { name: name, type: type, variables: variables };\n    react_common_esm_cache.set(document, payload);\n    return payload;\n}\n\n\n//# sourceMappingURL=react-common.esm.js.map\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./node_modules/apollo-utilities/lib/bundle.esm.js\nvar bundle_esm = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/@wry/equality/lib/equality.esm.js\nvar equality_esm = __webpack_require__(8);\n\n// EXTERNAL MODULE: ./node_modules/zen-observable/index.js\nvar zen_observable = __webpack_require__(22);\nvar zen_observable_default = /*#__PURE__*/__webpack_require__.n(zen_observable);\n\n// CONCATENATED MODULE: ./node_modules/zen-observable-ts/lib/bundle.esm.js\n\n\nvar bundle_esm_Observable = zen_observable_default.a;\n\n/* harmony default export */ var lib_bundle_esm = (bundle_esm_Observable);\n\n//# sourceMappingURL=bundle.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/apollo-link/lib/bundle.esm.js\n\n\n\n\n\n\n\nfunction validateOperation(operation) {\n    var OPERATION_FIELDS = [\n        'query',\n        'operationName',\n        'variables',\n        'extensions',\n        'context',\n    ];\n    for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {\n        var key = _a[_i];\n        if (OPERATION_FIELDS.indexOf(key) < 0) {\n            throw  true ? new invariant_esm[\"a\" /* InvariantError */](2) : undefined;\n        }\n    }\n    return operation;\n}\nvar bundle_esm_LinkError = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(LinkError, _super);\n    function LinkError(message, link) {\n        var _this = _super.call(this, message) || this;\n        _this.link = link;\n        return _this;\n    }\n    return LinkError;\n}(Error));\nfunction isTerminating(link) {\n    return link.request.length <= 1;\n}\nfunction toPromise(observable) {\n    var completed = false;\n    return new Promise(function (resolve, reject) {\n        observable.subscribe({\n            next: function (data) {\n                if (completed) {\n                     true || false;\n                }\n                else {\n                    completed = true;\n                    resolve(data);\n                }\n            },\n            error: reject,\n        });\n    });\n}\nvar makePromise = toPromise;\nfunction fromPromise(promise) {\n    return new lib_bundle_esm(function (observer) {\n        promise\n            .then(function (value) {\n            observer.next(value);\n            observer.complete();\n        })\n            .catch(observer.error.bind(observer));\n    });\n}\nfunction fromError(errorValue) {\n    return new lib_bundle_esm(function (observer) {\n        observer.error(errorValue);\n    });\n}\nfunction transformOperation(operation) {\n    var transformedOperation = {\n        variables: operation.variables || {},\n        extensions: operation.extensions || {},\n        operationName: operation.operationName,\n        query: operation.query,\n    };\n    if (!transformedOperation.operationName) {\n        transformedOperation.operationName =\n            typeof transformedOperation.query !== 'string'\n                ? Object(bundle_esm[\"n\" /* getOperationName */])(transformedOperation.query)\n                : '';\n    }\n    return transformedOperation;\n}\nfunction createOperation(starting, operation) {\n    var context = Object(tslib_es6[\"a\" /* __assign */])({}, starting);\n    var setContext = function (next) {\n        if (typeof next === 'function') {\n            context = Object(tslib_es6[\"a\" /* __assign */])({}, context, next(context));\n        }\n        else {\n            context = Object(tslib_es6[\"a\" /* __assign */])({}, context, next);\n        }\n    };\n    var getContext = function () { return (Object(tslib_es6[\"a\" /* __assign */])({}, context)); };\n    Object.defineProperty(operation, 'setContext', {\n        enumerable: false,\n        value: setContext,\n    });\n    Object.defineProperty(operation, 'getContext', {\n        enumerable: false,\n        value: getContext,\n    });\n    Object.defineProperty(operation, 'toKey', {\n        enumerable: false,\n        value: function () { return getKey(operation); },\n    });\n    return operation;\n}\nfunction getKey(operation) {\n    var query = operation.query, variables = operation.variables, operationName = operation.operationName;\n    return JSON.stringify([operationName, query, variables]);\n}\n\nfunction passthrough(op, forward) {\n    return forward ? forward(op) : lib_bundle_esm.of();\n}\nfunction toLink(handler) {\n    return typeof handler === 'function' ? new bundle_esm_ApolloLink(handler) : handler;\n}\nfunction empty() {\n    return new bundle_esm_ApolloLink(function () { return lib_bundle_esm.of(); });\n}\nfunction from(links) {\n    if (links.length === 0)\n        return empty();\n    return links.map(toLink).reduce(function (x, y) { return x.concat(y); });\n}\nfunction split(test, left, right) {\n    var leftLink = toLink(left);\n    var rightLink = toLink(right || new bundle_esm_ApolloLink(passthrough));\n    if (isTerminating(leftLink) && isTerminating(rightLink)) {\n        return new bundle_esm_ApolloLink(function (operation) {\n            return test(operation)\n                ? leftLink.request(operation) || lib_bundle_esm.of()\n                : rightLink.request(operation) || lib_bundle_esm.of();\n        });\n    }\n    else {\n        return new bundle_esm_ApolloLink(function (operation, forward) {\n            return test(operation)\n                ? leftLink.request(operation, forward) || lib_bundle_esm.of()\n                : rightLink.request(operation, forward) || lib_bundle_esm.of();\n        });\n    }\n}\nvar concat = function (first, second) {\n    var firstLink = toLink(first);\n    if (isTerminating(firstLink)) {\n         true || false;\n        return firstLink;\n    }\n    var nextLink = toLink(second);\n    if (isTerminating(nextLink)) {\n        return new bundle_esm_ApolloLink(function (operation) {\n            return firstLink.request(operation, function (op) { return nextLink.request(op) || lib_bundle_esm.of(); }) || lib_bundle_esm.of();\n        });\n    }\n    else {\n        return new bundle_esm_ApolloLink(function (operation, forward) {\n            return (firstLink.request(operation, function (op) {\n                return nextLink.request(op, forward) || lib_bundle_esm.of();\n            }) || lib_bundle_esm.of());\n        });\n    }\n};\nvar bundle_esm_ApolloLink = (function () {\n    function ApolloLink(request) {\n        if (request)\n            this.request = request;\n    }\n    ApolloLink.prototype.split = function (test, left, right) {\n        return this.concat(split(test, left, right || new ApolloLink(passthrough)));\n    };\n    ApolloLink.prototype.concat = function (next) {\n        return concat(this, next);\n    };\n    ApolloLink.prototype.request = function (operation, forward) {\n        throw  true ? new invariant_esm[\"a\" /* InvariantError */](1) : undefined;\n    };\n    ApolloLink.empty = empty;\n    ApolloLink.from = from;\n    ApolloLink.split = split;\n    ApolloLink.execute = bundle_esm_execute;\n    return ApolloLink;\n}());\nfunction bundle_esm_execute(link, operation) {\n    return (link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || lib_bundle_esm.of());\n}\n\n\n//# sourceMappingURL=bundle.esm.js.map\n\n// EXTERNAL MODULE: ./node_modules/symbol-observable/es/index.js\nvar es = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./node_modules/graphql/language/visitor.mjs\nvar visitor = __webpack_require__(7);\n\n// CONCATENATED MODULE: ./node_modules/apollo-client/bundle.esm.js\n\n\n\n\n\n\n\nvar NetworkStatus;\n(function (NetworkStatus) {\n    NetworkStatus[NetworkStatus[\"loading\"] = 1] = \"loading\";\n    NetworkStatus[NetworkStatus[\"setVariables\"] = 2] = \"setVariables\";\n    NetworkStatus[NetworkStatus[\"fetchMore\"] = 3] = \"fetchMore\";\n    NetworkStatus[NetworkStatus[\"refetch\"] = 4] = \"refetch\";\n    NetworkStatus[NetworkStatus[\"poll\"] = 6] = \"poll\";\n    NetworkStatus[NetworkStatus[\"ready\"] = 7] = \"ready\";\n    NetworkStatus[NetworkStatus[\"error\"] = 8] = \"error\";\n})(NetworkStatus || (NetworkStatus = {}));\nfunction isNetworkRequestInFlight(networkStatus) {\n    return networkStatus < 7;\n}\n\nvar apollo_client_bundle_esm_Observable = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(Observable, _super);\n    function Observable() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Observable.prototype[es[\"a\" /* default */]] = function () {\n        return this;\n    };\n    Observable.prototype['@@observable'] = function () {\n        return this;\n    };\n    return Observable;\n}(lib_bundle_esm));\n\nfunction isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\n\nfunction isApolloError(err) {\n    return err.hasOwnProperty('graphQLErrors');\n}\nvar generateErrorMessage = function (err) {\n    var message = '';\n    if (isNonEmptyArray(err.graphQLErrors)) {\n        err.graphQLErrors.forEach(function (graphQLError) {\n            var errorMessage = graphQLError\n                ? graphQLError.message\n                : 'Error message not found.';\n            message += \"GraphQL error: \" + errorMessage + \"\\n\";\n        });\n    }\n    if (err.networkError) {\n        message += 'Network error: ' + err.networkError.message + '\\n';\n    }\n    message = message.replace(/\\n$/, '');\n    return message;\n};\nvar bundle_esm_ApolloError = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(ApolloError, _super);\n    function ApolloError(_a) {\n        var graphQLErrors = _a.graphQLErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;\n        var _this = _super.call(this, errorMessage) || this;\n        _this.graphQLErrors = graphQLErrors || [];\n        _this.networkError = networkError || null;\n        if (!errorMessage) {\n            _this.message = generateErrorMessage(_this);\n        }\n        else {\n            _this.message = errorMessage;\n        }\n        _this.extraInfo = extraInfo;\n        _this.__proto__ = ApolloError.prototype;\n        return _this;\n    }\n    return ApolloError;\n}(Error));\n\nvar FetchType;\n(function (FetchType) {\n    FetchType[FetchType[\"normal\"] = 1] = \"normal\";\n    FetchType[FetchType[\"refetch\"] = 2] = \"refetch\";\n    FetchType[FetchType[\"poll\"] = 3] = \"poll\";\n})(FetchType || (FetchType = {}));\n\nvar hasError = function (storeValue, policy) {\n    if (policy === void 0) { policy = 'none'; }\n    return storeValue && (storeValue.networkError ||\n        (policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors)));\n};\nvar bundle_esm_ObservableQuery = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(ObservableQuery, _super);\n    function ObservableQuery(_a) {\n        var queryManager = _a.queryManager, options = _a.options, _b = _a.shouldSubscribe, shouldSubscribe = _b === void 0 ? true : _b;\n        var _this = _super.call(this, function (observer) {\n            return _this.onSubscribe(observer);\n        }) || this;\n        _this.observers = new Set();\n        _this.subscriptions = new Set();\n        _this.isTornDown = false;\n        _this.options = options;\n        _this.variables = options.variables || {};\n        _this.queryId = queryManager.generateQueryId();\n        _this.shouldSubscribe = shouldSubscribe;\n        var opDef = Object(bundle_esm[\"m\" /* getOperationDefinition */])(options.query);\n        _this.queryName = opDef && opDef.name && opDef.name.value;\n        _this.queryManager = queryManager;\n        return _this;\n    }\n    ObservableQuery.prototype.result = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var observer = {\n                next: function (result) {\n                    resolve(result);\n                    _this.observers.delete(observer);\n                    if (!_this.observers.size) {\n                        _this.queryManager.removeQuery(_this.queryId);\n                    }\n                    setTimeout(function () {\n                        subscription.unsubscribe();\n                    }, 0);\n                },\n                error: reject,\n            };\n            var subscription = _this.subscribe(observer);\n        });\n    };\n    ObservableQuery.prototype.currentResult = function () {\n        var result = this.getCurrentResult();\n        if (result.data === undefined) {\n            result.data = {};\n        }\n        return result;\n    };\n    ObservableQuery.prototype.getCurrentResult = function () {\n        if (this.isTornDown) {\n            var lastResult = this.lastResult;\n            return {\n                data: !this.lastError && lastResult && lastResult.data || void 0,\n                error: this.lastError,\n                loading: false,\n                networkStatus: NetworkStatus.error,\n            };\n        }\n        var _a = this.queryManager.getCurrentQueryResult(this), data = _a.data, partial = _a.partial;\n        var queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n        var result;\n        var fetchPolicy = this.options.fetchPolicy;\n        var isNetworkFetchPolicy = fetchPolicy === 'network-only' ||\n            fetchPolicy === 'no-cache';\n        if (queryStoreValue) {\n            var networkStatus = queryStoreValue.networkStatus;\n            if (hasError(queryStoreValue, this.options.errorPolicy)) {\n                return {\n                    data: void 0,\n                    loading: false,\n                    networkStatus: networkStatus,\n                    error: new bundle_esm_ApolloError({\n                        graphQLErrors: queryStoreValue.graphQLErrors,\n                        networkError: queryStoreValue.networkError,\n                    }),\n                };\n            }\n            if (queryStoreValue.variables) {\n                this.options.variables = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.options.variables), queryStoreValue.variables);\n                this.variables = this.options.variables;\n            }\n            result = {\n                data: data,\n                loading: isNetworkRequestInFlight(networkStatus),\n                networkStatus: networkStatus,\n            };\n            if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {\n                result.errors = queryStoreValue.graphQLErrors;\n            }\n        }\n        else {\n            var loading = isNetworkFetchPolicy ||\n                (partial && fetchPolicy !== 'cache-only');\n            result = {\n                data: data,\n                loading: loading,\n                networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready,\n            };\n        }\n        if (!partial) {\n            this.updateLastResult(Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, result), { stale: false }));\n        }\n        return Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, result), { partial: partial });\n    };\n    ObservableQuery.prototype.isDifferentFromLastResult = function (newResult) {\n        var snapshot = this.lastResultSnapshot;\n        return !(snapshot &&\n            newResult &&\n            snapshot.networkStatus === newResult.networkStatus &&\n            snapshot.stale === newResult.stale &&\n            Object(equality_esm[\"a\" /* equal */])(snapshot.data, newResult.data));\n    };\n    ObservableQuery.prototype.getLastResult = function () {\n        return this.lastResult;\n    };\n    ObservableQuery.prototype.getLastError = function () {\n        return this.lastError;\n    };\n    ObservableQuery.prototype.resetLastResults = function () {\n        delete this.lastResult;\n        delete this.lastResultSnapshot;\n        delete this.lastError;\n        this.isTornDown = false;\n    };\n    ObservableQuery.prototype.resetQueryStoreErrors = function () {\n        var queryStore = this.queryManager.queryStore.get(this.queryId);\n        if (queryStore) {\n            queryStore.networkError = null;\n            queryStore.graphQLErrors = [];\n        }\n    };\n    ObservableQuery.prototype.refetch = function (variables) {\n        var fetchPolicy = this.options.fetchPolicy;\n        if (fetchPolicy === 'cache-only') {\n            return Promise.reject( true ? new invariant_esm[\"a\" /* InvariantError */](1) : undefined);\n        }\n        if (fetchPolicy !== 'no-cache' &&\n            fetchPolicy !== 'cache-and-network') {\n            fetchPolicy = 'network-only';\n        }\n        if (!Object(equality_esm[\"a\" /* equal */])(this.variables, variables)) {\n            this.variables = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.variables), variables);\n        }\n        if (!Object(equality_esm[\"a\" /* equal */])(this.options.variables, this.variables)) {\n            this.options.variables = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.options.variables), this.variables);\n        }\n        return this.queryManager.fetchQuery(this.queryId, Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.options), { fetchPolicy: fetchPolicy }), FetchType.refetch);\n    };\n    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {\n        var _this = this;\n         true ? Object(invariant_esm[\"b\" /* invariant */])(fetchMoreOptions.updateQuery, 2) : undefined;\n        var combinedOptions = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, (fetchMoreOptions.query ? fetchMoreOptions : Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.options), fetchMoreOptions), { variables: Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.variables), fetchMoreOptions.variables) }))), { fetchPolicy: 'network-only' });\n        var qid = this.queryManager.generateQueryId();\n        return this.queryManager\n            .fetchQuery(qid, combinedOptions, FetchType.normal, this.queryId)\n            .then(function (fetchMoreResult) {\n            _this.updateQuery(function (previousResult) {\n                return fetchMoreOptions.updateQuery(previousResult, {\n                    fetchMoreResult: fetchMoreResult.data,\n                    variables: combinedOptions.variables,\n                });\n            });\n            _this.queryManager.stopQuery(qid);\n            return fetchMoreResult;\n        }, function (error) {\n            _this.queryManager.stopQuery(qid);\n            throw error;\n        });\n    };\n    ObservableQuery.prototype.subscribeToMore = function (options) {\n        var _this = this;\n        var subscription = this.queryManager\n            .startGraphQLSubscription({\n            query: options.document,\n            variables: options.variables,\n        })\n            .subscribe({\n            next: function (subscriptionData) {\n                var updateQuery = options.updateQuery;\n                if (updateQuery) {\n                    _this.updateQuery(function (previous, _a) {\n                        var variables = _a.variables;\n                        return updateQuery(previous, {\n                            subscriptionData: subscriptionData,\n                            variables: variables,\n                        });\n                    });\n                }\n            },\n            error: function (err) {\n                if (options.onError) {\n                    options.onError(err);\n                    return;\n                }\n                 true || false;\n            },\n        });\n        this.subscriptions.add(subscription);\n        return function () {\n            if (_this.subscriptions.delete(subscription)) {\n                subscription.unsubscribe();\n            }\n        };\n    };\n    ObservableQuery.prototype.setOptions = function (opts) {\n        var oldFetchPolicy = this.options.fetchPolicy;\n        this.options = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.options), opts);\n        if (opts.pollInterval) {\n            this.startPolling(opts.pollInterval);\n        }\n        else if (opts.pollInterval === 0) {\n            this.stopPolling();\n        }\n        var fetchPolicy = opts.fetchPolicy;\n        return this.setVariables(this.options.variables, oldFetchPolicy !== fetchPolicy && (oldFetchPolicy === 'cache-only' ||\n            oldFetchPolicy === 'standby' ||\n            fetchPolicy === 'network-only'), opts.fetchResults);\n    };\n    ObservableQuery.prototype.setVariables = function (variables, tryFetch, fetchResults) {\n        if (tryFetch === void 0) { tryFetch = false; }\n        if (fetchResults === void 0) { fetchResults = true; }\n        this.isTornDown = false;\n        variables = variables || this.variables;\n        if (!tryFetch && Object(equality_esm[\"a\" /* equal */])(variables, this.variables)) {\n            return this.observers.size && fetchResults\n                ? this.result()\n                : Promise.resolve();\n        }\n        this.variables = this.options.variables = variables;\n        if (!this.observers.size) {\n            return Promise.resolve();\n        }\n        return this.queryManager.fetchQuery(this.queryId, this.options);\n    };\n    ObservableQuery.prototype.updateQuery = function (mapFn) {\n        var queryManager = this.queryManager;\n        var _a = queryManager.getQueryWithPreviousResult(this.queryId), previousResult = _a.previousResult, variables = _a.variables, document = _a.document;\n        var newResult = Object(bundle_esm[\"I\" /* tryFunctionOrLogError */])(function () {\n            return mapFn(previousResult, { variables: variables });\n        });\n        if (newResult) {\n            queryManager.dataStore.markUpdateQueryResult(document, variables, newResult);\n            queryManager.broadcastQueries();\n        }\n    };\n    ObservableQuery.prototype.stopPolling = function () {\n        this.queryManager.stopPollingQuery(this.queryId);\n        this.options.pollInterval = undefined;\n    };\n    ObservableQuery.prototype.startPolling = function (pollInterval) {\n        assertNotCacheFirstOrOnly(this);\n        this.options.pollInterval = pollInterval;\n        this.queryManager.startPollingQuery(this.options, this.queryId);\n    };\n    ObservableQuery.prototype.updateLastResult = function (newResult) {\n        var previousResult = this.lastResult;\n        this.lastResult = newResult;\n        this.lastResultSnapshot = this.queryManager.assumeImmutableResults\n            ? newResult\n            : Object(bundle_esm[\"f\" /* cloneDeep */])(newResult);\n        return previousResult;\n    };\n    ObservableQuery.prototype.onSubscribe = function (observer) {\n        var _this = this;\n        try {\n            var subObserver = observer._subscription._observer;\n            if (subObserver && !subObserver.error) {\n                subObserver.error = defaultSubscriptionObserverErrorCallback;\n            }\n        }\n        catch (_a) { }\n        var first = !this.observers.size;\n        this.observers.add(observer);\n        if (observer.next && this.lastResult)\n            observer.next(this.lastResult);\n        if (observer.error && this.lastError)\n            observer.error(this.lastError);\n        if (first) {\n            this.setUpQuery();\n        }\n        return function () {\n            if (_this.observers.delete(observer) && !_this.observers.size) {\n                _this.tearDownQuery();\n            }\n        };\n    };\n    ObservableQuery.prototype.setUpQuery = function () {\n        var _this = this;\n        var _a = this, queryManager = _a.queryManager, queryId = _a.queryId;\n        if (this.shouldSubscribe) {\n            queryManager.addObservableQuery(queryId, this);\n        }\n        if (this.options.pollInterval) {\n            assertNotCacheFirstOrOnly(this);\n            queryManager.startPollingQuery(this.options, queryId);\n        }\n        var onError = function (error) {\n            _this.updateLastResult(Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, _this.lastResult), { errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false }));\n            iterateObserversSafely(_this.observers, 'error', _this.lastError = error);\n        };\n        queryManager.observeQuery(queryId, this.options, {\n            next: function (result) {\n                if (_this.lastError || _this.isDifferentFromLastResult(result)) {\n                    var previousResult_1 = _this.updateLastResult(result);\n                    var _a = _this.options, query_1 = _a.query, variables = _a.variables, fetchPolicy_1 = _a.fetchPolicy;\n                    if (queryManager.transform(query_1).hasClientExports) {\n                        queryManager.getLocalState().addExportedVariables(query_1, variables).then(function (variables) {\n                            var previousVariables = _this.variables;\n                            _this.variables = _this.options.variables = variables;\n                            if (!result.loading &&\n                                previousResult_1 &&\n                                fetchPolicy_1 !== 'cache-only' &&\n                                queryManager.transform(query_1).serverQuery &&\n                                !Object(equality_esm[\"a\" /* equal */])(previousVariables, variables)) {\n                                _this.refetch();\n                            }\n                            else {\n                                iterateObserversSafely(_this.observers, 'next', result);\n                            }\n                        });\n                    }\n                    else {\n                        iterateObserversSafely(_this.observers, 'next', result);\n                    }\n                }\n            },\n            error: onError,\n        }).catch(onError);\n    };\n    ObservableQuery.prototype.tearDownQuery = function () {\n        var queryManager = this.queryManager;\n        this.isTornDown = true;\n        queryManager.stopPollingQuery(this.queryId);\n        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });\n        this.subscriptions.clear();\n        queryManager.removeObservableQuery(this.queryId);\n        queryManager.stopQuery(this.queryId);\n        this.observers.clear();\n    };\n    return ObservableQuery;\n}(apollo_client_bundle_esm_Observable));\nfunction defaultSubscriptionObserverErrorCallback(error) {\n     true || false;\n}\nfunction iterateObserversSafely(observers, method, argument) {\n    var observersWithMethod = [];\n    observers.forEach(function (obs) { return obs[method] && observersWithMethod.push(obs); });\n    observersWithMethod.forEach(function (obs) { return obs[method](argument); });\n}\nfunction assertNotCacheFirstOrOnly(obsQuery) {\n    var fetchPolicy = obsQuery.options.fetchPolicy;\n     true ? Object(invariant_esm[\"b\" /* invariant */])(fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only', 3) : undefined;\n}\n\nvar MutationStore = (function () {\n    function MutationStore() {\n        this.store = {};\n    }\n    MutationStore.prototype.getStore = function () {\n        return this.store;\n    };\n    MutationStore.prototype.get = function (mutationId) {\n        return this.store[mutationId];\n    };\n    MutationStore.prototype.initMutation = function (mutationId, mutation, variables) {\n        this.store[mutationId] = {\n            mutation: mutation,\n            variables: variables || {},\n            loading: true,\n            error: null,\n        };\n    };\n    MutationStore.prototype.markMutationError = function (mutationId, error) {\n        var mutation = this.store[mutationId];\n        if (mutation) {\n            mutation.loading = false;\n            mutation.error = error;\n        }\n    };\n    MutationStore.prototype.markMutationResult = function (mutationId) {\n        var mutation = this.store[mutationId];\n        if (mutation) {\n            mutation.loading = false;\n            mutation.error = null;\n        }\n    };\n    MutationStore.prototype.reset = function () {\n        this.store = {};\n    };\n    return MutationStore;\n}());\n\nvar bundle_esm_QueryStore = (function () {\n    function QueryStore() {\n        this.store = {};\n    }\n    QueryStore.prototype.getStore = function () {\n        return this.store;\n    };\n    QueryStore.prototype.get = function (queryId) {\n        return this.store[queryId];\n    };\n    QueryStore.prototype.initQuery = function (query) {\n        var previousQuery = this.store[query.queryId];\n         true ? Object(invariant_esm[\"b\" /* invariant */])(!previousQuery ||\n            previousQuery.document === query.document ||\n            Object(equality_esm[\"a\" /* equal */])(previousQuery.document, query.document), 19) : undefined;\n        var isSetVariables = false;\n        var previousVariables = null;\n        if (query.storePreviousVariables &&\n            previousQuery &&\n            previousQuery.networkStatus !== NetworkStatus.loading) {\n            if (!Object(equality_esm[\"a\" /* equal */])(previousQuery.variables, query.variables)) {\n                isSetVariables = true;\n                previousVariables = previousQuery.variables;\n            }\n        }\n        var networkStatus;\n        if (isSetVariables) {\n            networkStatus = NetworkStatus.setVariables;\n        }\n        else if (query.isPoll) {\n            networkStatus = NetworkStatus.poll;\n        }\n        else if (query.isRefetch) {\n            networkStatus = NetworkStatus.refetch;\n        }\n        else {\n            networkStatus = NetworkStatus.loading;\n        }\n        var graphQLErrors = [];\n        if (previousQuery && previousQuery.graphQLErrors) {\n            graphQLErrors = previousQuery.graphQLErrors;\n        }\n        this.store[query.queryId] = {\n            document: query.document,\n            variables: query.variables,\n            previousVariables: previousVariables,\n            networkError: null,\n            graphQLErrors: graphQLErrors,\n            networkStatus: networkStatus,\n            metadata: query.metadata,\n        };\n        if (typeof query.fetchMoreForQueryId === 'string' &&\n            this.store[query.fetchMoreForQueryId]) {\n            this.store[query.fetchMoreForQueryId].networkStatus =\n                NetworkStatus.fetchMore;\n        }\n    };\n    QueryStore.prototype.markQueryResult = function (queryId, result, fetchMoreForQueryId) {\n        if (!this.store || !this.store[queryId])\n            return;\n        this.store[queryId].networkError = null;\n        this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];\n        this.store[queryId].previousVariables = null;\n        this.store[queryId].networkStatus = NetworkStatus.ready;\n        if (typeof fetchMoreForQueryId === 'string' &&\n            this.store[fetchMoreForQueryId]) {\n            this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n        }\n    };\n    QueryStore.prototype.markQueryError = function (queryId, error, fetchMoreForQueryId) {\n        if (!this.store || !this.store[queryId])\n            return;\n        this.store[queryId].networkError = error;\n        this.store[queryId].networkStatus = NetworkStatus.error;\n        if (typeof fetchMoreForQueryId === 'string') {\n            this.markQueryResultClient(fetchMoreForQueryId, true);\n        }\n    };\n    QueryStore.prototype.markQueryResultClient = function (queryId, complete) {\n        var storeValue = this.store && this.store[queryId];\n        if (storeValue) {\n            storeValue.networkError = null;\n            storeValue.previousVariables = null;\n            if (complete) {\n                storeValue.networkStatus = NetworkStatus.ready;\n            }\n        }\n    };\n    QueryStore.prototype.stopQuery = function (queryId) {\n        delete this.store[queryId];\n    };\n    QueryStore.prototype.reset = function (observableQueryIds) {\n        var _this = this;\n        Object.keys(this.store).forEach(function (queryId) {\n            if (observableQueryIds.indexOf(queryId) < 0) {\n                _this.stopQuery(queryId);\n            }\n            else {\n                _this.store[queryId].networkStatus = NetworkStatus.loading;\n            }\n        });\n    };\n    return QueryStore;\n}());\n\nfunction capitalizeFirstLetter(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nvar bundle_esm_LocalState = (function () {\n    function LocalState(_a) {\n        var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;\n        this.cache = cache;\n        if (client) {\n            this.client = client;\n        }\n        if (resolvers) {\n            this.addResolvers(resolvers);\n        }\n        if (fragmentMatcher) {\n            this.setFragmentMatcher(fragmentMatcher);\n        }\n    }\n    LocalState.prototype.addResolvers = function (resolvers) {\n        var _this = this;\n        this.resolvers = this.resolvers || {};\n        if (Array.isArray(resolvers)) {\n            resolvers.forEach(function (resolverGroup) {\n                _this.resolvers = Object(bundle_esm[\"A\" /* mergeDeep */])(_this.resolvers, resolverGroup);\n            });\n        }\n        else {\n            this.resolvers = Object(bundle_esm[\"A\" /* mergeDeep */])(this.resolvers, resolvers);\n        }\n    };\n    LocalState.prototype.setResolvers = function (resolvers) {\n        this.resolvers = {};\n        this.addResolvers(resolvers);\n    };\n    LocalState.prototype.getResolvers = function () {\n        return this.resolvers || {};\n    };\n    LocalState.prototype.runResolvers = function (_a) {\n        var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;\n        return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_c) {\n                if (document) {\n                    return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) { return (Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, remoteResult), { data: localResult.result })); })];\n                }\n                return [2, remoteResult];\n            });\n        });\n    };\n    LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n        this.fragmentMatcher = fragmentMatcher;\n    };\n    LocalState.prototype.getFragmentMatcher = function () {\n        return this.fragmentMatcher;\n    };\n    LocalState.prototype.clientQuery = function (document) {\n        if (Object(bundle_esm[\"s\" /* hasDirectives */])(['client'], document)) {\n            if (this.resolvers) {\n                return document;\n            }\n             true || false;\n        }\n        return null;\n    };\n    LocalState.prototype.serverQuery = function (document) {\n        return this.resolvers ? Object(bundle_esm[\"C\" /* removeClientSetsFromDocument */])(document) : document;\n    };\n    LocalState.prototype.prepareContext = function (context) {\n        if (context === void 0) { context = {}; }\n        var cache = this.cache;\n        var newContext = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, context), { cache: cache, getCacheKey: function (obj) {\n                if (cache.config) {\n                    return cache.config.dataIdFromObject(obj);\n                }\n                else {\n                     true ? Object(invariant_esm[\"b\" /* invariant */])(false, 6) : undefined;\n                }\n            } });\n        return newContext;\n    };\n    LocalState.prototype.addExportedVariables = function (document, variables, context) {\n        if (variables === void 0) { variables = {}; }\n        if (context === void 0) { context = {}; }\n        return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_a) {\n                if (document) {\n                    return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) { return (Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, variables), data.exportedVariables)); })];\n                }\n                return [2, Object(tslib_es6[\"a\" /* __assign */])({}, variables)];\n            });\n        });\n    };\n    LocalState.prototype.shouldForceResolvers = function (document) {\n        var forceResolvers = false;\n        Object(visitor[\"b\" /* visit */])(document, {\n            Directive: {\n                enter: function (node) {\n                    if (node.name.value === 'client' && node.arguments) {\n                        forceResolvers = node.arguments.some(function (arg) {\n                            return arg.name.value === 'always' &&\n                                arg.value.kind === 'BooleanValue' &&\n                                arg.value.value === true;\n                        });\n                        if (forceResolvers) {\n                            return visitor[\"a\" /* BREAK */];\n                        }\n                    }\n                },\n            },\n        });\n        return forceResolvers;\n    };\n    LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n        return this.cache.diff({\n            query: Object(bundle_esm[\"d\" /* buildQueryFromSelectionSet */])(document),\n            variables: variables,\n            returnPartialData: true,\n            optimistic: false,\n        }).result;\n    };\n    LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n        if (context === void 0) { context = {}; }\n        if (variables === void 0) { variables = {}; }\n        if (fragmentMatcher === void 0) { fragmentMatcher = function () { return true; }; }\n        if (onlyRunForcedResolvers === void 0) { onlyRunForcedResolvers = false; }\n        return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\n            var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_b) {\n                mainDefinition = Object(bundle_esm[\"l\" /* getMainDefinition */])(document);\n                fragments = Object(bundle_esm[\"j\" /* getFragmentDefinitions */])(document);\n                fragmentMap = Object(bundle_esm[\"g\" /* createFragmentMap */])(fragments);\n                definitionOperation = mainDefinition\n                    .operation;\n                defaultOperationType = definitionOperation\n                    ? capitalizeFirstLetter(definitionOperation)\n                    : 'Query';\n                _a = this, cache = _a.cache, client = _a.client;\n                execContext = {\n                    fragmentMap: fragmentMap,\n                    context: Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, context), { cache: cache,\n                        client: client }),\n                    variables: variables,\n                    fragmentMatcher: fragmentMatcher,\n                    defaultOperationType: defaultOperationType,\n                    exportedVariables: {},\n                    onlyRunForcedResolvers: onlyRunForcedResolvers,\n                };\n                return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function (result) { return ({\n                        result: result,\n                        exportedVariables: execContext.exportedVariables,\n                    }); })];\n            });\n        });\n    };\n    LocalState.prototype.resolveSelectionSet = function (selectionSet, rootValue, execContext) {\n        return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\n            var fragmentMap, context, variables, resultsToMerge, execute;\n            var _this = this;\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_a) {\n                fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n                resultsToMerge = [rootValue];\n                execute = function (selection) { return Object(tslib_es6[\"b\" /* __awaiter */])(_this, void 0, void 0, function () {\n                    var fragment, typeCondition;\n                    return Object(tslib_es6[\"d\" /* __generator */])(this, function (_a) {\n                        if (!Object(bundle_esm[\"F\" /* shouldInclude */])(selection, variables)) {\n                            return [2];\n                        }\n                        if (Object(bundle_esm[\"t\" /* isField */])(selection)) {\n                            return [2, this.resolveField(selection, rootValue, execContext).then(function (fieldResult) {\n                                    var _a;\n                                    if (typeof fieldResult !== 'undefined') {\n                                        resultsToMerge.push((_a = {},\n                                            _a[Object(bundle_esm[\"E\" /* resultKeyNameFromField */])(selection)] = fieldResult,\n                                            _a));\n                                    }\n                                })];\n                        }\n                        if (Object(bundle_esm[\"v\" /* isInlineFragment */])(selection)) {\n                            fragment = selection;\n                        }\n                        else {\n                            fragment = fragmentMap[selection.name.value];\n                             true ? Object(invariant_esm[\"b\" /* invariant */])(fragment, 7) : undefined;\n                        }\n                        if (fragment && fragment.typeCondition) {\n                            typeCondition = fragment.typeCondition.name.value;\n                            if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                                return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function (fragmentResult) {\n                                        resultsToMerge.push(fragmentResult);\n                                    })];\n                            }\n                        }\n                        return [2];\n                    });\n                }); };\n                return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {\n                        return Object(bundle_esm[\"B\" /* mergeDeepArray */])(resultsToMerge);\n                    })];\n            });\n        });\n    };\n    LocalState.prototype.resolveField = function (field, rootValue, execContext) {\n        return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\n            var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n            var _this = this;\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_a) {\n                variables = execContext.variables;\n                fieldName = field.name.value;\n                aliasedFieldName = Object(bundle_esm[\"E\" /* resultKeyNameFromField */])(field);\n                aliasUsed = fieldName !== aliasedFieldName;\n                defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n                resultPromise = Promise.resolve(defaultResult);\n                if (!execContext.onlyRunForcedResolvers ||\n                    this.shouldForceResolvers(field)) {\n                    resolverType = rootValue.__typename || execContext.defaultOperationType;\n                    resolverMap = this.resolvers && this.resolvers[resolverType];\n                    if (resolverMap) {\n                        resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n                        if (resolve) {\n                            resultPromise = Promise.resolve(resolve(rootValue, Object(bundle_esm[\"b\" /* argumentsObjectFromField */])(field, variables), execContext.context, { field: field, fragmentMap: execContext.fragmentMap }));\n                        }\n                    }\n                }\n                return [2, resultPromise.then(function (result) {\n                        if (result === void 0) { result = defaultResult; }\n                        if (field.directives) {\n                            field.directives.forEach(function (directive) {\n                                if (directive.name.value === 'export' && directive.arguments) {\n                                    directive.arguments.forEach(function (arg) {\n                                        if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                                            execContext.exportedVariables[arg.value.value] = result;\n                                        }\n                                    });\n                                }\n                            });\n                        }\n                        if (!field.selectionSet) {\n                            return result;\n                        }\n                        if (result == null) {\n                            return result;\n                        }\n                        if (Array.isArray(result)) {\n                            return _this.resolveSubSelectedArray(field, result, execContext);\n                        }\n                        if (field.selectionSet) {\n                            return _this.resolveSelectionSet(field.selectionSet, result, execContext);\n                        }\n                    })];\n            });\n        });\n    };\n    LocalState.prototype.resolveSubSelectedArray = function (field, result, execContext) {\n        var _this = this;\n        return Promise.all(result.map(function (item) {\n            if (item === null) {\n                return null;\n            }\n            if (Array.isArray(item)) {\n                return _this.resolveSubSelectedArray(field, item, execContext);\n            }\n            if (field.selectionSet) {\n                return _this.resolveSelectionSet(field.selectionSet, item, execContext);\n            }\n        }));\n    };\n    return LocalState;\n}());\n\nfunction multiplex(inner) {\n    var observers = new Set();\n    var sub = null;\n    return new apollo_client_bundle_esm_Observable(function (observer) {\n        observers.add(observer);\n        sub = sub || inner.subscribe({\n            next: function (value) {\n                observers.forEach(function (obs) { return obs.next && obs.next(value); });\n            },\n            error: function (error) {\n                observers.forEach(function (obs) { return obs.error && obs.error(error); });\n            },\n            complete: function () {\n                observers.forEach(function (obs) { return obs.complete && obs.complete(); });\n            },\n        });\n        return function () {\n            if (observers.delete(observer) && !observers.size && sub) {\n                sub.unsubscribe();\n                sub = null;\n            }\n        };\n    });\n}\nfunction asyncMap(observable, mapFn) {\n    return new apollo_client_bundle_esm_Observable(function (observer) {\n        var next = observer.next, error = observer.error, complete = observer.complete;\n        var activeNextCount = 0;\n        var completed = false;\n        var handler = {\n            next: function (value) {\n                ++activeNextCount;\n                new Promise(function (resolve) {\n                    resolve(mapFn(value));\n                }).then(function (result) {\n                    --activeNextCount;\n                    next && next.call(observer, result);\n                    completed && handler.complete();\n                }, function (e) {\n                    --activeNextCount;\n                    error && error.call(observer, e);\n                });\n            },\n            error: function (e) {\n                error && error.call(observer, e);\n            },\n            complete: function () {\n                completed = true;\n                if (!activeNextCount) {\n                    complete && complete.call(observer);\n                }\n            },\n        };\n        var sub = observable.subscribe(handler);\n        return function () { return sub.unsubscribe(); };\n    });\n}\n\nvar bundle_esm_hasOwnProperty = Object.prototype.hasOwnProperty;\nvar bundle_esm_QueryManager = (function () {\n    function QueryManager(_a) {\n        var link = _a.link, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, store = _a.store, _c = _a.onBroadcast, onBroadcast = _c === void 0 ? function () { return undefined; } : _c, _d = _a.ssrMode, ssrMode = _d === void 0 ? false : _d, _e = _a.clientAwareness, clientAwareness = _e === void 0 ? {} : _e, localState = _a.localState, assumeImmutableResults = _a.assumeImmutableResults;\n        this.mutationStore = new MutationStore();\n        this.queryStore = new bundle_esm_QueryStore();\n        this.clientAwareness = {};\n        this.idCounter = 1;\n        this.queries = new Map();\n        this.fetchQueryRejectFns = new Map();\n        this.transformCache = new (bundle_esm[\"e\" /* canUseWeakMap */] ? WeakMap : Map)();\n        this.inFlightLinkObservables = new Map();\n        this.pollingInfoByQueryId = new Map();\n        this.link = link;\n        this.queryDeduplication = queryDeduplication;\n        this.dataStore = store;\n        this.onBroadcast = onBroadcast;\n        this.clientAwareness = clientAwareness;\n        this.localState = localState || new bundle_esm_LocalState({ cache: store.getCache() });\n        this.ssrMode = ssrMode;\n        this.assumeImmutableResults = !!assumeImmutableResults;\n    }\n    QueryManager.prototype.stop = function () {\n        var _this = this;\n        this.queries.forEach(function (_info, queryId) {\n            _this.stopQueryNoBroadcast(queryId);\n        });\n        this.fetchQueryRejectFns.forEach(function (reject) {\n            reject( true ? new invariant_esm[\"a\" /* InvariantError */](8) : undefined);\n        });\n    };\n    QueryManager.prototype.mutate = function (_a) {\n        var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueriesByName = _a.updateQueries, _b = _a.refetchQueries, refetchQueries = _b === void 0 ? [] : _b, _c = _a.awaitRefetchQueries, awaitRefetchQueries = _c === void 0 ? false : _c, updateWithProxyFn = _a.update, _d = _a.errorPolicy, errorPolicy = _d === void 0 ? 'none' : _d, fetchPolicy = _a.fetchPolicy, _e = _a.context, context = _e === void 0 ? {} : _e;\n        return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\n            var mutationId, generateUpdateQueriesInfo, self;\n            var _this = this;\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_f) {\n                switch (_f.label) {\n                    case 0:\n                         true ? Object(invariant_esm[\"b\" /* invariant */])(mutation, 9) : undefined;\n                         true ? Object(invariant_esm[\"b\" /* invariant */])(!fetchPolicy || fetchPolicy === 'no-cache', 10) : undefined;\n                        mutationId = this.generateQueryId();\n                        mutation = this.transform(mutation).document;\n                        this.setQuery(mutationId, function () { return ({ document: mutation }); });\n                        variables = this.getVariables(mutation, variables);\n                        if (!this.transform(mutation).hasClientExports) return [3, 2];\n                        return [4, this.localState.addExportedVariables(mutation, variables, context)];\n                    case 1:\n                        variables = _f.sent();\n                        _f.label = 2;\n                    case 2:\n                        generateUpdateQueriesInfo = function () {\n                            var ret = {};\n                            if (updateQueriesByName) {\n                                _this.queries.forEach(function (_a, queryId) {\n                                    var observableQuery = _a.observableQuery;\n                                    if (observableQuery) {\n                                        var queryName = observableQuery.queryName;\n                                        if (queryName &&\n                                            bundle_esm_hasOwnProperty.call(updateQueriesByName, queryName)) {\n                                            ret[queryId] = {\n                                                updater: updateQueriesByName[queryName],\n                                                query: _this.queryStore.get(queryId),\n                                            };\n                                        }\n                                    }\n                                });\n                            }\n                            return ret;\n                        };\n                        this.mutationStore.initMutation(mutationId, mutation, variables);\n                        this.dataStore.markMutationInit({\n                            mutationId: mutationId,\n                            document: mutation,\n                            variables: variables,\n                            updateQueries: generateUpdateQueriesInfo(),\n                            update: updateWithProxyFn,\n                            optimisticResponse: optimisticResponse,\n                        });\n                        this.broadcastQueries();\n                        self = this;\n                        return [2, new Promise(function (resolve, reject) {\n                                var storeResult;\n                                var error;\n                                self.getObservableFromLink(mutation, Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, context), { optimisticResponse: optimisticResponse }), variables, false).subscribe({\n                                    next: function (result) {\n                                        if (Object(bundle_esm[\"q\" /* graphQLResultHasError */])(result) && errorPolicy === 'none') {\n                                            error = new bundle_esm_ApolloError({\n                                                graphQLErrors: result.errors,\n                                            });\n                                            return;\n                                        }\n                                        self.mutationStore.markMutationResult(mutationId);\n                                        if (fetchPolicy !== 'no-cache') {\n                                            self.dataStore.markMutationResult({\n                                                mutationId: mutationId,\n                                                result: result,\n                                                document: mutation,\n                                                variables: variables,\n                                                updateQueries: generateUpdateQueriesInfo(),\n                                                update: updateWithProxyFn,\n                                            });\n                                        }\n                                        storeResult = result;\n                                    },\n                                    error: function (err) {\n                                        self.mutationStore.markMutationError(mutationId, err);\n                                        self.dataStore.markMutationComplete({\n                                            mutationId: mutationId,\n                                            optimisticResponse: optimisticResponse,\n                                        });\n                                        self.broadcastQueries();\n                                        self.setQuery(mutationId, function () { return ({ document: null }); });\n                                        reject(new bundle_esm_ApolloError({\n                                            networkError: err,\n                                        }));\n                                    },\n                                    complete: function () {\n                                        if (error) {\n                                            self.mutationStore.markMutationError(mutationId, error);\n                                        }\n                                        self.dataStore.markMutationComplete({\n                                            mutationId: mutationId,\n                                            optimisticResponse: optimisticResponse,\n                                        });\n                                        self.broadcastQueries();\n                                        if (error) {\n                                            reject(error);\n                                            return;\n                                        }\n                                        if (typeof refetchQueries === 'function') {\n                                            refetchQueries = refetchQueries(storeResult);\n                                        }\n                                        var refetchQueryPromises = [];\n                                        if (isNonEmptyArray(refetchQueries)) {\n                                            refetchQueries.forEach(function (refetchQuery) {\n                                                if (typeof refetchQuery === 'string') {\n                                                    self.queries.forEach(function (_a) {\n                                                        var observableQuery = _a.observableQuery;\n                                                        if (observableQuery &&\n                                                            observableQuery.queryName === refetchQuery) {\n                                                            refetchQueryPromises.push(observableQuery.refetch());\n                                                        }\n                                                    });\n                                                }\n                                                else {\n                                                    var queryOptions = {\n                                                        query: refetchQuery.query,\n                                                        variables: refetchQuery.variables,\n                                                        fetchPolicy: 'network-only',\n                                                    };\n                                                    if (refetchQuery.context) {\n                                                        queryOptions.context = refetchQuery.context;\n                                                    }\n                                                    refetchQueryPromises.push(self.query(queryOptions));\n                                                }\n                                            });\n                                        }\n                                        Promise.all(awaitRefetchQueries ? refetchQueryPromises : []).then(function () {\n                                            self.setQuery(mutationId, function () { return ({ document: null }); });\n                                            if (errorPolicy === 'ignore' &&\n                                                storeResult &&\n                                                Object(bundle_esm[\"q\" /* graphQLResultHasError */])(storeResult)) {\n                                                delete storeResult.errors;\n                                            }\n                                            resolve(storeResult);\n                                        });\n                                    },\n                                });\n                            })];\n                }\n            });\n        });\n    };\n    QueryManager.prototype.fetchQuery = function (queryId, options, fetchType, fetchMoreForQueryId) {\n        return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\n            var _a, metadata, _b, fetchPolicy, _c, context, query, variables, storeResult, isNetworkOnly, needToFetch, _d, complete, result, shouldFetch, requestId, cancel, networkResult;\n            var _this = this;\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        _a = options.metadata, metadata = _a === void 0 ? null : _a, _b = options.fetchPolicy, fetchPolicy = _b === void 0 ? 'cache-first' : _b, _c = options.context, context = _c === void 0 ? {} : _c;\n                        query = this.transform(options.query).document;\n                        variables = this.getVariables(query, options.variables);\n                        if (!this.transform(query).hasClientExports) return [3, 2];\n                        return [4, this.localState.addExportedVariables(query, variables, context)];\n                    case 1:\n                        variables = _e.sent();\n                        _e.label = 2;\n                    case 2:\n                        options = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, options), { variables: variables });\n                        isNetworkOnly = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n                        needToFetch = isNetworkOnly;\n                        if (!isNetworkOnly) {\n                            _d = this.dataStore.getCache().diff({\n                                query: query,\n                                variables: variables,\n                                returnPartialData: true,\n                                optimistic: false,\n                            }), complete = _d.complete, result = _d.result;\n                            needToFetch = !complete || fetchPolicy === 'cache-and-network';\n                            storeResult = result;\n                        }\n                        shouldFetch = needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n                        if (Object(bundle_esm[\"s\" /* hasDirectives */])(['live'], query))\n                            shouldFetch = true;\n                        requestId = this.idCounter++;\n                        cancel = fetchPolicy !== 'no-cache'\n                            ? this.updateQueryWatch(queryId, query, options)\n                            : undefined;\n                        this.setQuery(queryId, function () { return ({\n                            document: query,\n                            lastRequestId: requestId,\n                            invalidated: true,\n                            cancel: cancel,\n                        }); });\n                        this.invalidate(fetchMoreForQueryId);\n                        this.queryStore.initQuery({\n                            queryId: queryId,\n                            document: query,\n                            storePreviousVariables: shouldFetch,\n                            variables: variables,\n                            isPoll: fetchType === FetchType.poll,\n                            isRefetch: fetchType === FetchType.refetch,\n                            metadata: metadata,\n                            fetchMoreForQueryId: fetchMoreForQueryId,\n                        });\n                        this.broadcastQueries();\n                        if (shouldFetch) {\n                            networkResult = this.fetchRequest({\n                                requestId: requestId,\n                                queryId: queryId,\n                                document: query,\n                                options: options,\n                                fetchMoreForQueryId: fetchMoreForQueryId,\n                            }).catch(function (error) {\n                                if (isApolloError(error)) {\n                                    throw error;\n                                }\n                                else {\n                                    if (requestId >= _this.getQuery(queryId).lastRequestId) {\n                                        _this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n                                        _this.invalidate(queryId);\n                                        _this.invalidate(fetchMoreForQueryId);\n                                        _this.broadcastQueries();\n                                    }\n                                    throw new bundle_esm_ApolloError({ networkError: error });\n                                }\n                            });\n                            if (fetchPolicy !== 'cache-and-network') {\n                                return [2, networkResult];\n                            }\n                            networkResult.catch(function () { });\n                        }\n                        this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n                        this.invalidate(queryId);\n                        this.invalidate(fetchMoreForQueryId);\n                        if (this.transform(query).hasForcedResolvers) {\n                            return [2, this.localState.runResolvers({\n                                    document: query,\n                                    remoteResult: { data: storeResult },\n                                    context: context,\n                                    variables: variables,\n                                    onlyRunForcedResolvers: true,\n                                }).then(function (result) {\n                                    _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);\n                                    _this.broadcastQueries();\n                                    return result;\n                                })];\n                        }\n                        this.broadcastQueries();\n                        return [2, { data: storeResult }];\n                }\n            });\n        });\n    };\n    QueryManager.prototype.markQueryResult = function (queryId, result, _a, fetchMoreForQueryId) {\n        var fetchPolicy = _a.fetchPolicy, variables = _a.variables, errorPolicy = _a.errorPolicy;\n        if (fetchPolicy === 'no-cache') {\n            this.setQuery(queryId, function () { return ({\n                newData: { result: result.data, complete: true },\n            }); });\n        }\n        else {\n            this.dataStore.markQueryResult(result, this.getQuery(queryId).document, variables, fetchMoreForQueryId, errorPolicy === 'ignore' || errorPolicy === 'all');\n        }\n    };\n    QueryManager.prototype.queryListenerForObserver = function (queryId, options, observer) {\n        var _this = this;\n        function invoke(method, argument) {\n            if (observer[method]) {\n                try {\n                    observer[method](argument);\n                }\n                catch (e) {\n                     true || false;\n                }\n            }\n            else if (method === 'error') {\n                 true || false;\n            }\n        }\n        return function (queryStoreValue, newData) {\n            _this.invalidate(queryId, false);\n            if (!queryStoreValue)\n                return;\n            var _a = _this.getQuery(queryId), observableQuery = _a.observableQuery, document = _a.document;\n            var fetchPolicy = observableQuery\n                ? observableQuery.options.fetchPolicy\n                : options.fetchPolicy;\n            if (fetchPolicy === 'standby')\n                return;\n            var loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);\n            var lastResult = observableQuery && observableQuery.getLastResult();\n            var networkStatusChanged = !!(lastResult &&\n                lastResult.networkStatus !== queryStoreValue.networkStatus);\n            var shouldNotifyIfLoading = options.returnPartialData ||\n                (!newData && queryStoreValue.previousVariables) ||\n                (networkStatusChanged && options.notifyOnNetworkStatusChange) ||\n                fetchPolicy === 'cache-only' ||\n                fetchPolicy === 'cache-and-network';\n            if (loading && !shouldNotifyIfLoading) {\n                return;\n            }\n            var hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);\n            var errorPolicy = observableQuery\n                && observableQuery.options.errorPolicy\n                || options.errorPolicy\n                || 'none';\n            if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {\n                return invoke('error', new bundle_esm_ApolloError({\n                    graphQLErrors: queryStoreValue.graphQLErrors,\n                    networkError: queryStoreValue.networkError,\n                }));\n            }\n            try {\n                var data = void 0;\n                var isMissing = void 0;\n                if (newData) {\n                    if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {\n                        _this.setQuery(queryId, function () { return ({ newData: null }); });\n                    }\n                    data = newData.result;\n                    isMissing = !newData.complete;\n                }\n                else {\n                    var lastError = observableQuery && observableQuery.getLastError();\n                    var errorStatusChanged = errorPolicy !== 'none' &&\n                        (lastError && lastError.graphQLErrors) !==\n                            queryStoreValue.graphQLErrors;\n                    if (lastResult && lastResult.data && !errorStatusChanged) {\n                        data = lastResult.data;\n                        isMissing = false;\n                    }\n                    else {\n                        var diffResult = _this.dataStore.getCache().diff({\n                            query: document,\n                            variables: queryStoreValue.previousVariables ||\n                                queryStoreValue.variables,\n                            returnPartialData: true,\n                            optimistic: true,\n                        });\n                        data = diffResult.result;\n                        isMissing = !diffResult.complete;\n                    }\n                }\n                var stale = isMissing && !(options.returnPartialData ||\n                    fetchPolicy === 'cache-only');\n                var resultFromStore = {\n                    data: stale ? lastResult && lastResult.data : data,\n                    loading: loading,\n                    networkStatus: queryStoreValue.networkStatus,\n                    stale: stale,\n                };\n                if (errorPolicy === 'all' && hasGraphQLErrors) {\n                    resultFromStore.errors = queryStoreValue.graphQLErrors;\n                }\n                invoke('next', resultFromStore);\n            }\n            catch (networkError) {\n                invoke('error', new bundle_esm_ApolloError({ networkError: networkError }));\n            }\n        };\n    };\n    QueryManager.prototype.transform = function (document) {\n        var transformCache = this.transformCache;\n        if (!transformCache.has(document)) {\n            var cache = this.dataStore.getCache();\n            var transformed = cache.transformDocument(document);\n            var forLink = Object(bundle_esm[\"D\" /* removeConnectionDirectiveFromDocument */])(cache.transformForLink(transformed));\n            var clientQuery = this.localState.clientQuery(transformed);\n            var serverQuery = this.localState.serverQuery(forLink);\n            var cacheEntry_1 = {\n                document: transformed,\n                hasClientExports: Object(bundle_esm[\"r\" /* hasClientExports */])(transformed),\n                hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n                clientQuery: clientQuery,\n                serverQuery: serverQuery,\n                defaultVars: Object(bundle_esm[\"h\" /* getDefaultValues */])(Object(bundle_esm[\"m\" /* getOperationDefinition */])(transformed)),\n            };\n            var add = function (doc) {\n                if (doc && !transformCache.has(doc)) {\n                    transformCache.set(doc, cacheEntry_1);\n                }\n            };\n            add(document);\n            add(transformed);\n            add(clientQuery);\n            add(serverQuery);\n        }\n        return transformCache.get(document);\n    };\n    QueryManager.prototype.getVariables = function (document, variables) {\n        return Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.transform(document).defaultVars), variables);\n    };\n    QueryManager.prototype.watchQuery = function (options, shouldSubscribe) {\n        if (shouldSubscribe === void 0) { shouldSubscribe = true; }\n         true ? Object(invariant_esm[\"b\" /* invariant */])(options.fetchPolicy !== 'standby', 11) : undefined;\n        options.variables = this.getVariables(options.query, options.variables);\n        if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n            options.notifyOnNetworkStatusChange = false;\n        }\n        var transformedOptions = Object(tslib_es6[\"a\" /* __assign */])({}, options);\n        return new bundle_esm_ObservableQuery({\n            queryManager: this,\n            options: transformedOptions,\n            shouldSubscribe: shouldSubscribe,\n        });\n    };\n    QueryManager.prototype.query = function (options) {\n        var _this = this;\n         true ? Object(invariant_esm[\"b\" /* invariant */])(options.query, 12) : undefined;\n         true ? Object(invariant_esm[\"b\" /* invariant */])(options.query.kind === 'Document', 13) : undefined;\n         true ? Object(invariant_esm[\"b\" /* invariant */])(!options.returnPartialData, 14) : undefined;\n         true ? Object(invariant_esm[\"b\" /* invariant */])(!options.pollInterval, 15) : undefined;\n        return new Promise(function (resolve, reject) {\n            var watchedQuery = _this.watchQuery(options, false);\n            _this.fetchQueryRejectFns.set(\"query:\" + watchedQuery.queryId, reject);\n            watchedQuery\n                .result()\n                .then(resolve, reject)\n                .then(function () {\n                return _this.fetchQueryRejectFns.delete(\"query:\" + watchedQuery.queryId);\n            });\n        });\n    };\n    QueryManager.prototype.generateQueryId = function () {\n        return String(this.idCounter++);\n    };\n    QueryManager.prototype.stopQueryInStore = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n        this.stopPollingQuery(queryId);\n        this.queryStore.stopQuery(queryId);\n        this.invalidate(queryId);\n    };\n    QueryManager.prototype.addQueryListener = function (queryId, listener) {\n        this.setQuery(queryId, function (_a) {\n            var listeners = _a.listeners;\n            listeners.add(listener);\n            return { invalidated: false };\n        });\n    };\n    QueryManager.prototype.updateQueryWatch = function (queryId, document, options) {\n        var _this = this;\n        var cancel = this.getQuery(queryId).cancel;\n        if (cancel)\n            cancel();\n        var previousResult = function () {\n            var previousResult = null;\n            var observableQuery = _this.getQuery(queryId).observableQuery;\n            if (observableQuery) {\n                var lastResult = observableQuery.getLastResult();\n                if (lastResult) {\n                    previousResult = lastResult.data;\n                }\n            }\n            return previousResult;\n        };\n        return this.dataStore.getCache().watch({\n            query: document,\n            variables: options.variables,\n            optimistic: true,\n            previousResult: previousResult,\n            callback: function (newData) {\n                _this.setQuery(queryId, function () { return ({ invalidated: true, newData: newData }); });\n            },\n        });\n    };\n    QueryManager.prototype.addObservableQuery = function (queryId, observableQuery) {\n        this.setQuery(queryId, function () { return ({ observableQuery: observableQuery }); });\n    };\n    QueryManager.prototype.removeObservableQuery = function (queryId) {\n        var cancel = this.getQuery(queryId).cancel;\n        this.setQuery(queryId, function () { return ({ observableQuery: null }); });\n        if (cancel)\n            cancel();\n    };\n    QueryManager.prototype.clearStore = function () {\n        this.fetchQueryRejectFns.forEach(function (reject) {\n            reject( true ? new invariant_esm[\"a\" /* InvariantError */](16) : undefined);\n        });\n        var resetIds = [];\n        this.queries.forEach(function (_a, queryId) {\n            var observableQuery = _a.observableQuery;\n            if (observableQuery)\n                resetIds.push(queryId);\n        });\n        this.queryStore.reset(resetIds);\n        this.mutationStore.reset();\n        return this.dataStore.reset();\n    };\n    QueryManager.prototype.resetStore = function () {\n        var _this = this;\n        return this.clearStore().then(function () {\n            return _this.reFetchObservableQueries();\n        });\n    };\n    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n        var _this = this;\n        if (includeStandby === void 0) { includeStandby = false; }\n        var observableQueryPromises = [];\n        this.queries.forEach(function (_a, queryId) {\n            var observableQuery = _a.observableQuery;\n            if (observableQuery) {\n                var fetchPolicy = observableQuery.options.fetchPolicy;\n                observableQuery.resetLastResults();\n                if (fetchPolicy !== 'cache-only' &&\n                    (includeStandby || fetchPolicy !== 'standby')) {\n                    observableQueryPromises.push(observableQuery.refetch());\n                }\n                _this.setQuery(queryId, function () { return ({ newData: null }); });\n                _this.invalidate(queryId);\n            }\n        });\n        this.broadcastQueries();\n        return Promise.all(observableQueryPromises);\n    };\n    QueryManager.prototype.observeQuery = function (queryId, options, observer) {\n        this.addQueryListener(queryId, this.queryListenerForObserver(queryId, options, observer));\n        return this.fetchQuery(queryId, options);\n    };\n    QueryManager.prototype.startQuery = function (queryId, options, listener) {\n         true || false;\n        this.addQueryListener(queryId, listener);\n        this.fetchQuery(queryId, options)\n            .catch(function () { return undefined; });\n        return queryId;\n    };\n    QueryManager.prototype.startGraphQLSubscription = function (_a) {\n        var _this = this;\n        var query = _a.query, fetchPolicy = _a.fetchPolicy, variables = _a.variables;\n        query = this.transform(query).document;\n        variables = this.getVariables(query, variables);\n        var makeObservable = function (variables) {\n            return _this.getObservableFromLink(query, {}, variables, false).map(function (result) {\n                if (!fetchPolicy || fetchPolicy !== 'no-cache') {\n                    _this.dataStore.markSubscriptionResult(result, query, variables);\n                    _this.broadcastQueries();\n                }\n                if (Object(bundle_esm[\"q\" /* graphQLResultHasError */])(result)) {\n                    throw new bundle_esm_ApolloError({\n                        graphQLErrors: result.errors,\n                    });\n                }\n                return result;\n            });\n        };\n        if (this.transform(query).hasClientExports) {\n            var observablePromise_1 = this.localState.addExportedVariables(query, variables).then(makeObservable);\n            return new apollo_client_bundle_esm_Observable(function (observer) {\n                var sub = null;\n                observablePromise_1.then(function (observable) { return sub = observable.subscribe(observer); }, observer.error);\n                return function () { return sub && sub.unsubscribe(); };\n            });\n        }\n        return makeObservable(variables);\n    };\n    QueryManager.prototype.stopQuery = function (queryId) {\n        this.stopQueryNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.removeQuery(queryId);\n    };\n    QueryManager.prototype.removeQuery = function (queryId) {\n        this.fetchQueryRejectFns.delete(\"query:\" + queryId);\n        this.fetchQueryRejectFns.delete(\"fetchRequest:\" + queryId);\n        this.getQuery(queryId).subscriptions.forEach(function (x) { return x.unsubscribe(); });\n        this.queries.delete(queryId);\n    };\n    QueryManager.prototype.getCurrentQueryResult = function (observableQuery, optimistic) {\n        if (optimistic === void 0) { optimistic = true; }\n        var _a = observableQuery.options, variables = _a.variables, query = _a.query, fetchPolicy = _a.fetchPolicy, returnPartialData = _a.returnPartialData;\n        var lastResult = observableQuery.getLastResult();\n        var newData = this.getQuery(observableQuery.queryId).newData;\n        if (newData && newData.complete) {\n            return { data: newData.result, partial: false };\n        }\n        if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {\n            return { data: undefined, partial: false };\n        }\n        var _b = this.dataStore.getCache().diff({\n            query: query,\n            variables: variables,\n            previousResult: lastResult ? lastResult.data : undefined,\n            returnPartialData: true,\n            optimistic: optimistic,\n        }), result = _b.result, complete = _b.complete;\n        return {\n            data: (complete || returnPartialData) ? result : void 0,\n            partial: !complete,\n        };\n    };\n    QueryManager.prototype.getQueryWithPreviousResult = function (queryIdOrObservable) {\n        var observableQuery;\n        if (typeof queryIdOrObservable === 'string') {\n            var foundObserveableQuery = this.getQuery(queryIdOrObservable).observableQuery;\n             true ? Object(invariant_esm[\"b\" /* invariant */])(foundObserveableQuery, 17) : undefined;\n            observableQuery = foundObserveableQuery;\n        }\n        else {\n            observableQuery = queryIdOrObservable;\n        }\n        var _a = observableQuery.options, variables = _a.variables, query = _a.query;\n        return {\n            previousResult: this.getCurrentQueryResult(observableQuery, false).data,\n            variables: variables,\n            document: query,\n        };\n    };\n    QueryManager.prototype.broadcastQueries = function () {\n        var _this = this;\n        this.onBroadcast();\n        this.queries.forEach(function (info, id) {\n            if (info.invalidated) {\n                info.listeners.forEach(function (listener) {\n                    if (listener) {\n                        listener(_this.queryStore.get(id), info.newData);\n                    }\n                });\n            }\n        });\n    };\n    QueryManager.prototype.getLocalState = function () {\n        return this.localState;\n    };\n    QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {\n        var _this = this;\n        if (deduplication === void 0) { deduplication = this.queryDeduplication; }\n        var observable;\n        var serverQuery = this.transform(query).serverQuery;\n        if (serverQuery) {\n            var _a = this, inFlightLinkObservables_1 = _a.inFlightLinkObservables, link = _a.link;\n            var operation = {\n                query: serverQuery,\n                variables: variables,\n                operationName: Object(bundle_esm[\"n\" /* getOperationName */])(serverQuery) || void 0,\n                context: this.prepareContext(Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, context), { forceFetch: !deduplication })),\n            };\n            context = operation.context;\n            if (deduplication) {\n                var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();\n                inFlightLinkObservables_1.set(serverQuery, byVariables_1);\n                var varJson_1 = JSON.stringify(variables);\n                observable = byVariables_1.get(varJson_1);\n                if (!observable) {\n                    byVariables_1.set(varJson_1, observable = multiplex(bundle_esm_execute(link, operation)));\n                    var cleanup = function () {\n                        byVariables_1.delete(varJson_1);\n                        if (!byVariables_1.size)\n                            inFlightLinkObservables_1.delete(serverQuery);\n                        cleanupSub_1.unsubscribe();\n                    };\n                    var cleanupSub_1 = observable.subscribe({\n                        next: cleanup,\n                        error: cleanup,\n                        complete: cleanup,\n                    });\n                }\n            }\n            else {\n                observable = multiplex(bundle_esm_execute(link, operation));\n            }\n        }\n        else {\n            observable = apollo_client_bundle_esm_Observable.of({ data: {} });\n            context = this.prepareContext(context);\n        }\n        var clientQuery = this.transform(query).clientQuery;\n        if (clientQuery) {\n            observable = asyncMap(observable, function (result) {\n                return _this.localState.runResolvers({\n                    document: clientQuery,\n                    remoteResult: result,\n                    context: context,\n                    variables: variables,\n                });\n            });\n        }\n        return observable;\n    };\n    QueryManager.prototype.fetchRequest = function (_a) {\n        var _this = this;\n        var requestId = _a.requestId, queryId = _a.queryId, document = _a.document, options = _a.options, fetchMoreForQueryId = _a.fetchMoreForQueryId;\n        var variables = options.variables, _b = options.errorPolicy, errorPolicy = _b === void 0 ? 'none' : _b, fetchPolicy = options.fetchPolicy;\n        var resultFromStore;\n        var errorsFromStore;\n        return new Promise(function (resolve, reject) {\n            var observable = _this.getObservableFromLink(document, options.context, variables);\n            var fqrfId = \"fetchRequest:\" + queryId;\n            _this.fetchQueryRejectFns.set(fqrfId, reject);\n            var cleanup = function () {\n                _this.fetchQueryRejectFns.delete(fqrfId);\n                _this.setQuery(queryId, function (_a) {\n                    var subscriptions = _a.subscriptions;\n                    subscriptions.delete(subscription);\n                });\n            };\n            var subscription = observable.map(function (result) {\n                if (requestId >= _this.getQuery(queryId).lastRequestId) {\n                    _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);\n                    _this.queryStore.markQueryResult(queryId, result, fetchMoreForQueryId);\n                    _this.invalidate(queryId);\n                    _this.invalidate(fetchMoreForQueryId);\n                    _this.broadcastQueries();\n                }\n                if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {\n                    return reject(new bundle_esm_ApolloError({\n                        graphQLErrors: result.errors,\n                    }));\n                }\n                if (errorPolicy === 'all') {\n                    errorsFromStore = result.errors;\n                }\n                if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n                    resultFromStore = result.data;\n                }\n                else {\n                    var _a = _this.dataStore.getCache().diff({\n                        variables: variables,\n                        query: document,\n                        optimistic: false,\n                        returnPartialData: true,\n                    }), result_1 = _a.result, complete = _a.complete;\n                    if (complete || options.returnPartialData) {\n                        resultFromStore = result_1;\n                    }\n                }\n            }).subscribe({\n                error: function (error) {\n                    cleanup();\n                    reject(error);\n                },\n                complete: function () {\n                    cleanup();\n                    resolve({\n                        data: resultFromStore,\n                        errors: errorsFromStore,\n                        loading: false,\n                        networkStatus: NetworkStatus.ready,\n                        stale: false,\n                    });\n                },\n            });\n            _this.setQuery(queryId, function (_a) {\n                var subscriptions = _a.subscriptions;\n                subscriptions.add(subscription);\n            });\n        });\n    };\n    QueryManager.prototype.getQuery = function (queryId) {\n        return (this.queries.get(queryId) || {\n            listeners: new Set(),\n            invalidated: false,\n            document: null,\n            newData: null,\n            lastRequestId: 1,\n            observableQuery: null,\n            subscriptions: new Set(),\n        });\n    };\n    QueryManager.prototype.setQuery = function (queryId, updater) {\n        var prev = this.getQuery(queryId);\n        var newInfo = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, prev), updater(prev));\n        this.queries.set(queryId, newInfo);\n    };\n    QueryManager.prototype.invalidate = function (queryId, invalidated) {\n        if (invalidated === void 0) { invalidated = true; }\n        if (queryId) {\n            this.setQuery(queryId, function () { return ({ invalidated: invalidated }); });\n        }\n    };\n    QueryManager.prototype.prepareContext = function (context) {\n        if (context === void 0) { context = {}; }\n        var newContext = this.localState.prepareContext(context);\n        return Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, newContext), { clientAwareness: this.clientAwareness });\n    };\n    QueryManager.prototype.checkInFlight = function (queryId) {\n        var query = this.queryStore.get(queryId);\n        return (query &&\n            query.networkStatus !== NetworkStatus.ready &&\n            query.networkStatus !== NetworkStatus.error);\n    };\n    QueryManager.prototype.startPollingQuery = function (options, queryId, listener) {\n        var _this = this;\n        var pollInterval = options.pollInterval;\n         true ? Object(invariant_esm[\"b\" /* invariant */])(pollInterval, 18) : undefined;\n        if (!this.ssrMode) {\n            var info = this.pollingInfoByQueryId.get(queryId);\n            if (!info) {\n                this.pollingInfoByQueryId.set(queryId, (info = {}));\n            }\n            info.interval = pollInterval;\n            info.options = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, options), { fetchPolicy: 'network-only' });\n            var maybeFetch_1 = function () {\n                var info = _this.pollingInfoByQueryId.get(queryId);\n                if (info) {\n                    if (_this.checkInFlight(queryId)) {\n                        poll_1();\n                    }\n                    else {\n                        _this.fetchQuery(queryId, info.options, FetchType.poll).then(poll_1, poll_1);\n                    }\n                }\n            };\n            var poll_1 = function () {\n                var info = _this.pollingInfoByQueryId.get(queryId);\n                if (info) {\n                    clearTimeout(info.timeout);\n                    info.timeout = setTimeout(maybeFetch_1, info.interval);\n                }\n            };\n            if (listener) {\n                this.addQueryListener(queryId, listener);\n            }\n            poll_1();\n        }\n        return queryId;\n    };\n    QueryManager.prototype.stopPollingQuery = function (queryId) {\n        this.pollingInfoByQueryId.delete(queryId);\n    };\n    return QueryManager;\n}());\n\nvar bundle_esm_DataStore = (function () {\n    function DataStore(initialCache) {\n        this.cache = initialCache;\n    }\n    DataStore.prototype.getCache = function () {\n        return this.cache;\n    };\n    DataStore.prototype.markQueryResult = function (result, document, variables, fetchMoreForQueryId, ignoreErrors) {\n        if (ignoreErrors === void 0) { ignoreErrors = false; }\n        var writeWithErrors = !Object(bundle_esm[\"q\" /* graphQLResultHasError */])(result);\n        if (ignoreErrors && Object(bundle_esm[\"q\" /* graphQLResultHasError */])(result) && result.data) {\n            writeWithErrors = true;\n        }\n        if (!fetchMoreForQueryId && writeWithErrors) {\n            this.cache.write({\n                result: result.data,\n                dataId: 'ROOT_QUERY',\n                query: document,\n                variables: variables,\n            });\n        }\n    };\n    DataStore.prototype.markSubscriptionResult = function (result, document, variables) {\n        if (!Object(bundle_esm[\"q\" /* graphQLResultHasError */])(result)) {\n            this.cache.write({\n                result: result.data,\n                dataId: 'ROOT_SUBSCRIPTION',\n                query: document,\n                variables: variables,\n            });\n        }\n    };\n    DataStore.prototype.markMutationInit = function (mutation) {\n        var _this = this;\n        if (mutation.optimisticResponse) {\n            var optimistic_1;\n            if (typeof mutation.optimisticResponse === 'function') {\n                optimistic_1 = mutation.optimisticResponse(mutation.variables);\n            }\n            else {\n                optimistic_1 = mutation.optimisticResponse;\n            }\n            this.cache.recordOptimisticTransaction(function (c) {\n                var orig = _this.cache;\n                _this.cache = c;\n                try {\n                    _this.markMutationResult({\n                        mutationId: mutation.mutationId,\n                        result: { data: optimistic_1 },\n                        document: mutation.document,\n                        variables: mutation.variables,\n                        updateQueries: mutation.updateQueries,\n                        update: mutation.update,\n                    });\n                }\n                finally {\n                    _this.cache = orig;\n                }\n            }, mutation.mutationId);\n        }\n    };\n    DataStore.prototype.markMutationResult = function (mutation) {\n        var _this = this;\n        if (!Object(bundle_esm[\"q\" /* graphQLResultHasError */])(mutation.result)) {\n            var cacheWrites_1 = [{\n                    result: mutation.result.data,\n                    dataId: 'ROOT_MUTATION',\n                    query: mutation.document,\n                    variables: mutation.variables,\n                }];\n            var updateQueries_1 = mutation.updateQueries;\n            if (updateQueries_1) {\n                Object.keys(updateQueries_1).forEach(function (id) {\n                    var _a = updateQueries_1[id], query = _a.query, updater = _a.updater;\n                    var _b = _this.cache.diff({\n                        query: query.document,\n                        variables: query.variables,\n                        returnPartialData: true,\n                        optimistic: false,\n                    }), currentQueryResult = _b.result, complete = _b.complete;\n                    if (complete) {\n                        var nextQueryResult = Object(bundle_esm[\"I\" /* tryFunctionOrLogError */])(function () {\n                            return updater(currentQueryResult, {\n                                mutationResult: mutation.result,\n                                queryName: Object(bundle_esm[\"n\" /* getOperationName */])(query.document) || undefined,\n                                queryVariables: query.variables,\n                            });\n                        });\n                        if (nextQueryResult) {\n                            cacheWrites_1.push({\n                                result: nextQueryResult,\n                                dataId: 'ROOT_QUERY',\n                                query: query.document,\n                                variables: query.variables,\n                            });\n                        }\n                    }\n                });\n            }\n            this.cache.performTransaction(function (c) {\n                cacheWrites_1.forEach(function (write) { return c.write(write); });\n                var update = mutation.update;\n                if (update) {\n                    Object(bundle_esm[\"I\" /* tryFunctionOrLogError */])(function () { return update(c, mutation.result); });\n                }\n            });\n        }\n    };\n    DataStore.prototype.markMutationComplete = function (_a) {\n        var mutationId = _a.mutationId, optimisticResponse = _a.optimisticResponse;\n        if (optimisticResponse) {\n            this.cache.removeOptimistic(mutationId);\n        }\n    };\n    DataStore.prototype.markUpdateQueryResult = function (document, variables, newResult) {\n        this.cache.write({\n            result: newResult,\n            dataId: 'ROOT_QUERY',\n            variables: variables,\n            query: document,\n        });\n    };\n    DataStore.prototype.reset = function () {\n        return this.cache.reset();\n    };\n    return DataStore;\n}());\n\nvar bundle_esm_version = \"2.6.10\";\n\nvar hasSuggestedDevtools = false;\nvar bundle_esm_ApolloClient = (function () {\n    function ApolloClient(options) {\n        var _this = this;\n        this.defaultOptions = {};\n        this.resetStoreCallbacks = [];\n        this.clearStoreCallbacks = [];\n        var cache = options.cache, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, connectToDevTools = options.connectToDevTools, _c = options.queryDeduplication, queryDeduplication = _c === void 0 ? true : _c, defaultOptions = options.defaultOptions, _d = options.assumeImmutableResults, assumeImmutableResults = _d === void 0 ? false : _d, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;\n        var link = options.link;\n        if (!link && resolvers) {\n            link = bundle_esm_ApolloLink.empty();\n        }\n        if (!link || !cache) {\n            throw  true ? new invariant_esm[\"a\" /* InvariantError */](4) : undefined;\n        }\n        this.link = link;\n        this.cache = cache;\n        this.store = new bundle_esm_DataStore(cache);\n        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n        this.queryDeduplication = queryDeduplication;\n        this.defaultOptions = defaultOptions || {};\n        this.typeDefs = typeDefs;\n        if (ssrForceFetchDelay) {\n            setTimeout(function () { return (_this.disableNetworkFetches = false); }, ssrForceFetchDelay);\n        }\n        this.watchQuery = this.watchQuery.bind(this);\n        this.query = this.query.bind(this);\n        this.mutate = this.mutate.bind(this);\n        this.resetStore = this.resetStore.bind(this);\n        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n        var defaultConnectToDevTools =  false &&\n            false;\n        if (typeof connectToDevTools === 'undefined'\n            ? defaultConnectToDevTools\n            : connectToDevTools && typeof window !== 'undefined') {\n            window.__APOLLO_CLIENT__ = this;\n        }\n        if (!hasSuggestedDevtools && \"production\" !== 'production') {\n            hasSuggestedDevtools = true;\n            if (typeof window !== 'undefined' &&\n                window.document &&\n                window.top === window.self) {\n                if (typeof window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n                    if (window.navigator &&\n                        window.navigator.userAgent &&\n                        window.navigator.userAgent.indexOf('Chrome') > -1) {\n                        console.debug('Download the Apollo DevTools ' +\n                            'for a better development experience: ' +\n                            'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm');\n                    }\n                }\n            }\n        }\n        this.version = bundle_esm_version;\n        this.localState = new bundle_esm_LocalState({\n            cache: cache,\n            client: this,\n            resolvers: resolvers,\n            fragmentMatcher: fragmentMatcher,\n        });\n        this.queryManager = new bundle_esm_QueryManager({\n            link: this.link,\n            store: this.store,\n            queryDeduplication: queryDeduplication,\n            ssrMode: ssrMode,\n            clientAwareness: {\n                name: clientAwarenessName,\n                version: clientAwarenessVersion,\n            },\n            localState: this.localState,\n            assumeImmutableResults: assumeImmutableResults,\n            onBroadcast: function () {\n                if (_this.devToolsHookCb) {\n                    _this.devToolsHookCb({\n                        action: {},\n                        state: {\n                            queries: _this.queryManager.queryStore.getStore(),\n                            mutations: _this.queryManager.mutationStore.getStore(),\n                        },\n                        dataWithOptimisticResults: _this.cache.extract(true),\n                    });\n                }\n            },\n        });\n    }\n    ApolloClient.prototype.stop = function () {\n        this.queryManager.stop();\n    };\n    ApolloClient.prototype.watchQuery = function (options) {\n        if (this.defaultOptions.watchQuery) {\n            options = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.defaultOptions.watchQuery), options);\n        }\n        if (this.disableNetworkFetches &&\n            (options.fetchPolicy === 'network-only' ||\n                options.fetchPolicy === 'cache-and-network')) {\n            options = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, options), { fetchPolicy: 'cache-first' });\n        }\n        return this.queryManager.watchQuery(options);\n    };\n    ApolloClient.prototype.query = function (options) {\n        if (this.defaultOptions.query) {\n            options = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.defaultOptions.query), options);\n        }\n         true ? Object(invariant_esm[\"b\" /* invariant */])(options.fetchPolicy !== 'cache-and-network', 5) : undefined;\n        if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n            options = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, options), { fetchPolicy: 'cache-first' });\n        }\n        return this.queryManager.query(options);\n    };\n    ApolloClient.prototype.mutate = function (options) {\n        if (this.defaultOptions.mutate) {\n            options = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.defaultOptions.mutate), options);\n        }\n        return this.queryManager.mutate(options);\n    };\n    ApolloClient.prototype.subscribe = function (options) {\n        return this.queryManager.startGraphQLSubscription(options);\n    };\n    ApolloClient.prototype.readQuery = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return this.cache.readQuery(options, optimistic);\n    };\n    ApolloClient.prototype.readFragment = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return this.cache.readFragment(options, optimistic);\n    };\n    ApolloClient.prototype.writeQuery = function (options) {\n        var result = this.cache.writeQuery(options);\n        this.queryManager.broadcastQueries();\n        return result;\n    };\n    ApolloClient.prototype.writeFragment = function (options) {\n        var result = this.cache.writeFragment(options);\n        this.queryManager.broadcastQueries();\n        return result;\n    };\n    ApolloClient.prototype.writeData = function (options) {\n        var result = this.cache.writeData(options);\n        this.queryManager.broadcastQueries();\n        return result;\n    };\n    ApolloClient.prototype.__actionHookForDevTools = function (cb) {\n        this.devToolsHookCb = cb;\n    };\n    ApolloClient.prototype.__requestRaw = function (payload) {\n        return bundle_esm_execute(this.link, payload);\n    };\n    ApolloClient.prototype.initQueryManager = function () {\n         true || false;\n        return this.queryManager;\n    };\n    ApolloClient.prototype.resetStore = function () {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () { return _this.queryManager.clearStore(); })\n            .then(function () { return Promise.all(_this.resetStoreCallbacks.map(function (fn) { return fn(); })); })\n            .then(function () { return _this.reFetchObservableQueries(); });\n    };\n    ApolloClient.prototype.clearStore = function () {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () { return _this.queryManager.clearStore(); })\n            .then(function () { return Promise.all(_this.clearStoreCallbacks.map(function (fn) { return fn(); })); });\n    };\n    ApolloClient.prototype.onResetStore = function (cb) {\n        var _this = this;\n        this.resetStoreCallbacks.push(cb);\n        return function () {\n            _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) { return c !== cb; });\n        };\n    };\n    ApolloClient.prototype.onClearStore = function (cb) {\n        var _this = this;\n        this.clearStoreCallbacks.push(cb);\n        return function () {\n            _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) { return c !== cb; });\n        };\n    };\n    ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {\n        return this.queryManager.reFetchObservableQueries(includeStandby);\n    };\n    ApolloClient.prototype.extract = function (optimistic) {\n        return this.cache.extract(optimistic);\n    };\n    ApolloClient.prototype.restore = function (serializedState) {\n        return this.cache.restore(serializedState);\n    };\n    ApolloClient.prototype.addResolvers = function (resolvers) {\n        this.localState.addResolvers(resolvers);\n    };\n    ApolloClient.prototype.setResolvers = function (resolvers) {\n        this.localState.setResolvers(resolvers);\n    };\n    ApolloClient.prototype.getResolvers = function () {\n        return this.localState.getResolvers();\n    };\n    ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {\n        this.localState.setFragmentMatcher(fragmentMatcher);\n    };\n    return ApolloClient;\n}());\n\n/* harmony default export */ var apollo_client_bundle_esm = (bundle_esm_ApolloClient);\n\n//# sourceMappingURL=bundle.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/@apollo/react-hooks/lib/react-hooks.esm.js\n\n\n\n\n\n\n\n\nvar react_hooks_esm_OperationData = (function () {\n    function OperationData(options, context) {\n        this.isMounted = false;\n        this.previousOptions = {};\n        this.context = {};\n        this.options = {};\n        this.options = options || {};\n        this.context = context || {};\n    }\n    OperationData.prototype.getOptions = function () {\n        return this.options;\n    };\n    OperationData.prototype.setOptions = function (newOptions, storePrevious) {\n        if (storePrevious === void 0) { storePrevious = false; }\n        if (storePrevious && !Object(equality_esm[\"a\" /* equal */])(this.options, newOptions)) {\n            this.previousOptions = this.options;\n        }\n        this.options = newOptions;\n    };\n    OperationData.prototype.unmount = function () {\n        this.isMounted = false;\n    };\n    OperationData.prototype.refreshClient = function () {\n        var client = (this.options && this.options.client) ||\n            (this.context && this.context.client);\n         true ? Object(invariant_esm[\"b\" /* invariant */])(!!client, 2) : undefined;\n        var isNew = false;\n        if (client !== this.client) {\n            isNew = true;\n            this.client = client;\n            this.cleanup();\n        }\n        return {\n            client: this.client,\n            isNew: isNew\n        };\n    };\n    OperationData.prototype.verifyDocumentType = function (document, type) {\n        var operation = parser(document);\n        var requiredOperationName = react_common_esm_operationName(type);\n        var usedOperationName = react_common_esm_operationName(operation.type);\n         true ? Object(invariant_esm[\"b\" /* invariant */])(operation.type === type, 3) : undefined;\n    };\n    return OperationData;\n}());\n\nvar react_hooks_esm_QueryData = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(QueryData, _super);\n    function QueryData(_a) {\n        var options = _a.options, context = _a.context, onNewData = _a.onNewData;\n        var _this = _super.call(this, options, context) || this;\n        _this.previousData = {};\n        _this.currentObservable = {};\n        _this.runLazy = false;\n        _this.runLazyQuery = function (options) {\n            _this.cleanup();\n            _this.runLazy = true;\n            _this.lazyOptions = options;\n            _this.onNewData();\n        };\n        _this.getExecuteResult = function () {\n            var result = _this.getQueryResult();\n            _this.startQuerySubscription();\n            return result;\n        };\n        _this.obsRefetch = function (variables) {\n            return _this.currentObservable.query.refetch(variables);\n        };\n        _this.obsFetchMore = function (fetchMoreOptions) { return _this.currentObservable.query.fetchMore(fetchMoreOptions); };\n        _this.obsUpdateQuery = function (mapFn) { return _this.currentObservable.query.updateQuery(mapFn); };\n        _this.obsStartPolling = function (pollInterval) {\n            _this.currentObservable &&\n                _this.currentObservable.query &&\n                _this.currentObservable.query.startPolling(pollInterval);\n        };\n        _this.obsStopPolling = function () {\n            _this.currentObservable &&\n                _this.currentObservable.query &&\n                _this.currentObservable.query.stopPolling();\n        };\n        _this.obsSubscribeToMore = function (options) { return _this.currentObservable.query.subscribeToMore(options); };\n        _this.onNewData = onNewData;\n        return _this;\n    }\n    QueryData.prototype.execute = function () {\n        this.refreshClient();\n        var _a = this.getOptions(), skip = _a.skip, query = _a.query;\n        if (skip || query !== this.previousData.query) {\n            this.removeQuerySubscription();\n            this.previousData.query = query;\n        }\n        this.updateObservableQuery();\n        if (this.isMounted)\n            this.startQuerySubscription();\n        return this.getExecuteSsrResult() || this.getExecuteResult();\n    };\n    QueryData.prototype.executeLazy = function () {\n        return !this.runLazy\n            ? [\n                this.runLazyQuery,\n                {\n                    loading: false,\n                    networkStatus: NetworkStatus.ready,\n                    called: false,\n                    data: undefined,\n                },\n            ]\n            : [this.runLazyQuery, this.execute()];\n    };\n    QueryData.prototype.fetchData = function () {\n        var options = this.getOptions();\n        if (options.skip || options.ssr === false)\n            return false;\n        var obs = this.currentObservable.query;\n        var currentResult = obs.getCurrentResult();\n        return currentResult.loading ? obs.result() : false;\n    };\n    QueryData.prototype.afterExecute = function (_a) {\n        var _b = (_a === void 0 ? {} : _a).lazy, lazy = _b === void 0 ? false : _b;\n        this.isMounted = true;\n        if (!lazy || this.runLazy) {\n            this.handleErrorOrCompleted();\n        }\n        this.previousOptions = this.getOptions();\n        return this.unmount.bind(this);\n    };\n    QueryData.prototype.cleanup = function () {\n        this.removeQuerySubscription();\n        delete this.currentObservable.query;\n        delete this.previousData.result;\n    };\n    QueryData.prototype.getOptions = function () {\n        var options = _super.prototype.getOptions.call(this);\n        if (this.lazyOptions) {\n            options.variables = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, options.variables), this.lazyOptions.variables);\n            options.context = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, options.context), this.lazyOptions.context);\n        }\n        if (this.runLazy) {\n            delete options.skip;\n        }\n        return options;\n    };\n    QueryData.prototype.ssrInitiated = function () {\n        return this.context && this.context.renderPromises;\n    };\n    QueryData.prototype.getExecuteSsrResult = function () {\n        var ssrDisabled = this.getOptions().ssr === false;\n        var fetchDisabled = this.refreshClient().client.disableNetworkFetches;\n        var ssrLoading = Object(tslib_es6[\"a\" /* __assign */])({ loading: true, networkStatus: NetworkStatus.loading, called: true, data: undefined, stale: false, client: this.client }, this.observableQueryFields());\n        if (ssrDisabled && (this.ssrInitiated() || fetchDisabled)) {\n            this.previousData.result = ssrLoading;\n            return ssrLoading;\n        }\n        var result;\n        if (this.ssrInitiated()) {\n            result =\n                this.context.renderPromises.addQueryPromise(this, this.getExecuteResult) || ssrLoading;\n        }\n        return result;\n    };\n    QueryData.prototype.prepareObservableQueryOptions = function () {\n        var options = this.getOptions();\n        this.verifyDocumentType(options.query, DocumentType.Query);\n        var displayName = options.displayName || 'Query';\n        if (this.ssrInitiated() &&\n            (options.fetchPolicy === 'network-only' ||\n                options.fetchPolicy === 'cache-and-network')) {\n            options.fetchPolicy = 'cache-first';\n        }\n        return Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, options), { displayName: displayName, context: options.context, metadata: { reactComponent: { displayName: displayName } } });\n    };\n    QueryData.prototype.initializeObservableQuery = function () {\n        var _a, _b;\n        if (this.ssrInitiated()) {\n            this.currentObservable.query = this.context.renderPromises.getSSRObservable(this.getOptions());\n        }\n        if (!this.currentObservable.query) {\n            var observableQueryOptions = this.prepareObservableQueryOptions();\n            this.previousData.observableQueryOptions = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, observableQueryOptions), { children: null });\n            this.currentObservable.query = this.refreshClient().client.watchQuery(Object(tslib_es6[\"a\" /* __assign */])({}, observableQueryOptions));\n            if (this.ssrInitiated()) {\n                (_b = (_a = this.context) === null || _a === void 0 ? void 0 : _a.renderPromises) === null || _b === void 0 ? void 0 : _b.registerSSRObservable(this.currentObservable.query, observableQueryOptions);\n            }\n        }\n    };\n    QueryData.prototype.updateObservableQuery = function () {\n        if (!this.currentObservable.query) {\n            this.initializeObservableQuery();\n            return;\n        }\n        var newObservableQueryOptions = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.prepareObservableQueryOptions()), { children: null });\n        if (!Object(equality_esm[\"a\" /* equal */])(newObservableQueryOptions, this.previousData.observableQueryOptions)) {\n            this.previousData.observableQueryOptions = newObservableQueryOptions;\n            this.currentObservable\n                .query.setOptions(newObservableQueryOptions)\n                .catch(function () { });\n        }\n    };\n    QueryData.prototype.startQuerySubscription = function () {\n        var _this = this;\n        if (this.currentObservable.subscription || this.getOptions().skip)\n            return;\n        var obsQuery = this.currentObservable.query;\n        this.currentObservable.subscription = obsQuery.subscribe({\n            next: function (_a) {\n                var loading = _a.loading, networkStatus = _a.networkStatus, data = _a.data;\n                var previousResult = _this.previousData.result;\n                if (previousResult &&\n                    previousResult.loading === loading &&\n                    previousResult.networkStatus === networkStatus &&\n                    Object(equality_esm[\"a\" /* equal */])(previousResult.data, data)) {\n                    return;\n                }\n                _this.onNewData();\n            },\n            error: function (error) {\n                _this.resubscribeToQuery();\n                if (!error.hasOwnProperty('graphQLErrors'))\n                    throw error;\n                var previousResult = _this.previousData.result;\n                if ((previousResult && previousResult.loading) ||\n                    !Object(equality_esm[\"a\" /* equal */])(error, _this.previousData.error)) {\n                    _this.previousData.error = error;\n                    _this.onNewData();\n                }\n            },\n        });\n    };\n    QueryData.prototype.resubscribeToQuery = function () {\n        this.removeQuerySubscription();\n        var lastError = this.currentObservable.query.getLastError();\n        var lastResult = this.currentObservable.query.getLastResult();\n        this.currentObservable.query.resetLastResults();\n        this.startQuerySubscription();\n        Object.assign(this.currentObservable.query, {\n            lastError: lastError,\n            lastResult: lastResult,\n        });\n    };\n    QueryData.prototype.getQueryResult = function () {\n        var result = this.observableQueryFields();\n        var options = this.getOptions();\n        if (options.skip) {\n            result = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, result), { data: undefined, error: undefined, loading: false, called: true });\n        }\n        else {\n            var currentResult = this.currentObservable.query.getCurrentResult();\n            var loading = currentResult.loading, partial = currentResult.partial, networkStatus = currentResult.networkStatus, errors = currentResult.errors;\n            var error = currentResult.error, data = currentResult.data;\n            if (errors && errors.length > 0) {\n                error = new bundle_esm_ApolloError({ graphQLErrors: errors });\n            }\n            result = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, result), { loading: loading,\n                networkStatus: networkStatus,\n                error: error, called: true });\n            if (loading) {\n                var previousData = this.previousData.result && this.previousData.result.data;\n                result.data =\n                    previousData && data\n                        ? Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, previousData), data) : previousData || data;\n            }\n            else if (error) {\n                Object.assign(result, {\n                    data: (this.currentObservable.query.getLastResult() || {})\n                        .data,\n                });\n            }\n            else {\n                var fetchPolicy = this.currentObservable.query.options.fetchPolicy;\n                var partialRefetch = options.partialRefetch;\n                if (partialRefetch &&\n                    !data &&\n                    partial &&\n                    fetchPolicy !== 'cache-only') {\n                    Object.assign(result, {\n                        loading: true,\n                        networkStatus: NetworkStatus.loading,\n                    });\n                    result.refetch();\n                    return result;\n                }\n                result.data = data;\n            }\n        }\n        result.client = this.client;\n        this.previousData.loading =\n            (this.previousData.result && this.previousData.result.loading) || false;\n        this.previousData.result = result;\n        this.currentObservable.query &&\n            this.currentObservable.query.resetQueryStoreErrors();\n        return result;\n    };\n    QueryData.prototype.handleErrorOrCompleted = function () {\n        var obsQuery = this.currentObservable.query;\n        if (!obsQuery || !this.previousData.result)\n            return;\n        var _a = this.previousData.result, data = _a.data, loading = _a.loading, error = _a.error;\n        if (!loading) {\n            var _b = this.getOptions(), query = _b.query, variables = _b.variables, onCompleted = _b.onCompleted, onError = _b.onError;\n            if (this.previousOptions &&\n                !this.previousData.loading &&\n                Object(equality_esm[\"a\" /* equal */])(this.previousOptions.query, query) &&\n                Object(equality_esm[\"a\" /* equal */])(this.previousOptions.variables, variables)) {\n                return;\n            }\n            if (onCompleted && !error) {\n                onCompleted(data);\n            }\n            else if (onError && error) {\n                onError(error);\n            }\n        }\n    };\n    QueryData.prototype.removeQuerySubscription = function () {\n        if (this.currentObservable.subscription) {\n            this.currentObservable.subscription.unsubscribe();\n            delete this.currentObservable.subscription;\n        }\n    };\n    QueryData.prototype.observableQueryFields = function () {\n        var observable = this.currentObservable.query;\n        return {\n            variables: observable.variables,\n            refetch: this.obsRefetch,\n            fetchMore: this.obsFetchMore,\n            updateQuery: this.obsUpdateQuery,\n            startPolling: this.obsStartPolling,\n            stopPolling: this.obsStopPolling,\n            subscribeToMore: this.obsSubscribeToMore,\n        };\n    };\n    return QueryData;\n}(react_hooks_esm_OperationData));\n\nfunction useDeepMemo(memoFn, key) {\n    var ref = Object(react[\"useRef\"])();\n    if (!ref.current || !Object(equality_esm[\"a\" /* equal */])(key, ref.current.key)) {\n        ref.current = { key: key, value: memoFn() };\n    }\n    return ref.current.value;\n}\n\nfunction useBaseQuery(query, options, lazy) {\n    if (lazy === void 0) { lazy = false; }\n    var context = Object(react[\"useContext\"])(getApolloContext());\n    var _a = Object(react[\"useReducer\"])(function (x) { return x + 1; }, 0), tick = _a[0], forceUpdate = _a[1];\n    var updatedOptions = options ? Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, options), { query: query }) : { query: query };\n    var queryDataRef = Object(react[\"useRef\"])();\n    var queryData = queryDataRef.current ||\n        new react_hooks_esm_QueryData({\n            options: updatedOptions,\n            context: context,\n            onNewData: function () {\n                if (!queryData.ssrInitiated()) {\n                    Promise.resolve().then(forceUpdate);\n                }\n                else {\n                    forceUpdate();\n                }\n            },\n        });\n    queryData.setOptions(updatedOptions);\n    queryData.context = context;\n    if (queryData.ssrInitiated() && !queryDataRef.current) {\n        queryDataRef.current = queryData;\n    }\n    var memo = {\n        options: Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, updatedOptions), { onError: undefined, onCompleted: undefined }),\n        context: context,\n        tick: tick,\n    };\n    var result = useDeepMemo(function () { return (lazy ? queryData.executeLazy() : queryData.execute()); }, memo);\n    var queryResult = lazy\n        ? result[1]\n        : result;\n    Object(react[\"useEffect\"])(function () {\n        if (!queryDataRef.current) {\n            queryDataRef.current = queryData;\n        }\n        return function () { return queryData.cleanup(); };\n    }, []);\n    Object(react[\"useEffect\"])(function () { return queryData.afterExecute({ lazy: lazy }); }, [\n        queryResult.loading,\n        queryResult.networkStatus,\n        queryResult.error,\n        queryResult.data,\n    ]);\n    return result;\n}\n\nfunction useQuery(query, options) {\n    return useBaseQuery(query, options, false);\n}\n\nfunction useLazyQuery(query, options) {\n    return useBaseQuery(query, options, true);\n}\n\nvar react_hooks_esm_MutationData = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(MutationData, _super);\n    function MutationData(_a) {\n        var options = _a.options, context = _a.context, result = _a.result, setResult = _a.setResult;\n        var _this = _super.call(this, options, context) || this;\n        _this.runMutation = function (mutationFunctionOptions) {\n            if (mutationFunctionOptions === void 0) { mutationFunctionOptions = {}; }\n            _this.onMutationStart();\n            var mutationId = _this.generateNewMutationId();\n            return _this.mutate(mutationFunctionOptions)\n                .then(function (response) {\n                _this.onMutationCompleted(response, mutationId);\n                return response;\n            })\n                .catch(function (error) {\n                _this.onMutationError(error, mutationId);\n                if (!_this.getOptions().onError)\n                    throw error;\n            });\n        };\n        _this.verifyDocumentType(options.mutation, DocumentType.Mutation);\n        _this.result = result;\n        _this.setResult = setResult;\n        _this.mostRecentMutationId = 0;\n        return _this;\n    }\n    MutationData.prototype.execute = function (result) {\n        this.isMounted = true;\n        this.verifyDocumentType(this.getOptions().mutation, DocumentType.Mutation);\n        result.client = this.refreshClient().client;\n        return [this.runMutation, result];\n    };\n    MutationData.prototype.afterExecute = function () {\n        this.isMounted = true;\n        return this.unmount.bind(this);\n    };\n    MutationData.prototype.cleanup = function () {\n    };\n    MutationData.prototype.mutate = function (mutationFunctionOptions) {\n        var _a = this.getOptions(), mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, update = _a.update, _b = _a.context, mutationContext = _b === void 0 ? {} : _b, _c = _a.awaitRefetchQueries, awaitRefetchQueries = _c === void 0 ? false : _c, fetchPolicy = _a.fetchPolicy;\n        var mutateOptions = Object(tslib_es6[\"a\" /* __assign */])({}, mutationFunctionOptions);\n        var mutateVariables = Object.assign({}, variables, mutateOptions.variables);\n        delete mutateOptions.variables;\n        return this.refreshClient().client.mutate(Object(tslib_es6[\"a\" /* __assign */])({ mutation: mutation,\n            optimisticResponse: optimisticResponse, refetchQueries: mutateOptions.refetchQueries || this.getOptions().refetchQueries, awaitRefetchQueries: awaitRefetchQueries,\n            update: update, context: mutationContext, fetchPolicy: fetchPolicy, variables: mutateVariables }, mutateOptions));\n    };\n    MutationData.prototype.onMutationStart = function () {\n        if (!this.result.loading && !this.getOptions().ignoreResults) {\n            this.updateResult({\n                loading: true,\n                error: undefined,\n                data: undefined,\n                called: true\n            });\n        }\n    };\n    MutationData.prototype.onMutationCompleted = function (response, mutationId) {\n        var _a = this.getOptions(), onCompleted = _a.onCompleted, ignoreResults = _a.ignoreResults;\n        var data = response.data, errors = response.errors;\n        var error = errors && errors.length > 0\n            ? new bundle_esm_ApolloError({ graphQLErrors: errors })\n            : undefined;\n        var callOncomplete = function () {\n            return onCompleted ? onCompleted(data) : null;\n        };\n        if (this.isMostRecentMutation(mutationId) && !ignoreResults) {\n            this.updateResult({\n                called: true,\n                loading: false,\n                data: data,\n                error: error\n            });\n        }\n        callOncomplete();\n    };\n    MutationData.prototype.onMutationError = function (error, mutationId) {\n        var onError = this.getOptions().onError;\n        if (this.isMostRecentMutation(mutationId)) {\n            this.updateResult({\n                loading: false,\n                error: error,\n                data: undefined,\n                called: true\n            });\n        }\n        if (onError) {\n            onError(error);\n        }\n    };\n    MutationData.prototype.generateNewMutationId = function () {\n        return ++this.mostRecentMutationId;\n    };\n    MutationData.prototype.isMostRecentMutation = function (mutationId) {\n        return this.mostRecentMutationId === mutationId;\n    };\n    MutationData.prototype.updateResult = function (result) {\n        if (this.isMounted &&\n            (!this.previousResult || !Object(equality_esm[\"a\" /* equal */])(this.previousResult, result))) {\n            this.setResult(result);\n            this.previousResult = result;\n        }\n    };\n    return MutationData;\n}(react_hooks_esm_OperationData));\n\nfunction useMutation(mutation, options) {\n    var context = Object(react[\"useContext\"])(getApolloContext());\n    var _a = Object(react[\"useState\"])({ called: false, loading: false }), result = _a[0], setResult = _a[1];\n    var updatedOptions = options ? Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, options), { mutation: mutation }) : { mutation: mutation };\n    var mutationDataRef = Object(react[\"useRef\"])();\n    function getMutationDataRef() {\n        if (!mutationDataRef.current) {\n            mutationDataRef.current = new react_hooks_esm_MutationData({\n                options: updatedOptions,\n                context: context,\n                result: result,\n                setResult: setResult\n            });\n        }\n        return mutationDataRef.current;\n    }\n    var mutationData = getMutationDataRef();\n    mutationData.setOptions(updatedOptions);\n    mutationData.context = context;\n    Object(react[\"useEffect\"])(function () { return mutationData.afterExecute(); });\n    return mutationData.execute(result);\n}\n\nvar react_hooks_esm_SubscriptionData = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(SubscriptionData, _super);\n    function SubscriptionData(_a) {\n        var options = _a.options, context = _a.context, setResult = _a.setResult;\n        var _this = _super.call(this, options, context) || this;\n        _this.currentObservable = {};\n        _this.setResult = setResult;\n        _this.initialize(options);\n        return _this;\n    }\n    SubscriptionData.prototype.execute = function (result) {\n        if (this.getOptions().skip === true) {\n            this.cleanup();\n            return {\n                loading: false,\n                error: undefined,\n                data: undefined,\n                variables: this.getOptions().variables\n            };\n        }\n        var currentResult = result;\n        if (this.refreshClient().isNew) {\n            currentResult = this.getLoadingResult();\n        }\n        var shouldResubscribe = this.getOptions().shouldResubscribe;\n        if (typeof shouldResubscribe === 'function') {\n            shouldResubscribe = !!shouldResubscribe(this.getOptions());\n        }\n        if (shouldResubscribe !== false &&\n            this.previousOptions &&\n            Object.keys(this.previousOptions).length > 0 &&\n            (this.previousOptions.subscription !== this.getOptions().subscription ||\n                !Object(equality_esm[\"a\" /* equal */])(this.previousOptions.variables, this.getOptions().variables) ||\n                this.previousOptions.skip !== this.getOptions().skip)) {\n            this.cleanup();\n            currentResult = this.getLoadingResult();\n        }\n        this.initialize(this.getOptions());\n        this.startSubscription();\n        this.previousOptions = this.getOptions();\n        return Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, currentResult), { variables: this.getOptions().variables });\n    };\n    SubscriptionData.prototype.afterExecute = function () {\n        this.isMounted = true;\n    };\n    SubscriptionData.prototype.cleanup = function () {\n        this.endSubscription();\n        delete this.currentObservable.query;\n    };\n    SubscriptionData.prototype.initialize = function (options) {\n        if (this.currentObservable.query || this.getOptions().skip === true)\n            return;\n        this.currentObservable.query = this.refreshClient().client.subscribe({\n            query: options.subscription,\n            variables: options.variables,\n            fetchPolicy: options.fetchPolicy\n        });\n    };\n    SubscriptionData.prototype.startSubscription = function () {\n        if (this.currentObservable.subscription)\n            return;\n        this.currentObservable.subscription = this.currentObservable.query.subscribe({\n            next: this.updateCurrentData.bind(this),\n            error: this.updateError.bind(this),\n            complete: this.completeSubscription.bind(this)\n        });\n    };\n    SubscriptionData.prototype.getLoadingResult = function () {\n        return {\n            loading: true,\n            error: undefined,\n            data: undefined\n        };\n    };\n    SubscriptionData.prototype.updateResult = function (result) {\n        if (this.isMounted) {\n            this.setResult(result);\n        }\n    };\n    SubscriptionData.prototype.updateCurrentData = function (result) {\n        var onSubscriptionData = this.getOptions().onSubscriptionData;\n        this.updateResult({\n            data: result.data,\n            loading: false,\n            error: undefined\n        });\n        if (onSubscriptionData) {\n            onSubscriptionData({\n                client: this.refreshClient().client,\n                subscriptionData: result\n            });\n        }\n    };\n    SubscriptionData.prototype.updateError = function (error) {\n        this.updateResult({\n            error: error,\n            loading: false\n        });\n    };\n    SubscriptionData.prototype.completeSubscription = function () {\n        var onSubscriptionComplete = this.getOptions().onSubscriptionComplete;\n        if (onSubscriptionComplete)\n            onSubscriptionComplete();\n        this.endSubscription();\n    };\n    SubscriptionData.prototype.endSubscription = function () {\n        if (this.currentObservable.subscription) {\n            this.currentObservable.subscription.unsubscribe();\n            delete this.currentObservable.subscription;\n        }\n    };\n    return SubscriptionData;\n}(react_hooks_esm_OperationData));\n\nfunction useSubscription(subscription, options) {\n    var context = Object(react[\"useContext\"])(getApolloContext());\n    var updatedOptions = options\n        ? Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, options), { subscription: subscription }) : { subscription: subscription };\n    var _a = Object(react[\"useState\"])({\n        loading: !updatedOptions.skip,\n        error: undefined,\n        data: undefined\n    }), result = _a[0], setResult = _a[1];\n    var subscriptionDataRef = Object(react[\"useRef\"])();\n    function getSubscriptionDataRef() {\n        if (!subscriptionDataRef.current) {\n            subscriptionDataRef.current = new react_hooks_esm_SubscriptionData({\n                options: updatedOptions,\n                context: context,\n                setResult: setResult\n            });\n        }\n        return subscriptionDataRef.current;\n    }\n    var subscriptionData = getSubscriptionDataRef();\n    subscriptionData.setOptions(updatedOptions, true);\n    subscriptionData.context = context;\n    Object(react[\"useEffect\"])(function () { return subscriptionData.afterExecute(); });\n    Object(react[\"useEffect\"])(function () { return subscriptionData.cleanup.bind(subscriptionData); }, []);\n    return subscriptionData.execute(result);\n}\n\nfunction useApolloClient() {\n    var client = react_default.a.useContext(getApolloContext()).client;\n     true ? Object(invariant_esm[\"b\" /* invariant */])(client, 1) : undefined;\n    return client;\n}\n\nfunction makeDefaultQueryInfo() {\n    return {\n        seen: false,\n        observable: null\n    };\n}\nvar RenderPromises = (function () {\n    function RenderPromises() {\n        this.queryPromises = new Map();\n        this.queryInfoTrie = new Map();\n    }\n    RenderPromises.prototype.registerSSRObservable = function (observable, props) {\n        this.lookupQueryInfo(props).observable = observable;\n    };\n    RenderPromises.prototype.getSSRObservable = function (props) {\n        return this.lookupQueryInfo(props).observable;\n    };\n    RenderPromises.prototype.addQueryPromise = function (queryInstance, finish) {\n        var info = this.lookupQueryInfo(queryInstance.getOptions());\n        if (!info.seen) {\n            this.queryPromises.set(queryInstance.getOptions(), new Promise(function (resolve) {\n                resolve(queryInstance.fetchData());\n            }));\n            return null;\n        }\n        return finish();\n    };\n    RenderPromises.prototype.hasPromises = function () {\n        return this.queryPromises.size > 0;\n    };\n    RenderPromises.prototype.consumeAndAwaitPromises = function () {\n        var _this = this;\n        var promises = [];\n        this.queryPromises.forEach(function (promise, queryInstance) {\n            _this.lookupQueryInfo(queryInstance).seen = true;\n            promises.push(promise);\n        });\n        this.queryPromises.clear();\n        return Promise.all(promises);\n    };\n    RenderPromises.prototype.lookupQueryInfo = function (props) {\n        var queryInfoTrie = this.queryInfoTrie;\n        var query = props.query, variables = props.variables;\n        var varMap = queryInfoTrie.get(query) || new Map();\n        if (!queryInfoTrie.has(query))\n            queryInfoTrie.set(query, varMap);\n        var variablesString = JSON.stringify(variables);\n        var info = varMap.get(variablesString) || makeDefaultQueryInfo();\n        if (!varMap.has(variablesString))\n            varMap.set(variablesString, info);\n        return info;\n    };\n    return RenderPromises;\n}());\n\n\n//# sourceMappingURL=react-hooks.esm.js.map\n\n// EXTERNAL MODULE: ./node_modules/graphql-tag/src/index.js\nvar src = __webpack_require__(9);\nvar src_default = /*#__PURE__*/__webpack_require__.n(src);\n\n// CONCATENATED MODULE: ./client/components/Main.jsx\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([\"\\n  mutation RemoveTodo($id: String!) {\\n    removeTodo(id: $id)\\n  }\\n\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\\n  mutation CreateTodo($name: String!) {\\n    createTodo(name: $name) {\\n      id\\n      __typename\\n      name\\n      completed\\n    }\\n  }\\n\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n  query todos {\\n    todos {\\n      id\\n      name\\n      completed\\n    }\\n  }\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n // import './App.css';\n\n\n\nvar READ_TODOS = src_default()(_templateObject());\nvar CREATE_TODO = src_default()(_templateObject2());\nvar REMOVE_TODO = src_default()(_templateObject3());\nfunction Main() {\n  var {\n    data,\n    loading,\n    error,\n    refetch\n  } = useQuery(READ_TODOS, {\n    notifyOnNetworkStatusChange: true\n  });\n  var [createTodo] = useMutation(CREATE_TODO);\n  var [removeTodo] = useMutation(REMOVE_TODO);\n  if (loading) return /*#__PURE__*/react_default.a.createElement(\"p\", null, \"loading...\");\n  if (error) return /*#__PURE__*/react_default.a.createElement(\"p\", null, \"ERROR\");\n  if (!data) return /*#__PURE__*/react_default.a.createElement(\"p\", null, \"Not found\");\n  return /*#__PURE__*/react_default.a.createElement(ToDoList, {\n    data: data,\n    refetch: refetch,\n    createTodo: createTodo,\n    removeTodo: removeTodo\n  });\n} // Check that service workers are supported\n\nif (\"serviceWorker\" in navigator) {\n  window.addEventListener(\"load\", () => {\n    navigator.serviceWorker.register(\"/sw.js\").then(registration => {\n      console.log(\"SW registered: \", registration);\n    }).catch(registrationError => {\n      console.log(\"SW registration failed: \", registrationError);\n    });\n  });\n}\n// EXTERNAL MODULE: ./node_modules/graphql/language/blockString.mjs\nvar blockString = __webpack_require__(14);\n\n// CONCATENATED MODULE: ./node_modules/graphql/language/printer.mjs\n\n\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nfunction print(ast) {\n  return Object(visitor[\"b\" /* visit */])(ast, {\n    leave: printDocASTReducer\n  });\n} // TODO: provide better type coverage in future\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return '$' + node.name;\n  },\n  // Document\n  Document: function Document(node) {\n    return printer_join(node.definitions, '\\n\\n') + '\\n';\n  },\n  OperationDefinition: function OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var varDefs = wrap('(', printer_join(node.variableDefinitions, ', '), ')');\n    var directives = printer_join(node.directives, ' ');\n    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use\n    // the query short form.\n\n    return !name && !directives && !varDefs && op === 'query' ? selectionSet : printer_join([op, printer_join([name, varDefs]), directives, selectionSet], ' ');\n  },\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable,\n        type = _ref.type,\n        defaultValue = _ref.defaultValue,\n        directives = _ref.directives;\n    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', printer_join(directives, ' '));\n  },\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias,\n        name = _ref3.name,\n        args = _ref3.arguments,\n        directives = _ref3.directives,\n        selectionSet = _ref3.selectionSet;\n    return printer_join([wrap('', alias, ': ') + name + wrap('(', printer_join(args, ', '), ')'), printer_join(directives, ' '), selectionSet], ' ');\n  },\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name,\n        value = _ref4.value;\n    return name + ': ' + value;\n  },\n  // Fragments\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name,\n        directives = _ref5.directives;\n    return '...' + name + wrap(' ', printer_join(directives, ' '));\n  },\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition,\n        directives = _ref6.directives,\n        selectionSet = _ref6.selectionSet;\n    return printer_join(['...', wrap('on ', typeCondition), printer_join(directives, ' '), selectionSet], ' ');\n  },\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name,\n        typeCondition = _ref7.typeCondition,\n        variableDefinitions = _ref7.variableDefinitions,\n        directives = _ref7.directives,\n        selectionSet = _ref7.selectionSet;\n    return (// Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      \"fragment \".concat(name).concat(wrap('(', printer_join(variableDefinitions, ', '), ')'), \" \") + \"on \".concat(typeCondition, \" \").concat(wrap('', printer_join(directives, ' '), ' ')) + selectionSet\n    );\n  },\n  // Value\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10, key) {\n    var value = _ref10.value,\n        isBlockString = _ref10.block;\n    return isBlockString ? Object(blockString[\"b\" /* printBlockString */])(value, key === 'description' ? '' : '  ') : JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return value ? 'true' : 'false';\n  },\n  NullValue: function NullValue() {\n    return 'null';\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return '[' + printer_join(values, ', ') + ']';\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return '{' + printer_join(fields, ', ') + '}';\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name,\n        value = _ref15.value;\n    return name + ': ' + value;\n  },\n  // Directive\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name,\n        args = _ref16.arguments;\n    return '@' + name + wrap('(', printer_join(args, ', '), ')');\n  },\n  // Type\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return '[' + type + ']';\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return type + '!';\n  },\n  // Type System Definitions\n  SchemaDefinition: function SchemaDefinition(_ref20) {\n    var directives = _ref20.directives,\n        operationTypes = _ref20.operationTypes;\n    return printer_join(['schema', printer_join(directives, ' '), block(operationTypes)], ' ');\n  },\n  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {\n    var operation = _ref21.operation,\n        type = _ref21.type;\n    return operation + ': ' + type;\n  },\n  ScalarTypeDefinition: addDescription(function (_ref22) {\n    var name = _ref22.name,\n        directives = _ref22.directives;\n    return printer_join(['scalar', name, printer_join(directives, ' ')], ' ');\n  }),\n  ObjectTypeDefinition: addDescription(function (_ref23) {\n    var name = _ref23.name,\n        interfaces = _ref23.interfaces,\n        directives = _ref23.directives,\n        fields = _ref23.fields;\n    return printer_join(['type', name, wrap('implements ', printer_join(interfaces, ' & ')), printer_join(directives, ' '), block(fields)], ' ');\n  }),\n  FieldDefinition: addDescription(function (_ref24) {\n    var name = _ref24.name,\n        args = _ref24.arguments,\n        type = _ref24.type,\n        directives = _ref24.directives;\n    return name + (hasMultilineItems(args) ? wrap('(\\n', indent(printer_join(args, '\\n')), '\\n)') : wrap('(', printer_join(args, ', '), ')')) + ': ' + type + wrap(' ', printer_join(directives, ' '));\n  }),\n  InputValueDefinition: addDescription(function (_ref25) {\n    var name = _ref25.name,\n        type = _ref25.type,\n        defaultValue = _ref25.defaultValue,\n        directives = _ref25.directives;\n    return printer_join([name + ': ' + type, wrap('= ', defaultValue), printer_join(directives, ' ')], ' ');\n  }),\n  InterfaceTypeDefinition: addDescription(function (_ref26) {\n    var name = _ref26.name,\n        directives = _ref26.directives,\n        fields = _ref26.fields;\n    return printer_join(['interface', name, printer_join(directives, ' '), block(fields)], ' ');\n  }),\n  UnionTypeDefinition: addDescription(function (_ref27) {\n    var name = _ref27.name,\n        directives = _ref27.directives,\n        types = _ref27.types;\n    return printer_join(['union', name, printer_join(directives, ' '), types && types.length !== 0 ? '= ' + printer_join(types, ' | ') : ''], ' ');\n  }),\n  EnumTypeDefinition: addDescription(function (_ref28) {\n    var name = _ref28.name,\n        directives = _ref28.directives,\n        values = _ref28.values;\n    return printer_join(['enum', name, printer_join(directives, ' '), block(values)], ' ');\n  }),\n  EnumValueDefinition: addDescription(function (_ref29) {\n    var name = _ref29.name,\n        directives = _ref29.directives;\n    return printer_join([name, printer_join(directives, ' ')], ' ');\n  }),\n  InputObjectTypeDefinition: addDescription(function (_ref30) {\n    var name = _ref30.name,\n        directives = _ref30.directives,\n        fields = _ref30.fields;\n    return printer_join(['input', name, printer_join(directives, ' '), block(fields)], ' ');\n  }),\n  DirectiveDefinition: addDescription(function (_ref31) {\n    var name = _ref31.name,\n        args = _ref31.arguments,\n        repeatable = _ref31.repeatable,\n        locations = _ref31.locations;\n    return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(printer_join(args, '\\n')), '\\n)') : wrap('(', printer_join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + printer_join(locations, ' | ');\n  }),\n  SchemaExtension: function SchemaExtension(_ref32) {\n    var directives = _ref32.directives,\n        operationTypes = _ref32.operationTypes;\n    return printer_join(['extend schema', printer_join(directives, ' '), block(operationTypes)], ' ');\n  },\n  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {\n    var name = _ref33.name,\n        directives = _ref33.directives;\n    return printer_join(['extend scalar', name, printer_join(directives, ' ')], ' ');\n  },\n  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {\n    var name = _ref34.name,\n        interfaces = _ref34.interfaces,\n        directives = _ref34.directives,\n        fields = _ref34.fields;\n    return printer_join(['extend type', name, wrap('implements ', printer_join(interfaces, ' & ')), printer_join(directives, ' '), block(fields)], ' ');\n  },\n  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {\n    var name = _ref35.name,\n        directives = _ref35.directives,\n        fields = _ref35.fields;\n    return printer_join(['extend interface', name, printer_join(directives, ' '), block(fields)], ' ');\n  },\n  UnionTypeExtension: function UnionTypeExtension(_ref36) {\n    var name = _ref36.name,\n        directives = _ref36.directives,\n        types = _ref36.types;\n    return printer_join(['extend union', name, printer_join(directives, ' '), types && types.length !== 0 ? '= ' + printer_join(types, ' | ') : ''], ' ');\n  },\n  EnumTypeExtension: function EnumTypeExtension(_ref37) {\n    var name = _ref37.name,\n        directives = _ref37.directives,\n        values = _ref37.values;\n    return printer_join(['extend enum', name, printer_join(directives, ' '), block(values)], ' ');\n  },\n  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {\n    var name = _ref38.name,\n        directives = _ref38.directives,\n        fields = _ref38.fields;\n    return printer_join(['extend input', name, printer_join(directives, ' '), block(fields)], ' ');\n  }\n};\n\nfunction addDescription(cb) {\n  return function (node) {\n    return printer_join([node.description, cb(node)], '\\n');\n  };\n}\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction printer_join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return array && array.length !== 0 ? '{\\n' + indent(printer_join(array, '\\n')) + '\\n}' : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\n\n\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n\nfunction indent(maybeString) {\n  return maybeString && '  ' + maybeString.replace(/\\n/g, '\\n  ');\n}\n\nfunction isMultiline(string) {\n  return string.indexOf('\\n') !== -1;\n}\n\nfunction hasMultilineItems(maybeArray) {\n  return maybeArray && maybeArray.some(isMultiline);\n}\n\n// CONCATENATED MODULE: ./node_modules/apollo-link-http-common/lib/bundle.esm.js\n\n\n\n\nvar defaultHttpOptions = {\n    includeQuery: true,\n    includeExtensions: false,\n};\nvar defaultHeaders = {\n    accept: '*/*',\n    'content-type': 'application/json',\n};\nvar bundle_esm_defaultOptions = {\n    method: 'POST',\n};\nvar fallbackHttpConfig = {\n    http: defaultHttpOptions,\n    headers: defaultHeaders,\n    options: bundle_esm_defaultOptions,\n};\nvar throwServerError = function (response, result, message) {\n    var error = new Error(message);\n    error.name = 'ServerError';\n    error.response = response;\n    error.statusCode = response.status;\n    error.result = result;\n    throw error;\n};\nvar parseAndCheckHttpResponse = function (operations) { return function (response) {\n    return (response\n        .text()\n        .then(function (bodyText) {\n        try {\n            return JSON.parse(bodyText);\n        }\n        catch (err) {\n            var parseError = err;\n            parseError.name = 'ServerParseError';\n            parseError.response = response;\n            parseError.statusCode = response.status;\n            parseError.bodyText = bodyText;\n            return Promise.reject(parseError);\n        }\n    })\n        .then(function (result) {\n        if (response.status >= 300) {\n            throwServerError(response, result, \"Response not successful: Received status code \" + response.status);\n        }\n        if (!Array.isArray(result) &&\n            !result.hasOwnProperty('data') &&\n            !result.hasOwnProperty('errors')) {\n            throwServerError(response, result, \"Server response was missing for query '\" + (Array.isArray(operations)\n                ? operations.map(function (op) { return op.operationName; })\n                : operations.operationName) + \"'.\");\n        }\n        return result;\n    }));\n}; };\nvar checkFetcher = function (fetcher) {\n    if (!fetcher && typeof fetch === 'undefined') {\n        var library = 'unfetch';\n        if (typeof window === 'undefined')\n            library = 'node-fetch';\n        throw  true ? new invariant_esm[\"a\" /* InvariantError */](1) : undefined;\n    }\n};\nvar createSignalIfSupported = function () {\n    if (typeof AbortController === 'undefined')\n        return { controller: false, signal: false };\n    var controller = new AbortController();\n    var signal = controller.signal;\n    return { controller: controller, signal: signal };\n};\nvar selectHttpOptionsAndBody = function (operation, fallbackConfig) {\n    var configs = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        configs[_i - 2] = arguments[_i];\n    }\n    var options = Object(tslib_es6[\"a\" /* __assign */])({}, fallbackConfig.options, { headers: fallbackConfig.headers, credentials: fallbackConfig.credentials });\n    var http = fallbackConfig.http;\n    configs.forEach(function (config) {\n        options = Object(tslib_es6[\"a\" /* __assign */])({}, options, config.options, { headers: Object(tslib_es6[\"a\" /* __assign */])({}, options.headers, config.headers) });\n        if (config.credentials)\n            options.credentials = config.credentials;\n        http = Object(tslib_es6[\"a\" /* __assign */])({}, http, config.http);\n    });\n    var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;\n    var body = { operationName: operationName, variables: variables };\n    if (http.includeExtensions)\n        body.extensions = extensions;\n    if (http.includeQuery)\n        body.query = print(query);\n    return {\n        options: options,\n        body: body,\n    };\n};\nvar serializeFetchParameter = function (p, label) {\n    var serialized;\n    try {\n        serialized = JSON.stringify(p);\n    }\n    catch (e) {\n        var parseError =  true ? new invariant_esm[\"a\" /* InvariantError */](2) : undefined;\n        parseError.parseError = e;\n        throw parseError;\n    }\n    return serialized;\n};\nvar selectURI = function (operation, fallbackURI) {\n    var context = operation.getContext();\n    var contextURI = context.uri;\n    if (contextURI) {\n        return contextURI;\n    }\n    else if (typeof fallbackURI === 'function') {\n        return fallbackURI(operation);\n    }\n    else {\n        return fallbackURI || '/graphql';\n    }\n};\n\n\n//# sourceMappingURL=bundle.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/apollo-link-http/lib/bundle.esm.js\n\n\n\n\nvar createHttpLink = function (linkOptions) {\n    if (linkOptions === void 0) { linkOptions = {}; }\n    var _a = linkOptions.uri, uri = _a === void 0 ? '/graphql' : _a, fetcher = linkOptions.fetch, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, requestOptions = Object(tslib_es6[\"e\" /* __rest */])(linkOptions, [\"uri\", \"fetch\", \"includeExtensions\", \"useGETForQueries\"]);\n    checkFetcher(fetcher);\n    if (!fetcher) {\n        fetcher = fetch;\n    }\n    var linkConfig = {\n        http: { includeExtensions: includeExtensions },\n        options: requestOptions.fetchOptions,\n        credentials: requestOptions.credentials,\n        headers: requestOptions.headers,\n    };\n    return new bundle_esm_ApolloLink(function (operation) {\n        var chosenURI = selectURI(operation, uri);\n        var context = operation.getContext();\n        var clientAwarenessHeaders = {};\n        if (context.clientAwareness) {\n            var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;\n            if (name_1) {\n                clientAwarenessHeaders['apollographql-client-name'] = name_1;\n            }\n            if (version) {\n                clientAwarenessHeaders['apollographql-client-version'] = version;\n            }\n        }\n        var contextHeaders = Object(tslib_es6[\"a\" /* __assign */])({}, clientAwarenessHeaders, context.headers);\n        var contextConfig = {\n            http: context.http,\n            options: context.fetchOptions,\n            credentials: context.credentials,\n            headers: contextHeaders,\n        };\n        var _b = selectHttpOptionsAndBody(operation, fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;\n        var controller;\n        if (!options.signal) {\n            var _c = createSignalIfSupported(), _controller = _c.controller, signal = _c.signal;\n            controller = _controller;\n            if (controller)\n                options.signal = signal;\n        }\n        var definitionIsMutation = function (d) {\n            return d.kind === 'OperationDefinition' && d.operation === 'mutation';\n        };\n        if (useGETForQueries &&\n            !operation.query.definitions.some(definitionIsMutation)) {\n            options.method = 'GET';\n        }\n        if (options.method === 'GET') {\n            var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;\n            if (parseError) {\n                return fromError(parseError);\n            }\n            chosenURI = newURI;\n        }\n        else {\n            try {\n                options.body = serializeFetchParameter(body, 'Payload');\n            }\n            catch (parseError) {\n                return fromError(parseError);\n            }\n        }\n        return new lib_bundle_esm(function (observer) {\n            fetcher(chosenURI, options)\n                .then(function (response) {\n                operation.setContext({ response: response });\n                return response;\n            })\n                .then(parseAndCheckHttpResponse(operation))\n                .then(function (result) {\n                observer.next(result);\n                observer.complete();\n                return result;\n            })\n                .catch(function (err) {\n                if (err.name === 'AbortError')\n                    return;\n                if (err.result && err.result.errors && err.result.data) {\n                    observer.next(err.result);\n                }\n                observer.error(err);\n            });\n            return function () {\n                if (controller)\n                    controller.abort();\n            };\n        });\n    });\n};\nfunction rewriteURIForGET(chosenURI, body) {\n    var queryParams = [];\n    var addQueryParam = function (key, value) {\n        queryParams.push(key + \"=\" + encodeURIComponent(value));\n    };\n    if ('query' in body) {\n        addQueryParam('query', body.query);\n    }\n    if (body.operationName) {\n        addQueryParam('operationName', body.operationName);\n    }\n    if (body.variables) {\n        var serializedVariables = void 0;\n        try {\n            serializedVariables = serializeFetchParameter(body.variables, 'Variables map');\n        }\n        catch (parseError) {\n            return { parseError: parseError };\n        }\n        addQueryParam('variables', serializedVariables);\n    }\n    if (body.extensions) {\n        var serializedExtensions = void 0;\n        try {\n            serializedExtensions = serializeFetchParameter(body.extensions, 'Extensions map');\n        }\n        catch (parseError) {\n            return { parseError: parseError };\n        }\n        addQueryParam('extensions', serializedExtensions);\n    }\n    var fragment = '', preFragment = chosenURI;\n    var fragmentStart = chosenURI.indexOf('#');\n    if (fragmentStart !== -1) {\n        fragment = chosenURI.substr(fragmentStart);\n        preFragment = chosenURI.substr(0, fragmentStart);\n    }\n    var queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';\n    var newURI = preFragment + queryParamsPrefix + queryParams.join('&') + fragment;\n    return { newURI: newURI };\n}\nvar bundle_esm_HttpLink = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(HttpLink, _super);\n    function HttpLink(opts) {\n        return _super.call(this, createHttpLink(opts).request) || this;\n    }\n    return HttpLink;\n}(bundle_esm_ApolloLink));\n\n\n//# sourceMappingURL=bundle.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/apollo-link-retry/lib/bundle.esm.js\n\n\n\nfunction buildDelayFunction(delayOptions) {\n    var _a = delayOptions || {}, _b = _a.initial, initial = _b === void 0 ? 300 : _b, _c = _a.jitter, jitter = _c === void 0 ? true : _c, _d = _a.max, max = _d === void 0 ? Infinity : _d;\n    var baseDelay = jitter ? initial : initial / 2;\n    return function delayFunction(count) {\n        var delay = Math.min(max, baseDelay * Math.pow(2, count));\n        if (jitter) {\n            delay = Math.random() * delay;\n        }\n        return delay;\n    };\n}\n\nfunction buildRetryFunction(retryOptions) {\n    var _a = retryOptions || {}, retryIf = _a.retryIf, _b = _a.max, max = _b === void 0 ? 5 : _b;\n    return function retryFunction(count, operation, error) {\n        if (count >= max)\n            return false;\n        return retryIf ? retryIf(error, operation) : !!error;\n    };\n}\n\nvar bundle_esm_RetryableOperation = (function () {\n    function RetryableOperation(operation, nextLink, delayFor, retryIf) {\n        var _this = this;\n        this.operation = operation;\n        this.nextLink = nextLink;\n        this.delayFor = delayFor;\n        this.retryIf = retryIf;\n        this.retryCount = 0;\n        this.values = [];\n        this.complete = false;\n        this.canceled = false;\n        this.observers = [];\n        this.currentSubscription = null;\n        this.onNext = function (value) {\n            _this.values.push(value);\n            for (var _i = 0, _a = _this.observers; _i < _a.length; _i++) {\n                var observer = _a[_i];\n                if (!observer)\n                    continue;\n                observer.next(value);\n            }\n        };\n        this.onComplete = function () {\n            _this.complete = true;\n            for (var _i = 0, _a = _this.observers; _i < _a.length; _i++) {\n                var observer = _a[_i];\n                if (!observer)\n                    continue;\n                observer.complete();\n            }\n        };\n        this.onError = function (error) { return Object(tslib_es6[\"b\" /* __awaiter */])(_this, void 0, void 0, function () {\n            var shouldRetry, _i, _a, observer;\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        this.retryCount += 1;\n                        return [4, this.retryIf(this.retryCount, this.operation, error)];\n                    case 1:\n                        shouldRetry = _b.sent();\n                        if (shouldRetry) {\n                            this.scheduleRetry(this.delayFor(this.retryCount, this.operation, error));\n                            return [2];\n                        }\n                        this.error = error;\n                        for (_i = 0, _a = this.observers; _i < _a.length; _i++) {\n                            observer = _a[_i];\n                            if (!observer)\n                                continue;\n                            observer.error(error);\n                        }\n                        return [2];\n                }\n            });\n        }); };\n    }\n    RetryableOperation.prototype.subscribe = function (observer) {\n        if (this.canceled) {\n            throw new Error(\"Subscribing to a retryable link that was canceled is not supported\");\n        }\n        this.observers.push(observer);\n        for (var _i = 0, _a = this.values; _i < _a.length; _i++) {\n            var value = _a[_i];\n            observer.next(value);\n        }\n        if (this.complete) {\n            observer.complete();\n        }\n        else if (this.error) {\n            observer.error(this.error);\n        }\n    };\n    RetryableOperation.prototype.unsubscribe = function (observer) {\n        var index = this.observers.indexOf(observer);\n        if (index < 0) {\n            throw new Error(\"RetryLink BUG! Attempting to unsubscribe unknown observer!\");\n        }\n        this.observers[index] = null;\n        if (this.observers.every(function (o) { return o === null; })) {\n            this.cancel();\n        }\n    };\n    RetryableOperation.prototype.start = function () {\n        if (this.currentSubscription)\n            return;\n        this.try();\n    };\n    RetryableOperation.prototype.cancel = function () {\n        if (this.currentSubscription) {\n            this.currentSubscription.unsubscribe();\n        }\n        clearTimeout(this.timerId);\n        this.timerId = null;\n        this.currentSubscription = null;\n        this.canceled = true;\n    };\n    RetryableOperation.prototype.try = function () {\n        this.currentSubscription = this.nextLink(this.operation).subscribe({\n            next: this.onNext,\n            error: this.onError,\n            complete: this.onComplete,\n        });\n    };\n    RetryableOperation.prototype.scheduleRetry = function (delay) {\n        var _this = this;\n        if (this.timerId) {\n            throw new Error(\"RetryLink BUG! Encountered overlapping retries\");\n        }\n        this.timerId = setTimeout(function () {\n            _this.timerId = null;\n            _this.try();\n        }, delay);\n    };\n    return RetryableOperation;\n}());\nvar bundle_esm_RetryLink = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(RetryLink, _super);\n    function RetryLink(options) {\n        var _this = _super.call(this) || this;\n        var _a = options || {}, attempts = _a.attempts, delay = _a.delay;\n        _this.delayFor =\n            typeof delay === 'function' ? delay : buildDelayFunction(delay);\n        _this.retryIf =\n            typeof attempts === 'function' ? attempts : buildRetryFunction(attempts);\n        return _this;\n    }\n    RetryLink.prototype.request = function (operation, nextLink) {\n        var retryable = new bundle_esm_RetryableOperation(operation, nextLink, this.delayFor, this.retryIf);\n        retryable.start();\n        return new lib_bundle_esm(function (observer) {\n            retryable.subscribe(observer);\n            return function () {\n                retryable.unsubscribe(observer);\n            };\n        });\n    };\n    return RetryLink;\n}(bundle_esm_ApolloLink));\n\n\n//# sourceMappingURL=bundle.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/apollo-cache/lib/bundle.esm.js\n\n\nfunction queryFromPojo(obj) {\n    var op = {\n        kind: 'OperationDefinition',\n        operation: 'query',\n        name: {\n            kind: 'Name',\n            value: 'GeneratedClientQuery',\n        },\n        selectionSet: selectionSetFromObj(obj),\n    };\n    var out = {\n        kind: 'Document',\n        definitions: [op],\n    };\n    return out;\n}\nfunction fragmentFromPojo(obj, typename) {\n    var frag = {\n        kind: 'FragmentDefinition',\n        typeCondition: {\n            kind: 'NamedType',\n            name: {\n                kind: 'Name',\n                value: typename || '__FakeType',\n            },\n        },\n        name: {\n            kind: 'Name',\n            value: 'GeneratedClientQuery',\n        },\n        selectionSet: selectionSetFromObj(obj),\n    };\n    var out = {\n        kind: 'Document',\n        definitions: [frag],\n    };\n    return out;\n}\nfunction selectionSetFromObj(obj) {\n    if (typeof obj === 'number' ||\n        typeof obj === 'boolean' ||\n        typeof obj === 'string' ||\n        typeof obj === 'undefined' ||\n        obj === null) {\n        return null;\n    }\n    if (Array.isArray(obj)) {\n        return selectionSetFromObj(obj[0]);\n    }\n    var selections = [];\n    Object.keys(obj).forEach(function (key) {\n        var nestedSelSet = selectionSetFromObj(obj[key]);\n        var field = {\n            kind: 'Field',\n            name: {\n                kind: 'Name',\n                value: key,\n            },\n            selectionSet: nestedSelSet || undefined,\n        };\n        selections.push(field);\n    });\n    var selectionSet = {\n        kind: 'SelectionSet',\n        selections: selections,\n    };\n    return selectionSet;\n}\nvar justTypenameQuery = {\n    kind: 'Document',\n    definitions: [\n        {\n            kind: 'OperationDefinition',\n            operation: 'query',\n            name: null,\n            variableDefinitions: null,\n            directives: [],\n            selectionSet: {\n                kind: 'SelectionSet',\n                selections: [\n                    {\n                        kind: 'Field',\n                        alias: null,\n                        name: {\n                            kind: 'Name',\n                            value: '__typename',\n                        },\n                        arguments: [],\n                        directives: [],\n                        selectionSet: null,\n                    },\n                ],\n            },\n        },\n    ],\n};\n\nvar bundle_esm_ApolloCache = (function () {\n    function ApolloCache() {\n    }\n    ApolloCache.prototype.transformDocument = function (document) {\n        return document;\n    };\n    ApolloCache.prototype.transformForLink = function (document) {\n        return document;\n    };\n    ApolloCache.prototype.readQuery = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return this.read({\n            query: options.query,\n            variables: options.variables,\n            optimistic: optimistic,\n        });\n    };\n    ApolloCache.prototype.readFragment = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return this.read({\n            query: Object(bundle_esm[\"k\" /* getFragmentQueryDocument */])(options.fragment, options.fragmentName),\n            variables: options.variables,\n            rootId: options.id,\n            optimistic: optimistic,\n        });\n    };\n    ApolloCache.prototype.writeQuery = function (options) {\n        this.write({\n            dataId: 'ROOT_QUERY',\n            result: options.data,\n            query: options.query,\n            variables: options.variables,\n        });\n    };\n    ApolloCache.prototype.writeFragment = function (options) {\n        this.write({\n            dataId: options.id,\n            result: options.data,\n            variables: options.variables,\n            query: Object(bundle_esm[\"k\" /* getFragmentQueryDocument */])(options.fragment, options.fragmentName),\n        });\n    };\n    ApolloCache.prototype.writeData = function (_a) {\n        var id = _a.id, data = _a.data;\n        if (typeof id !== 'undefined') {\n            var typenameResult = null;\n            try {\n                typenameResult = this.read({\n                    rootId: id,\n                    optimistic: false,\n                    query: justTypenameQuery,\n                });\n            }\n            catch (e) {\n            }\n            var __typename = (typenameResult && typenameResult.__typename) || '__ClientData';\n            var dataToWrite = Object.assign({ __typename: __typename }, data);\n            this.writeFragment({\n                id: id,\n                fragment: fragmentFromPojo(dataToWrite, __typename),\n                data: dataToWrite,\n            });\n        }\n        else {\n            this.writeQuery({ query: queryFromPojo(data), data: data });\n        }\n    };\n    return ApolloCache;\n}());\n\nvar Cache;\n(function (Cache) {\n})(Cache || (Cache = {}));\n\n\n//# sourceMappingURL=bundle.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/@wry/context/lib/context.esm.js\n// This currentContext variable will only be used if the makeSlotClass\r\n// function is called, which happens only if this is the first copy of the\r\n// @wry/context package to be imported.\r\nvar currentContext = null;\r\n// This unique internal object is used to denote the absence of a value\r\n// for a given Slot, and is never exposed to outside code.\r\nvar MISSING_VALUE = {};\r\nvar idCounter = 1;\r\n// Although we can't do anything about the cost of duplicated code from\r\n// accidentally bundling multiple copies of the @wry/context package, we can\r\n// avoid creating the Slot class more than once using makeSlotClass.\r\nvar makeSlotClass = function () { return /** @class */ (function () {\r\n    function Slot() {\r\n        // If you have a Slot object, you can find out its slot.id, but you cannot\r\n        // guess the slot.id of a Slot you don't have access to, thanks to the\r\n        // randomized suffix.\r\n        this.id = [\r\n            \"slot\",\r\n            idCounter++,\r\n            Date.now(),\r\n            Math.random().toString(36).slice(2),\r\n        ].join(\":\");\r\n    }\r\n    Slot.prototype.hasValue = function () {\r\n        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {\r\n            // We use the Slot object iself as a key to its value, which means the\r\n            // value cannot be obtained without a reference to the Slot object.\r\n            if (this.id in context_1.slots) {\r\n                var value = context_1.slots[this.id];\r\n                if (value === MISSING_VALUE)\r\n                    break;\r\n                if (context_1 !== currentContext) {\r\n                    // Cache the value in currentContext.slots so the next lookup will\r\n                    // be faster. This caching is safe because the tree of contexts and\r\n                    // the values of the slots are logically immutable.\r\n                    currentContext.slots[this.id] = value;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        if (currentContext) {\r\n            // If a value was not found for this Slot, it's never going to be found\r\n            // no matter how many times we look it up, so we might as well cache\r\n            // the absence of the value, too.\r\n            currentContext.slots[this.id] = MISSING_VALUE;\r\n        }\r\n        return false;\r\n    };\r\n    Slot.prototype.getValue = function () {\r\n        if (this.hasValue()) {\r\n            return currentContext.slots[this.id];\r\n        }\r\n    };\r\n    Slot.prototype.withValue = function (value, callback, \r\n    // Given the prevalence of arrow functions, specifying arguments is likely\r\n    // to be much more common than specifying `this`, hence this ordering:\r\n    args, thisArg) {\r\n        var _a;\r\n        var slots = (_a = {\r\n                __proto__: null\r\n            },\r\n            _a[this.id] = value,\r\n            _a);\r\n        var parent = currentContext;\r\n        currentContext = { parent: parent, slots: slots };\r\n        try {\r\n            // Function.prototype.apply allows the arguments array argument to be\r\n            // omitted or undefined, so args! is fine here.\r\n            return callback.apply(thisArg, args);\r\n        }\r\n        finally {\r\n            currentContext = parent;\r\n        }\r\n    };\r\n    // Capture the current context and wrap a callback function so that it\r\n    // reestablishes the captured context when called.\r\n    Slot.bind = function (callback) {\r\n        var context = currentContext;\r\n        return function () {\r\n            var saved = currentContext;\r\n            try {\r\n                currentContext = context;\r\n                return callback.apply(this, arguments);\r\n            }\r\n            finally {\r\n                currentContext = saved;\r\n            }\r\n        };\r\n    };\r\n    // Immediately run a callback function without any captured context.\r\n    Slot.noContext = function (callback, \r\n    // Given the prevalence of arrow functions, specifying arguments is likely\r\n    // to be much more common than specifying `this`, hence this ordering:\r\n    args, thisArg) {\r\n        if (currentContext) {\r\n            var saved = currentContext;\r\n            try {\r\n                currentContext = null;\r\n                // Function.prototype.apply allows the arguments array argument to be\r\n                // omitted or undefined, so args! is fine here.\r\n                return callback.apply(thisArg, args);\r\n            }\r\n            finally {\r\n                currentContext = saved;\r\n            }\r\n        }\r\n        else {\r\n            return callback.apply(thisArg, args);\r\n        }\r\n    };\r\n    return Slot;\r\n}()); };\r\n// We store a single global implementation of the Slot class as a permanent\r\n// non-enumerable symbol property of the Array constructor. This obfuscation\r\n// does nothing to prevent access to the Slot class, but at least it ensures\r\n// the implementation (i.e. currentContext) cannot be tampered with, and all\r\n// copies of the @wry/context package (hopefully just one) will share the\r\n// same Slot implementation. Since the first copy of the @wry/context package\r\n// to be imported wins, this technique imposes a very high cost for any\r\n// future breaking changes to the Slot class.\r\nvar globalKey = \"@wry/context:Slot\";\r\nvar host = Array;\r\nvar Slot = host[globalKey] || function () {\r\n    var Slot = makeSlotClass();\r\n    try {\r\n        Object.defineProperty(host, globalKey, {\r\n            value: host[globalKey] = Slot,\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: false,\r\n        });\r\n    }\r\n    finally {\r\n        return Slot;\r\n    }\r\n}();\n\nvar bind = Slot.bind, noContext = Slot.noContext;\r\nfunction setTimeoutWithContext(callback, delay) {\r\n    return setTimeout(bind(callback), delay);\r\n}\r\n// Turn any generator function into an async function (using yield instead\r\n// of await), with context automatically preserved across yields.\r\nfunction asyncFromGen(genFn) {\r\n    return function () {\r\n        var gen = genFn.apply(this, arguments);\r\n        var boundNext = bind(gen.next);\r\n        var boundThrow = bind(gen.throw);\r\n        return new Promise(function (resolve, reject) {\r\n            function invoke(method, argument) {\r\n                try {\r\n                    var result = method.call(gen, argument);\r\n                }\r\n                catch (error) {\r\n                    return reject(error);\r\n                }\r\n                var next = result.done ? resolve : invokeNext;\r\n                if (isPromiseLike(result.value)) {\r\n                    result.value.then(next, result.done ? reject : invokeThrow);\r\n                }\r\n                else {\r\n                    next(result.value);\r\n                }\r\n            }\r\n            var invokeNext = function (value) { return invoke(boundNext, value); };\r\n            var invokeThrow = function (error) { return invoke(boundThrow, error); };\r\n            invokeNext();\r\n        });\r\n    };\r\n}\r\nfunction isPromiseLike(value) {\r\n    return value && typeof value.then === \"function\";\r\n}\r\n// If you use the fibers npm package to implement coroutines in Node.js,\r\n// you should call this function at least once to ensure context management\r\n// remains coherent across any yields.\r\nvar wrappedFibers = [];\r\nfunction wrapYieldingFiberMethods(Fiber) {\r\n    // There can be only one implementation of Fiber per process, so this array\r\n    // should never grow longer than one element.\r\n    if (wrappedFibers.indexOf(Fiber) < 0) {\r\n        var wrap = function (obj, method) {\r\n            var fn = obj[method];\r\n            obj[method] = function () {\r\n                return noContext(fn, arguments, this);\r\n            };\r\n        };\r\n        // These methods can yield, according to\r\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\r\n        wrap(Fiber, \"yield\");\r\n        wrap(Fiber.prototype, \"run\");\r\n        wrap(Fiber.prototype, \"throwInto\");\r\n        wrappedFibers.push(Fiber);\r\n    }\r\n    return Fiber;\r\n}\n\n\n//# sourceMappingURL=context.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/optimism/lib/bundle.esm.js\n\n\n\nfunction defaultDispose() { }\r\nvar bundle_esm_Cache = /** @class */ (function () {\r\n    function Cache(max, dispose) {\r\n        if (max === void 0) { max = Infinity; }\r\n        if (dispose === void 0) { dispose = defaultDispose; }\r\n        this.max = max;\r\n        this.dispose = dispose;\r\n        this.map = new Map();\r\n        this.newest = null;\r\n        this.oldest = null;\r\n    }\r\n    Cache.prototype.has = function (key) {\r\n        return this.map.has(key);\r\n    };\r\n    Cache.prototype.get = function (key) {\r\n        var entry = this.getEntry(key);\r\n        return entry && entry.value;\r\n    };\r\n    Cache.prototype.getEntry = function (key) {\r\n        var entry = this.map.get(key);\r\n        if (entry && entry !== this.newest) {\r\n            var older = entry.older, newer = entry.newer;\r\n            if (newer) {\r\n                newer.older = older;\r\n            }\r\n            if (older) {\r\n                older.newer = newer;\r\n            }\r\n            entry.older = this.newest;\r\n            entry.older.newer = entry;\r\n            entry.newer = null;\r\n            this.newest = entry;\r\n            if (entry === this.oldest) {\r\n                this.oldest = newer;\r\n            }\r\n        }\r\n        return entry;\r\n    };\r\n    Cache.prototype.set = function (key, value) {\r\n        var entry = this.getEntry(key);\r\n        if (entry) {\r\n            return entry.value = value;\r\n        }\r\n        entry = {\r\n            key: key,\r\n            value: value,\r\n            newer: null,\r\n            older: this.newest\r\n        };\r\n        if (this.newest) {\r\n            this.newest.newer = entry;\r\n        }\r\n        this.newest = entry;\r\n        this.oldest = this.oldest || entry;\r\n        this.map.set(key, entry);\r\n        return entry.value;\r\n    };\r\n    Cache.prototype.clean = function () {\r\n        while (this.oldest && this.map.size > this.max) {\r\n            this.delete(this.oldest.key);\r\n        }\r\n    };\r\n    Cache.prototype.delete = function (key) {\r\n        var entry = this.map.get(key);\r\n        if (entry) {\r\n            if (entry === this.newest) {\r\n                this.newest = entry.older;\r\n            }\r\n            if (entry === this.oldest) {\r\n                this.oldest = entry.newer;\r\n            }\r\n            if (entry.newer) {\r\n                entry.newer.older = entry.older;\r\n            }\r\n            if (entry.older) {\r\n                entry.older.newer = entry.newer;\r\n            }\r\n            this.map.delete(key);\r\n            this.dispose(entry.value, key);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    return Cache;\r\n}());\n\nvar parentEntrySlot = new Slot();\n\nvar reusableEmptyArray = [];\r\nvar emptySetPool = [];\r\nvar POOL_TARGET_SIZE = 100;\r\n// Since this package might be used browsers, we should avoid using the\r\n// Node built-in assert module.\r\nfunction assert(condition, optionalMessage) {\r\n    if (!condition) {\r\n        throw new Error(optionalMessage || \"assertion failure\");\r\n    }\r\n}\r\nfunction valueIs(a, b) {\r\n    var len = a.length;\r\n    return (\r\n    // Unknown values are not equal to each other.\r\n    len > 0 &&\r\n        // Both values must be ordinary (or both exceptional) to be equal.\r\n        len === b.length &&\r\n        // The underlying value or exception must be the same.\r\n        a[len - 1] === b[len - 1]);\r\n}\r\nfunction valueGet(value) {\r\n    switch (value.length) {\r\n        case 0: throw new Error(\"unknown value\");\r\n        case 1: return value[0];\r\n        case 2: throw value[1];\r\n    }\r\n}\r\nfunction valueCopy(value) {\r\n    return value.slice(0);\r\n}\r\nvar Entry = /** @class */ (function () {\r\n    function Entry(fn, args) {\r\n        this.fn = fn;\r\n        this.args = args;\r\n        this.parents = new Set();\r\n        this.childValues = new Map();\r\n        // When this Entry has children that are dirty, this property becomes\r\n        // a Set containing other Entry objects, borrowed from emptySetPool.\r\n        // When the set becomes empty, it gets recycled back to emptySetPool.\r\n        this.dirtyChildren = null;\r\n        this.dirty = true;\r\n        this.recomputing = false;\r\n        this.value = [];\r\n        ++Entry.count;\r\n    }\r\n    // This is the most important method of the Entry API, because it\r\n    // determines whether the cached this.value can be returned immediately,\r\n    // or must be recomputed. The overall performance of the caching system\r\n    // depends on the truth of the following observations: (1) this.dirty is\r\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\r\n    // (3) valueGet(this.value) is usually returned without recomputation.\r\n    Entry.prototype.recompute = function () {\r\n        assert(!this.recomputing, \"already recomputing\");\r\n        if (!rememberParent(this) && maybeReportOrphan(this)) {\r\n            // The recipient of the entry.reportOrphan callback decided to dispose\r\n            // of this orphan entry by calling entry.dispose(), so we don't need to\r\n            // (and should not) proceed with the recomputation.\r\n            return void 0;\r\n        }\r\n        return mightBeDirty(this)\r\n            ? reallyRecompute(this)\r\n            : valueGet(this.value);\r\n    };\r\n    Entry.prototype.setDirty = function () {\r\n        if (this.dirty)\r\n            return;\r\n        this.dirty = true;\r\n        this.value.length = 0;\r\n        reportDirty(this);\r\n        // We can go ahead and unsubscribe here, since any further dirty\r\n        // notifications we receive will be redundant, and unsubscribing may\r\n        // free up some resources, e.g. file watchers.\r\n        maybeUnsubscribe(this);\r\n    };\r\n    Entry.prototype.dispose = function () {\r\n        var _this = this;\r\n        forgetChildren(this).forEach(maybeReportOrphan);\r\n        maybeUnsubscribe(this);\r\n        // Because this entry has been kicked out of the cache (in index.js),\r\n        // we've lost the ability to find out if/when this entry becomes dirty,\r\n        // whether that happens through a subscription, because of a direct call\r\n        // to entry.setDirty(), or because one of its children becomes dirty.\r\n        // Because of this loss of future information, we have to assume the\r\n        // worst (that this entry might have become dirty very soon), so we must\r\n        // immediately mark this entry's parents as dirty. Normally we could\r\n        // just call entry.setDirty() rather than calling parent.setDirty() for\r\n        // each parent, but that would leave this entry in parent.childValues\r\n        // and parent.dirtyChildren, which would prevent the child from being\r\n        // truly forgotten.\r\n        this.parents.forEach(function (parent) {\r\n            parent.setDirty();\r\n            forgetChild(parent, _this);\r\n        });\r\n    };\r\n    Entry.count = 0;\r\n    return Entry;\r\n}());\r\nfunction rememberParent(child) {\r\n    var parent = parentEntrySlot.getValue();\r\n    if (parent) {\r\n        child.parents.add(parent);\r\n        if (!parent.childValues.has(child)) {\r\n            parent.childValues.set(child, []);\r\n        }\r\n        if (mightBeDirty(child)) {\r\n            reportDirtyChild(parent, child);\r\n        }\r\n        else {\r\n            reportCleanChild(parent, child);\r\n        }\r\n        return parent;\r\n    }\r\n}\r\nfunction reallyRecompute(entry) {\r\n    // Since this recomputation is likely to re-remember some of this\r\n    // entry's children, we forget our children here but do not call\r\n    // maybeReportOrphan until after the recomputation finishes.\r\n    var originalChildren = forgetChildren(entry);\r\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\r\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);\r\n    if (maybeSubscribe(entry)) {\r\n        // If we successfully recomputed entry.value and did not fail to\r\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\r\n        setClean(entry);\r\n    }\r\n    // Now that we've had a chance to re-remember any children that were\r\n    // involved in the recomputation, we can safely report any orphan\r\n    // children that remain.\r\n    originalChildren.forEach(maybeReportOrphan);\r\n    return valueGet(entry.value);\r\n}\r\nfunction recomputeNewValue(entry) {\r\n    entry.recomputing = true;\r\n    // Set entry.value as unknown.\r\n    entry.value.length = 0;\r\n    try {\r\n        // If entry.fn succeeds, entry.value will become a normal Value.\r\n        entry.value[0] = entry.fn.apply(null, entry.args);\r\n    }\r\n    catch (e) {\r\n        // If entry.fn throws, entry.value will become exceptional.\r\n        entry.value[1] = e;\r\n    }\r\n    // Either way, this line is always reached.\r\n    entry.recomputing = false;\r\n}\r\nfunction mightBeDirty(entry) {\r\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\r\n}\r\nfunction setClean(entry) {\r\n    entry.dirty = false;\r\n    if (mightBeDirty(entry)) {\r\n        // This Entry may still have dirty children, in which case we can't\r\n        // let our parents know we're clean just yet.\r\n        return;\r\n    }\r\n    reportClean(entry);\r\n}\r\nfunction reportDirty(child) {\r\n    child.parents.forEach(function (parent) { return reportDirtyChild(parent, child); });\r\n}\r\nfunction reportClean(child) {\r\n    child.parents.forEach(function (parent) { return reportCleanChild(parent, child); });\r\n}\r\n// Let a parent Entry know that one of its children may be dirty.\r\nfunction reportDirtyChild(parent, child) {\r\n    // Must have called rememberParent(child) before calling\r\n    // reportDirtyChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(mightBeDirty(child));\r\n    if (!parent.dirtyChildren) {\r\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\r\n    }\r\n    else if (parent.dirtyChildren.has(child)) {\r\n        // If we already know this child is dirty, then we must have already\r\n        // informed our own parents that we are dirty, so we can terminate\r\n        // the recursion early.\r\n        return;\r\n    }\r\n    parent.dirtyChildren.add(child);\r\n    reportDirty(parent);\r\n}\r\n// Let a parent Entry know that one of its children is no longer dirty.\r\nfunction reportCleanChild(parent, child) {\r\n    // Must have called rememberChild(child) before calling\r\n    // reportCleanChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(!mightBeDirty(child));\r\n    var childValue = parent.childValues.get(child);\r\n    if (childValue.length === 0) {\r\n        parent.childValues.set(child, valueCopy(child.value));\r\n    }\r\n    else if (!valueIs(childValue, child.value)) {\r\n        parent.setDirty();\r\n    }\r\n    removeDirtyChild(parent, child);\r\n    if (mightBeDirty(parent)) {\r\n        return;\r\n    }\r\n    reportClean(parent);\r\n}\r\nfunction removeDirtyChild(parent, child) {\r\n    var dc = parent.dirtyChildren;\r\n    if (dc) {\r\n        dc.delete(child);\r\n        if (dc.size === 0) {\r\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\r\n                emptySetPool.push(dc);\r\n            }\r\n            parent.dirtyChildren = null;\r\n        }\r\n    }\r\n}\r\n// If the given entry has a reportOrphan method, and no remaining parents,\r\n// call entry.reportOrphan and return true iff it returns true. The\r\n// reportOrphan function should return true to indicate entry.dispose()\r\n// has been called, and the entry has been removed from any other caches\r\n// (see index.js for the only current example).\r\nfunction maybeReportOrphan(entry) {\r\n    return entry.parents.size === 0 &&\r\n        typeof entry.reportOrphan === \"function\" &&\r\n        entry.reportOrphan() === true;\r\n}\r\n// Removes all children from this entry and returns an array of the\r\n// removed children.\r\nfunction forgetChildren(parent) {\r\n    var children = reusableEmptyArray;\r\n    if (parent.childValues.size > 0) {\r\n        children = [];\r\n        parent.childValues.forEach(function (_value, child) {\r\n            forgetChild(parent, child);\r\n            children.push(child);\r\n        });\r\n    }\r\n    // After we forget all our children, this.dirtyChildren must be empty\r\n    // and therefore must have been reset to null.\r\n    assert(parent.dirtyChildren === null);\r\n    return children;\r\n}\r\nfunction forgetChild(parent, child) {\r\n    child.parents.delete(parent);\r\n    parent.childValues.delete(child);\r\n    removeDirtyChild(parent, child);\r\n}\r\nfunction maybeSubscribe(entry) {\r\n    if (typeof entry.subscribe === \"function\") {\r\n        try {\r\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\r\n            entry.unsubscribe = entry.subscribe.apply(null, entry.args);\r\n        }\r\n        catch (e) {\r\n            // If this Entry has a subscribe function and it threw an exception\r\n            // (or an unsubscribe function it previously returned now throws),\r\n            // return false to indicate that we were not able to subscribe (or\r\n            // unsubscribe), and this Entry should remain dirty.\r\n            entry.setDirty();\r\n            return false;\r\n        }\r\n    }\r\n    // Returning true indicates either that there was no entry.subscribe\r\n    // function or that it succeeded.\r\n    return true;\r\n}\r\nfunction maybeUnsubscribe(entry) {\r\n    var unsubscribe = entry.unsubscribe;\r\n    if (typeof unsubscribe === \"function\") {\r\n        entry.unsubscribe = void 0;\r\n        unsubscribe();\r\n    }\r\n}\n\n// A trie data structure that holds object keys weakly, yet can also hold\r\n// non-object keys, unlike the native `WeakMap`.\r\nvar KeyTrie = /** @class */ (function () {\r\n    function KeyTrie(weakness) {\r\n        this.weakness = weakness;\r\n    }\r\n    KeyTrie.prototype.lookup = function () {\r\n        var array = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            array[_i] = arguments[_i];\r\n        }\r\n        return this.lookupArray(array);\r\n    };\r\n    KeyTrie.prototype.lookupArray = function (array) {\r\n        var node = this;\r\n        array.forEach(function (key) { return node = node.getChildTrie(key); });\r\n        return node.data || (node.data = Object.create(null));\r\n    };\r\n    KeyTrie.prototype.getChildTrie = function (key) {\r\n        var map = this.weakness && isObjRef(key)\r\n            ? this.weak || (this.weak = new WeakMap())\r\n            : this.strong || (this.strong = new Map());\r\n        var child = map.get(key);\r\n        if (!child)\r\n            map.set(key, child = new KeyTrie(this.weakness));\r\n        return child;\r\n    };\r\n    return KeyTrie;\r\n}());\r\nfunction isObjRef(value) {\r\n    switch (typeof value) {\r\n        case \"object\":\r\n            if (value === null)\r\n                break;\r\n        // Fall through to return true...\r\n        case \"function\":\r\n            return true;\r\n    }\r\n    return false;\r\n}\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\r\n// a unique object for any shallow-identical list of arguments. If you need\r\n// to implement a custom makeCacheKey function, you may find it helpful to\r\n// delegate the final work to defaultMakeCacheKey, which is why we export it\r\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\r\n// does not support WeakMap, or you have the ability to return a string key.\r\n// In those cases, just write your own custom makeCacheKey functions.\r\nvar keyTrie = new KeyTrie(typeof WeakMap === \"function\");\r\nfunction defaultMakeCacheKey() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    return keyTrie.lookupArray(args);\r\n}\r\nvar caches = new Set();\r\nfunction bundle_esm_wrap(originalFunction, options) {\r\n    if (options === void 0) { options = Object.create(null); }\r\n    var cache = new bundle_esm_Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });\r\n    var disposable = !!options.disposable;\r\n    var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;\r\n    function optimistic() {\r\n        if (disposable && !parentEntrySlot.hasValue()) {\r\n            // If there's no current parent computation, and this wrapped\r\n            // function is disposable (meaning we don't care about entry.value,\r\n            // just dependency tracking), then we can short-cut everything else\r\n            // in this function, because entry.recompute() is going to recycle\r\n            // the entry object without recomputing anything, anyway.\r\n            return void 0;\r\n        }\r\n        var key = makeCacheKey.apply(null, arguments);\r\n        if (key === void 0) {\r\n            return originalFunction.apply(null, arguments);\r\n        }\r\n        var args = Array.prototype.slice.call(arguments);\r\n        var entry = cache.get(key);\r\n        if (entry) {\r\n            entry.args = args;\r\n        }\r\n        else {\r\n            entry = new Entry(originalFunction, args);\r\n            cache.set(key, entry);\r\n            entry.subscribe = options.subscribe;\r\n            if (disposable) {\r\n                entry.reportOrphan = function () { return cache.delete(key); };\r\n            }\r\n        }\r\n        var value = entry.recompute();\r\n        // Move this entry to the front of the least-recently used queue,\r\n        // since we just finished computing its value.\r\n        cache.set(key, entry);\r\n        caches.add(cache);\r\n        // Clean up any excess entries in the cache, but only if there is no\r\n        // active parent entry, meaning we're not in the middle of a larger\r\n        // computation that might be flummoxed by the cleaning.\r\n        if (!parentEntrySlot.hasValue()) {\r\n            caches.forEach(function (cache) { return cache.clean(); });\r\n            caches.clear();\r\n        }\r\n        // If options.disposable is truthy, the caller of wrap is telling us\r\n        // they don't care about the result of entry.recompute(), so we should\r\n        // avoid returning the value, so it won't be accidentally used.\r\n        return disposable ? void 0 : value;\r\n    }\r\n    optimistic.dirty = function () {\r\n        var key = makeCacheKey.apply(null, arguments);\r\n        var child = key !== void 0 && cache.get(key);\r\n        if (child) {\r\n            child.setDirty();\r\n        }\r\n    };\r\n    return optimistic;\r\n}\n\n\n//# sourceMappingURL=bundle.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/apollo-cache-inmemory/lib/bundle.esm.js\n\n\n\n\n\n\nvar haveWarned = false;\nfunction shouldWarn() {\n    var answer = !haveWarned;\n    if (!Object(bundle_esm[\"y\" /* isTest */])()) {\n        haveWarned = true;\n    }\n    return answer;\n}\nvar HeuristicFragmentMatcher = (function () {\n    function HeuristicFragmentMatcher() {\n    }\n    HeuristicFragmentMatcher.prototype.ensureReady = function () {\n        return Promise.resolve();\n    };\n    HeuristicFragmentMatcher.prototype.canBypassInit = function () {\n        return true;\n    };\n    HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n        var obj = context.store.get(idValue.id);\n        var isRootQuery = idValue.id === 'ROOT_QUERY';\n        if (!obj) {\n            return isRootQuery;\n        }\n        var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && 'Query' : _a;\n        if (!__typename) {\n            if (shouldWarn()) {\n                 true || false;\n                 true || false;\n                 true || false;\n            }\n            return 'heuristic';\n        }\n        if (__typename === typeCondition) {\n            return true;\n        }\n        if (shouldWarn()) {\n             true || false;\n        }\n        return 'heuristic';\n    };\n    return HeuristicFragmentMatcher;\n}());\nvar bundle_esm_IntrospectionFragmentMatcher = (function () {\n    function IntrospectionFragmentMatcher(options) {\n        if (options && options.introspectionQueryResultData) {\n            this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);\n            this.isReady = true;\n        }\n        else {\n            this.isReady = false;\n        }\n        this.match = this.match.bind(this);\n    }\n    IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n         true ? Object(invariant_esm[\"b\" /* invariant */])(this.isReady, 1) : undefined;\n        var obj = context.store.get(idValue.id);\n        var isRootQuery = idValue.id === 'ROOT_QUERY';\n        if (!obj) {\n            return isRootQuery;\n        }\n        var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && 'Query' : _a;\n         true ? Object(invariant_esm[\"b\" /* invariant */])(__typename, 2) : undefined;\n        if (__typename === typeCondition) {\n            return true;\n        }\n        var implementingTypes = this.possibleTypesMap[typeCondition];\n        if (__typename &&\n            implementingTypes &&\n            implementingTypes.indexOf(__typename) > -1) {\n            return true;\n        }\n        return false;\n    };\n    IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {\n        var typeMap = {};\n        introspectionResultData.__schema.types.forEach(function (type) {\n            if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n                typeMap[type.name] = type.possibleTypes.map(function (implementingType) { return implementingType.name; });\n            }\n        });\n        return typeMap;\n    };\n    return IntrospectionFragmentMatcher;\n}());\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar bundle_esm_DepTrackingCache = (function () {\n    function DepTrackingCache(data) {\n        var _this = this;\n        if (data === void 0) { data = Object.create(null); }\n        this.data = data;\n        this.depend = bundle_esm_wrap(function (dataId) { return _this.data[dataId]; }, {\n            disposable: true,\n            makeCacheKey: function (dataId) {\n                return dataId;\n            },\n        });\n    }\n    DepTrackingCache.prototype.toObject = function () {\n        return this.data;\n    };\n    DepTrackingCache.prototype.get = function (dataId) {\n        this.depend(dataId);\n        return this.data[dataId];\n    };\n    DepTrackingCache.prototype.set = function (dataId, value) {\n        var oldValue = this.data[dataId];\n        if (value !== oldValue) {\n            this.data[dataId] = value;\n            this.depend.dirty(dataId);\n        }\n    };\n    DepTrackingCache.prototype.delete = function (dataId) {\n        if (hasOwn.call(this.data, dataId)) {\n            delete this.data[dataId];\n            this.depend.dirty(dataId);\n        }\n    };\n    DepTrackingCache.prototype.clear = function () {\n        this.replace(null);\n    };\n    DepTrackingCache.prototype.replace = function (newData) {\n        var _this = this;\n        if (newData) {\n            Object.keys(newData).forEach(function (dataId) {\n                _this.set(dataId, newData[dataId]);\n            });\n            Object.keys(this.data).forEach(function (dataId) {\n                if (!hasOwn.call(newData, dataId)) {\n                    _this.delete(dataId);\n                }\n            });\n        }\n        else {\n            Object.keys(this.data).forEach(function (dataId) {\n                _this.delete(dataId);\n            });\n        }\n    };\n    return DepTrackingCache;\n}());\nfunction defaultNormalizedCacheFactory(seed) {\n    return new bundle_esm_DepTrackingCache(seed);\n}\n\nvar bundle_esm_StoreReader = (function () {\n    function StoreReader(_a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.cacheKeyRoot, cacheKeyRoot = _c === void 0 ? new KeyTrie(bundle_esm[\"e\" /* canUseWeakMap */]) : _c, _d = _b.freezeResults, freezeResults = _d === void 0 ? false : _d;\n        var _e = this, executeStoreQuery = _e.executeStoreQuery, executeSelectionSet = _e.executeSelectionSet, executeSubSelectedArray = _e.executeSubSelectedArray;\n        this.freezeResults = freezeResults;\n        this.executeStoreQuery = bundle_esm_wrap(function (options) {\n            return executeStoreQuery.call(_this, options);\n        }, {\n            makeCacheKey: function (_a) {\n                var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, fragmentMatcher = _a.fragmentMatcher;\n                if (contextValue.store instanceof bundle_esm_DepTrackingCache) {\n                    return cacheKeyRoot.lookup(contextValue.store, query, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);\n                }\n            }\n        });\n        this.executeSelectionSet = bundle_esm_wrap(function (options) {\n            return executeSelectionSet.call(_this, options);\n        }, {\n            makeCacheKey: function (_a) {\n                var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;\n                if (execContext.contextValue.store instanceof bundle_esm_DepTrackingCache) {\n                    return cacheKeyRoot.lookup(execContext.contextValue.store, selectionSet, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);\n                }\n            }\n        });\n        this.executeSubSelectedArray = bundle_esm_wrap(function (options) {\n            return executeSubSelectedArray.call(_this, options);\n        }, {\n            makeCacheKey: function (_a) {\n                var field = _a.field, array = _a.array, execContext = _a.execContext;\n                if (execContext.contextValue.store instanceof bundle_esm_DepTrackingCache) {\n                    return cacheKeyRoot.lookup(execContext.contextValue.store, field, array, JSON.stringify(execContext.variableValues));\n                }\n            }\n        });\n    }\n    StoreReader.prototype.readQueryFromStore = function (options) {\n        return this.diffQueryAgainstStore(Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, options), { returnPartialData: false })).result;\n    };\n    StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n        var store = _a.store, query = _a.query, variables = _a.variables, previousResult = _a.previousResult, _b = _a.returnPartialData, returnPartialData = _b === void 0 ? true : _b, _c = _a.rootId, rootId = _c === void 0 ? 'ROOT_QUERY' : _c, fragmentMatcherFunction = _a.fragmentMatcherFunction, config = _a.config;\n        var queryDefinition = Object(bundle_esm[\"o\" /* getQueryDefinition */])(query);\n        variables = Object(bundle_esm[\"c\" /* assign */])({}, Object(bundle_esm[\"h\" /* getDefaultValues */])(queryDefinition), variables);\n        var context = {\n            store: store,\n            dataIdFromObject: config && config.dataIdFromObject,\n            cacheRedirects: (config && config.cacheRedirects) || {},\n        };\n        var execResult = this.executeStoreQuery({\n            query: query,\n            rootValue: {\n                type: 'id',\n                id: rootId,\n                generated: true,\n                typename: 'Query',\n            },\n            contextValue: context,\n            variableValues: variables,\n            fragmentMatcher: fragmentMatcherFunction,\n        });\n        var hasMissingFields = execResult.missing && execResult.missing.length > 0;\n        if (hasMissingFields && !returnPartialData) {\n            execResult.missing.forEach(function (info) {\n                if (info.tolerable)\n                    return;\n                throw  true ? new invariant_esm[\"a\" /* InvariantError */](8) : undefined;\n            });\n        }\n        if (previousResult) {\n            if (Object(equality_esm[\"a\" /* equal */])(previousResult, execResult.result)) {\n                execResult.result = previousResult;\n            }\n        }\n        return {\n            result: execResult.result,\n            complete: !hasMissingFields,\n        };\n    };\n    StoreReader.prototype.executeStoreQuery = function (_a) {\n        var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, _b = _a.fragmentMatcher, fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;\n        var mainDefinition = Object(bundle_esm[\"l\" /* getMainDefinition */])(query);\n        var fragments = Object(bundle_esm[\"j\" /* getFragmentDefinitions */])(query);\n        var fragmentMap = Object(bundle_esm[\"g\" /* createFragmentMap */])(fragments);\n        var execContext = {\n            query: query,\n            fragmentMap: fragmentMap,\n            contextValue: contextValue,\n            variableValues: variableValues,\n            fragmentMatcher: fragmentMatcher,\n        };\n        return this.executeSelectionSet({\n            selectionSet: mainDefinition.selectionSet,\n            rootValue: rootValue,\n            execContext: execContext,\n        });\n    };\n    StoreReader.prototype.executeSelectionSet = function (_a) {\n        var _this = this;\n        var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;\n        var fragmentMap = execContext.fragmentMap, contextValue = execContext.contextValue, variables = execContext.variableValues;\n        var finalResult = { result: null };\n        var objectsToMerge = [];\n        var object = contextValue.store.get(rootValue.id);\n        var typename = (object && object.__typename) ||\n            (rootValue.id === 'ROOT_QUERY' && 'Query') ||\n            void 0;\n        function handleMissing(result) {\n            var _a;\n            if (result.missing) {\n                finalResult.missing = finalResult.missing || [];\n                (_a = finalResult.missing).push.apply(_a, result.missing);\n            }\n            return result.result;\n        }\n        selectionSet.selections.forEach(function (selection) {\n            var _a;\n            if (!Object(bundle_esm[\"F\" /* shouldInclude */])(selection, variables)) {\n                return;\n            }\n            if (Object(bundle_esm[\"t\" /* isField */])(selection)) {\n                var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));\n                if (typeof fieldResult !== 'undefined') {\n                    objectsToMerge.push((_a = {},\n                        _a[Object(bundle_esm[\"E\" /* resultKeyNameFromField */])(selection)] = fieldResult,\n                        _a));\n                }\n            }\n            else {\n                var fragment = void 0;\n                if (Object(bundle_esm[\"v\" /* isInlineFragment */])(selection)) {\n                    fragment = selection;\n                }\n                else {\n                    fragment = fragmentMap[selection.name.value];\n                    if (!fragment) {\n                        throw  true ? new invariant_esm[\"a\" /* InvariantError */](9) : undefined;\n                    }\n                }\n                var typeCondition = fragment.typeCondition && fragment.typeCondition.name.value;\n                var match = !typeCondition ||\n                    execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n                if (match) {\n                    var fragmentExecResult = _this.executeSelectionSet({\n                        selectionSet: fragment.selectionSet,\n                        rootValue: rootValue,\n                        execContext: execContext,\n                    });\n                    if (match === 'heuristic' && fragmentExecResult.missing) {\n                        fragmentExecResult = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, fragmentExecResult), { missing: fragmentExecResult.missing.map(function (info) {\n                                return Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, info), { tolerable: true });\n                            }) });\n                    }\n                    objectsToMerge.push(handleMissing(fragmentExecResult));\n                }\n            }\n        });\n        finalResult.result = Object(bundle_esm[\"B\" /* mergeDeepArray */])(objectsToMerge);\n        if (this.freezeResults && \"production\" !== 'production') {\n            Object.freeze(finalResult.result);\n        }\n        return finalResult;\n    };\n    StoreReader.prototype.executeField = function (object, typename, field, execContext) {\n        var variables = execContext.variableValues, contextValue = execContext.contextValue;\n        var fieldName = field.name.value;\n        var args = Object(bundle_esm[\"b\" /* argumentsObjectFromField */])(field, variables);\n        var info = {\n            resultKey: Object(bundle_esm[\"E\" /* resultKeyNameFromField */])(field),\n            directives: Object(bundle_esm[\"i\" /* getDirectiveInfoFromField */])(field, variables),\n        };\n        var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);\n        if (Array.isArray(readStoreResult.result)) {\n            return this.combineExecResults(readStoreResult, this.executeSubSelectedArray({\n                field: field,\n                array: readStoreResult.result,\n                execContext: execContext,\n            }));\n        }\n        if (!field.selectionSet) {\n            assertSelectionSetForIdValue(field, readStoreResult.result);\n            if (this.freezeResults && \"production\" !== 'production') {\n                Object(bundle_esm[\"z\" /* maybeDeepFreeze */])(readStoreResult);\n            }\n            return readStoreResult;\n        }\n        if (readStoreResult.result == null) {\n            return readStoreResult;\n        }\n        return this.combineExecResults(readStoreResult, this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            rootValue: readStoreResult.result,\n            execContext: execContext,\n        }));\n    };\n    StoreReader.prototype.combineExecResults = function () {\n        var execResults = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            execResults[_i] = arguments[_i];\n        }\n        var missing;\n        execResults.forEach(function (execResult) {\n            if (execResult.missing) {\n                missing = missing || [];\n                missing.push.apply(missing, execResult.missing);\n            }\n        });\n        return {\n            result: execResults.pop().result,\n            missing: missing,\n        };\n    };\n    StoreReader.prototype.executeSubSelectedArray = function (_a) {\n        var _this = this;\n        var field = _a.field, array = _a.array, execContext = _a.execContext;\n        var missing;\n        function handleMissing(childResult) {\n            if (childResult.missing) {\n                missing = missing || [];\n                missing.push.apply(missing, childResult.missing);\n            }\n            return childResult.result;\n        }\n        array = array.map(function (item) {\n            if (item === null) {\n                return null;\n            }\n            if (Array.isArray(item)) {\n                return handleMissing(_this.executeSubSelectedArray({\n                    field: field,\n                    array: item,\n                    execContext: execContext,\n                }));\n            }\n            if (field.selectionSet) {\n                return handleMissing(_this.executeSelectionSet({\n                    selectionSet: field.selectionSet,\n                    rootValue: item,\n                    execContext: execContext,\n                }));\n            }\n            assertSelectionSetForIdValue(field, item);\n            return item;\n        });\n        if (this.freezeResults && \"production\" !== 'production') {\n            Object.freeze(array);\n        }\n        return { result: array, missing: missing };\n    };\n    return StoreReader;\n}());\nfunction assertSelectionSetForIdValue(field, value) {\n    if (!field.selectionSet && Object(bundle_esm[\"u\" /* isIdValue */])(value)) {\n        throw  true ? new invariant_esm[\"a\" /* InvariantError */](10) : undefined;\n    }\n}\nfunction defaultFragmentMatcher() {\n    return true;\n}\nfunction assertIdValue(idValue) {\n     true ? Object(invariant_esm[\"b\" /* invariant */])(Object(bundle_esm[\"u\" /* isIdValue */])(idValue), 11) : undefined;\n}\nfunction readStoreResolver(object, typename, fieldName, args, context, _a) {\n    var resultKey = _a.resultKey, directives = _a.directives;\n    var storeKeyName = fieldName;\n    if (args || directives) {\n        storeKeyName = Object(bundle_esm[\"p\" /* getStoreKeyName */])(storeKeyName, args, directives);\n    }\n    var fieldValue = void 0;\n    if (object) {\n        fieldValue = object[storeKeyName];\n        if (typeof fieldValue === 'undefined' &&\n            context.cacheRedirects &&\n            typeof typename === 'string') {\n            var type = context.cacheRedirects[typename];\n            if (type) {\n                var resolver = type[fieldName];\n                if (resolver) {\n                    fieldValue = resolver(object, args, {\n                        getCacheKey: function (storeObj) {\n                            var id = context.dataIdFromObject(storeObj);\n                            return id && Object(bundle_esm[\"H\" /* toIdValue */])({\n                                id: id,\n                                typename: storeObj.__typename,\n                            });\n                        },\n                    });\n                }\n            }\n        }\n    }\n    if (typeof fieldValue === 'undefined') {\n        return {\n            result: fieldValue,\n            missing: [{\n                    object: object,\n                    fieldName: storeKeyName,\n                    tolerable: false,\n                }],\n        };\n    }\n    if (Object(bundle_esm[\"w\" /* isJsonValue */])(fieldValue)) {\n        fieldValue = fieldValue.json;\n    }\n    return {\n        result: fieldValue,\n    };\n}\n\nvar ObjectCache = (function () {\n    function ObjectCache(data) {\n        if (data === void 0) { data = Object.create(null); }\n        this.data = data;\n    }\n    ObjectCache.prototype.toObject = function () {\n        return this.data;\n    };\n    ObjectCache.prototype.get = function (dataId) {\n        return this.data[dataId];\n    };\n    ObjectCache.prototype.set = function (dataId, value) {\n        this.data[dataId] = value;\n    };\n    ObjectCache.prototype.delete = function (dataId) {\n        this.data[dataId] = void 0;\n    };\n    ObjectCache.prototype.clear = function () {\n        this.data = Object.create(null);\n    };\n    ObjectCache.prototype.replace = function (newData) {\n        this.data = newData || Object.create(null);\n    };\n    return ObjectCache;\n}());\nfunction defaultNormalizedCacheFactory$1(seed) {\n    return new ObjectCache(seed);\n}\n\nvar bundle_esm_WriteError = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(WriteError, _super);\n    function WriteError() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'WriteError';\n        return _this;\n    }\n    return WriteError;\n}(Error));\nfunction enhanceErrorWithDocument(error, document) {\n    var enhancedError = new bundle_esm_WriteError(\"Error writing result to store for query:\\n \" + JSON.stringify(document));\n    enhancedError.message += '\\n' + error.message;\n    enhancedError.stack = error.stack;\n    return enhancedError;\n}\nvar bundle_esm_StoreWriter = (function () {\n    function StoreWriter() {\n    }\n    StoreWriter.prototype.writeQueryToStore = function (_a) {\n        var query = _a.query, result = _a.result, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;\n        return this.writeResultToStore({\n            dataId: 'ROOT_QUERY',\n            result: result,\n            document: query,\n            store: store,\n            variables: variables,\n            dataIdFromObject: dataIdFromObject,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n        });\n    };\n    StoreWriter.prototype.writeResultToStore = function (_a) {\n        var dataId = _a.dataId, result = _a.result, document = _a.document, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;\n        var operationDefinition = Object(bundle_esm[\"m\" /* getOperationDefinition */])(document);\n        try {\n            return this.writeSelectionSetToStore({\n                result: result,\n                dataId: dataId,\n                selectionSet: operationDefinition.selectionSet,\n                context: {\n                    store: store,\n                    processedData: {},\n                    variables: Object(bundle_esm[\"c\" /* assign */])({}, Object(bundle_esm[\"h\" /* getDefaultValues */])(operationDefinition), variables),\n                    dataIdFromObject: dataIdFromObject,\n                    fragmentMap: Object(bundle_esm[\"g\" /* createFragmentMap */])(Object(bundle_esm[\"j\" /* getFragmentDefinitions */])(document)),\n                    fragmentMatcherFunction: fragmentMatcherFunction,\n                },\n            });\n        }\n        catch (e) {\n            throw enhanceErrorWithDocument(e, document);\n        }\n    };\n    StoreWriter.prototype.writeSelectionSetToStore = function (_a) {\n        var _this = this;\n        var result = _a.result, dataId = _a.dataId, selectionSet = _a.selectionSet, context = _a.context;\n        var variables = context.variables, store = context.store, fragmentMap = context.fragmentMap;\n        selectionSet.selections.forEach(function (selection) {\n            var _a;\n            if (!Object(bundle_esm[\"F\" /* shouldInclude */])(selection, variables)) {\n                return;\n            }\n            if (Object(bundle_esm[\"t\" /* isField */])(selection)) {\n                var resultFieldKey = Object(bundle_esm[\"E\" /* resultKeyNameFromField */])(selection);\n                var value = result[resultFieldKey];\n                if (typeof value !== 'undefined') {\n                    _this.writeFieldToStore({\n                        dataId: dataId,\n                        value: value,\n                        field: selection,\n                        context: context,\n                    });\n                }\n                else {\n                    var isDefered = false;\n                    var isClient = false;\n                    if (selection.directives && selection.directives.length) {\n                        isDefered = selection.directives.some(function (directive) { return directive.name && directive.name.value === 'defer'; });\n                        isClient = selection.directives.some(function (directive) { return directive.name && directive.name.value === 'client'; });\n                    }\n                    if (!isDefered && !isClient && context.fragmentMatcherFunction) {\n                         true || false;\n                    }\n                }\n            }\n            else {\n                var fragment = void 0;\n                if (Object(bundle_esm[\"v\" /* isInlineFragment */])(selection)) {\n                    fragment = selection;\n                }\n                else {\n                    fragment = (fragmentMap || {})[selection.name.value];\n                     true ? Object(invariant_esm[\"b\" /* invariant */])(fragment, 3) : undefined;\n                }\n                var matches = true;\n                if (context.fragmentMatcherFunction && fragment.typeCondition) {\n                    var id = dataId || 'self';\n                    var idValue = Object(bundle_esm[\"H\" /* toIdValue */])({ id: id, typename: undefined });\n                    var fakeContext = {\n                        store: new ObjectCache((_a = {}, _a[id] = result, _a)),\n                        cacheRedirects: {},\n                    };\n                    var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);\n                    if (!Object(bundle_esm[\"x\" /* isProduction */])() && match === 'heuristic') {\n                         true || false;\n                    }\n                    matches = !!match;\n                }\n                if (matches) {\n                    _this.writeSelectionSetToStore({\n                        result: result,\n                        selectionSet: fragment.selectionSet,\n                        dataId: dataId,\n                        context: context,\n                    });\n                }\n            }\n        });\n        return store;\n    };\n    StoreWriter.prototype.writeFieldToStore = function (_a) {\n        var _b;\n        var field = _a.field, value = _a.value, dataId = _a.dataId, context = _a.context;\n        var variables = context.variables, dataIdFromObject = context.dataIdFromObject, store = context.store;\n        var storeValue;\n        var storeObject;\n        var storeFieldName = Object(bundle_esm[\"G\" /* storeKeyNameFromField */])(field, variables);\n        if (!field.selectionSet || value === null) {\n            storeValue =\n                value != null && typeof value === 'object'\n                    ?\n                        { type: 'json', json: value }\n                    :\n                        value;\n        }\n        else if (Array.isArray(value)) {\n            var generatedId = dataId + \".\" + storeFieldName;\n            storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);\n        }\n        else {\n            var valueDataId = dataId + \".\" + storeFieldName;\n            var generated = true;\n            if (!isGeneratedId(valueDataId)) {\n                valueDataId = '$' + valueDataId;\n            }\n            if (dataIdFromObject) {\n                var semanticId = dataIdFromObject(value);\n                 true ? Object(invariant_esm[\"b\" /* invariant */])(!semanticId || !isGeneratedId(semanticId), 4) : undefined;\n                if (semanticId ||\n                    (typeof semanticId === 'number' && semanticId === 0)) {\n                    valueDataId = semanticId;\n                    generated = false;\n                }\n            }\n            if (!isDataProcessed(valueDataId, field, context.processedData)) {\n                this.writeSelectionSetToStore({\n                    dataId: valueDataId,\n                    result: value,\n                    selectionSet: field.selectionSet,\n                    context: context,\n                });\n            }\n            var typename = value.__typename;\n            storeValue = Object(bundle_esm[\"H\" /* toIdValue */])({ id: valueDataId, typename: typename }, generated);\n            storeObject = store.get(dataId);\n            var escapedId = storeObject && storeObject[storeFieldName];\n            if (escapedId !== storeValue && Object(bundle_esm[\"u\" /* isIdValue */])(escapedId)) {\n                var hadTypename = escapedId.typename !== undefined;\n                var hasTypename = typename !== undefined;\n                var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;\n                 true ? Object(invariant_esm[\"b\" /* invariant */])(!generated || escapedId.generated || typenameChanged, 5) : undefined;\n                 true ? Object(invariant_esm[\"b\" /* invariant */])(!hadTypename || hasTypename, 6) : undefined;\n                if (escapedId.generated) {\n                    if (typenameChanged) {\n                        if (!generated) {\n                            store.delete(escapedId.id);\n                        }\n                    }\n                    else {\n                        mergeWithGenerated(escapedId.id, storeValue.id, store);\n                    }\n                }\n            }\n        }\n        storeObject = store.get(dataId);\n        if (!storeObject || !Object(equality_esm[\"a\" /* equal */])(storeValue, storeObject[storeFieldName])) {\n            store.set(dataId, Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, storeObject), (_b = {}, _b[storeFieldName] = storeValue, _b)));\n        }\n    };\n    StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {\n        var _this = this;\n        return value.map(function (item, index) {\n            if (item === null) {\n                return null;\n            }\n            var itemDataId = generatedId + \".\" + index;\n            if (Array.isArray(item)) {\n                return _this.processArrayValue(item, itemDataId, selectionSet, context);\n            }\n            var generated = true;\n            if (context.dataIdFromObject) {\n                var semanticId = context.dataIdFromObject(item);\n                if (semanticId) {\n                    itemDataId = semanticId;\n                    generated = false;\n                }\n            }\n            if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n                _this.writeSelectionSetToStore({\n                    dataId: itemDataId,\n                    result: item,\n                    selectionSet: selectionSet,\n                    context: context,\n                });\n            }\n            return Object(bundle_esm[\"H\" /* toIdValue */])({ id: itemDataId, typename: item.__typename }, generated);\n        });\n    };\n    return StoreWriter;\n}());\nfunction isGeneratedId(id) {\n    return id[0] === '$';\n}\nfunction mergeWithGenerated(generatedKey, realKey, cache) {\n    if (generatedKey === realKey) {\n        return false;\n    }\n    var generated = cache.get(generatedKey);\n    var real = cache.get(realKey);\n    var madeChanges = false;\n    Object.keys(generated).forEach(function (key) {\n        var value = generated[key];\n        var realValue = real[key];\n        if (Object(bundle_esm[\"u\" /* isIdValue */])(value) &&\n            isGeneratedId(value.id) &&\n            Object(bundle_esm[\"u\" /* isIdValue */])(realValue) &&\n            !Object(equality_esm[\"a\" /* equal */])(value, realValue) &&\n            mergeWithGenerated(value.id, realValue.id, cache)) {\n            madeChanges = true;\n        }\n    });\n    cache.delete(generatedKey);\n    var newRealValue = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, generated), real);\n    if (Object(equality_esm[\"a\" /* equal */])(newRealValue, real)) {\n        return madeChanges;\n    }\n    cache.set(realKey, newRealValue);\n    return true;\n}\nfunction isDataProcessed(dataId, field, processedData) {\n    if (!processedData) {\n        return false;\n    }\n    if (processedData[dataId]) {\n        if (processedData[dataId].indexOf(field) >= 0) {\n            return true;\n        }\n        else {\n            processedData[dataId].push(field);\n        }\n    }\n    else {\n        processedData[dataId] = [field];\n    }\n    return false;\n}\n\nvar defaultConfig = {\n    fragmentMatcher: new HeuristicFragmentMatcher(),\n    dataIdFromObject: defaultDataIdFromObject,\n    addTypename: true,\n    resultCaching: true,\n    freezeResults: false,\n};\nfunction defaultDataIdFromObject(result) {\n    if (result.__typename) {\n        if (result.id !== undefined) {\n            return result.__typename + \":\" + result.id;\n        }\n        if (result._id !== undefined) {\n            return result.__typename + \":\" + result._id;\n        }\n    }\n    return null;\n}\nvar hasOwn$1 = Object.prototype.hasOwnProperty;\nvar bundle_esm_OptimisticCacheLayer = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(OptimisticCacheLayer, _super);\n    function OptimisticCacheLayer(optimisticId, parent, transaction) {\n        var _this = _super.call(this, Object.create(null)) || this;\n        _this.optimisticId = optimisticId;\n        _this.parent = parent;\n        _this.transaction = transaction;\n        return _this;\n    }\n    OptimisticCacheLayer.prototype.toObject = function () {\n        return Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, this.parent.toObject()), this.data);\n    };\n    OptimisticCacheLayer.prototype.get = function (dataId) {\n        return hasOwn$1.call(this.data, dataId)\n            ? this.data[dataId]\n            : this.parent.get(dataId);\n    };\n    return OptimisticCacheLayer;\n}(ObjectCache));\nvar bundle_esm_InMemoryCache = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(InMemoryCache, _super);\n    function InMemoryCache(config) {\n        if (config === void 0) { config = {}; }\n        var _this = _super.call(this) || this;\n        _this.watches = new Set();\n        _this.typenameDocumentCache = new Map();\n        _this.cacheKeyRoot = new KeyTrie(bundle_esm[\"e\" /* canUseWeakMap */]);\n        _this.silenceBroadcast = false;\n        _this.config = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, defaultConfig), config);\n        if (_this.config.customResolvers) {\n             true || false;\n            _this.config.cacheRedirects = _this.config.customResolvers;\n        }\n        if (_this.config.cacheResolvers) {\n             true || false;\n            _this.config.cacheRedirects = _this.config.cacheResolvers;\n        }\n        _this.addTypename = !!_this.config.addTypename;\n        _this.data = _this.config.resultCaching\n            ? new bundle_esm_DepTrackingCache()\n            : new ObjectCache();\n        _this.optimisticData = _this.data;\n        _this.storeWriter = new bundle_esm_StoreWriter();\n        _this.storeReader = new bundle_esm_StoreReader({\n            cacheKeyRoot: _this.cacheKeyRoot,\n            freezeResults: config.freezeResults,\n        });\n        var cache = _this;\n        var maybeBroadcastWatch = cache.maybeBroadcastWatch;\n        _this.maybeBroadcastWatch = bundle_esm_wrap(function (c) {\n            return maybeBroadcastWatch.call(_this, c);\n        }, {\n            makeCacheKey: function (c) {\n                if (c.optimistic) {\n                    return;\n                }\n                if (c.previousResult) {\n                    return;\n                }\n                if (cache.data instanceof bundle_esm_DepTrackingCache) {\n                    return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));\n                }\n            }\n        });\n        return _this;\n    }\n    InMemoryCache.prototype.restore = function (data) {\n        if (data)\n            this.data.replace(data);\n        return this;\n    };\n    InMemoryCache.prototype.extract = function (optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return (optimistic ? this.optimisticData : this.data).toObject();\n    };\n    InMemoryCache.prototype.read = function (options) {\n        if (typeof options.rootId === 'string' &&\n            typeof this.data.get(options.rootId) === 'undefined') {\n            return null;\n        }\n        var fragmentMatcher = this.config.fragmentMatcher;\n        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n        return this.storeReader.readQueryFromStore({\n            store: options.optimistic ? this.optimisticData : this.data,\n            query: this.transformDocument(options.query),\n            variables: options.variables,\n            rootId: options.rootId,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n            previousResult: options.previousResult,\n            config: this.config,\n        }) || null;\n    };\n    InMemoryCache.prototype.write = function (write) {\n        var fragmentMatcher = this.config.fragmentMatcher;\n        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n        this.storeWriter.writeResultToStore({\n            dataId: write.dataId,\n            result: write.result,\n            variables: write.variables,\n            document: this.transformDocument(write.query),\n            store: this.data,\n            dataIdFromObject: this.config.dataIdFromObject,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n        });\n        this.broadcastWatches();\n    };\n    InMemoryCache.prototype.diff = function (query) {\n        var fragmentMatcher = this.config.fragmentMatcher;\n        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n        return this.storeReader.diffQueryAgainstStore({\n            store: query.optimistic ? this.optimisticData : this.data,\n            query: this.transformDocument(query.query),\n            variables: query.variables,\n            returnPartialData: query.returnPartialData,\n            previousResult: query.previousResult,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n            config: this.config,\n        });\n    };\n    InMemoryCache.prototype.watch = function (watch) {\n        var _this = this;\n        this.watches.add(watch);\n        return function () {\n            _this.watches.delete(watch);\n        };\n    };\n    InMemoryCache.prototype.evict = function (query) {\n        throw  true ? new invariant_esm[\"a\" /* InvariantError */](7) : undefined;\n    };\n    InMemoryCache.prototype.reset = function () {\n        this.data.clear();\n        this.broadcastWatches();\n        return Promise.resolve();\n    };\n    InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n        var toReapply = [];\n        var removedCount = 0;\n        var layer = this.optimisticData;\n        while (layer instanceof bundle_esm_OptimisticCacheLayer) {\n            if (layer.optimisticId === idToRemove) {\n                ++removedCount;\n            }\n            else {\n                toReapply.push(layer);\n            }\n            layer = layer.parent;\n        }\n        if (removedCount > 0) {\n            this.optimisticData = layer;\n            while (toReapply.length > 0) {\n                var layer_1 = toReapply.pop();\n                this.performTransaction(layer_1.transaction, layer_1.optimisticId);\n            }\n            this.broadcastWatches();\n        }\n    };\n    InMemoryCache.prototype.performTransaction = function (transaction, optimisticId) {\n        var _a = this, data = _a.data, silenceBroadcast = _a.silenceBroadcast;\n        this.silenceBroadcast = true;\n        if (typeof optimisticId === 'string') {\n            this.data = this.optimisticData = new bundle_esm_OptimisticCacheLayer(optimisticId, this.optimisticData, transaction);\n        }\n        try {\n            transaction(this);\n        }\n        finally {\n            this.silenceBroadcast = silenceBroadcast;\n            this.data = data;\n        }\n        this.broadcastWatches();\n    };\n    InMemoryCache.prototype.recordOptimisticTransaction = function (transaction, id) {\n        return this.performTransaction(transaction, id);\n    };\n    InMemoryCache.prototype.transformDocument = function (document) {\n        if (this.addTypename) {\n            var result = this.typenameDocumentCache.get(document);\n            if (!result) {\n                result = Object(bundle_esm[\"a\" /* addTypenameToDocument */])(document);\n                this.typenameDocumentCache.set(document, result);\n                this.typenameDocumentCache.set(result, result);\n            }\n            return result;\n        }\n        return document;\n    };\n    InMemoryCache.prototype.broadcastWatches = function () {\n        var _this = this;\n        if (!this.silenceBroadcast) {\n            this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c); });\n        }\n    };\n    InMemoryCache.prototype.maybeBroadcastWatch = function (c) {\n        c.callback(this.diff({\n            query: c.query,\n            variables: c.variables,\n            previousResult: c.previousResult && c.previousResult(),\n            optimistic: c.optimistic,\n        }));\n    };\n    return InMemoryCache;\n}(bundle_esm_ApolloCache));\n\n\n//# sourceMappingURL=bundle.esm.js.map\n\n// EXTERNAL MODULE: ./node_modules/apollo-cache-persist/bundle.umd.js\nvar bundle_umd = __webpack_require__(24);\n\n// CONCATENATED MODULE: ./node_modules/apollo-link-error/lib/bundle.esm.js\n\n\n\nfunction bundle_esm_onError(errorHandler) {\n    return new bundle_esm_ApolloLink(function (operation, forward) {\n        return new lib_bundle_esm(function (observer) {\n            var sub;\n            var retriedSub;\n            var retriedResult;\n            try {\n                sub = forward(operation).subscribe({\n                    next: function (result) {\n                        if (result.errors) {\n                            retriedResult = errorHandler({\n                                graphQLErrors: result.errors,\n                                response: result,\n                                operation: operation,\n                                forward: forward,\n                            });\n                            if (retriedResult) {\n                                retriedSub = retriedResult.subscribe({\n                                    next: observer.next.bind(observer),\n                                    error: observer.error.bind(observer),\n                                    complete: observer.complete.bind(observer),\n                                });\n                                return;\n                            }\n                        }\n                        observer.next(result);\n                    },\n                    error: function (networkError) {\n                        retriedResult = errorHandler({\n                            operation: operation,\n                            networkError: networkError,\n                            graphQLErrors: networkError &&\n                                networkError.result &&\n                                networkError.result.errors,\n                            forward: forward,\n                        });\n                        if (retriedResult) {\n                            retriedSub = retriedResult.subscribe({\n                                next: observer.next.bind(observer),\n                                error: observer.error.bind(observer),\n                                complete: observer.complete.bind(observer),\n                            });\n                            return;\n                        }\n                        observer.error(networkError);\n                    },\n                    complete: function () {\n                        if (!retriedResult) {\n                            observer.complete.bind(observer)();\n                        }\n                    },\n                });\n            }\n            catch (e) {\n                errorHandler({ networkError: e, operation: operation, forward: forward });\n                observer.error(e);\n            }\n            return function () {\n                if (sub)\n                    sub.unsubscribe();\n                if (retriedSub)\n                    sub.unsubscribe();\n            };\n        });\n    });\n}\nvar bundle_esm_ErrorLink = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(ErrorLink, _super);\n    function ErrorLink(errorHandler) {\n        var _this = _super.call(this) || this;\n        _this.link = bundle_esm_onError(errorHandler);\n        return _this;\n    }\n    ErrorLink.prototype.request = function (operation, forward) {\n        return this.link.request(operation, forward);\n    };\n    return ErrorLink;\n}(bundle_esm_ApolloLink));\n\n\n//# sourceMappingURL=bundle.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/apollo-boost/lib/bundle.esm.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar PRESET_CONFIG_KEYS = [\n    'request',\n    'uri',\n    'credentials',\n    'headers',\n    'fetch',\n    'fetchOptions',\n    'clientState',\n    'onError',\n    'cacheRedirects',\n    'cache',\n    'name',\n    'version',\n    'resolvers',\n    'typeDefs',\n    'fragmentMatcher',\n];\nvar bundle_esm_DefaultClient = (function (_super) {\n    Object(tslib_es6[\"c\" /* __extends */])(DefaultClient, _super);\n    function DefaultClient(config) {\n        if (config === void 0) { config = {}; }\n        var _this = this;\n        if (config) {\n            var diff = Object.keys(config).filter(function (key) { return PRESET_CONFIG_KEYS.indexOf(key) === -1; });\n            if (diff.length > 0) {\n                 true || false;\n            }\n        }\n        var request = config.request, uri = config.uri, credentials = config.credentials, headers = config.headers, fetch = config.fetch, fetchOptions = config.fetchOptions, clientState = config.clientState, cacheRedirects = config.cacheRedirects, errorCallback = config.onError, name = config.name, version = config.version, resolvers = config.resolvers, typeDefs = config.typeDefs, fragmentMatcher = config.fragmentMatcher;\n        var cache = config.cache;\n         true ? Object(invariant_esm[\"b\" /* invariant */])(!cache || !cacheRedirects, 1) : undefined;\n        if (!cache) {\n            cache = cacheRedirects\n                ? new bundle_esm_InMemoryCache({ cacheRedirects: cacheRedirects })\n                : new bundle_esm_InMemoryCache();\n        }\n        var errorLink = errorCallback\n            ? bundle_esm_onError(errorCallback)\n            : bundle_esm_onError(function (_a) {\n                var graphQLErrors = _a.graphQLErrors, networkError = _a.networkError;\n                if (graphQLErrors) {\n                    graphQLErrors.forEach(function (_a) {\n                        var message = _a.message, locations = _a.locations, path = _a.path;\n                        return  true || false;\n                    });\n                }\n                if (networkError) {\n                     true || false;\n                }\n            });\n        var requestHandler = request\n            ? new bundle_esm_ApolloLink(function (operation, forward) {\n                return new lib_bundle_esm(function (observer) {\n                    var handle;\n                    Promise.resolve(operation)\n                        .then(function (oper) { return request(oper); })\n                        .then(function () {\n                        handle = forward(operation).subscribe({\n                            next: observer.next.bind(observer),\n                            error: observer.error.bind(observer),\n                            complete: observer.complete.bind(observer),\n                        });\n                    })\n                        .catch(observer.error.bind(observer));\n                    return function () {\n                        if (handle) {\n                            handle.unsubscribe();\n                        }\n                    };\n                });\n            })\n            : false;\n        var httpLink = new bundle_esm_HttpLink({\n            uri: uri || '/graphql',\n            fetch: fetch,\n            fetchOptions: fetchOptions || {},\n            credentials: credentials || 'same-origin',\n            headers: headers || {},\n        });\n        var link = bundle_esm_ApolloLink.from([errorLink, requestHandler, httpLink].filter(function (x) { return !!x; }));\n        var activeResolvers = resolvers;\n        var activeTypeDefs = typeDefs;\n        var activeFragmentMatcher = fragmentMatcher;\n        if (clientState) {\n            if (clientState.defaults) {\n                cache.writeData({\n                    data: clientState.defaults,\n                });\n            }\n            activeResolvers = clientState.resolvers;\n            activeTypeDefs = clientState.typeDefs;\n            activeFragmentMatcher = clientState.fragmentMatcher;\n        }\n        _this = _super.call(this, {\n            cache: cache,\n            link: link,\n            name: name,\n            version: version,\n            resolvers: activeResolvers,\n            typeDefs: activeTypeDefs,\n            fragmentMatcher: activeFragmentMatcher,\n        }) || this;\n        return _this;\n    }\n    return DefaultClient;\n}(apollo_client_bundle_esm));\n\n/* harmony default export */ var apollo_boost_lib_bundle_esm = (bundle_esm_DefaultClient);\n//# sourceMappingURL=bundle.esm.js.map\n\n// CONCATENATED MODULE: ./client/src/app.js\n\n\n\n\n\n\n\n\n\n\nvar retry = new bundle_esm_RetryLink({\n  attempts: {\n    max: Infinity\n  }\n});\nvar app_http = new createHttpLink({\n  uri: \"http://localhost:4000/graphql\"\n});\nvar app_link = concat(retry, app_http); // Use an InMemoryCache, but keep it synced to localStorage\n\nvar app_cache = new bundle_esm_InMemoryCache();\nvar storage = window.localStorage;\nvar waitOnCache = Object(bundle_umd[\"persistCache\"])({\n  cache: app_cache,\n  storage\n});\nvar app_client = new apollo_boost_lib_bundle_esm({\n  cache: app_cache,\n  uri: \"http://localhost:4000/graphql\"\n}); // const client = new ApolloClient({\n//   uri: \"http://localhost:4000/graphql\",\n// });\n// ReactDOM.render(<Main />, document.getElementById(\"root\"));\n// const g = document.createElement(\"div\");\n// g.setAttribute(\"id\", \"root\");\n\nwaitOnCache.then(() => {\n  react_dom_default.a.render( /*#__PURE__*/react_default.a.createElement(ApolloProvider, {\n    client: app_client\n  }, /*#__PURE__*/react_default.a.createElement(Main, null)), document.getElementById(\"root\"));\n});\n\nif (\"serviceWorker\" in navigator) {\n  window.addEventListener(\"load\", () => {\n    navigator.serviceWorker.register(\"/service-worker.js\").then(registration => {\n      console.log(\"SW registered: \", registration);\n    }).catch(registrationError => {\n      console.log(\"SW registration failed: \", registrationError);\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcz9jMzFkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzP2NjYjUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzLmpzPzE1ZmQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzLWluLWJyb3dzZXIvZGlzdC9tb2R1bGUuanM/Y2VkNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGlueS13YXJuaW5nL2Rpc3QvdGlueS13YXJuaW5nLmVzbS5qcz8yZDQ0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qcz9iZWUyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlLmpzPzc0OGUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcz8yNTdlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MvZGlzdC9qc3MuZXNtLmpzP2ZkYzciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL21lcmdlQ2xhc3Nlcy9tZXJnZUNsYXNzZXMuanM/NWNkNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vbWFrZVN0eWxlcy9tdWx0aUtleVN0b3JlLmpzPzNmNWIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL3VzZVRoZW1lL1RoZW1lQ29udGV4dC5qcz8zOGE4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS91c2VUaGVtZS91c2VUaGVtZS5qcz82OTczIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS9UaGVtZVByb3ZpZGVyL25lc3RlZC5qcz84NWY4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZS9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZS5qcz8zZDE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLXJ1bGUtdmFsdWUtZnVuY3Rpb24vZGlzdC9qc3MtcGx1Z2luLXJ1bGUtdmFsdWUtZnVuY3Rpb24uZXNtLmpzPzViNjAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tZ2xvYmFsL2Rpc3QvanNzLXBsdWdpbi1nbG9iYWwuZXNtLmpzPzdhZDUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tbmVzdGVkL2Rpc3QvanNzLXBsdWdpbi1uZXN0ZWQuZXNtLmpzPzNkYmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h5cGhlbmF0ZS1zdHlsZS1uYW1lL2luZGV4LmpzPzMwMDkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tY2FtZWwtY2FzZS9kaXN0L2pzcy1wbHVnaW4tY2FtZWwtY2FzZS5lc20uanM/MjQwOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1kZWZhdWx0LXVuaXQvZGlzdC9qc3MtcGx1Z2luLWRlZmF1bHQtdW5pdC5lc20uanM/NzJkNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qcz82Yjc1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcz82MDA1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanM/ZGI5MCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanM/MDZjNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanM/MzQyNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanM/MjkwOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLXZlbmRvci9kaXN0L2Nzcy12ZW5kb3IuZXNtLmpzPzc4ZjMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tdmVuZG9yLXByZWZpeGVyL2Rpc3QvanNzLXBsdWdpbi12ZW5kb3ItcHJlZml4ZXIuZXNtLmpzPzk2ZmMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tcHJvcHMtc29ydC9kaXN0L2pzcy1wbHVnaW4tcHJvcHMtc29ydC5lc20uanM/OTMyYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vanNzUHJlc2V0L2pzc1ByZXNldC5qcz9jMzQ4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS9TdHlsZXNQcm92aWRlci9TdHlsZXNQcm92aWRlci5qcz9hM2M0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS9tYWtlU3R5bGVzL2luZGV4Q291bnRlci5qcz9lMGU5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanM/NTNjYSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3V0aWxzL2VzbS9kZWVwbWVyZ2UuanM/ZGJlZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vZ2V0U3R5bGVzQ3JlYXRvci9nZXRTdHlsZXNDcmVhdG9yLmpzPzA5MDgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL2dldFN0eWxlc0NyZWF0b3Ivbm9vcFRoZW1lLmpzPzNlZGEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL21ha2VTdHlsZXMvbWFrZVN0eWxlcy5qcz80NDNlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcz9hZGUzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL2NyZWF0ZUJyZWFrcG9pbnRzLmpzPzJjNDIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvY3JlYXRlTWl4aW5zLmpzPzM4YzQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS91dGlscy9lc20vZm9ybWF0TXVpRXJyb3JNZXNzYWdlLmpzPzRlYjgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9jb2xvcnMvY29tbW9uLmpzPzVkNTQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9jb2xvcnMvZ3JleS5qcz8yZDc1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vY29sb3JzL2luZGlnby5qcz9hZjBiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vY29sb3JzL3BpbmsuanM/OWQ3YiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2NvbG9ycy9yZWQuanM/NzY1ZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2NvbG9ycy9vcmFuZ2UuanM/NjFiZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2NvbG9ycy9ibHVlLmpzPzc5ZGMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9jb2xvcnMvZ3JlZW4uanM/ZWIyMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3N0eWxlcy9jb2xvck1hbmlwdWxhdG9yLmpzP2M5ZWYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvY3JlYXRlUGFsZXR0ZS5qcz85NWVhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL2NyZWF0ZVR5cG9ncmFwaHkuanM/MjMxNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3N0eWxlcy9zaGFkb3dzLmpzPzcwMDciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvc2hhcGUuanM/OWM1NSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanM/MGQyMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5TGltaXQuanM/MDlmMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzPzNkOGMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanM/MzgzNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N5c3RlbS9lc20vbWVyZ2UuanM/NmVmZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N5c3RlbS9lc20vYnJlYWtwb2ludHMuanM/MmYyNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N5c3RlbS9lc20vbWVtb2l6ZS5qcz8xYjZjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3lzdGVtL2VzbS9zcGFjaW5nLmpzP2Y4NzkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvY3JlYXRlU3BhY2luZy5qcz85NTVmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL3RyYW5zaXRpb25zLmpzP2MyOTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvekluZGV4LmpzPzFmMGMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvY3JlYXRlTXVpVGhlbWUuanM/YmUyNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3N0eWxlcy9kZWZhdWx0VGhlbWUuanM/NzBkYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3N0eWxlcy9tYWtlU3R5bGVzLmpzPzQ3ZjUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm0uanM/OGFlOCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vZ2V0VGhlbWVQcm9wcy9nZXRUaGVtZVByb3BzLmpzPzAzZTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL3dpdGhTdHlsZXMvd2l0aFN0eWxlcy5qcz9iOWM4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL3dpdGhTdHlsZXMuanM/MWY2NCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL1BhcGVyL1BhcGVyLmpzPzkwYTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9DYXJkL0NhcmQuanM/ZGY0ZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0NhcmRDb250ZW50L0NhcmRDb250ZW50LmpzP2ExYWYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9jYXBpdGFsaXplLmpzPzM2YWIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9UeXBvZ3JhcGh5L1R5cG9ncmFwaHkuanM/YTFmNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0NhcmRIZWFkZXIvQ2FyZEhlYWRlci5qcz9lNzQwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vTGlzdC9MaXN0Q29udGV4dC5qcz8zMmFiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vTGlzdC9MaXN0LmpzPzc4M2YiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9zZXRSZWYuanM/MTg4NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3V0aWxzL3VzZUZvcmtSZWYuanM/NmRmMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3V0aWxzL3VzZUV2ZW50Q2FsbGJhY2suanM/M2FmNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3V0aWxzL3VzZUlzRm9jdXNWaXNpYmxlLmpzPzFiYjAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvZXNtL1RyYW5zaXRpb25Hcm91cENvbnRleHQuanM/ZDBmNCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vdXRpbHMvQ2hpbGRNYXBwaW5nLmpzPzIwYzgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvZXNtL1RyYW5zaXRpb25Hcm91cC5qcz81NWUwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vQnV0dG9uQmFzZS9SaXBwbGUuanM/YmUyNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0J1dHRvbkJhc2UvVG91Y2hSaXBwbGUuanM/MDRlMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0J1dHRvbkJhc2UvQnV0dG9uQmFzZS5qcz81NDNmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvaXNNdWlFbGVtZW50LmpzP2I5YzAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9MaXN0SXRlbS9MaXN0SXRlbS5qcz9iNTU2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vTGlzdEl0ZW1UZXh0L0xpc3RJdGVtVGV4dC5qcz8yMmNhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vRGl2aWRlci9EaXZpZGVyLmpzP2MxYmQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9MaXN0SXRlbUljb24vTGlzdEl0ZW1JY29uLmpzP2U3YTQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Gb3JtQ29udHJvbC9mb3JtQ29udHJvbFN0YXRlLmpzP2RiYzciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbENvbnRleHQuanM/ZTIxYSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3V0aWxzL2RlYm91bmNlLmpzPzk3NzUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9UZXh0YXJlYUF1dG9zaXplL1RleHRhcmVhQXV0b3NpemUuanM/ODM3NSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0lucHV0QmFzZS91dGlscy5qcz8wNzJhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vSW5wdXRCYXNlL0lucHV0QmFzZS5qcz8zMjM0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vSW5wdXQvSW5wdXQuanM/YTVkYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0ZpbGxlZElucHV0L0ZpbGxlZElucHV0LmpzPzRjYjYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvdXNlVGhlbWUuanM/YjZiZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL091dGxpbmVkSW5wdXQvTm90Y2hlZE91dGxpbmUuanM/M2VhOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL091dGxpbmVkSW5wdXQvT3V0bGluZWRJbnB1dC5qcz8yYTYzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vRm9ybUNvbnRyb2wvdXNlRm9ybUNvbnRyb2wuanM/MTA3NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0Zvcm1MYWJlbC9Gb3JtTGFiZWwuanM/MzQzYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0lucHV0TGFiZWwvSW5wdXRMYWJlbC5qcz9kNDA2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vRm9ybUNvbnRyb2wvRm9ybUNvbnRyb2wuanM/MDAzOCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0Zvcm1IZWxwZXJUZXh0L0Zvcm1IZWxwZXJUZXh0LmpzPzRhOTciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9vd25lckRvY3VtZW50LmpzPzgyNGQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9vd25lcldpbmRvdy5qcz84M2VhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uLmpzP2M3YTMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Qb3J0YWwvUG9ydGFsLmpzPzZlM2EiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzP2Q0ZWMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9nZXRTY3JvbGxiYXJTaXplLmpzPzZmMDkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Nb2RhbC9Nb2RhbE1hbmFnZXIuanM/YTAxMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL1Vuc3RhYmxlX1RyYXBGb2N1cy9VbnN0YWJsZV9UcmFwRm9jdXMuanM/YWJmZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL01vZGFsL1NpbXBsZUJhY2tkcm9wLmpzP2Q0YTgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Nb2RhbC9Nb2RhbC5qcz81ZWRkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9jb25maWcuanM/MmE0MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vVHJhbnNpdGlvbi5qcz83NTFiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdHJhbnNpdGlvbnMvdXRpbHMuanM/ZTA3YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0dyb3cvR3Jvdy5qcz82ZWFiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vUG9wb3Zlci9Qb3BvdmVyLmpzP2U0NjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9NZW51TGlzdC9NZW51TGlzdC5qcz9iNzQ1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vTWVudS9NZW51LmpzPzgxZGYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy91c2VDb250cm9sbGVkLmpzP2M4MmMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9TZWxlY3QvU2VsZWN0SW5wdXQuanM/YjJiNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL1N2Z0ljb24vU3ZnSWNvbi5qcz8xZDFlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvY3JlYXRlU3ZnSWNvbi5qcz9lNDAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vaW50ZXJuYWwvc3ZnLWljb25zL0Fycm93RHJvcERvd24uanM/NzNiYSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL05hdGl2ZVNlbGVjdC9OYXRpdmVTZWxlY3RJbnB1dC5qcz8yMzdmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vTmF0aXZlU2VsZWN0L05hdGl2ZVNlbGVjdC5qcz80N2RiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vU2VsZWN0L1NlbGVjdC5qcz83MTU1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vVGV4dEZpZWxkL1RleHRGaWVsZC5qcz9hZmRjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vQnV0dG9uL0J1dHRvbi5qcz82NzdiIiwid2VicGFjazovLy8uL2NsaWVudC9jb250YWluZXJzL0xpc3QuanN4Pzg2OTYiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvVG9Eb0xpc3QuanN4P2YxZjQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vcmVhY3QtY29tbW9uL2xpYi9yZWFjdC1jb21tb24uZXNtLmpzPzk2YTMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3plbi1vYnNlcnZhYmxlLXRzL2xpYi9idW5kbGUuZXNtLmpzPzZmNDciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fwb2xsby1saW5rL2xpYi9idW5kbGUuZXNtLmpzP2Q2MzQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fwb2xsby1jbGllbnQvYnVuZGxlLmVzbS5qcz83NGNhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL3JlYWN0LWhvb2tzL2xpYi9yZWFjdC1ob29rcy5lc20uanM/YjZkNiIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9NYWluLmpzeD9hOGMzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3ByaW50ZXIubWpzPzc1MDYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fwb2xsby1saW5rLWh0dHAtY29tbW9uL2xpYi9idW5kbGUuZXNtLmpzP2M5ZDYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fwb2xsby1saW5rLWh0dHAvbGliL2J1bmRsZS5lc20uanM/NDc4ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXBvbGxvLWxpbmstcmV0cnkvbGliL2J1bmRsZS5lc20uanM/MDEyNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXBvbGxvLWNhY2hlL2xpYi9idW5kbGUuZXNtLmpzPzYzZTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3cnkvY29udGV4dC9saWIvY29udGV4dC5lc20uanM/ODQzOCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2J1bmRsZS5lc20uanM/ZTMyOCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXBvbGxvLWNhY2hlLWlubWVtb3J5L2xpYi9idW5kbGUuZXNtLmpzPzJiZjIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fwb2xsby1saW5rLWVycm9yL2xpYi9idW5kbGUuZXNtLmpzP2UxM2IiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fwb2xsby1ib29zdC9saWIvYnVuZGxlLmVzbS5qcz8yYzgyIiwid2VicGFjazovLy8uL2NsaWVudC9zcmMvYXBwLmpzPzdlNjMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCJpbXBvcnQgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiLi9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnQgdmFyIGlzQnJvd3NlciA9ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPT09IFwib2JqZWN0XCIgJiYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGRvY3VtZW50KSkgPT09ICdvYmplY3QnICYmIGRvY3VtZW50Lm5vZGVUeXBlID09PSA5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0Jyb3dzZXI7XG4iLCJ2YXIgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbmZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghaXNQcm9kdWN0aW9uKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gXCJXYXJuaW5nOiBcIiArIG1lc3NhZ2U7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4odGV4dCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRocm93IEVycm9yKHRleHQpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgd2FybmluZztcbiIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgaXNJbkJyb3dzZXIgZnJvbSAnaXMtaW4tYnJvd3Nlcic7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyc7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQnO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnO1xuXG52YXIgcGxhaW5PYmplY3RDb25zdHJ1cmN0b3IgPSB7fS5jb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIGNsb25lU3R5bGUoc3R5bGUpIHtcbiAgaWYgKHN0eWxlID09IG51bGwgfHwgdHlwZW9mIHN0eWxlICE9PSAnb2JqZWN0JykgcmV0dXJuIHN0eWxlO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHJldHVybiBzdHlsZS5tYXAoY2xvbmVTdHlsZSk7XG4gIGlmIChzdHlsZS5jb25zdHJ1Y3RvciAhPT0gcGxhaW5PYmplY3RDb25zdHJ1cmN0b3IpIHJldHVybiBzdHlsZTtcbiAgdmFyIG5ld1N0eWxlID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZSkge1xuICAgIG5ld1N0eWxlW25hbWVdID0gY2xvbmVTdHlsZShzdHlsZVtuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3R5bGU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcnVsZSBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIG5hbWUgPSAndW5uYW1lZCc7XG4gIH1cblxuICB2YXIganNzID0gb3B0aW9ucy5qc3M7XG4gIHZhciBkZWNsQ29weSA9IGNsb25lU3R5bGUoZGVjbCk7XG4gIHZhciBydWxlID0ganNzLnBsdWdpbnMub25DcmVhdGVSdWxlKG5hbWUsIGRlY2xDb3B5LCBvcHRpb25zKTtcbiAgaWYgKHJ1bGUpIHJldHVybiBydWxlOyAvLyBJdCBpcyBhbiBhdC1ydWxlIGFuZCBpdCBoYXMgbm8gaW5zdGFuY2UuXG5cbiAgaWYgKG5hbWVbMF0gPT09ICdAJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gVW5rbm93biBydWxlIFwiICsgbmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGpvaW4gPSBmdW5jdGlvbiBqb2luKHZhbHVlLCBieSkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIFJlbW92ZSAhaW1wb3J0YW50IGZyb20gdGhlIHZhbHVlLCBpdCB3aWxsIGJlIHJlYWRkZWQgbGF0ZXIuXG4gICAgaWYgKHZhbHVlW2ldID09PSAnIWltcG9ydGFudCcpIGJyZWFrO1xuICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSBieTtcbiAgICByZXN1bHQgKz0gdmFsdWVbaV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQ29udmVydHMgYXJyYXkgdmFsdWVzIHRvIHN0cmluZy5cbiAqXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddXWAgPiBgbWFyZ2luOiA1cHggMTBweDtgXG4gKiBgYm9yZGVyOiBbJzFweCcsICcycHgnXWAgPiBgYm9yZGVyOiAxcHgsIDJweDtgXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddLCAnIWltcG9ydGFudCddYCA+IGBtYXJnaW46IDVweCAxMHB4ICFpbXBvcnRhbnQ7YFxuICogYGNvbG9yOiBbJ3JlZCcsICFpbXBvcnRhbnRdYCA+IGBjb2xvcjogcmVkICFpbXBvcnRhbnQ7YFxuICovXG5cblxuZnVuY3Rpb24gdG9Dc3NWYWx1ZSh2YWx1ZSwgaWdub3JlSW1wb3J0YW50KSB7XG4gIGlmIChpZ25vcmVJbXBvcnRhbnQgPT09IHZvaWQgMCkge1xuICAgIGlnbm9yZUltcG9ydGFudCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICB2YXIgY3NzVmFsdWUgPSAnJzsgLy8gU3VwcG9ydCBzcGFjZSBzZXBhcmF0ZWQgdmFsdWVzIHZpYSBgW1snNXB4JywgJzEwcHgnXV1gLlxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSA9PT0gJyFpbXBvcnRhbnQnKSBicmVhaztcbiAgICAgIGlmIChjc3NWYWx1ZSkgY3NzVmFsdWUgKz0gJywgJztcbiAgICAgIGNzc1ZhbHVlICs9IGpvaW4odmFsdWVbaV0sICcgJyk7XG4gICAgfVxuICB9IGVsc2UgY3NzVmFsdWUgPSBqb2luKHZhbHVlLCAnLCAnKTsgLy8gQWRkICFpbXBvcnRhbnQsIGJlY2F1c2UgaXQgd2FzIGlnbm9yZWQuXG5cblxuICBpZiAoIWlnbm9yZUltcG9ydGFudCAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJyFpbXBvcnRhbnQnKSB7XG4gICAgY3NzVmFsdWUgKz0gJyAhaW1wb3J0YW50JztcbiAgfVxuXG4gIHJldHVybiBjc3NWYWx1ZTtcbn1cblxuLyoqXG4gKiBJbmRlbnQgYSBzdHJpbmcuXG4gKiBodHRwOi8vanNwZXJmLmNvbS9hcnJheS1qb2luLXZzLWZvclxuICovXG5mdW5jdGlvbiBpbmRlbnRTdHIoc3RyLCBpbmRlbnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpbmRlbnQ7IGluZGV4KyspIHtcbiAgICByZXN1bHQgKz0gJyAgJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQgKyBzdHI7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgUnVsZSB0byBDU1Mgc3RyaW5nLlxuICovXG5cblxuZnVuY3Rpb24gdG9Dc3Moc2VsZWN0b3IsIHN0eWxlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICghc3R5bGUpIHJldHVybiByZXN1bHQ7XG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRpbmRlbnQgPSBfb3B0aW9ucy5pbmRlbnQsXG4gICAgICBpbmRlbnQgPSBfb3B0aW9ucyRpbmRlbnQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRpbmRlbnQ7XG4gIHZhciBmYWxsYmFja3MgPSBzdHlsZS5mYWxsYmFja3M7XG4gIGlmIChzZWxlY3RvcikgaW5kZW50Kys7IC8vIEFwcGx5IGZhbGxiYWNrcyBmaXJzdC5cblxuICBpZiAoZmFsbGJhY2tzKSB7XG4gICAgLy8gQXJyYXkgc3ludGF4IHtmYWxsYmFja3M6IFt7cHJvcDogdmFsdWV9XX1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmYWxsYmFja3MpKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZmFsbGJhY2tzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgZmFsbGJhY2sgPSBmYWxsYmFja3NbaW5kZXhdO1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZmFsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBmYWxsYmFja1twcm9wXTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcIiArIGluZGVudFN0cihwcm9wICsgXCI6IFwiICsgdG9Dc3NWYWx1ZSh2YWx1ZSkgKyBcIjtcIiwgaW5kZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2JqZWN0IHN5bnRheCB7ZmFsbGJhY2tzOiB7cHJvcDogdmFsdWV9fVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gZmFsbGJhY2tzKSB7XG4gICAgICAgIHZhciBfdmFsdWUgPSBmYWxsYmFja3NbX3Byb3BdO1xuXG4gICAgICAgIGlmIChfdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICByZXN1bHQgKz0gXCJcIiArIGluZGVudFN0cihfcHJvcCArIFwiOiBcIiArIHRvQ3NzVmFsdWUoX3ZhbHVlKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3AyIGluIHN0eWxlKSB7XG4gICAgdmFyIF92YWx1ZTIgPSBzdHlsZVtfcHJvcDJdO1xuXG4gICAgaWYgKF92YWx1ZTIgIT0gbnVsbCAmJiBfcHJvcDIgIT09ICdmYWxsYmFja3MnKSB7XG4gICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gJ1xcbic7XG4gICAgICByZXN1bHQgKz0gXCJcIiArIGluZGVudFN0cihfcHJvcDIgKyBcIjogXCIgKyB0b0Nzc1ZhbHVlKF92YWx1ZTIpICsgXCI7XCIsIGluZGVudCk7XG4gICAgfVxuICB9IC8vIEFsbG93IGVtcHR5IHN0eWxlIGluIHRoaXMgY2FzZSwgYmVjYXVzZSBwcm9wZXJ0aWVzIHdpbGwgYmUgYWRkZWQgZHluYW1pY2FsbHkuXG5cblxuICBpZiAoIXJlc3VsdCAmJiAhb3B0aW9ucy5hbGxvd0VtcHR5KSByZXR1cm4gcmVzdWx0OyAvLyBXaGVuIHJ1bGUgaXMgYmVpbmcgc3RyaW5naWZpZWQgYmVmb3JlIHNlbGVjdG9yIHdhcyBkZWZpbmVkLlxuXG4gIGlmICghc2VsZWN0b3IpIHJldHVybiByZXN1bHQ7XG4gIGluZGVudC0tO1xuICBpZiAocmVzdWx0KSByZXN1bHQgPSBcIlxcblwiICsgcmVzdWx0ICsgXCJcXG5cIjtcbiAgcmV0dXJuIGluZGVudFN0cihzZWxlY3RvciArIFwiIHtcIiArIHJlc3VsdCwgaW5kZW50KSArIGluZGVudFN0cignfScsIGluZGVudCk7XG59XG5cbnZhciBlc2NhcGVSZWdleCA9IC8oW1tcXF0uIyokPjwrfj18XjooKSxcIidgXFxzXSkvZztcbnZhciBuYXRpdmVFc2NhcGUgPSB0eXBlb2YgQ1NTICE9PSAndW5kZWZpbmVkJyAmJiBDU1MuZXNjYXBlO1xudmFyIGVzY2FwZSA9IChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBuYXRpdmVFc2NhcGUgPyBuYXRpdmVFc2NhcGUoc3RyKSA6IHN0ci5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnXFxcXCQxJyk7XG59KTtcblxudmFyIEJhc2VTdHlsZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlU3R5bGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnc3R5bGUnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMucmVuZGVyZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB2YXIgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBSZW5kZXJlciA9IG9wdGlvbnMuUmVuZGVyZXI7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgaWYgKHNoZWV0KSB0aGlzLnJlbmRlcmVyID0gc2hlZXQucmVuZGVyZXI7ZWxzZSBpZiAoUmVuZGVyZXIpIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IG9yIHNldCBhIHN0eWxlIHByb3BlcnR5LlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBCYXNlU3R5bGVSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJvcCA9IGZ1bmN0aW9uIHByb3AobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAvLyBJdCdzIGEgZ2V0dGVyLlxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5zdHlsZVtuYW1lXTsgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZC5cblxuICAgIHZhciBmb3JjZSA9IG9wdGlvbnMgPyBvcHRpb25zLmZvcmNlIDogZmFsc2U7XG4gICAgaWYgKCFmb3JjZSAmJiB0aGlzLnN0eWxlW25hbWVdID09PSB2YWx1ZSkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5wcm9jZXNzICE9PSBmYWxzZSkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25DaGFuZ2VWYWx1ZSh2YWx1ZSwgbmFtZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIGlzRW1wdHkgPSBuZXdWYWx1ZSA9PSBudWxsIHx8IG5ld1ZhbHVlID09PSBmYWxzZTtcbiAgICB2YXIgaXNEZWZpbmVkID0gbmFtZSBpbiB0aGlzLnN0eWxlOyAvLyBWYWx1ZSBpcyBlbXB0eSBhbmQgd2Fzbid0IGRlZmluZWQgYmVmb3JlLlxuXG4gICAgaWYgKGlzRW1wdHkgJiYgIWlzRGVmaW5lZCAmJiAhZm9yY2UpIHJldHVybiB0aGlzOyAvLyBXZSBhcmUgZ29pbmcgdG8gcmVtb3ZlIHRoaXMgdmFsdWUuXG5cbiAgICB2YXIgcmVtb3ZlID0gaXNFbXB0eSAmJiBpc0RlZmluZWQ7XG4gICAgaWYgKHJlbW92ZSkgZGVsZXRlIHRoaXMuc3R5bGVbbmFtZV07ZWxzZSB0aGlzLnN0eWxlW25hbWVdID0gbmV3VmFsdWU7IC8vIFJlbmRlcmFibGUgaXMgZGVmaW5lZCBpZiBTdHlsZVNoZWV0IG9wdGlvbiBgbGlua2AgaXMgdHJ1ZS5cblxuICAgIGlmICh0aGlzLnJlbmRlcmFibGUgJiYgdGhpcy5yZW5kZXJlcikge1xuICAgICAgaWYgKHJlbW92ZSkgdGhpcy5yZW5kZXJlci5yZW1vdmVQcm9wZXJ0eSh0aGlzLnJlbmRlcmFibGUsIG5hbWUpO2Vsc2UgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLnJlbmRlcmFibGUsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcblxuICAgIGlmIChzaGVldCAmJiBzaGVldC5hdHRhY2hlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ1tKU1NdIFJ1bGUgaXMgbm90IGxpbmtlZC4gTWlzc2luZyBzaGVldCBvcHRpb24gXCJsaW5rOiB0cnVlXCIuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2VTdHlsZVJ1bGU7XG59KCk7XG52YXIgU3R5bGVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZVN0eWxlUnVsZSkge1xuICBfaW5oZXJpdHNMb29zZShTdHlsZVJ1bGUsIF9CYXNlU3R5bGVSdWxlKTtcblxuICBmdW5jdGlvbiBTdHlsZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VTdHlsZVJ1bGUuY2FsbCh0aGlzLCBrZXksIHN0eWxlLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIF90aGlzLnNlbGVjdG9yVGV4dCA9IHZvaWQgMDtcbiAgICBfdGhpcy5pZCA9IHZvaWQgMDtcbiAgICBfdGhpcy5yZW5kZXJhYmxlID0gdm9pZCAwO1xuICAgIHZhciBzZWxlY3RvciA9IG9wdGlvbnMuc2VsZWN0b3IsXG4gICAgICAgIHNjb3BlZCA9IG9wdGlvbnMuc2NvcGVkLFxuICAgICAgICBzaGVldCA9IG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBvcHRpb25zLmdlbmVyYXRlSWQ7XG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIF90aGlzLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuICAgIH0gZWxzZSBpZiAoc2NvcGVkICE9PSBmYWxzZSkge1xuICAgICAgX3RoaXMuaWQgPSBnZW5lcmF0ZUlkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBzaGVldCk7XG4gICAgICBfdGhpcy5zZWxlY3RvclRleHQgPSBcIi5cIiArIGVzY2FwZShfdGhpcy5pZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0b3Igc3RyaW5nLlxuICAgKiBBdHRlbnRpb246IHVzZSB0aGlzIHdpdGggY2F1dGlvbi4gTW9zdCBicm93c2VycyBkaWRuJ3QgaW1wbGVtZW50XG4gICAqIHNlbGVjdG9yVGV4dCBzZXR0ZXIsIHNvIHRoaXMgbWF5IHJlc3VsdCBpbiByZXJlbmRlcmluZyBvZiBlbnRpcmUgU3R5bGUgU2hlZXQuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90bzIgPSBTdHlsZVJ1bGUucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBBcHBseSBydWxlIHRvIGFuIGVsZW1lbnQgaW5saW5lLlxuICAgKi9cbiAgX3Byb3RvMi5hcHBseVRvID0gZnVuY3Rpb24gYXBwbHlUbyhyZW5kZXJhYmxlKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcblxuICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgdmFyIGpzb24gPSB0aGlzLnRvSlNPTigpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGpzb24pIHtcbiAgICAgICAgcmVuZGVyZXIuc2V0UHJvcGVydHkocmVuZGVyYWJsZSwgcHJvcCwganNvbltwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcnVsZS5cbiAgICogRmFsbGJhY2tzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgKiBVc2VmdWwgZm9yIGlubGluZSBzdHlsZXMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMi50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgdmFyIGpzb24gPSB7fTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdHlsZVtwcm9wXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSBqc29uW3Byb3BdID0gdmFsdWU7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIGpzb25bcHJvcF0gPSB0b0Nzc1ZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcbiAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG4gICAgdmFyIG9wdHMgPSBsaW5rID8gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGFsbG93RW1wdHk6IHRydWVcbiAgICB9KSA6IG9wdGlvbnM7XG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMuc2VsZWN0b3JUZXh0LCB0aGlzLnN0eWxlLCBvcHRzKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU3R5bGVSdWxlLCBbe1xuICAgIGtleTogXCJzZWxlY3RvclwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IHRoaXMuc2VsZWN0b3JUZXh0KSByZXR1cm47XG4gICAgICB0aGlzLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICByZW5kZXJhYmxlID0gdGhpcy5yZW5kZXJhYmxlO1xuICAgICAgaWYgKCFyZW5kZXJhYmxlIHx8ICFyZW5kZXJlcikgcmV0dXJuO1xuICAgICAgdmFyIGhhc0NoYW5nZWQgPSByZW5kZXJlci5zZXRTZWxlY3RvcihyZW5kZXJhYmxlLCBzZWxlY3Rvcik7IC8vIElmIHNlbGVjdG9yIHNldHRlciBpcyBub3QgaW1wbGVtZW50ZWQsIHJlcmVuZGVyIHRoZSBydWxlLlxuXG4gICAgICBpZiAoIWhhc0NoYW5nZWQpIHtcbiAgICAgICAgcmVuZGVyZXIucmVwbGFjZVJ1bGUocmVuZGVyYWJsZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzZWxlY3RvciBzdHJpbmcuXG4gICAgICovXG4gICAgLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3JUZXh0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHlsZVJ1bGU7XG59KEJhc2VTdHlsZVJ1bGUpO1xudmFyIHBsdWdpblN0eWxlUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAobmFtZVswXSA9PT0gJ0AnIHx8IG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0eWxlUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0VG9TdHJpbmdPcHRpb25zID0ge1xuICBpbmRlbnQ6IDEsXG4gIGNoaWxkcmVuOiB0cnVlXG59O1xudmFyIGF0UmVnRXhwID0gL0AoW1xcdy1dKykvO1xuLyoqXG4gKiBDb25kaXRpb25hbCBydWxlIGZvciBAbWVkaWEsIEBzdXBwb3J0c1xuICovXG5cbnZhciBDb25kaXRpb25hbFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25kaXRpb25hbFJ1bGUoa2V5LCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnY29uZGl0aW9uYWwnO1xuICAgIHRoaXMuYXQgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5xdWVyeSA9IHZvaWQgMDtcbiAgICB0aGlzLnJ1bGVzID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0ga2V5OyAvLyBLZXkgbWlnaHQgY29udGFpbiBhIHVuaXF1ZSBzdWZmaXggaW4gY2FzZSB0aGUgYG5hbWVgIHBhc3NlZCBieSB1c2VyIHdhcyBkdXBsaWNhdGUuXG5cbiAgICB0aGlzLnF1ZXJ5ID0gb3B0aW9ucy5uYW1lO1xuICAgIHZhciBhdE1hdGNoID0ga2V5Lm1hdGNoKGF0UmVnRXhwKTtcbiAgICB0aGlzLmF0ID0gYXRNYXRjaCA/IGF0TWF0Y2hbMV0gOiAndW5rbm93bic7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGVzW25hbWVdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gQ29uZGl0aW9uYWxSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0UnVsZSA9IGZ1bmN0aW9uIGdldFJ1bGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgcmVnaXN0ZXIgcnVsZSwgcnVuIHBsdWdpbnMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGUgPSBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5kZW50ID09IG51bGwpIG9wdGlvbnMuaW5kZW50ID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucy5pbmRlbnQ7XG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT0gbnVsbCkgb3B0aW9ucy5jaGlsZHJlbiA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMuY2hpbGRyZW47XG5cbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5ICsgXCIge31cIjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIHJldHVybiBjaGlsZHJlbiA/IHRoaXMucXVlcnkgKyBcIiB7XFxuXCIgKyBjaGlsZHJlbiArIFwiXFxufVwiIDogJyc7XG4gIH07XG5cbiAgcmV0dXJuIENvbmRpdGlvbmFsUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAgPSAvQG1lZGlhfEBzdXBwb3J0c1xccysvO1xudmFyIHBsdWdpbkNvbmRpdGlvbmFsUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5UmVnRXhwLnRlc3Qoa2V5KSA/IG5ldyBDb25kaXRpb25hbFJ1bGUoa2V5LCBzdHlsZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgfVxufTtcblxudmFyIGRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMSA9IHtcbiAgaW5kZW50OiAxLFxuICBjaGlsZHJlbjogdHJ1ZVxufTtcbnZhciBuYW1lUmVnRXhwID0gL0BrZXlmcmFtZXNcXHMrKFtcXHctXSspLztcbi8qKlxuICogUnVsZSBmb3IgQGtleWZyYW1lc1xuICovXG5cbnZhciBLZXlmcmFtZXNSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gS2V5ZnJhbWVzUnVsZShrZXksIGZyYW1lcywgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdrZXlmcmFtZXMnO1xuICAgIHRoaXMuYXQgPSAnQGtleWZyYW1lcyc7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5ydWxlcyA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB2YXIgbmFtZU1hdGNoID0ga2V5Lm1hdGNoKG5hbWVSZWdFeHApO1xuXG4gICAgaWYgKG5hbWVNYXRjaCAmJiBuYW1lTWF0Y2hbMV0pIHtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWVNYXRjaFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uYW1lID0gJ25vbmFtZSc7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIEJhZCBrZXlmcmFtZXMgbmFtZSBcIiArIGtleSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdGhpcy5rZXkgPSB0aGlzLnR5cGUgKyBcIi1cIiArIHRoaXMubmFtZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzY29wZWQgPSBvcHRpb25zLnNjb3BlZCxcbiAgICAgICAgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBnZW5lcmF0ZUlkID0gb3B0aW9ucy5nZW5lcmF0ZUlkO1xuICAgIHRoaXMuaWQgPSBzY29wZWQgPT09IGZhbHNlID8gdGhpcy5uYW1lIDogZXNjYXBlKGdlbmVyYXRlSWQodGhpcywgc2hlZXQpKTtcbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGZyYW1lcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgZnJhbWVzW25hbWVdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gS2V5ZnJhbWVzUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDE7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5kZW50ID09IG51bGwpIG9wdGlvbnMuaW5kZW50ID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxLmluZGVudDtcbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PSBudWxsKSBvcHRpb25zLmNoaWxkcmVuID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxLmNoaWxkcmVuO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdCArIFwiIFwiICsgdGhpcy5pZCArIFwiIHt9XCI7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICBpZiAoY2hpbGRyZW4pIGNoaWxkcmVuID0gXCJcXG5cIiArIGNoaWxkcmVuICsgXCJcXG5cIjtcbiAgICByZXR1cm4gdGhpcy5hdCArIFwiIFwiICsgdGhpcy5pZCArIFwiIHtcIiArIGNoaWxkcmVuICsgXCJ9XCI7XG4gIH07XG5cbiAgcmV0dXJuIEtleWZyYW1lc1J1bGU7XG59KCk7XG52YXIga2V5UmVnRXhwJDEgPSAvQGtleWZyYW1lc1xccysvO1xudmFyIHJlZlJlZ0V4cCA9IC9cXCQoW1xcdy1dKykvZztcblxudmFyIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUgPSBmdW5jdGlvbiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwga2V5ZnJhbWVzKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWwucmVwbGFjZShyZWZSZWdFeHAsIGZ1bmN0aW9uIChtYXRjaCwgbmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4ga2V5ZnJhbWVzKSB7XG4gICAgICAgIHJldHVybiBrZXlmcmFtZXNbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gUmVmZXJlbmNlZCBrZXlmcmFtZXMgcnVsZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkLlwiKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuLyoqXG4gKiBSZXBsYWNlIHRoZSByZWZlcmVuY2UgZm9yIGEgYW5pbWF0aW9uIG5hbWUuXG4gKi9cblxuXG52YXIgcmVwbGFjZVJlZiA9IGZ1bmN0aW9uIHJlcGxhY2VSZWYoc3R5bGUsIHByb3AsIGtleWZyYW1lcykge1xuICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcbiAgdmFyIHJlZktleWZyYW1lID0gZmluZFJlZmVyZW5jZWRLZXlmcmFtZSh2YWx1ZSwga2V5ZnJhbWVzKTtcblxuICBpZiAocmVmS2V5ZnJhbWUgIT09IHZhbHVlKSB7XG4gICAgc3R5bGVbcHJvcF0gPSByZWZLZXlmcmFtZTtcbiAgfVxufTtcblxudmFyIHBsdWdpbiA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5UmVnRXhwJDEudGVzdChrZXkpID8gbmV3IEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgfSxcbiAgLy8gQW5pbWF0aW9uIG5hbWUgcmVmIHJlcGxhY2VyLlxuICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJyB8fCAhc2hlZXQpIHJldHVybiBzdHlsZTtcbiAgICBpZiAoJ2FuaW1hdGlvbi1uYW1lJyBpbiBzdHlsZSkgcmVwbGFjZVJlZihzdHlsZSwgJ2FuaW1hdGlvbi1uYW1lJywgc2hlZXQua2V5ZnJhbWVzKTtcbiAgICBpZiAoJ2FuaW1hdGlvbicgaW4gc3R5bGUpIHJlcGxhY2VSZWYoc3R5bGUsICdhbmltYXRpb24nLCBzaGVldC5rZXlmcmFtZXMpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgb25DaGFuZ2VWYWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWwsIHByb3AsIHJ1bGUpIHtcbiAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBpZiAoIXNoZWV0KSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgcmV0dXJuIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBzaGVldC5rZXlmcmFtZXMpO1xuXG4gICAgICBjYXNlICdhbmltYXRpb24tbmFtZSc6XG4gICAgICAgIHJldHVybiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwgc2hlZXQua2V5ZnJhbWVzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBLZXlmcmFtZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlU3R5bGVSdWxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKEtleWZyYW1lUnVsZSwgX0Jhc2VTdHlsZVJ1bGUpO1xuXG4gIGZ1bmN0aW9uIEtleWZyYW1lUnVsZSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQmFzZVN0eWxlUnVsZS5jYWxsLmFwcGx5KF9CYXNlU3R5bGVSdWxlLCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEtleWZyYW1lUnVsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYWxsb3dFbXB0eTogdHJ1ZVxuICAgIH0pIDogb3B0aW9ucztcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5rZXksIHRoaXMuc3R5bGUsIG9wdHMpO1xuICB9O1xuXG4gIHJldHVybiBLZXlmcmFtZVJ1bGU7XG59KEJhc2VTdHlsZVJ1bGUpO1xudmFyIHBsdWdpbktleWZyYW1lUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcmV0dXJuIG5ldyBLZXlmcmFtZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnZhciBGb250RmFjZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb250RmFjZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdmb250LWZhY2UnO1xuICAgIHRoaXMuYXQgPSAnQGZvbnQtZmFjZSc7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gRm9udEZhY2VSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zdHlsZSkpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0ciArPSB0b0Nzcyh0aGlzLmF0LCB0aGlzLnN0eWxlW2luZGV4XSk7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlW2luZGV4ICsgMV0pIHN0ciArPSAnXFxuJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9Dc3ModGhpcy5hdCwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIEZvbnRGYWNlUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMiA9IC9AZm9udC1mYWNlLztcbnZhciBwbHVnaW5Gb250RmFjZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5UmVnRXhwJDIudGVzdChrZXkpID8gbmV3IEZvbnRGYWNlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBWaWV3cG9ydFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICd2aWV3cG9ydCc7XG4gICAgdGhpcy5hdCA9ICdAdmlld3BvcnQnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFZpZXdwb3J0UnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0b0Nzcyh0aGlzLmtleSwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFZpZXdwb3J0UnVsZTtcbn0oKTtcbnZhciBwbHVnaW5WaWV3cG9ydFJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5ID09PSAnQHZpZXdwb3J0JyB8fCBrZXkgPT09ICdALW1zLXZpZXdwb3J0JyA/IG5ldyBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgU2ltcGxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpbXBsZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdzaW1wbGUnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuXG4gIHZhciBfcHJvdG8gPSBTaW1wbGVSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMudmFsdWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0ciArPSB0aGlzLmtleSArIFwiIFwiICsgdGhpcy52YWx1ZVtpbmRleF0gKyBcIjtcIjtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVbaW5kZXggKyAxXSkgc3RyICs9ICdcXG4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmtleSArIFwiIFwiICsgdGhpcy52YWx1ZSArIFwiO1wiO1xuICB9O1xuXG4gIHJldHVybiBTaW1wbGVSdWxlO1xufSgpO1xudmFyIGtleXNNYXAgPSB7XG4gICdAY2hhcnNldCc6IHRydWUsXG4gICdAaW1wb3J0JzogdHJ1ZSxcbiAgJ0BuYW1lc3BhY2UnOiB0cnVlXG59O1xudmFyIHBsdWdpblNpbXBsZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5IGluIGtleXNNYXAgPyBuZXcgU2ltcGxlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBwbHVnaW5zID0gW3BsdWdpblN0eWxlUnVsZSwgcGx1Z2luQ29uZGl0aW9uYWxSdWxlLCBwbHVnaW4sIHBsdWdpbktleWZyYW1lUnVsZSwgcGx1Z2luRm9udEZhY2VSdWxlLCBwbHVnaW5WaWV3cG9ydFJ1bGUsIHBsdWdpblNpbXBsZVJ1bGVdO1xuXG52YXIgZGVmYXVsdFVwZGF0ZU9wdGlvbnMgPSB7XG4gIHByb2Nlc3M6IHRydWVcbn07XG52YXIgZm9yY2VVcGRhdGVPcHRpb25zID0ge1xuICBmb3JjZTogdHJ1ZSxcbiAgcHJvY2VzczogdHJ1ZVxuICAvKipcbiAgICogQ29udGFpbnMgcnVsZXMgb2JqZWN0cyBhbmQgYWxsb3dzIGFkZGluZy9yZW1vdmluZyBldGMuXG4gICAqIElzIHVzZWQgZm9yIGUuZy4gYnkgYFN0eWxlU2hlZXRgIG9yIGBDb25kaXRpb25hbFJ1bGVgLlxuICAgKi9cblxufTtcblxudmFyIFJ1bGVMaXN0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gUnVsZXMgcmVnaXN0cnkgZm9yIGFjY2VzcyBieSAuZ2V0KCkgbWV0aG9kLlxuICAvLyBJdCBjb250YWlucyB0aGUgc2FtZSBydWxlIHJlZ2lzdGVyZWQgYnkgbmFtZSBhbmQgYnkgc2VsZWN0b3IuXG4gIC8vIE9yaWdpbmFsIHN0eWxlcyBvYmplY3QuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIGNvcnJlY3QgcnVsZXMgb3JkZXIuXG4gIGZ1bmN0aW9uIFJ1bGVMaXN0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMucmF3ID0ge307XG4gICAgdGhpcy5pbmRleCA9IFtdO1xuICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleWZyYW1lcyA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2xhc3NlcyA9IG9wdGlvbnMuY2xhc3NlcztcbiAgICB0aGlzLmtleWZyYW1lcyA9IG9wdGlvbnMua2V5ZnJhbWVzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUuXG4gICAqXG4gICAqIFdpbGwgbm90IHJlbmRlciBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFJ1bGVMaXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG5hbWUsIGRlY2wsIHJ1bGVPcHRpb25zKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHBhcmVudCA9IF90aGlzJG9wdGlvbnMucGFyZW50LFxuICAgICAgICBzaGVldCA9IF90aGlzJG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGpzcyA9IF90aGlzJG9wdGlvbnMuanNzLFxuICAgICAgICBSZW5kZXJlciA9IF90aGlzJG9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBfdGhpcyRvcHRpb25zLmdlbmVyYXRlSWQsXG4gICAgICAgIHNjb3BlZCA9IF90aGlzJG9wdGlvbnMuc2NvcGVkO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHNoZWV0OiBzaGVldCxcbiAgICAgIGpzczoganNzLFxuICAgICAgUmVuZGVyZXI6IFJlbmRlcmVyLFxuICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZCxcbiAgICAgIHNjb3BlZDogc2NvcGVkLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0sIHJ1bGVPcHRpb25zKTsgLy8gV2hlbiB1c2VyIHVzZXMgLmNyZWF0ZVN0eWxlU2hlZXQoKSwgZHVwbGljYXRlIG5hbWVzIGFyZSBub3QgcG9zc2libGUsIGJ1dFxuICAgIC8vIGBzaGVldC5hZGRSdWxlKClgIG9wZW5zIHRoZSBkb29yIGZvciBhbnkgZHVwbGljYXRlIHJ1bGUgbmFtZS4gV2hlbiB0aGlzIGhhcHBlbnNcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2UgdGhlIGtleSB1bmlxdWUgd2l0aGluIHRoaXMgUnVsZUxpc3QgaW5zdGFuY2Ugc2NvcGUuXG5cblxuICAgIHZhciBrZXkgPSBuYW1lO1xuXG4gICAgaWYgKG5hbWUgaW4gdGhpcy5yYXcpIHtcbiAgICAgIGtleSA9IG5hbWUgKyBcIi1kXCIgKyB0aGlzLmNvdW50ZXIrKztcbiAgICB9IC8vIFdlIG5lZWQgdG8gc2F2ZSB0aGUgb3JpZ2luYWwgZGVjbCBiZWZvcmUgY3JlYXRpbmcgdGhlIHJ1bGVcbiAgICAvLyBiZWNhdXNlIGNhY2hlIHBsdWdpbiBuZWVkcyB0byB1c2UgaXQgYXMgYSBrZXkgdG8gcmV0dXJuIGEgY2FjaGVkIHJ1bGUuXG5cblxuICAgIHRoaXMucmF3W2tleV0gPSBkZWNsO1xuXG4gICAgaWYgKGtleSBpbiB0aGlzLmNsYXNzZXMpIHtcbiAgICAgIC8vIEUuZy4gcnVsZXMgaW5zaWRlIG9mIEBtZWRpYSBjb250YWluZXJcbiAgICAgIG9wdGlvbnMuc2VsZWN0b3IgPSBcIi5cIiArIGVzY2FwZSh0aGlzLmNsYXNzZXNba2V5XSk7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGUgPSBjcmVhdGVSdWxlKGtleSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLnJlZ2lzdGVyKHJ1bGUpO1xuICAgIHZhciBpbmRleCA9IG9wdGlvbnMuaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMuaW5kZXgubGVuZ3RoIDogb3B0aW9ucy5pbmRleDtcbiAgICB0aGlzLmluZGV4LnNwbGljZShpbmRleCwgMCwgcnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW25hbWVdO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUocnVsZSkge1xuICAgIHRoaXMudW5yZWdpc3RlcihydWxlKTtcbiAgICBkZWxldGUgdGhpcy5yYXdbcnVsZS5rZXldO1xuICAgIHRoaXMuaW5kZXguc3BsaWNlKHRoaXMuaW5kZXguaW5kZXhPZihydWxlKSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleC5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBSdW4gYG9uUHJvY2Vzc1J1bGUoKWAgcGx1Z2lucyBvbiBldmVyeSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICB2YXIgcGx1Z2lucyA9IHRoaXMub3B0aW9ucy5qc3MucGx1Z2luczsgLy8gV2UgbmVlZCB0byBjbG9uZSBhcnJheSBiZWNhdXNlIGlmIHdlIG1vZGlmeSB0aGUgaW5kZXggc29tZXdoZXJlIGVsc2UgZHVyaW5nIGEgbG9vcFxuICAgIC8vIHdlIGVuZCB1cCB3aXRoIHZlcnkgaGFyZC10by10cmFjay1kb3duIHNpZGUgZWZmZWN0cy5cblxuICAgIHRoaXMuaW5kZXguc2xpY2UoMCkuZm9yRWFjaChwbHVnaW5zLm9uUHJvY2Vzc1J1bGUsIHBsdWdpbnMpO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHJ1bGUgaW4gYC5tYXBgLCBgLmNsYXNzZXNgIGFuZCBgLmtleWZyYW1lc2AgbWFwcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihydWxlKSB7XG4gICAgdGhpcy5tYXBbcnVsZS5rZXldID0gcnVsZTtcblxuICAgIGlmIChydWxlIGluc3RhbmNlb2YgU3R5bGVSdWxlKSB7XG4gICAgICB0aGlzLm1hcFtydWxlLnNlbGVjdG9yXSA9IHJ1bGU7XG4gICAgICBpZiAocnVsZS5pZCkgdGhpcy5jbGFzc2VzW3J1bGUua2V5XSA9IHJ1bGUuaWQ7XG4gICAgfSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgS2V5ZnJhbWVzUnVsZSAmJiB0aGlzLmtleWZyYW1lcykge1xuICAgICAgdGhpcy5rZXlmcmFtZXNbcnVsZS5uYW1lXSA9IHJ1bGUuaWQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIocnVsZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtydWxlLmtleV07XG5cbiAgICBpZiAocnVsZSBpbnN0YW5jZW9mIFN0eWxlUnVsZSkge1xuICAgICAgZGVsZXRlIHRoaXMubWFwW3J1bGUuc2VsZWN0b3JdO1xuICAgICAgZGVsZXRlIHRoaXMuY2xhc3Nlc1tydWxlLmtleV07XG4gICAgfSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgS2V5ZnJhbWVzUnVsZSkge1xuICAgICAgZGVsZXRlIHRoaXMua2V5ZnJhbWVzW3J1bGUubmFtZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgb3B0aW9ucztcblxuICAgIGlmICh0eXBlb2YgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07IC8vICRGbG93Rml4TWVcblxuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICAgICAgbmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHRoaXMudXBkYXRlT25lKHRoaXMubWFwW25hbWVdLCBkYXRhLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuaW5kZXgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHRoaXMudXBkYXRlT25lKHRoaXMuaW5kZXhbaW5kZXhdLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgcGx1Z2lucywgdXBkYXRlIHJ1bGUgcHJvcHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShydWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRVcGRhdGVPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRvcHRpb25zMiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcGx1Z2lucyA9IF90aGlzJG9wdGlvbnMyLmpzcy5wbHVnaW5zLFxuICAgICAgICBzaGVldCA9IF90aGlzJG9wdGlvbnMyLnNoZWV0OyAvLyBJdCBpcyBhIHJ1bGVzIGNvbnRhaW5lciBsaWtlIGZvciBlLmcuIENvbmRpdGlvbmFsUnVsZS5cblxuICAgIGlmIChydWxlLnJ1bGVzIGluc3RhbmNlb2YgUnVsZUxpc3QpIHtcbiAgICAgIHJ1bGUucnVsZXMudXBkYXRlKGRhdGEsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlO1xuICAgIHZhciBzdHlsZSA9IHN0eWxlUnVsZS5zdHlsZTtcbiAgICBwbHVnaW5zLm9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKTsgLy8gV2UgcmVseSBvbiBhIG5ldyBgc3R5bGVgIHJlZiBpbiBjYXNlIGl0IHdhcyBtdXRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLlxuXG4gICAgaWYgKG9wdGlvbnMucHJvY2VzcyAmJiBzdHlsZSAmJiBzdHlsZSAhPT0gc3R5bGVSdWxlLnN0eWxlKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHJ1biB0aGUgcGx1Z2lucyBpbiBjYXNlIG5ldyBgc3R5bGVgIHJlbGllcyBvbiBzeW50YXggcGx1Z2lucy5cbiAgICAgIHBsdWdpbnMub25Qcm9jZXNzU3R5bGUoc3R5bGVSdWxlLnN0eWxlLCBzdHlsZVJ1bGUsIHNoZWV0KTsgLy8gVXBkYXRlIGFuZCBhZGQgcHJvcHMuXG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGVSdWxlLnN0eWxlKSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBzdHlsZVJ1bGUuc3R5bGVbcHJvcF07XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBzdHlsZVtwcm9wXTsgLy8gV2UgbmVlZCB0byB1c2UgYGZvcmNlOiB0cnVlYCBiZWNhdXNlIGBydWxlLnN0eWxlYCBoYXMgYmVlbiB1cGRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLCBzbyBgcnVsZS5wcm9wKClgIHdpbGwgbm90IHVwZGF0ZSB0aGUgQ1NTT00gcnVsZS5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBjb21wYXJpc29uIHRvIGF2b2lkIHVubmVlZGVkIGBydWxlLnByb3AoKWAgY2FsbHMsIHNpbmNlIHdlIGhhdmUgdGhlIG9sZCBgc3R5bGVgIG9iamVjdCBoZXJlLlxuXG4gICAgICAgIGlmIChuZXh0VmFsdWUgIT09IHByZXZWYWx1ZSkge1xuICAgICAgICAgIHN0eWxlUnVsZS5wcm9wKHByb3AsIG5leHRWYWx1ZSwgZm9yY2VVcGRhdGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZW1vdmUgcHJvcHMuXG5cblxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgdmFyIF9uZXh0VmFsdWUgPSBzdHlsZVJ1bGUuc3R5bGVbX3Byb3BdO1xuICAgICAgICB2YXIgX3ByZXZWYWx1ZSA9IHN0eWxlW19wcm9wXTsgLy8gV2UgbmVlZCB0byB1c2UgYGZvcmNlOiB0cnVlYCBiZWNhdXNlIGBydWxlLnN0eWxlYCBoYXMgYmVlbiB1cGRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLCBzbyBgcnVsZS5wcm9wKClgIHdpbGwgbm90IHVwZGF0ZSB0aGUgQ1NTT00gcnVsZS5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBjb21wYXJpc29uIHRvIGF2b2lkIHVubmVlZGVkIGBydWxlLnByb3AoKWAgY2FsbHMsIHNpbmNlIHdlIGhhdmUgdGhlIG9sZCBgc3R5bGVgIG9iamVjdCBoZXJlLlxuXG4gICAgICAgIGlmIChfbmV4dFZhbHVlID09IG51bGwgJiYgX25leHRWYWx1ZSAhPT0gX3ByZXZWYWx1ZSkge1xuICAgICAgICAgIHN0eWxlUnVsZS5wcm9wKF9wcm9wLCBudWxsLCBmb3JjZVVwZGF0ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcbiAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbmRleC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5pbmRleFtpbmRleF07XG4gICAgICB2YXIgY3NzID0gcnVsZS50b1N0cmluZyhvcHRpb25zKTsgLy8gTm8gbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgcnVsZS5cblxuICAgICAgaWYgKCFjc3MgJiYgIWxpbmspIGNvbnRpbnVlO1xuICAgICAgaWYgKHN0cikgc3RyICs9ICdcXG4nO1xuICAgICAgc3RyICs9IGNzcztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHJldHVybiBSdWxlTGlzdDtcbn0oKTtcblxudmFyIFN0eWxlU2hlZXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVNoZWV0KHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcGxveWVkID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0YWNoZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5ydWxlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbmRlcmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleWZyYW1lcyA9IHZvaWQgMDtcbiAgICB0aGlzLnF1ZXVlID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgdGhpcy5jbGFzc2VzID0ge307XG4gICAgdGhpcy5rZXlmcmFtZXMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2hlZXQ6IHRoaXMsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBrZXlmcmFtZXM6IHRoaXMua2V5ZnJhbWVzXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5SZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBvcHRpb25zLlJlbmRlcmVyKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QodGhpcy5vcHRpb25zKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2ggcmVuZGVyYWJsZSB0byB0aGUgcmVuZGVyIHRyZWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHJldHVybiB0aGlzO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmF0dGFjaCgpO1xuICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlOyAvLyBPcmRlciBpcyBpbXBvcnRhbnQsIGJlY2F1c2Ugd2UgY2FuJ3QgdXNlIGluc2VydFJ1bGUgQVBJIGlmIHN0eWxlIGVsZW1lbnQgaXMgbm90IGF0dGFjaGVkLlxuXG4gICAgaWYgKCF0aGlzLmRlcGxveWVkKSB0aGlzLmRlcGxveSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgcmVuZGVyYWJsZSBmcm9tIHJlbmRlciB0cmVlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgaWYgKCF0aGlzLmF0dGFjaGVkKSByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5kZXRhY2goKTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIHJ1bGUgdG8gdGhlIGN1cnJlbnQgc3R5bGVzaGVldC5cbiAgICogV2lsbCBpbnNlcnQgYSBydWxlIGFsc28gYWZ0ZXIgdGhlIHN0eWxlc2hlZXQgaGFzIGJlZW4gcmVuZGVyZWQgZmlyc3QgdGltZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7IC8vIFBsdWdpbnMgY2FuIGNyZWF0ZSBydWxlcy5cbiAgICAvLyBJbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgcmlnaHQgb3JkZXIsIHdlIG5lZWQgdG8gcXVldWUgYWxsIGAuYWRkUnVsZWAgY2FsbHMsXG4gICAgLy8gd2hpY2ggaGFwcGVuIGFmdGVyIHRoZSBmaXJzdCBgcnVsZXMuYWRkKClgIGNhbGwuXG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhcXVldWUpIHRoaXMucXVldWUgPSBbXTtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKCF0aGlzLmRlcGxveWVkKSByZXR1cm4gcnVsZTsgLy8gRG9uJ3QgaW5zZXJ0IHJ1bGUgZGlyZWN0bHkgaWYgdGhlcmUgaXMgbm8gc3RyaW5naWZpZWQgdmVyc2lvbiB5ZXQuXG4gICAgICAvLyBJdCB3aWxsIGJlIGluc2VydGVkIGFsbCB0b2dldGhlciB3aGVuIC5hdHRhY2ggaXMgY2FsbGVkLlxuXG4gICAgICBpZiAocXVldWUpIHF1ZXVlLnB1c2gocnVsZSk7ZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcblxuICAgICAgICBpZiAodGhpcy5xdWV1ZSkge1xuICAgICAgICAgIHRoaXMucXVldWUuZm9yRWFjaCh0aGlzLmluc2VydFJ1bGUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMucXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0gLy8gV2UgY2FuJ3QgYWRkIHJ1bGVzIHRvIGEgZGV0YWNoZWQgc3R5bGUgbm9kZS5cbiAgICAvLyBXZSB3aWxsIHJlZGVwbG95IHRoZSBzaGVldCBvbmNlIHVzZXIgd2lsbCBhdHRhY2ggaXQuXG5cblxuICAgIHRoaXMuZGVwbG95ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHJ1bGUgaW50byB0aGUgU3R5bGVTaGVldFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuaW5zZXJ0UnVsZShydWxlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgYWRkIHJ1bGVzLlxuICAgKiBXaWxsIHJlbmRlciBhbHNvIGFmdGVyIFN0eWxlIFNoZWV0IHdhcyByZW5kZXJlZCB0aGUgZmlyc3QgdGltZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZXMgPSBmdW5jdGlvbiBhZGRSdWxlcyhzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgYWRkZWQgPSBbXTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMuYWRkUnVsZShuYW1lLCBzdHlsZXNbbmFtZV0sIG9wdGlvbnMpO1xuICAgICAgaWYgKHJ1bGUpIGFkZGVkLnB1c2gocnVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZGVkO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlIGJ5IG5hbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUgYnkgbmFtZS5cbiAgICogUmV0dXJucyBgdHJ1ZWA6IGlmIHJ1bGUgaGFzIGJlZW4gZGVsZXRlZCBmcm9tIHRoZSBET00uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKG5hbWUpIHtcbiAgICB2YXIgcnVsZSA9IHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyA/IG5hbWUgOiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLnJ1bGVzLnJlbW92ZShydWxlKTtcblxuICAgIGlmICh0aGlzLmF0dGFjaGVkICYmIHJ1bGUucmVuZGVyYWJsZSAmJiB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5kZWxldGVSdWxlKHJ1bGUucmVuZGVyYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBEZXBsb3kgcHVyZSBDU1Mgc3RyaW5nIHRvIGEgcmVuZGVyYWJsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVwbG95ID0gZnVuY3Rpb24gZGVwbG95KCkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmRlcGxveSgpO1xuICAgIHRoaXMuZGVwbG95ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkcnVsZXM7XG5cbiAgICAoX3RoaXMkcnVsZXMgPSB0aGlzLnJ1bGVzKS51cGRhdGUuYXBwbHkoX3RoaXMkcnVsZXMsIGFyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhIHNpbmdsZSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUocnVsZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMucnVsZXMudXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbnZhciBQbHVnaW5zUmVnaXN0cnkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbHVnaW5zUmVnaXN0cnkoKSB7XG4gICAgdGhpcy5wbHVnaW5zID0ge1xuICAgICAgaW50ZXJuYWw6IFtdLFxuICAgICAgZXh0ZXJuYWw6IFtdXG4gICAgfTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gdm9pZCAwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBsdWdpbnNSZWdpc3RyeS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIENhbGwgYG9uQ3JlYXRlUnVsZWAgaG9va3MgYW5kIHJldHVybiBhbiBvYmplY3QgaWYgcmV0dXJuZWQgYnkgYSBob29rLlxuICAgKi9cbiAgX3Byb3RvLm9uQ3JlYXRlUnVsZSA9IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uQ3JlYXRlUnVsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJlZ2lzdHJ5Lm9uQ3JlYXRlUnVsZVtpXShuYW1lLCBkZWNsLCBvcHRpb25zKTtcbiAgICAgIGlmIChydWxlKSByZXR1cm4gcnVsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzUnVsZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uUHJvY2Vzc1J1bGUgPSBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUpIHtcbiAgICBpZiAocnVsZS5pc1Byb2Nlc3NlZCkgcmV0dXJuO1xuICAgIHZhciBzaGVldCA9IHJ1bGUub3B0aW9ucy5zaGVldDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NSdWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1J1bGVbaV0ocnVsZSwgc2hlZXQpO1xuICAgIH1cblxuICAgIGlmIChydWxlLnN0eWxlKSB0aGlzLm9uUHJvY2Vzc1N0eWxlKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTtcbiAgICBydWxlLmlzUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzU3R5bGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NTdHlsZSA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgcnVsZS5zdHlsZSA9IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU3R5bGVbaV0ocnVsZS5zdHlsZSwgcnVsZSwgc2hlZXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzU2hlZXRgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NTaGVldCA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1NoZWV0KHNoZWV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1NoZWV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1NoZWV0W2ldKHNoZWV0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uVXBkYXRlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblVwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblVwZGF0ZVtpXShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvbkNoYW5nZVZhbHVlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25DaGFuZ2VWYWx1ZSA9IGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3AsIHJ1bGUpIHtcbiAgICB2YXIgcHJvY2Vzc2VkVmFsdWUgPSB2YWx1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vbkNoYW5nZVZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9jZXNzZWRWYWx1ZSA9IHRoaXMucmVnaXN0cnkub25DaGFuZ2VWYWx1ZVtpXShwcm9jZXNzZWRWYWx1ZSwgcHJvcCwgcnVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2Nlc3NlZFZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHBsdWdpbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKG5ld1BsdWdpbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHF1ZXVlOiAnZXh0ZXJuYWwnXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwbHVnaW5zID0gdGhpcy5wbHVnaW5zW29wdGlvbnMucXVldWVdOyAvLyBBdm9pZHMgYXBwbHlpbmcgc2FtZSBwbHVnaW4gdHdpY2UsIGF0IGxlYXN0IGJhc2VkIG9uIHJlZi5cblxuICAgIGlmIChwbHVnaW5zLmluZGV4T2YobmV3UGx1Z2luKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwbHVnaW5zLnB1c2gobmV3UGx1Z2luKTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gW10uY29uY2F0KHRoaXMucGx1Z2lucy5leHRlcm5hbCwgdGhpcy5wbHVnaW5zLmludGVybmFsKS5yZWR1Y2UoZnVuY3Rpb24gKHJlZ2lzdHJ5LCBwbHVnaW4pIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcGx1Z2luKSB7XG4gICAgICAgIGlmIChuYW1lIGluIHJlZ2lzdHJ5KSB7XG4gICAgICAgICAgcmVnaXN0cnlbbmFtZV0ucHVzaChwbHVnaW5bbmFtZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gVW5rbm93biBob29rIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdpc3RyeTtcbiAgICB9LCB7XG4gICAgICBvbkNyZWF0ZVJ1bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzUnVsZTogW10sXG4gICAgICBvblByb2Nlc3NTdHlsZTogW10sXG4gICAgICBvblByb2Nlc3NTaGVldDogW10sXG4gICAgICBvbkNoYW5nZVZhbHVlOiBbXSxcbiAgICAgIG9uVXBkYXRlOiBbXVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBQbHVnaW5zUmVnaXN0cnk7XG59KCk7XG5cbi8qKlxuICogU2hlZXRzIHJlZ2lzdHJ5IHRvIGFjY2VzcyB0aGVtIGFsbCBhdCBvbmUgcGxhY2UuXG4gKi9cbnZhciBTaGVldHNSZWdpc3RyeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNoZWV0c1JlZ2lzdHJ5KCkge1xuICAgIHRoaXMucmVnaXN0cnkgPSBbXTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTaGVldHNSZWdpc3RyeS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgU3R5bGUgU2hlZXQuXG4gICAqL1xuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHNoZWV0KSB7XG4gICAgdmFyIHJlZ2lzdHJ5ID0gdGhpcy5yZWdpc3RyeTtcbiAgICB2YXIgaW5kZXggPSBzaGVldC5vcHRpb25zLmluZGV4O1xuICAgIGlmIChyZWdpc3RyeS5pbmRleE9mKHNoZWV0KSAhPT0gLTEpIHJldHVybjtcblxuICAgIGlmIChyZWdpc3RyeS5sZW5ndGggPT09IDAgfHwgaW5kZXggPj0gdGhpcy5pbmRleCkge1xuICAgICAgcmVnaXN0cnkucHVzaChzaGVldCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGaW5kIGEgcG9zaXRpb24uXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWdpc3RyeVtpXS5vcHRpb25zLmluZGV4ID4gaW5kZXgpIHtcbiAgICAgICAgcmVnaXN0cnkuc3BsaWNlKGksIDAsIHNoZWV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzZXQgdGhlIHJlZ2lzdHJ5LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMucmVnaXN0cnkgPSBbXTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgU3R5bGUgU2hlZXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShzaGVldCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMucmVnaXN0cnkuaW5kZXhPZihzaGVldCk7XG4gICAgdGhpcy5yZWdpc3RyeS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IGFsbCBhdHRhY2hlZCBzaGVldHMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKF90ZW1wKSB7XG4gICAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgYXR0YWNoZWQgPSBfcmVmLmF0dGFjaGVkLFxuICAgICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiYXR0YWNoZWRcIl0pO1xuXG4gICAgdmFyIGNzcyA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2hlZXQgPSB0aGlzLnJlZ2lzdHJ5W2ldO1xuXG4gICAgICBpZiAoYXR0YWNoZWQgIT0gbnVsbCAmJiBzaGVldC5hdHRhY2hlZCAhPT0gYXR0YWNoZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjc3MpIGNzcyArPSAnXFxuJztcbiAgICAgIGNzcyArPSBzaGVldC50b1N0cmluZyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTaGVldHNSZWdpc3RyeSwgW3tcbiAgICBrZXk6IFwiaW5kZXhcIixcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGlnaGVzdCBpbmRleCBudW1iZXIuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5sZW5ndGggPT09IDAgPyAwIDogdGhpcy5yZWdpc3RyeVt0aGlzLnJlZ2lzdHJ5Lmxlbmd0aCAtIDFdLm9wdGlvbnMuaW5kZXg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoZWV0c1JlZ2lzdHJ5O1xufSgpO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBnbG9iYWwgc2hlZXRzIHJlZ2lzdHJ5LiBPbmx5IERvbVJlbmRlcmVyIHdpbGwgYWRkIHNoZWV0cyB0byBpdC5cbiAqIE9uIHRoZSBzZXJ2ZXIgb25lIHNob3VsZCB1c2UgYW4gb3duIFNoZWV0c1JlZ2lzdHJ5IGluc3RhbmNlIGFuZCBhZGQgdGhlXG4gKiBzaGVldHMgdG8gaXQsIGJlY2F1c2UgeW91IG5lZWQgdG8gbWFrZSBzdXJlIHRvIGNyZWF0ZSBhIG5ldyByZWdpc3RyeSBmb3JcbiAqIGVhY2ggcmVxdWVzdCBpbiBvcmRlciB0byBub3QgbGVhayBzaGVldHMgYWNyb3NzIHJlcXVlc3RzLlxuICovXG5cbnZhciBzaGVldHMgPSBuZXcgU2hlZXRzUmVnaXN0cnkoKTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsVGhpcyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aCA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBucyA9ICcyZjFhY2M2YzNhNjA2YjA4MmU1ZWVmNWU1NDQxNGZmYic7XG5pZiAoZ2xvYmFsVGhpc1tuc10gPT0gbnVsbCkgZ2xvYmFsVGhpc1tuc10gPSAwOyAvLyBCdW5kbGUgbWF5IGNvbnRhaW4gbXVsdGlwbGUgSlNTIHZlcnNpb25zIGF0IHRoZSBzYW1lIHRpbWUuIEluIG9yZGVyIHRvIGlkZW50aWZ5XG4vLyB0aGUgY3VycmVudCB2ZXJzaW9uIHdpdGgganVzdCBvbmUgc2hvcnQgbnVtYmVyIGFuZCB1c2UgaXQgZm9yIGNsYXNzZXMgZ2VuZXJhdGlvblxuLy8gd2UgdXNlIGEgY291bnRlci4gQWxzbyBpdCBpcyBtb3JlIGFjY3VyYXRlLCBiZWNhdXNlIHVzZXIgY2FuIG1hbnVhbGx5IHJlZXZhbHVhdGVcbi8vIHRoZSBtb2R1bGUuXG5cbnZhciBtb2R1bGVJZCA9IGdsb2JhbFRoaXNbbnNdKys7XG5cbnZhciBtYXhSdWxlcyA9IDFlMTA7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyB1bmlxdWUgY2xhc3MgbmFtZXMgYmFzZWQgb24gY291bnRlcnMuXG4gKiBXaGVuIG5ldyBnZW5lcmF0b3IgZnVuY3Rpb24gaXMgY3JlYXRlZCwgcnVsZSBjb3VudGVyIGlzIHJlc2V0ZWQuXG4gKiBXZSBuZWVkIHRvIHJlc2V0IHRoZSBydWxlIGNvdW50ZXIgZm9yIFNTUiBmb3IgZWFjaCByZXF1ZXN0LlxuICovXG52YXIgY3JlYXRlR2VuZXJhdGVJZCA9IGZ1bmN0aW9uIGNyZWF0ZUdlbmVyYXRlSWQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHJ1bGVDb3VudGVyID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChydWxlLCBzaGVldCkge1xuICAgIHJ1bGVDb3VudGVyICs9IDE7XG5cbiAgICBpZiAocnVsZUNvdW50ZXIgPiBtYXhSdWxlcykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBZb3UgbWlnaHQgaGF2ZSBhIG1lbW9yeSBsZWFrLiBSdWxlIGNvdW50ZXIgaXMgYXQgXCIgKyBydWxlQ291bnRlciArIFwiLlwiKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIganNzSWQgPSAnJztcbiAgICB2YXIgcHJlZml4ID0gJyc7XG5cbiAgICBpZiAoc2hlZXQpIHtcbiAgICAgIGlmIChzaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeCkge1xuICAgICAgICBwcmVmaXggPSBzaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoZWV0Lm9wdGlvbnMuanNzLmlkICE9IG51bGwpIHtcbiAgICAgICAganNzSWQgPSBTdHJpbmcoc2hlZXQub3B0aW9ucy5qc3MuaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1pbmlmeSkge1xuICAgICAgLy8gVXNpbmcgXCJjXCIgYmVjYXVzZSBhIG51bWJlciBjYW4ndCBiZSB0aGUgZmlyc3QgY2hhciBpbiBhIGNsYXNzIG5hbWUuXG4gICAgICByZXR1cm4gXCJcIiArIChwcmVmaXggfHwgJ2MnKSArIG1vZHVsZUlkICsganNzSWQgKyBydWxlQ291bnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4ICsgcnVsZS5rZXkgKyBcIi1cIiArIG1vZHVsZUlkICsgKGpzc0lkID8gXCItXCIgKyBqc3NJZCA6ICcnKSArIFwiLVwiICsgcnVsZUNvdW50ZXI7XG4gIH07XG59O1xuXG4vKipcbiAqIENhY2hlIHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCB0aW1lIGEgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICovXG52YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgdmFyIHZhbHVlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdmFsdWUpIHZhbHVlID0gZm4oKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59O1xuLyoqXG4gKiBHZXQgYSBzdHlsZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5VmFsdWUoY3NzUnVsZSwgcHJvcCkge1xuICB0cnkge1xuICAgIC8vIFN1cHBvcnQgQ1NTVE9NLlxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICByZXR1cm4gY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5nZXQocHJvcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzc1J1bGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSUUgbWF5IHRocm93IGlmIHByb3BlcnR5IGlzIHVua25vd24uXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFNldCBhIHN0eWxlIHByb3BlcnR5LlxuICovXG5cblxuZnVuY3Rpb24gc2V0UHJvcGVydHkoY3NzUnVsZSwgcHJvcCwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgY3NzVmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY3NzVmFsdWUgPSB0b0Nzc1ZhbHVlKHZhbHVlLCB0cnVlKTtcblxuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnIWltcG9ydGFudCcpIHtcbiAgICAgICAgY3NzUnVsZS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBjc3NWYWx1ZSwgJ2ltcG9ydGFudCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIFN1cHBvcnQgQ1NTVE9NLlxuXG5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5zZXQocHJvcCwgY3NzVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjc3NSdWxlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIGNzc1ZhbHVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElFIG1heSB0aHJvdyBpZiBwcm9wZXJ0eSBpcyB1bmtub3duLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBSZW1vdmUgYSBzdHlsZSBwcm9wZXJ0eS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbW92ZVByb3BlcnR5KGNzc1J1bGUsIHByb3ApIHtcbiAgdHJ5IHtcbiAgICAvLyBTdXBwb3J0IENTU1RPTS5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5kZWxldGUocHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzc1J1bGUuc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIERPTUV4Y2VwdGlvbiBcXFwiXCIgKyBlcnIubWVzc2FnZSArIFwiXFxcIiB3YXMgdGhyb3duLiBUcmllZCB0byByZW1vdmUgcHJvcGVydHkgXFxcIlwiICsgcHJvcCArIFwiXFxcIi5cIikgOiB2b2lkIDA7XG4gIH1cbn1cbi8qKlxuICogU2V0IHRoZSBzZWxlY3Rvci5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFNlbGVjdG9yKGNzc1J1bGUsIHNlbGVjdG9yVGV4dCkge1xuICBjc3NSdWxlLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dDsgLy8gUmV0dXJuIGZhbHNlIGlmIHNldHRlciB3YXMgbm90IHN1Y2Nlc3NmdWwuXG4gIC8vIEN1cnJlbnRseSB3b3JrcyBpbiBjaHJvbWUgb25seS5cblxuICByZXR1cm4gY3NzUnVsZS5zZWxlY3RvclRleHQgPT09IHNlbGVjdG9yVGV4dDtcbn1cbi8qKlxuICogR2V0cyB0aGUgYGhlYWRgIGVsZW1lbnQgdXBvbiB0aGUgZmlyc3QgY2FsbCBhbmQgY2FjaGVzIGl0LlxuICogV2UgYXNzdW1lIGl0IGNhbid0IGJlIG51bGwuXG4gKi9cblxuXG52YXIgZ2V0SGVhZCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xufSk7XG4vKipcbiAqIEZpbmQgYXR0YWNoZWQgc2hlZXQgd2l0aCBhbiBpbmRleCBoaWdoZXIgdGhhbiB0aGUgcGFzc2VkIG9uZS5cbiAqL1xuXG5mdW5jdGlvbiBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzaGVldCA9IHJlZ2lzdHJ5W2ldO1xuXG4gICAgaWYgKHNoZWV0LmF0dGFjaGVkICYmIHNoZWV0Lm9wdGlvbnMuaW5kZXggPiBvcHRpb25zLmluZGV4ICYmIHNoZWV0Lm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPT09IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQpIHtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRmluZCBhdHRhY2hlZCBzaGVldCB3aXRoIHRoZSBoaWdoZXN0IGluZGV4LlxuICovXG5cblxuZnVuY3Rpb24gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gcmVnaXN0cnkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgc2hlZXQgPSByZWdpc3RyeVtpXTtcblxuICAgIGlmIChzaGVldC5hdHRhY2hlZCAmJiBzaGVldC5vcHRpb25zLmluc2VydGlvblBvaW50ID09PSBvcHRpb25zLmluc2VydGlvblBvaW50KSB7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEZpbmQgYSBjb21tZW50IHdpdGggXCJqc3NcIiBpbnNpZGUuXG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kQ29tbWVudE5vZGUodGV4dCkge1xuICB2YXIgaGVhZCA9IGdldEhlYWQoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gaGVhZC5jaGlsZE5vZGVzW2ldO1xuXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kIGEgbm9kZSBiZWZvcmUgd2hpY2ggd2UgY2FuIGluc2VydCB0aGUgc2hlZXQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQcmV2Tm9kZShvcHRpb25zKSB7XG4gIHZhciByZWdpc3RyeSA9IHNoZWV0cy5yZWdpc3RyeTtcblxuICBpZiAocmVnaXN0cnkubGVuZ3RoID4gMCkge1xuICAgIC8vIFRyeSB0byBpbnNlcnQgYmVmb3JlIHRoZSBuZXh0IGhpZ2hlciBzaGVldC5cbiAgICB2YXIgc2hlZXQgPSBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogc2hlZXQucmVuZGVyZXIuZWxlbWVudFxuICAgICAgfTtcbiAgICB9IC8vIE90aGVyd2lzZSBpbnNlcnQgYWZ0ZXIgdGhlIGxhc3QgYXR0YWNoZWQuXG5cblxuICAgIHNoZWV0ID0gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoc2hlZXQgJiYgc2hlZXQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBzaGVldC5yZW5kZXJlci5lbGVtZW50Lm5leHRTaWJsaW5nXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBUcnkgdG8gZmluZCBhIGNvbW1lbnQgcGxhY2Vob2xkZXIgaWYgcmVnaXN0cnkgaXMgZW1wdHkuXG5cblxuICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuXG4gIGlmIChpbnNlcnRpb25Qb2ludCAmJiB0eXBlb2YgaW5zZXJ0aW9uUG9pbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGNvbW1lbnQgPSBmaW5kQ29tbWVudE5vZGUoaW5zZXJ0aW9uUG9pbnQpO1xuXG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogY29tbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBjb21tZW50Lm5leHRTaWJsaW5nXG4gICAgICB9O1xuICAgIH0gLy8gSWYgdXNlciBzcGVjaWZpZXMgYW4gaW5zZXJ0aW9uIHBvaW50IGFuZCBpdCBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgZG9jdW1lbnQgLVxuICAgIC8vIGJhZCBzcGVjaWZpY2l0eSBpc3N1ZXMgbWF5IGFwcGVhci5cblxuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBJbnNlcnRpb24gcG9pbnQgXFxcIlwiICsgaW5zZXJ0aW9uUG9pbnQgKyBcIlxcXCIgbm90IGZvdW5kLlwiKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogSW5zZXJ0IHN0eWxlIGVsZW1lbnQgaW50byB0aGUgRE9NLlxuICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGUoc3R5bGUsIG9wdGlvbnMpIHtcbiAgdmFyIGluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcbiAgdmFyIG5leHROb2RlID0gZmluZFByZXZOb2RlKG9wdGlvbnMpO1xuXG4gIGlmIChuZXh0Tm9kZSAhPT0gZmFsc2UgJiYgbmV4dE5vZGUucGFyZW50KSB7XG4gICAgbmV4dE5vZGUucGFyZW50Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dE5vZGUubm9kZSk7XG4gICAgcmV0dXJuO1xuICB9IC8vIFdvcmtzIHdpdGggaWZyYW1lcyBhbmQgYW55IG5vZGUgdHlwZXMuXG5cblxuICBpZiAoaW5zZXJ0aW9uUG9pbnQgJiYgdHlwZW9mIGluc2VydGlvblBvaW50Lm5vZGVUeXBlID09PSAnbnVtYmVyJykge1xuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQxMzI4NzI4L2ZvcmNlLWNhc3RpbmctaW4tZmxvd1xuICAgIHZhciBpbnNlcnRpb25Qb2ludEVsZW1lbnQgPSBpbnNlcnRpb25Qb2ludDtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGluc2VydGlvblBvaW50RWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLmluc2VydEJlZm9yZShzdHlsZSwgaW5zZXJ0aW9uUG9pbnRFbGVtZW50Lm5leHRTaWJsaW5nKTtlbHNlIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdbSlNTXSBJbnNlcnRpb24gcG9pbnQgaXMgbm90IGluIHRoZSBET00uJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cbi8qKlxuICogUmVhZCBqc3Mgbm9uY2Ugc2V0dGluZyBmcm9tIHRoZSBwYWdlIGlmIHRoZSB1c2VyIGhhcyBzZXQgaXQuXG4gKi9cblxuXG52YXIgZ2V0Tm9uY2UgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW3Byb3BlcnR5PVwiY3NwLW5vbmNlXCJdJyk7XG4gIHJldHVybiBub2RlID8gbm9kZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSA6IG51bGw7XG59KTtcblxudmFyIF9pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShjb250YWluZXIsIHJ1bGUsIGluZGV4KSB7XG4gIHZhciBtYXhJbmRleCA9IGNvbnRhaW5lci5jc3NSdWxlcy5sZW5ndGg7IC8vIEluIGNhc2UgcHJldmlvdXMgaW5zZXJ0aW9uIGZhaWxzLCBwYXNzZWQgaW5kZXggbWlnaHQgYmUgd3JvbmdcblxuICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA+IG1heEluZGV4KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgaW5kZXggPSBtYXhJbmRleDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKCdpbnNlcnRSdWxlJyBpbiBjb250YWluZXIpIHtcbiAgICAgIHZhciBjID0gY29udGFpbmVyO1xuICAgICAgYy5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICB9IC8vIEtleWZyYW1lcyBydWxlLlxuICAgIGVsc2UgaWYgKCdhcHBlbmRSdWxlJyBpbiBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIF9jID0gY29udGFpbmVyO1xuXG4gICAgICAgIF9jLmFwcGVuZFJ1bGUocnVsZSk7XG4gICAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gXCIgKyBlcnIubWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5jc3NSdWxlc1tpbmRleF07XG59O1xuXG52YXIgY3JlYXRlU3R5bGUgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZSgpIHtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTsgLy8gV2l0aG91dCBpdCwgSUUgd2lsbCBoYXZlIGEgYnJva2VuIHNvdXJjZSBvcmRlciBzcGVjaWZpY2l0eSBpZiB3ZVxuICAvLyBpbnNlcnQgcnVsZXMgYWZ0ZXIgd2UgaW5zZXJ0IHRoZSBzdHlsZSB0YWcuXG4gIC8vIEl0IHNlZW1zIHRvIGtpY2stb2ZmIHRoZSBzb3VyY2Ugb3JkZXIgc3BlY2lmaWNpdHkgYWxnb3JpdGhtLlxuXG4gIGVsLnRleHRDb250ZW50ID0gJ1xcbic7XG4gIHJldHVybiBlbDtcbn07XG5cbnZhciBEb21SZW5kZXJlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8vIEhUTUxTdHlsZUVsZW1lbnQgbmVlZHMgZml4aW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yNjk2XG4gIGZ1bmN0aW9uIERvbVJlbmRlcmVyKHNoZWV0KSB7XG4gICAgdGhpcy5nZXRQcm9wZXJ0eVZhbHVlID0gZ2V0UHJvcGVydHlWYWx1ZTtcbiAgICB0aGlzLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG4gICAgdGhpcy5yZW1vdmVQcm9wZXJ0eSA9IHJlbW92ZVByb3BlcnR5O1xuICAgIHRoaXMuc2V0U2VsZWN0b3IgPSBzZXRTZWxlY3RvcjtcbiAgICB0aGlzLmVsZW1lbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5zaGVldCA9IHZvaWQgMDtcbiAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICAvLyBUaGVyZSBpcyBubyBzaGVldCB3aGVuIHRoZSByZW5kZXJlciBpcyB1c2VkIGZyb20gYSBzdGFuZGFsb25lIFN0eWxlUnVsZS5cbiAgICBpZiAoc2hlZXQpIHNoZWV0cy5hZGQoc2hlZXQpO1xuICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcblxuICAgIHZhciBfcmVmID0gdGhpcy5zaGVldCA/IHRoaXMuc2hlZXQub3B0aW9ucyA6IHt9LFxuICAgICAgICBtZWRpYSA9IF9yZWYubWVkaWEsXG4gICAgICAgIG1ldGEgPSBfcmVmLm1ldGEsXG4gICAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50IHx8IGNyZWF0ZVN0eWxlKCk7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1qc3MnLCAnJyk7XG4gICAgaWYgKG1lZGlhKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgICBpZiAobWV0YSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1tZXRhJywgbWV0YSk7XG4gICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgICBpZiAobm9uY2UpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgc3R5bGUgZWxlbWVudCBpbnRvIHJlbmRlciB0cmVlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBEb21SZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmF0dGFjaCA9IGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAvLyBJbiB0aGUgY2FzZSB0aGUgZWxlbWVudCBub2RlIGlzIGV4dGVybmFsIGFuZCBpdCBpcyBhbHJlYWR5IGluIHRoZSBET00uXG4gICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnROb2RlIHx8ICF0aGlzLnNoZWV0KSByZXR1cm47XG4gICAgaW5zZXJ0U3R5bGUodGhpcy5lbGVtZW50LCB0aGlzLnNoZWV0Lm9wdGlvbnMpOyAvLyBXaGVuIHJ1bGVzIGFyZSBpbnNlcnRlZCB1c2luZyBgaW5zZXJ0UnVsZWAgQVBJLCBhZnRlciBgc2hlZXQuZGV0YWNoKCkuYXR0YWNoKClgXG4gICAgLy8gbW9zdCBicm93c2VycyBjcmVhdGUgYSBuZXcgQ1NTU3R5bGVTaGVldCwgZXhjZXB0IG9mIGFsbCBJRXMuXG5cbiAgICB2YXIgZGVwbG95ZWQgPSBCb29sZWFuKHRoaXMuc2hlZXQgJiYgdGhpcy5zaGVldC5kZXBsb3llZCk7XG5cbiAgICBpZiAodGhpcy5oYXNJbnNlcnRlZFJ1bGVzICYmIGRlcGxveWVkKSB7XG4gICAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVwbG95KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgc3R5bGUgZWxlbWVudCBmcm9tIHJlbmRlciB0cmVlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICB9XG4gIC8qKlxuICAgKiBJbmplY3QgQ1NTIHN0cmluZyBpbnRvIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlcGxveSA9IGZ1bmN0aW9uIGRlcGxveSgpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLnNoZWV0O1xuICAgIGlmICghc2hlZXQpIHJldHVybjtcblxuICAgIGlmIChzaGVldC5vcHRpb25zLmxpbmspIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZXMoc2hlZXQucnVsZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9IFwiXFxuXCIgKyBzaGVldC50b1N0cmluZygpICsgXCJcXG5cIjtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IFJ1bGVMaXN0IGludG8gYW4gZWxlbWVudC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZXMgPSBmdW5jdGlvbiBpbnNlcnRSdWxlcyhydWxlcywgbmF0aXZlUGFyZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5pbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGVzLmluZGV4W2ldLCBpLCBuYXRpdmVQYXJlbnQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IGEgcnVsZSBpbnRvIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4LCBuYXRpdmVQYXJlbnQpIHtcbiAgICBpZiAobmF0aXZlUGFyZW50ID09PSB2b2lkIDApIHtcbiAgICAgIG5hdGl2ZVBhcmVudCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICB9XG5cbiAgICBpZiAocnVsZS5ydWxlcykge1xuICAgICAgdmFyIHBhcmVudCA9IHJ1bGU7XG4gICAgICB2YXIgbGF0ZXN0TmF0aXZlUGFyZW50ID0gbmF0aXZlUGFyZW50O1xuXG4gICAgICBpZiAocnVsZS50eXBlID09PSAnY29uZGl0aW9uYWwnIHx8IHJ1bGUudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZW5kZXIgdGhlIGNvbnRhaW5lciB3aXRob3V0IGNoaWxkcmVuIGZpcnN0LlxuICAgICAgICBsYXRlc3ROYXRpdmVQYXJlbnQgPSBfaW5zZXJ0UnVsZShuYXRpdmVQYXJlbnQsIHBhcmVudC50b1N0cmluZyh7XG4gICAgICAgICAgY2hpbGRyZW46IGZhbHNlXG4gICAgICAgIH0pLCBpbmRleCk7XG5cbiAgICAgICAgaWYgKGxhdGVzdE5hdGl2ZVBhcmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnNlcnRSdWxlcyhwYXJlbnQucnVsZXMsIGxhdGVzdE5hdGl2ZVBhcmVudCk7XG4gICAgICByZXR1cm4gbGF0ZXN0TmF0aXZlUGFyZW50O1xuICAgIH0gLy8gSUUga2VlcHMgdGhlIENTU1N0eWxlU2hlZXQgYWZ0ZXIgc3R5bGUgbm9kZSBoYXMgYmVlbiByZWF0dGFjaGVkLFxuICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGByZW5kZXJhYmxlYCByZWZlcmVuY2UgdGhlIHJpZ2h0IHN0eWxlIHNoZWV0IGFuZCBub3RcbiAgICAvLyByZXJlbmRlciB0aG9zZSBydWxlcy5cblxuXG4gICAgaWYgKHJ1bGUucmVuZGVyYWJsZSAmJiBydWxlLnJlbmRlcmFibGUucGFyZW50U3R5bGVTaGVldCA9PT0gdGhpcy5lbGVtZW50LnNoZWV0KSB7XG4gICAgICByZXR1cm4gcnVsZS5yZW5kZXJhYmxlO1xuICAgIH1cblxuICAgIHZhciBydWxlU3RyID0gcnVsZS50b1N0cmluZygpO1xuICAgIGlmICghcnVsZVN0cikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIG5hdGl2ZVJ1bGUgPSBfaW5zZXJ0UnVsZShuYXRpdmVQYXJlbnQsIHJ1bGVTdHIsIGluZGV4KTtcblxuICAgIGlmIChuYXRpdmVSdWxlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IHRydWU7XG4gICAgcnVsZS5yZW5kZXJhYmxlID0gbmF0aXZlUnVsZTtcbiAgICByZXR1cm4gbmF0aXZlUnVsZTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUoY3NzUnVsZSkge1xuICAgIHZhciBzaGVldCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBDU1MgUnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YoY3NzUnVsZSkge1xuICAgIHZhciBjc3NSdWxlcyA9IHRoaXMuZWxlbWVudC5zaGVldC5jc3NSdWxlcztcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjc3NSdWxlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChjc3NSdWxlID09PSBjc3NSdWxlc1tpbmRleF0pIHJldHVybiBpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IENTUyBydWxlIGFuZCByZXBsYWNlIHRoZSBleGlzdGluZyBvbmUuXG4gICAqXG4gICAqIE9ubHkgdXNlZCBmb3Igc29tZSBvbGQgYnJvd3NlcnMgYmVjYXVzZSB0aGV5IGNhbid0IHNldCBhIHNlbGVjdG9yLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBsYWNlUnVsZSA9IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKGNzc1J1bGUsIHJ1bGUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuZWxlbWVudC5zaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBydWxlcyBlbGVtZW50cy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0UnVsZXMgPSBmdW5jdGlvbiBnZXRSdWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNoZWV0LmNzc1J1bGVzO1xuICB9O1xuXG4gIHJldHVybiBEb21SZW5kZXJlcjtcbn0oKTtcblxudmFyIGluc3RhbmNlQ291bnRlciA9IDA7XG5cbnZhciBKc3MgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBKc3Mob3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSBpbnN0YW5jZUNvdW50ZXIrKztcbiAgICB0aGlzLnZlcnNpb24gPSBcIjEwLjMuMFwiO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBQbHVnaW5zUmVnaXN0cnkoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBpZDoge1xuICAgICAgICBtaW5pZnk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY3JlYXRlR2VuZXJhdGVJZDogY3JlYXRlR2VuZXJhdGVJZCxcbiAgICAgIFJlbmRlcmVyOiBpc0luQnJvd3NlciA/IERvbVJlbmRlcmVyIDogbnVsbCxcbiAgICAgIHBsdWdpbnM6IFtdXG4gICAgfTtcbiAgICB0aGlzLmdlbmVyYXRlSWQgPSBjcmVhdGVHZW5lcmF0ZUlkKHtcbiAgICAgIG1pbmlmeTogZmFsc2VcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5wbHVnaW5zLnVzZShwbHVnaW5zW2ldLCB7XG4gICAgICAgIHF1ZXVlOiAnaW50ZXJuYWwnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldHVwKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBQcmVwYXJlcyB2YXJpb3VzIG9wdGlvbnMsIGFwcGxpZXMgcGx1Z2lucy5cbiAgICogU2hvdWxkIG5vdCBiZSB1c2VkIHR3aWNlIG9uIHRoZSBzYW1lIGluc3RhbmNlLCBiZWNhdXNlIHRoZXJlIGlzIG5vIHBsdWdpbnNcbiAgICogZGVkdXBsaWNhdGlvbiBsb2dpYy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gSnNzLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0dXAgPSBmdW5jdGlvbiBzZXR1cChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkID0gb3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaWQgPSBfZXh0ZW5kcyh7fSwgdGhpcy5vcHRpb25zLmlkLCBvcHRpb25zLmlkKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkIHx8IG9wdGlvbnMuaWQpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJZCA9IHRoaXMub3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkKHRoaXMub3B0aW9ucy5pZCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgIT0gbnVsbCkgdGhpcy5vcHRpb25zLmluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcblxuICAgIGlmICgnUmVuZGVyZXInIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5SZW5kZXJlciA9IG9wdGlvbnMuUmVuZGVyZXI7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuXG5cbiAgICBpZiAob3B0aW9ucy5wbHVnaW5zKSB0aGlzLnVzZS5hcHBseSh0aGlzLCBvcHRpb25zLnBsdWdpbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlU3R5bGVTaGVldCA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlU2hlZXQoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICAgIGluZGV4ID0gX29wdGlvbnMuaW5kZXg7XG5cbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgaW5kZXggPSBzaGVldHMuaW5kZXggPT09IDAgPyAwIDogc2hlZXRzLmluZGV4ICsgMTtcbiAgICB9XG5cbiAgICB2YXIgc2hlZXQgPSBuZXcgU3R5bGVTaGVldChzdHlsZXMsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBqc3M6IHRoaXMsXG4gICAgICBnZW5lcmF0ZUlkOiBvcHRpb25zLmdlbmVyYXRlSWQgfHwgdGhpcy5nZW5lcmF0ZUlkLFxuICAgICAgaW5zZXJ0aW9uUG9pbnQ6IHRoaXMub3B0aW9ucy5pbnNlcnRpb25Qb2ludCxcbiAgICAgIFJlbmRlcmVyOiB0aGlzLm9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9KSk7XG4gICAgdGhpcy5wbHVnaW5zLm9uUHJvY2Vzc1NoZWV0KHNoZWV0KTtcbiAgICByZXR1cm4gc2hlZXQ7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaCB0aGUgU3R5bGUgU2hlZXQgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlU3R5bGVTaGVldCA9IGZ1bmN0aW9uIHJlbW92ZVN0eWxlU2hlZXQoc2hlZXQpIHtcbiAgICBzaGVldC5kZXRhY2goKTtcbiAgICBzaGVldHMucmVtb3ZlKHNoZWV0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcnVsZSB3aXRob3V0IGEgU3R5bGUgU2hlZXQuXG4gICAqIFtEZXByZWNhdGVkXSB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlUnVsZSA9IGZ1bmN0aW9uIGNyZWF0ZVJ1bGUkMShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChzdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdHlsZSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBFbmFibGUgcnVsZSB3aXRob3V0IG5hbWUgZm9yIGlubGluZSBzdHlsZXMuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUnVsZSh1bmRlZmluZWQsIG5hbWUsIHN0eWxlKTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZU9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGpzczogdGhpcyxcbiAgICAgIFJlbmRlcmVyOiB0aGlzLm9wdGlvbnMuUmVuZGVyZXJcbiAgICB9KTtcblxuICAgIGlmICghcnVsZU9wdGlvbnMuZ2VuZXJhdGVJZCkgcnVsZU9wdGlvbnMuZ2VuZXJhdGVJZCA9IHRoaXMuZ2VuZXJhdGVJZDtcbiAgICBpZiAoIXJ1bGVPcHRpb25zLmNsYXNzZXMpIHJ1bGVPcHRpb25zLmNsYXNzZXMgPSB7fTtcbiAgICBpZiAoIXJ1bGVPcHRpb25zLmtleWZyYW1lcykgcnVsZU9wdGlvbnMua2V5ZnJhbWVzID0ge307XG5cbiAgICB2YXIgcnVsZSA9IGNyZWF0ZVJ1bGUobmFtZSwgc3R5bGUsIHJ1bGVPcHRpb25zKTtcblxuICAgIGlmIChydWxlKSB0aGlzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgcGx1Z2luLiBQYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYSBydWxlIGluc3RhbmNlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2UoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGx1Z2luc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgX3RoaXMucGx1Z2lucy51c2UocGx1Z2luKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gSnNzO1xufSgpO1xuXG4vKipcbiAqIEV4dHJhY3RzIGEgc3R5bGVzIG9iamVjdCB3aXRoIG9ubHkgcHJvcHMgdGhhdCBjb250YWluIGZ1bmN0aW9uIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RHluYW1pY1N0eWxlcyhzdHlsZXMpIHtcbiAgdmFyIHRvID0gbnVsbDtcblxuICBmb3IgKHZhciBrZXkgaW4gc3R5bGVzKSB7XG4gICAgdmFyIHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKCF0bykgdG8gPSB7fTtcbiAgICAgIHRvW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFyIGV4dHJhY3RlZCA9IGdldER5bmFtaWNTdHlsZXModmFsdWUpO1xuXG4gICAgICBpZiAoZXh0cmFjdGVkKSB7XG4gICAgICAgIGlmICghdG8pIHRvID0ge307XG4gICAgICAgIHRvW2tleV0gPSBleHRyYWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIFNoZWV0c01hbmFnZXIgaXMgbGlrZSBhIFdlYWtNYXAgd2hpY2ggaXMgZGVzaWduZWQgdG8gY291bnQgU3R5bGVTaGVldFxuICogaW5zdGFuY2VzIGFuZCBhdHRhY2gvZGV0YWNoIGF1dG9tYXRpY2FsbHkuXG4gKi9cbnZhciBTaGVldHNNYW5hZ2VyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hlZXRzTWFuYWdlcigpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5zaGVldHMgPSBuZXcgV2Vha01hcCgpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNoZWV0c01hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnNoZWV0O1xuICB9O1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoa2V5LCBzaGVldCkge1xuICAgIGlmICh0aGlzLnNoZWV0cy5oYXMoa2V5KSkgcmV0dXJuO1xuICAgIHRoaXMubGVuZ3RoKys7XG4gICAgdGhpcy5zaGVldHMuc2V0KGtleSwge1xuICAgICAgc2hlZXQ6IHNoZWV0LFxuICAgICAgcmVmczogMFxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5tYW5hZ2UgPSBmdW5jdGlvbiBtYW5hZ2Uoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeS5yZWZzID09PSAwKSB7XG4gICAgICAgIGVudHJ5LnNoZWV0LmF0dGFjaCgpO1xuICAgICAgfVxuXG4gICAgICBlbnRyeS5yZWZzKys7XG4gICAgICByZXR1cm4gZW50cnkuc2hlZXQ7XG4gICAgfVxuXG4gICAgd2FybmluZyhmYWxzZSwgXCJbSlNTXSBTaGVldHNNYW5hZ2VyOiBjYW4ndCBmaW5kIHNoZWV0IHRvIG1hbmFnZVwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIF9wcm90by51bm1hbmFnZSA9IGZ1bmN0aW9uIHVubWFuYWdlKGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBpZiAoZW50cnkucmVmcyA+IDApIHtcbiAgICAgICAgZW50cnkucmVmcy0tO1xuICAgICAgICBpZiAoZW50cnkucmVmcyA9PT0gMCkgZW50cnkuc2hlZXQuZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiU2hlZXRzTWFuYWdlcjogY2FuJ3QgZmluZCBzaGVldCB0byB1bm1hbmFnZVwiKTtcbiAgICB9XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFNoZWV0c01hbmFnZXIsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hlZXRzTWFuYWdlcjtcbn0oKTtcblxuLyoqXG4gKiBBIGJldHRlciBhYnN0cmFjdGlvbiBvdmVyIENTUy5cbiAqXG4gKiBAY29weXJpZ2h0IE9sZWcgSXNvbmVuIChTbG9ib2Rza29pKSAvIElzb25lbiAyMDE0LXByZXNlbnRcbiAqIEB3ZWJzaXRlIGh0dHBzOi8vZ2l0aHViLmNvbS9jc3NpbmpzL2pzc1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuLyoqXG4gKiBFeHBvcnQgYSBjb25zdGFudCBpbmRpY2F0aW5nIGlmIHRoaXMgYnJvd3NlciBoYXMgQ1NTVE9NIHN1cHBvcnQuXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE4LzAzL2Nzc29tXG4gKi9cbnZhciBoYXNDU1NUT01TdXBwb3J0ID0gdHlwZW9mIENTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgQ1NTICYmICdudW1iZXInIGluIENTUztcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBKc3MuXG4gKi9cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSnNzKG9wdGlvbnMpO1xufTtcbi8qKlxuICogQSBnbG9iYWwgSnNzIGluc3RhbmNlLlxuICovXG5cbnZhciBpbmRleCA9IGNyZWF0ZSgpO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbmV4cG9ydCB7IFJ1bGVMaXN0LCBTaGVldHNNYW5hZ2VyLCBTaGVldHNSZWdpc3RyeSwgY3JlYXRlLCBjcmVhdGVHZW5lcmF0ZUlkLCBjcmVhdGVSdWxlLCBnZXREeW5hbWljU3R5bGVzLCBoYXNDU1NUT01TdXBwb3J0LCBzaGVldHMsIHRvQ3NzVmFsdWUgfTtcbiIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IHsgZ2V0RGlzcGxheU5hbWUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VDbGFzc2VzKCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBiYXNlQ2xhc3NlcyA9IG9wdGlvbnMuYmFzZUNsYXNzZXMsXG4gICAgICBuZXdDbGFzc2VzID0gb3B0aW9ucy5uZXdDbGFzc2VzLFxuICAgICAgQ29tcG9uZW50ID0gb3B0aW9ucy5Db21wb25lbnQ7XG5cbiAgaWYgKCFuZXdDbGFzc2VzKSB7XG4gICAgcmV0dXJuIGJhc2VDbGFzc2VzO1xuICB9XG5cbiAgdmFyIG5leHRDbGFzc2VzID0gX2V4dGVuZHMoe30sIGJhc2VDbGFzc2VzKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0eXBlb2YgbmV3Q2xhc3NlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IFRoZSB2YWx1ZSBgXCIuY29uY2F0KG5ld0NsYXNzZXMsIFwiYCBcIikgKyBcInByb3ZpZGVkIHRvIHRoZSBjbGFzc2VzIHByb3Agb2YgXCIuY29uY2F0KGdldERpc3BsYXlOYW1lKENvbXBvbmVudCksIFwiIGlzIGluY29ycmVjdC5cIiksICdZb3UgbWlnaHQgd2FudCB0byB1c2UgdGhlIGNsYXNzTmFtZSBwcm9wIGluc3RlYWQuJ10uam9pbignXFxuJykpO1xuICAgICAgcmV0dXJuIGJhc2VDbGFzc2VzO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKG5ld0NsYXNzZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWJhc2VDbGFzc2VzW2tleV0gJiYgbmV3Q2xhc3Nlc1trZXldKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IFRoZSBrZXkgYFwiLmNvbmNhdChrZXksIFwiYCBcIikgKyBcInByb3ZpZGVkIHRvIHRoZSBjbGFzc2VzIHByb3AgaXMgbm90IGltcGxlbWVudGVkIGluIFwiLmNvbmNhdChnZXREaXNwbGF5TmFtZShDb21wb25lbnQpLCBcIi5cIiksIFwiWW91IGNhbiBvbmx5IG92ZXJyaWRlIG9uZSBvZiB0aGUgZm9sbG93aW5nOiBcIi5jb25jYXQoT2JqZWN0LmtleXMoYmFzZUNsYXNzZXMpLmpvaW4oJywnKSwgXCIuXCIpXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdDbGFzc2VzW2tleV0gJiYgdHlwZW9mIG5ld0NsYXNzZXNba2V5XSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIGtleSBgXCIuY29uY2F0KGtleSwgXCJgIFwiKSArIFwicHJvdmlkZWQgdG8gdGhlIGNsYXNzZXMgcHJvcCBpcyBub3QgdmFsaWQgZm9yIFwiLmNvbmNhdChnZXREaXNwbGF5TmFtZShDb21wb25lbnQpLCBcIi5cIiksIFwiWW91IG5lZWQgdG8gcHJvdmlkZSBhIG5vbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCBvZjogXCIuY29uY2F0KG5ld0NsYXNzZXNba2V5XSwgXCIuXCIpXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld0NsYXNzZXNba2V5XSkge1xuICAgICAgbmV4dENsYXNzZXNba2V5XSA9IFwiXCIuY29uY2F0KGJhc2VDbGFzc2VzW2tleV0sIFwiIFwiKS5jb25jYXQobmV3Q2xhc3Nlc1trZXldKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV4dENsYXNzZXM7XG59IiwiLy8gVXNlZCBodHRwczovL2dpdGh1Yi5jb20vdGhpbmtsb29wL211bHRpLWtleS1jYWNoZSBhcyBpbnNwaXJhdGlvblxudmFyIG11bHRpS2V5U3RvcmUgPSB7XG4gIHNldDogZnVuY3Rpb24gc2V0KGNhY2hlLCBrZXkxLCBrZXkyLCB2YWx1ZSkge1xuICAgIHZhciBzdWJDYWNoZSA9IGNhY2hlLmdldChrZXkxKTtcblxuICAgIGlmICghc3ViQ2FjaGUpIHtcbiAgICAgIHN1YkNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgY2FjaGUuc2V0KGtleTEsIHN1YkNhY2hlKTtcbiAgICB9XG5cbiAgICBzdWJDYWNoZS5zZXQoa2V5MiwgdmFsdWUpO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIGdldChjYWNoZSwga2V5MSwga2V5Mikge1xuICAgIHZhciBzdWJDYWNoZSA9IGNhY2hlLmdldChrZXkxKTtcbiAgICByZXR1cm4gc3ViQ2FjaGUgPyBzdWJDYWNoZS5nZXQoa2V5MikgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIGRlbGV0ZTogZnVuY3Rpb24gX2RlbGV0ZShjYWNoZSwga2V5MSwga2V5Mikge1xuICAgIHZhciBzdWJDYWNoZSA9IGNhY2hlLmdldChrZXkxKTtcbiAgICBzdWJDYWNoZS5kZWxldGUoa2V5Mik7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBtdWx0aUtleVN0b3JlOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG52YXIgVGhlbWVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVGhlbWVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1RoZW1lQ29udGV4dCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRoZW1lQ29udGV4dDsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFRoZW1lQ29udGV4dCBmcm9tICcuL1RoZW1lQ29udGV4dCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VUaGVtZSgpIHtcbiAgdmFyIHRoZW1lID0gUmVhY3QudXNlQ29udGV4dChUaGVtZUNvbnRleHQpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZSh0aGVtZSk7XG4gIH1cblxuICByZXR1cm4gdGhlbWU7XG59IiwidmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbmV4cG9ydCBkZWZhdWx0IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ211aS5uZXN0ZWQnKSA6ICdfX1RIRU1FX05FU1RFRF9fJzsiLCJpbXBvcnQgbmVzdGVkIGZyb20gJy4uL1RoZW1lUHJvdmlkZXIvbmVzdGVkJztcbi8qKlxuICogVGhpcyBpcyB0aGUgbGlzdCBvZiB0aGUgc3R5bGUgcnVsZSBuYW1lIHdlIHVzZSBhcyBkcm9wIGluIHJlcGxhY2VtZW50IGZvciB0aGUgYnVpbHQtaW5cbiAqIHBzZXVkbyBjbGFzc2VzICg6Y2hlY2tlZCwgOmRpc2FibGVkLCA6Zm9jdXNlZCwgZXRjLikuXG4gKlxuICogV2h5IGRvIHRoZXkgZXhpc3QgaW4gdGhlIGZpcnN0IHBsYWNlP1xuICogVGhlc2UgY2xhc3NlcyBhcmUgdXNlZCBhdCBhIHNwZWNpZmljaXR5IG9mIDIuXG4gKiBJdCBhbGxvd3MgdGhlbSB0byBvdmVycmlkZSBwcmV2aW91c2x5IGRlZmluaWVkIHN0eWxlcyBhcyB3ZWxsIGFzXG4gKiBiZWluZyB1bnRvdWNoZWQgYnkgc2ltcGxlIHVzZXIgb3ZlcnJpZGVzLlxuICovXG5cbnZhciBwc2V1ZG9DbGFzc2VzID0gWydjaGVja2VkJywgJ2Rpc2FibGVkJywgJ2Vycm9yJywgJ2ZvY3VzZWQnLCAnZm9jdXNWaXNpYmxlJywgJ3JlcXVpcmVkJywgJ2V4cGFuZGVkJywgJ3NlbGVjdGVkJ107IC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgdW5pcXVlIGNsYXNzIG5hbWVzIGJhc2VkIG9uIGNvdW50ZXJzLlxuLy8gV2hlbiBuZXcgZ2VuZXJhdG9yIGZ1bmN0aW9uIGlzIGNyZWF0ZWQsIHJ1bGUgY291bnRlciBpcyByZXNldC5cbi8vIFdlIG5lZWQgdG8gcmVzZXQgdGhlIHJ1bGUgY291bnRlciBmb3IgU1NSIGZvciBlYWNoIHJlcXVlc3QuXG4vL1xuLy8gSXQncyBpbnNwaXJlZCBieVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nzc2luanMvanNzL2Jsb2IvNGU2YTA1ZGQzZjdiNjU3MmZkZDNhYjIxNjg2MWQ5ZTQ0NmMyMDMzMS9zcmMvdXRpbHMvY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUuanNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIF9vcHRpb25zJGRpc2FibGVHbG9iYSA9IG9wdGlvbnMuZGlzYWJsZUdsb2JhbCxcbiAgICAgIGRpc2FibGVHbG9iYWwgPSBfb3B0aW9ucyRkaXNhYmxlR2xvYmEgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkZGlzYWJsZUdsb2JhLFxuICAgICAgX29wdGlvbnMkcHJvZHVjdGlvblByID0gb3B0aW9ucy5wcm9kdWN0aW9uUHJlZml4LFxuICAgICAgcHJvZHVjdGlvblByZWZpeCA9IF9vcHRpb25zJHByb2R1Y3Rpb25QciA9PT0gdm9pZCAwID8gJ2pzcycgOiBfb3B0aW9ucyRwcm9kdWN0aW9uUHIsXG4gICAgICBfb3B0aW9ucyRzZWVkID0gb3B0aW9ucy5zZWVkLFxuICAgICAgc2VlZCA9IF9vcHRpb25zJHNlZWQgPT09IHZvaWQgMCA/ICcnIDogX29wdGlvbnMkc2VlZDtcbiAgdmFyIHNlZWRQcmVmaXggPSBzZWVkID09PSAnJyA/ICcnIDogXCJcIi5jb25jYXQoc2VlZCwgXCItXCIpO1xuICB2YXIgcnVsZUNvdW50ZXIgPSAwO1xuXG4gIHZhciBnZXROZXh0Q291bnRlcklkID0gZnVuY3Rpb24gZ2V0TmV4dENvdW50ZXJJZCgpIHtcbiAgICBydWxlQ291bnRlciArPSAxO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChydWxlQ291bnRlciA+PSAxZTEwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ01hdGVyaWFsLVVJOiBZb3UgbWlnaHQgaGF2ZSBhIG1lbW9yeSBsZWFrLicsICdUaGUgcnVsZUNvdW50ZXIgaXMgbm90IHN1cHBvc2VkIHRvIGdyb3cgdGhhdCBtdWNoLiddLmpvaW4oJycpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZUNvdW50ZXI7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChydWxlLCBzdHlsZVNoZWV0KSB7XG4gICAgdmFyIG5hbWUgPSBzdHlsZVNoZWV0Lm9wdGlvbnMubmFtZTsgLy8gSXMgYSBnbG9iYWwgc3RhdGljIE1VSSBzdHlsZT9cblxuICAgIGlmIChuYW1lICYmIG5hbWUuaW5kZXhPZignTXVpJykgPT09IDAgJiYgIXN0eWxlU2hlZXQub3B0aW9ucy5saW5rICYmICFkaXNhYmxlR2xvYmFsKSB7XG4gICAgICAvLyBXZSBjYW4gdXNlIGEgc2hvcnRoYW5kIGNsYXNzIG5hbWUsIHdlIG5ldmVyIHVzZSB0aGUga2V5cyB0byBzdHlsZSB0aGUgY29tcG9uZW50cy5cbiAgICAgIGlmIChwc2V1ZG9DbGFzc2VzLmluZGV4T2YocnVsZS5rZXkpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gXCJNdWktXCIuY29uY2F0KHJ1bGUua2V5KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZWZpeCA9IFwiXCIuY29uY2F0KHNlZWRQcmVmaXgpLmNvbmNhdChuYW1lLCBcIi1cIikuY29uY2F0KHJ1bGUua2V5KTtcblxuICAgICAgaWYgKCFzdHlsZVNoZWV0Lm9wdGlvbnMudGhlbWVbbmVzdGVkXSB8fCBzZWVkICE9PSAnJykge1xuICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQocHJlZml4LCBcIi1cIikuY29uY2F0KGdldE5leHRDb3VudGVySWQoKSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChzZWVkUHJlZml4KS5jb25jYXQocHJvZHVjdGlvblByZWZpeCkuY29uY2F0KGdldE5leHRDb3VudGVySWQoKSk7XG4gICAgfVxuXG4gICAgdmFyIHN1ZmZpeCA9IFwiXCIuY29uY2F0KHJ1bGUua2V5LCBcIi1cIikuY29uY2F0KGdldE5leHRDb3VudGVySWQoKSk7IC8vIEhlbHAgd2l0aCBkZWJ1Z2dhYmlsaXR5LlxuXG4gICAgaWYgKHN0eWxlU2hlZXQub3B0aW9ucy5jbGFzc05hbWVQcmVmaXgpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChzZWVkUHJlZml4KS5jb25jYXQoc3R5bGVTaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeCwgXCItXCIpLmNvbmNhdChzdWZmaXgpO1xuICAgIH1cblxuICAgIHJldHVybiBcIlwiLmNvbmNhdChzZWVkUHJlZml4KS5jb25jYXQoc3VmZml4KTtcbiAgfTtcbn0iLCJpbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IHsgY3JlYXRlUnVsZSB9IGZyb20gJ2pzcyc7XG5cbnZhciBub3cgPSBEYXRlLm5vdygpO1xudmFyIGZuVmFsdWVzTnMgPSBcImZuVmFsdWVzXCIgKyBub3c7XG52YXIgZm5SdWxlTnMgPSBcImZuU3R5bGVcIiArICsrbm93O1xuZnVuY3Rpb24gZnVuY3Rpb25QbHVnaW4oKSB7XG4gIHJldHVybiB7XG4gICAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBkZWNsICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBydWxlID0gY3JlYXRlUnVsZShuYW1lLCB7fSwgb3B0aW9ucyk7XG4gICAgICBydWxlW2ZuUnVsZU5zXSA9IGRlY2w7XG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9LFxuICAgIG9uUHJvY2Vzc1N0eWxlOiBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBleHRyYWN0IGZ1bmN0aW9uIHZhbHVlcyBmcm9tIHRoZSBkZWNsYXJhdGlvbiwgc28gdGhhdCB3ZSBjYW4ga2VlcCBjb3JlIHVuYXdhcmUgb2YgdGhlbS5cbiAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhhdCBvbmx5IG9uY2UuXG4gICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGV4dHJhY3QgZnVuY3Rpb25zIG9uIGVhY2ggc3R5bGUgdXBkYXRlLCBzaW5jZSB0aGlzIGNhbiBoYXBwZW4gb25seSBvbmNlLlxuICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBmdW5jdGlvbiB2YWx1ZXMgaW5zaWRlIG9mIGZ1bmN0aW9uIHJ1bGVzLlxuICAgICAgaWYgKGZuVmFsdWVzTnMgaW4gcnVsZSB8fCBmblJ1bGVOcyBpbiBydWxlKSByZXR1cm4gc3R5bGU7XG4gICAgICB2YXIgZm5WYWx1ZXMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgY29udGludWU7XG4gICAgICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICAgICAgZm5WYWx1ZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIHJ1bGVbZm5WYWx1ZXNOc10gPSBmblZhbHVlcztcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucykge1xuICAgICAgdmFyIHN0eWxlUnVsZSA9IHJ1bGU7XG4gICAgICB2YXIgZm5SdWxlID0gc3R5bGVSdWxlW2ZuUnVsZU5zXTsgLy8gSWYgd2UgaGF2ZSBhIHN0eWxlIGZ1bmN0aW9uLCB0aGUgZW50aXJlIHJ1bGUgaXMgZHluYW1pYyBhbmQgc3R5bGUgb2JqZWN0XG4gICAgICAvLyB3aWxsIGJlIHJldHVybmVkIGZyb20gdGhhdCBmdW5jdGlvbi5cblxuICAgICAgaWYgKGZuUnVsZSkge1xuICAgICAgICAvLyBFbXB0eSBvYmplY3Qgd2lsbCByZW1vdmUgYWxsIGN1cnJlbnRseSBkZWZpbmVkIHByb3BzXG4gICAgICAgIC8vIGluIGNhc2UgZnVuY3Rpb24gcnVsZSByZXR1cm5zIGEgZmFsc3kgdmFsdWUuXG4gICAgICAgIHN0eWxlUnVsZS5zdHlsZSA9IGZuUnVsZShkYXRhKSB8fCB7fTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlUnVsZS5zdHlsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZVJ1bGUuc3R5bGVbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ1tKU1NdIEZ1bmN0aW9uIHZhbHVlcyBpbnNpZGUgZnVuY3Rpb24gcnVsZXMgYXJlIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZm5WYWx1ZXMgPSBzdHlsZVJ1bGVbZm5WYWx1ZXNOc107IC8vIElmIHdlIGhhdmUgYSBmbiB2YWx1ZXMgbWFwLCBpdCBpcyBhIHJ1bGUgd2l0aCBmdW5jdGlvbiB2YWx1ZXMuXG5cbiAgICAgIGlmIChmblZhbHVlcykge1xuICAgICAgICBmb3IgKHZhciBfcHJvcCBpbiBmblZhbHVlcykge1xuICAgICAgICAgIHN0eWxlUnVsZS5wcm9wKF9wcm9wLCBmblZhbHVlc1tfcHJvcF0oZGF0YSksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvblBsdWdpbjtcbiIsImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB7IFJ1bGVMaXN0IH0gZnJvbSAnanNzJztcblxudmFyIGF0ID0gJ0BnbG9iYWwnO1xudmFyIGF0UHJlZml4ID0gJ0BnbG9iYWwgJztcblxudmFyIEdsb2JhbENvbnRhaW5lclJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxDb250YWluZXJSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2dsb2JhbCc7XG4gICAgdGhpcy5hdCA9IGF0O1xuICAgIHRoaXMucnVsZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIHNlbGVjdG9yIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQoc2VsZWN0b3IsIHN0eWxlc1tzZWxlY3Rvcl0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBHbG9iYWxDb250YWluZXJSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0UnVsZSA9IGZ1bmN0aW9uIGdldFJ1bGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLCBydW4gcGx1Z2lucy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgICB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMudG9TdHJpbmcoKTtcbiAgfTtcblxuICByZXR1cm4gR2xvYmFsQ29udGFpbmVyUnVsZTtcbn0oKTtcblxudmFyIEdsb2JhbFByZWZpeGVkUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdsb2JhbFByZWZpeGVkUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2dsb2JhbCc7XG4gICAgdGhpcy5hdCA9IGF0O1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLnJ1bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIHNlbGVjdG9yID0ga2V5LnN1YnN0cihhdFByZWZpeC5sZW5ndGgpO1xuICAgIHRoaXMucnVsZSA9IG9wdGlvbnMuanNzLmNyZWF0ZVJ1bGUoc2VsZWN0b3IsIHN0eWxlLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSkpO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBHbG9iYWxQcmVmaXhlZFJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZSA/IHRoaXMucnVsZS50b1N0cmluZyhvcHRpb25zKSA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBHbG9iYWxQcmVmaXhlZFJ1bGU7XG59KCk7XG5cbnZhciBzZXBhcmF0b3JSZWdFeHAgPSAvXFxzKixcXHMqL2c7XG5cbmZ1bmN0aW9uIGFkZFNjb3BlKHNlbGVjdG9yLCBzY29wZSkge1xuICB2YXIgcGFydHMgPSBzZWxlY3Rvci5zcGxpdChzZXBhcmF0b3JSZWdFeHApO1xuICB2YXIgc2NvcGVkID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIHNjb3BlZCArPSBzY29wZSArIFwiIFwiICsgcGFydHNbaV0udHJpbSgpO1xuICAgIGlmIChwYXJ0c1tpICsgMV0pIHNjb3BlZCArPSAnLCAnO1xuICB9XG5cbiAgcmV0dXJuIHNjb3BlZDtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTmVzdGVkR2xvYmFsQ29udGFpbmVyUnVsZShydWxlKSB7XG4gIHZhciBvcHRpb25zID0gcnVsZS5vcHRpb25zLFxuICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuICB2YXIgcnVsZXMgPSBzdHlsZSA/IHN0eWxlW2F0XSA6IG51bGw7XG4gIGlmICghcnVsZXMpIHJldHVybjtcblxuICBmb3IgKHZhciBuYW1lIGluIHJ1bGVzKSB7XG4gICAgb3B0aW9ucy5zaGVldC5hZGRSdWxlKG5hbWUsIHJ1bGVzW25hbWVdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2VsZWN0b3I6IGFkZFNjb3BlKG5hbWUsIHJ1bGUuc2VsZWN0b3IpXG4gICAgfSkpO1xuICB9XG5cbiAgZGVsZXRlIHN0eWxlW2F0XTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUHJlZml4ZWRHbG9iYWxSdWxlKHJ1bGUpIHtcbiAgdmFyIG9wdGlvbnMgPSBydWxlLm9wdGlvbnMsXG4gICAgICBzdHlsZSA9IHJ1bGUuc3R5bGU7XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgIGlmIChwcm9wWzBdICE9PSAnQCcgfHwgcHJvcC5zdWJzdHIoMCwgYXQubGVuZ3RoKSAhPT0gYXQpIGNvbnRpbnVlO1xuICAgIHZhciBzZWxlY3RvciA9IGFkZFNjb3BlKHByb3Auc3Vic3RyKGF0Lmxlbmd0aCksIHJ1bGUuc2VsZWN0b3IpO1xuICAgIG9wdGlvbnMuc2hlZXQuYWRkUnVsZShzZWxlY3Rvciwgc3R5bGVbcHJvcF0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICB9KSk7XG4gICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICB9XG59XG4vKipcbiAqIENvbnZlcnQgbmVzdGVkIHJ1bGVzIHRvIHNlcGFyYXRlLCByZW1vdmUgdGhlbSBmcm9tIG9yaWdpbmFsIHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBqc3NHbG9iYWwoKSB7XG4gIGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBudWxsO1xuXG4gICAgaWYgKG5hbWUgPT09IGF0KSB7XG4gICAgICByZXR1cm4gbmV3IEdsb2JhbENvbnRhaW5lclJ1bGUobmFtZSwgc3R5bGVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZVswXSA9PT0gJ0AnICYmIG5hbWUuc3Vic3RyKDAsIGF0UHJlZml4Lmxlbmd0aCkgPT09IGF0UHJlZml4KSB7XG4gICAgICByZXR1cm4gbmV3IEdsb2JhbFByZWZpeGVkUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ2dsb2JhbCcgfHwgcGFyZW50Lm9wdGlvbnMucGFyZW50ICYmIHBhcmVudC5vcHRpb25zLnBhcmVudC50eXBlID09PSAnZ2xvYmFsJykge1xuICAgICAgICBvcHRpb25zLnNjb3BlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNjb3BlZCA9PT0gZmFsc2UpIHtcbiAgICAgIG9wdGlvbnMuc2VsZWN0b3IgPSBuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuO1xuICAgIGhhbmRsZU5lc3RlZEdsb2JhbENvbnRhaW5lclJ1bGUocnVsZSk7XG4gICAgaGFuZGxlUHJlZml4ZWRHbG9iYWxSdWxlKHJ1bGUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvbkNyZWF0ZVJ1bGU6IG9uQ3JlYXRlUnVsZSxcbiAgICBvblByb2Nlc3NSdWxlOiBvblByb2Nlc3NSdWxlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGpzc0dsb2JhbDtcbiIsImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5cbnZhciBzZXBhcmF0b3JSZWdFeHAgPSAvXFxzKixcXHMqL2c7XG52YXIgcGFyZW50UmVnRXhwID0gLyYvZztcbnZhciByZWZSZWdFeHAgPSAvXFwkKFtcXHctXSspL2c7XG4vKipcbiAqIENvbnZlcnQgbmVzdGVkIHJ1bGVzIHRvIHNlcGFyYXRlLCByZW1vdmUgdGhlbSBmcm9tIG9yaWdpbmFsIHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24ganNzTmVzdGVkKCkge1xuICAvLyBHZXQgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciAkcmVmIHJlcGxhY2VtZW50LlxuICBmdW5jdGlvbiBnZXRSZXBsYWNlUmVmKGNvbnRhaW5lciwgc2hlZXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBrZXkpIHtcbiAgICAgIHZhciBydWxlID0gY29udGFpbmVyLmdldFJ1bGUoa2V5KSB8fCBzaGVldCAmJiBzaGVldC5nZXRSdWxlKGtleSk7XG5cbiAgICAgIGlmIChydWxlKSB7XG4gICAgICAgIHJ1bGUgPSBydWxlO1xuICAgICAgICByZXR1cm4gcnVsZS5zZWxlY3RvcjtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBDb3VsZCBub3QgZmluZCB0aGUgcmVmZXJlbmNlZCBydWxlIFxcXCJcIiArIGtleSArIFwiXFxcIiBpbiBcXFwiXCIgKyAoY29udGFpbmVyLm9wdGlvbnMubWV0YSB8fCBjb250YWluZXIudG9TdHJpbmcoKSkgKyBcIlxcXCIuXCIpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZVBhcmVudFJlZnMobmVzdGVkUHJvcCwgcGFyZW50UHJvcCkge1xuICAgIHZhciBwYXJlbnRTZWxlY3RvcnMgPSBwYXJlbnRQcm9wLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG4gICAgdmFyIG5lc3RlZFNlbGVjdG9ycyA9IG5lc3RlZFByb3Auc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcmVudCA9IHBhcmVudFNlbGVjdG9yc1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZXN0ZWRTZWxlY3RvcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG5lc3RlZCA9IG5lc3RlZFNlbGVjdG9yc1tqXTtcbiAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9ICcsICc7IC8vIFJlcGxhY2UgYWxsICYgYnkgdGhlIHBhcmVudCBvciBwcmVmaXggJiB3aXRoIHRoZSBwYXJlbnQuXG5cbiAgICAgICAgcmVzdWx0ICs9IG5lc3RlZC5pbmRleE9mKCcmJykgIT09IC0xID8gbmVzdGVkLnJlcGxhY2UocGFyZW50UmVnRXhwLCBwYXJlbnQpIDogcGFyZW50ICsgXCIgXCIgKyBuZXN0ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMocnVsZSwgY29udGFpbmVyLCBwcmV2T3B0aW9ucykge1xuICAgIC8vIE9wdGlvbnMgaGFzIGJlZW4gYWxyZWFkeSBjcmVhdGVkLCBub3cgd2Ugb25seSBpbmNyZWFzZSBpbmRleC5cbiAgICBpZiAocHJldk9wdGlvbnMpIHJldHVybiBfZXh0ZW5kcyh7fSwgcHJldk9wdGlvbnMsIHtcbiAgICAgIGluZGV4OiBwcmV2T3B0aW9ucy5pbmRleCArIDFcbiAgICB9KTtcbiAgICB2YXIgbmVzdGluZ0xldmVsID0gcnVsZS5vcHRpb25zLm5lc3RpbmdMZXZlbDtcbiAgICBuZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWwgPT09IHVuZGVmaW5lZCA/IDEgOiBuZXN0aW5nTGV2ZWwgKyAxO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgcnVsZS5vcHRpb25zLCB7XG4gICAgICBuZXN0aW5nTGV2ZWw6IG5lc3RpbmdMZXZlbCxcbiAgICAgIGluZGV4OiBjb250YWluZXIuaW5kZXhPZihydWxlKSArIDEgLy8gV2UgZG9uJ3QgbmVlZCB0aGUgcGFyZW50IG5hbWUgdG8gYmUgc2V0IG9wdGlvbnMgZm9yIGNobGlkLlxuXG4gICAgfSk7XG5cbiAgICBkZWxldGUgb3B0aW9ucy5uYW1lO1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlO1xuICAgIHZhciBjb250YWluZXIgPSBzdHlsZVJ1bGUub3B0aW9ucy5wYXJlbnQ7XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgdmFyIHJlcGxhY2VSZWY7XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICB2YXIgaXNOZXN0ZWQgPSBwcm9wLmluZGV4T2YoJyYnKSAhPT0gLTE7XG4gICAgICB2YXIgaXNOZXN0ZWRDb25kaXRpb25hbCA9IHByb3BbMF0gPT09ICdAJztcbiAgICAgIGlmICghaXNOZXN0ZWQgJiYgIWlzTmVzdGVkQ29uZGl0aW9uYWwpIGNvbnRpbnVlO1xuICAgICAgb3B0aW9ucyA9IGdldE9wdGlvbnMoc3R5bGVSdWxlLCBjb250YWluZXIsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoaXNOZXN0ZWQpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gcmVwbGFjZVBhcmVudFJlZnMocHJvcCwgc3R5bGVSdWxlLnNlbGVjdG9yKTsgLy8gTGF6aWx5IGNyZWF0ZSB0aGUgcmVmIHJlcGxhY2VyIGZ1bmN0aW9uIGp1c3Qgb25jZSBmb3JcbiAgICAgICAgLy8gYWxsIG5lc3RlZCBydWxlcyB3aXRoaW4gdGhlIHNoZWV0LlxuXG4gICAgICAgIGlmICghcmVwbGFjZVJlZikgcmVwbGFjZVJlZiA9IGdldFJlcGxhY2VSZWYoY29udGFpbmVyLCBzaGVldCk7IC8vIFJlcGxhY2UgYWxsICRyZWZzLlxuXG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShyZWZSZWdFeHAsIHJlcGxhY2VSZWYpO1xuICAgICAgICBjb250YWluZXIuYWRkUnVsZShzZWxlY3Rvciwgc3R5bGVbcHJvcF0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXN0ZWRDb25kaXRpb25hbCkge1xuICAgICAgICAvLyBQbGFjZSBjb25kaXRpb25hbCByaWdodCBhZnRlciB0aGUgcGFyZW50IHJ1bGUgdG8gZW5zdXJlIHJpZ2h0IG9yZGVyaW5nLlxuICAgICAgICBjb250YWluZXIuYWRkUnVsZShwcm9wLCB7fSwgb3B0aW9ucykgLy8gRmxvdyBleHBlY3RzIG1vcmUgb3B0aW9ucyBidXQgdGhleSBhcmVuJ3QgcmVxdWlyZWRcbiAgICAgICAgLy8gQW5kIGZsb3cgZG9lc24ndCBrbm93IHRoaXMgd2lsbCBhbHdheXMgYmUgYSBTdHlsZVJ1bGUgd2hpY2ggaGFzIHRoZSBhZGRSdWxlIG1ldGhvZFxuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIC5hZGRSdWxlKHN0eWxlUnVsZS5rZXksIHN0eWxlW3Byb3BdLCB7XG4gICAgICAgICAgc2VsZWN0b3I6IHN0eWxlUnVsZS5zZWxlY3RvclxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGpzc05lc3RlZDtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciwgcHJlZmVyLXRlbXBsYXRlICovXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC9bQS1aXS9nXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vXG52YXIgY2FjaGUgPSB7fVxuXG5mdW5jdGlvbiB0b0h5cGhlbkxvd2VyKG1hdGNoKSB7XG4gIHJldHVybiAnLScgKyBtYXRjaC50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBjYWNoZVtuYW1lXVxuICB9XG5cbiAgdmFyIGhOYW1lID0gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sIHRvSHlwaGVuTG93ZXIpXG4gIHJldHVybiAoY2FjaGVbbmFtZV0gPSBtc1BhdHRlcm4udGVzdChoTmFtZSkgPyAnLScgKyBoTmFtZSA6IGhOYW1lKVxufVxuXG5leHBvcnQgZGVmYXVsdCBoeXBoZW5hdGVTdHlsZU5hbWVcbiIsImltcG9ydCBoeXBoZW5hdGUgZnJvbSAnaHlwaGVuYXRlLXN0eWxlLW5hbWUnO1xuXG4vKipcbiAqIENvbnZlcnQgY2FtZWwgY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gZGFzaCBzZXBhcmF0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gY29udmVydENhc2Uoc3R5bGUpIHtcbiAgdmFyIGNvbnZlcnRlZCA9IHt9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICB2YXIga2V5ID0gcHJvcC5pbmRleE9mKCctLScpID09PSAwID8gcHJvcCA6IGh5cGhlbmF0ZShwcm9wKTtcbiAgICBjb252ZXJ0ZWRba2V5XSA9IHN0eWxlW3Byb3BdO1xuICB9XG5cbiAgaWYgKHN0eWxlLmZhbGxiYWNrcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlLmZhbGxiYWNrcykpIGNvbnZlcnRlZC5mYWxsYmFja3MgPSBzdHlsZS5mYWxsYmFja3MubWFwKGNvbnZlcnRDYXNlKTtlbHNlIGNvbnZlcnRlZC5mYWxsYmFja3MgPSBjb252ZXJ0Q2FzZShzdHlsZS5mYWxsYmFja3MpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbi8qKlxuICogQWxsb3cgY2FtZWwgY2FzZWQgcHJvcGVydHkgbmFtZXMgYnkgY29udmVydGluZyB0aGVtIGJhY2sgdG8gZGFzaGVyaXplZC5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNhbWVsQ2FzZSgpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICAgIC8vIEhhbmRsZSBydWxlcyBsaWtlIEBmb250LWZhY2UsIHdoaWNoIGNhbiBoYXZlIG11bHRpcGxlIHN0eWxlcyBpbiBhbiBhcnJheVxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0eWxlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzdHlsZVtpbmRleF0gPSBjb252ZXJ0Q2FzZShzdHlsZVtpbmRleF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRDYXNlKHN0eWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3AsIHJ1bGUpIHtcbiAgICBpZiAocHJvcC5pbmRleE9mKCctLScpID09PSAwKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGh5cGhlbmF0ZWRQcm9wID0gaHlwaGVuYXRlKHByb3ApOyAvLyBUaGVyZSB3YXMgbm8gY2FtZWwgY2FzZSBpbiBwbGFjZVxuXG4gICAgaWYgKHByb3AgPT09IGh5cGhlbmF0ZWRQcm9wKSByZXR1cm4gdmFsdWU7XG4gICAgcnVsZS5wcm9wKGh5cGhlbmF0ZWRQcm9wLCB2YWx1ZSk7IC8vIENvcmUgd2lsbCBpZ25vcmUgdGhhdCBwcm9wZXJ0eSB2YWx1ZSB3ZSBzZXQgdGhlIHByb3BlciBvbmUgYWJvdmUuXG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlLFxuICAgIG9uQ2hhbmdlVmFsdWU6IG9uQ2hhbmdlVmFsdWVcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FtZWxDYXNlO1xuIiwiaW1wb3J0IHsgaGFzQ1NTVE9NU3VwcG9ydCB9IGZyb20gJ2pzcyc7XG5cbnZhciBweCA9IGhhc0NTU1RPTVN1cHBvcnQgJiYgQ1NTID8gQ1NTLnB4IDogJ3B4JztcbnZhciBtcyA9IGhhc0NTU1RPTVN1cHBvcnQgJiYgQ1NTID8gQ1NTLm1zIDogJ21zJztcbnZhciBwZXJjZW50ID0gaGFzQ1NTVE9NU3VwcG9ydCAmJiBDU1MgPyBDU1MucGVyY2VudCA6ICclJztcbi8qKlxuICogR2VuZXJhdGVkIGpzcy1wbHVnaW4tZGVmYXVsdC11bml0IENTUyBwcm9wZXJ0eSB1bml0c1xuICpcbiAqIEB0eXBlIG9iamVjdFxuICovXG5cbnZhciBkZWZhdWx0VW5pdHMgPSB7XG4gIC8vIEFuaW1hdGlvbiBwcm9wZXJ0aWVzXG4gICdhbmltYXRpb24tZGVsYXknOiBtcyxcbiAgJ2FuaW1hdGlvbi1kdXJhdGlvbic6IG1zLFxuICAvLyBCYWNrZ3JvdW5kIHByb3BlcnRpZXNcbiAgJ2JhY2tncm91bmQtcG9zaXRpb24nOiBweCxcbiAgJ2JhY2tncm91bmQtcG9zaXRpb24teCc6IHB4LFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbi15JzogcHgsXG4gICdiYWNrZ3JvdW5kLXNpemUnOiBweCxcbiAgLy8gQm9yZGVyIFByb3BlcnRpZXNcbiAgYm9yZGVyOiBweCxcbiAgJ2JvcmRlci1ib3R0b20nOiBweCxcbiAgJ2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItYm90dG9tLXdpZHRoJzogcHgsXG4gICdib3JkZXItbGVmdCc6IHB4LFxuICAnYm9yZGVyLWxlZnQtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1yaWdodCc6IHB4LFxuICAnYm9yZGVyLXJpZ2h0LXdpZHRoJzogcHgsXG4gICdib3JkZXItdG9wJzogcHgsXG4gICdib3JkZXItdG9wLWxlZnQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItdG9wLXJpZ2h0LXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLXRvcC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLXdpZHRoJzogcHgsXG4gIC8vIE1hcmdpbiBwcm9wZXJ0aWVzXG4gIG1hcmdpbjogcHgsXG4gICdtYXJnaW4tYm90dG9tJzogcHgsXG4gICdtYXJnaW4tbGVmdCc6IHB4LFxuICAnbWFyZ2luLXJpZ2h0JzogcHgsXG4gICdtYXJnaW4tdG9wJzogcHgsXG4gIC8vIFBhZGRpbmcgcHJvcGVydGllc1xuICBwYWRkaW5nOiBweCxcbiAgJ3BhZGRpbmctYm90dG9tJzogcHgsXG4gICdwYWRkaW5nLWxlZnQnOiBweCxcbiAgJ3BhZGRpbmctcmlnaHQnOiBweCxcbiAgJ3BhZGRpbmctdG9wJzogcHgsXG4gIC8vIE1hc2sgcHJvcGVydGllc1xuICAnbWFzay1wb3NpdGlvbi14JzogcHgsXG4gICdtYXNrLXBvc2l0aW9uLXknOiBweCxcbiAgJ21hc2stc2l6ZSc6IHB4LFxuICAvLyBXaWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAgaGVpZ2h0OiBweCxcbiAgd2lkdGg6IHB4LFxuICAnbWluLWhlaWdodCc6IHB4LFxuICAnbWF4LWhlaWdodCc6IHB4LFxuICAnbWluLXdpZHRoJzogcHgsXG4gICdtYXgtd2lkdGgnOiBweCxcbiAgLy8gUG9zaXRpb24gcHJvcGVydGllc1xuICBib3R0b206IHB4LFxuICBsZWZ0OiBweCxcbiAgdG9wOiBweCxcbiAgcmlnaHQ6IHB4LFxuICAvLyBTaGFkb3cgcHJvcGVydGllc1xuICAnYm94LXNoYWRvdyc6IHB4LFxuICAndGV4dC1zaGFkb3cnOiBweCxcbiAgLy8gQ29sdW1uIHByb3BlcnRpZXNcbiAgJ2NvbHVtbi1nYXAnOiBweCxcbiAgJ2NvbHVtbi1ydWxlJzogcHgsXG4gICdjb2x1bW4tcnVsZS13aWR0aCc6IHB4LFxuICAnY29sdW1uLXdpZHRoJzogcHgsXG4gIC8vIEZvbnQgYW5kIHRleHQgcHJvcGVydGllc1xuICAnZm9udC1zaXplJzogcHgsXG4gICdmb250LXNpemUtZGVsdGEnOiBweCxcbiAgJ2xldHRlci1zcGFjaW5nJzogcHgsXG4gICd0ZXh0LWluZGVudCc6IHB4LFxuICAndGV4dC1zdHJva2UnOiBweCxcbiAgJ3RleHQtc3Ryb2tlLXdpZHRoJzogcHgsXG4gICd3b3JkLXNwYWNpbmcnOiBweCxcbiAgLy8gTW90aW9uIHByb3BlcnRpZXNcbiAgbW90aW9uOiBweCxcbiAgJ21vdGlvbi1vZmZzZXQnOiBweCxcbiAgLy8gT3V0bGluZSBwcm9wZXJ0aWVzXG4gIG91dGxpbmU6IHB4LFxuICAnb3V0bGluZS1vZmZzZXQnOiBweCxcbiAgJ291dGxpbmUtd2lkdGgnOiBweCxcbiAgLy8gUGVyc3BlY3RpdmUgcHJvcGVydGllc1xuICBwZXJzcGVjdGl2ZTogcHgsXG4gICdwZXJzcGVjdGl2ZS1vcmlnaW4teCc6IHBlcmNlbnQsXG4gICdwZXJzcGVjdGl2ZS1vcmlnaW4teSc6IHBlcmNlbnQsXG4gIC8vIFRyYW5zZm9ybSBwcm9wZXJ0aWVzXG4gICd0cmFuc2Zvcm0tb3JpZ2luJzogcGVyY2VudCxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4teCc6IHBlcmNlbnQsXG4gICd0cmFuc2Zvcm0tb3JpZ2luLXknOiBwZXJjZW50LFxuICAndHJhbnNmb3JtLW9yaWdpbi16JzogcGVyY2VudCxcbiAgLy8gVHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gICd0cmFuc2l0aW9uLWRlbGF5JzogbXMsXG4gICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogbXMsXG4gIC8vIEFsaWdubWVudCBwcm9wZXJ0aWVzXG4gICd2ZXJ0aWNhbC1hbGlnbic6IHB4LFxuICAnZmxleC1iYXNpcyc6IHB4LFxuICAvLyBTb21lIHJhbmRvbSBwcm9wZXJ0aWVzXG4gICdzaGFwZS1tYXJnaW4nOiBweCxcbiAgc2l6ZTogcHgsXG4gIC8vIEdyaWQgcHJvcGVydGllc1xuICBncmlkOiBweCxcbiAgJ2dyaWQtZ2FwJzogcHgsXG4gICdncmlkLXJvdy1nYXAnOiBweCxcbiAgJ2dyaWQtY29sdW1uLWdhcCc6IHB4LFxuICAnZ3JpZC10ZW1wbGF0ZS1yb3dzJzogcHgsXG4gICdncmlkLXRlbXBsYXRlLWNvbHVtbnMnOiBweCxcbiAgJ2dyaWQtYXV0by1yb3dzJzogcHgsXG4gICdncmlkLWF1dG8tY29sdW1ucyc6IHB4LFxuICAvLyBOb3QgZXhpc3RpbmcgcHJvcGVydGllcy5cbiAgLy8gVXNlZCB0byBhdm9pZCBpc3N1ZXMgd2l0aCBqc3MtcGx1Z2luLWV4cGFuZCBpbnRlZ3JhdGlvbi5cbiAgJ2JveC1zaGFkb3cteCc6IHB4LFxuICAnYm94LXNoYWRvdy15JzogcHgsXG4gICdib3gtc2hhZG93LWJsdXInOiBweCxcbiAgJ2JveC1zaGFkb3ctc3ByZWFkJzogcHgsXG4gICdmb250LWxpbmUtaGVpZ2h0JzogcHgsXG4gICd0ZXh0LXNoYWRvdy14JzogcHgsXG4gICd0ZXh0LXNoYWRvdy15JzogcHgsXG4gICd0ZXh0LXNoYWRvdy1ibHVyJzogcHhcbn07XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBvYmplY3QgYW5kIGFkZHMgYSBjYW1lbCBjYXNlZCBwcm9wZXJ0eSB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBhZGRDYW1lbENhc2VkVmVyc2lvbihvYmopIHtcbiAgdmFyIHJlZ0V4cCA9IC8oLVthLXpdKS9nO1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShzdHIpIHtcbiAgICByZXR1cm4gc3RyWzFdLnRvVXBwZXJDYXNlKCk7XG4gIH07XG5cbiAgdmFyIG5ld09iaiA9IHt9O1xuXG4gIGZvciAodmFyIF9rZXkgaW4gb2JqKSB7XG4gICAgbmV3T2JqW19rZXldID0gb2JqW19rZXldO1xuICAgIG5ld09ialtfa2V5LnJlcGxhY2UocmVnRXhwLCByZXBsYWNlKV0gPSBvYmpbX2tleV07XG4gIH1cblxuICByZXR1cm4gbmV3T2JqO1xufVxuXG52YXIgdW5pdHMgPSBhZGRDYW1lbENhc2VkVmVyc2lvbihkZWZhdWx0VW5pdHMpO1xuLyoqXG4gKiBSZWN1cnNpdmUgZGVlcCBzdHlsZSBwYXNzaW5nIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaXRlcmF0ZShwcm9wLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIXZhbHVlKSByZXR1cm4gdmFsdWU7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVbaV0gPSBpdGVyYXRlKHByb3AsIHZhbHVlW2ldLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChwcm9wID09PSAnZmFsbGJhY2tzJykge1xuICAgICAgZm9yICh2YXIgaW5uZXJQcm9wIGluIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlW2lubmVyUHJvcF0gPSBpdGVyYXRlKGlubmVyUHJvcCwgdmFsdWVbaW5uZXJQcm9wXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIF9pbm5lclByb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFsdWVbX2lubmVyUHJvcF0gPSBpdGVyYXRlKHByb3AgKyBcIi1cIiArIF9pbm5lclByb3AsIHZhbHVlW19pbm5lclByb3BdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHZhciB1bml0ID0gb3B0aW9uc1twcm9wXSB8fCB1bml0c1twcm9wXTtcblxuICAgIGlmICh1bml0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHVuaXQgPT09ICdmdW5jdGlvbicgPyB1bml0KHZhbHVlKS50b1N0cmluZygpIDogXCJcIiArIHZhbHVlICsgdW5pdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogQWRkIHVuaXQgdG8gbnVtZXJpYyB2YWx1ZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBkZWZhdWx0VW5pdChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgY2FtZWxDYXNlZE9wdGlvbnMgPSBhZGRDYW1lbENhc2VkVmVyc2lvbihvcHRpb25zKTtcblxuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHN0eWxlW3Byb3BdID0gaXRlcmF0ZShwcm9wLCBzdHlsZVtwcm9wXSwgY2FtZWxDYXNlZE9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3ApIHtcbiAgICByZXR1cm4gaXRlcmF0ZShwcm9wLCB2YWx1ZSwgY2FtZWxDYXNlZE9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0VW5pdDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiLi9hcnJheUxpa2VUb0FycmF5XCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufSIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCIuL2FycmF5TGlrZVRvQXJyYXlcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRob3V0SG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRob3V0SG9sZXNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vaXRlcmFibGVUb0FycmF5XCI7XG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIjtcbmltcG9ydCBub25JdGVyYWJsZVNwcmVhZCBmcm9tIFwiLi9ub25JdGVyYWJsZVNwcmVhZFwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59IiwiaW1wb3J0IGlzSW5Ccm93c2VyIGZyb20gJ2lzLWluLWJyb3dzZXInO1xuaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheSc7XG5cbi8vIEV4cG9ydCBqYXZhc2NyaXB0IHN0eWxlIGFuZCBjc3Mgc3R5bGUgdmVuZG9yIHByZWZpeGVzLlxudmFyIGpzID0gJyc7XG52YXIgY3NzID0gJyc7XG52YXIgdmVuZG9yID0gJyc7XG52YXIgYnJvd3NlciA9ICcnO1xudmFyIGlzVG91Y2ggPSBpc0luQnJvd3NlciAmJiAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IC8vIFdlIHNob3VsZCBub3QgZG8gYW55dGhpbmcgaWYgcmVxdWlyZWQgc2VydmVyc2lkZS5cblxuaWYgKGlzSW5Ccm93c2VyKSB7XG4gIC8vIE9yZGVyIG1hdHRlcnMuIFdlIG5lZWQgdG8gY2hlY2sgV2Via2l0IHRoZSBsYXN0IG9uZSBiZWNhdXNlXG4gIC8vIG90aGVyIHZlbmRvcnMgdXNlIHRvIGFkZCBXZWJraXQgcHJlZml4ZXMgdG8gc29tZSBwcm9wZXJ0aWVzXG4gIHZhciBqc0Nzc01hcCA9IHtcbiAgICBNb3o6ICctbW96LScsXG4gICAgbXM6ICctbXMtJyxcbiAgICBPOiAnLW8tJyxcbiAgICBXZWJraXQ6ICctd2Via2l0LSdcbiAgfTtcblxuICB2YXIgX2RvY3VtZW50JGNyZWF0ZUVsZW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpLFxuICAgICAgc3R5bGUgPSBfZG9jdW1lbnQkY3JlYXRlRWxlbWUuc3R5bGU7XG5cbiAgdmFyIHRlc3RQcm9wID0gJ1RyYW5zZm9ybSc7XG5cbiAgZm9yICh2YXIga2V5IGluIGpzQ3NzTWFwKSB7XG4gICAgaWYgKGtleSArIHRlc3RQcm9wIGluIHN0eWxlKSB7XG4gICAgICBqcyA9IGtleTtcbiAgICAgIGNzcyA9IGpzQ3NzTWFwW2tleV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gQ29ycmVjdGx5IGRldGVjdCB0aGUgRWRnZSBicm93c2VyLlxuXG5cbiAgaWYgKGpzID09PSAnV2Via2l0JyAmJiAnbXNIeXBoZW5zJyBpbiBzdHlsZSkge1xuICAgIGpzID0gJ21zJztcbiAgICBjc3MgPSBqc0Nzc01hcC5tcztcbiAgICBicm93c2VyID0gJ2VkZ2UnO1xuICB9IC8vIENvcnJlY3RseSBkZXRlY3QgdGhlIFNhZmFyaSBicm93c2VyLlxuXG5cbiAgaWYgKGpzID09PSAnV2Via2l0JyAmJiAnLWFwcGxlLXRyYWlsaW5nLXdvcmQnIGluIHN0eWxlKSB7XG4gICAgdmVuZG9yID0gJ2FwcGxlJztcbiAgfVxufVxuLyoqXG4gKiBWZW5kb3IgcHJlZml4IHN0cmluZyBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAdHlwZSB7e2pzOiBTdHJpbmcsIGNzczogU3RyaW5nLCB2ZW5kb3I6IFN0cmluZywgYnJvd3NlcjogU3RyaW5nfX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG52YXIgcHJlZml4ID0ge1xuICBqczoganMsXG4gIGNzczogY3NzLFxuICB2ZW5kb3I6IHZlbmRvcixcbiAgYnJvd3NlcjogYnJvd3NlcixcbiAgaXNUb3VjaDogaXNUb3VjaFxufTtcblxuLyoqXG4gKiBUZXN0IGlmIGEga2V5ZnJhbWUgYXQtcnVsZSBzaG91bGQgYmUgcHJlZml4ZWQgb3Igbm90XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZlbmRvciBwcmVmaXggc3RyaW5nIGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0ZWRLZXlmcmFtZXMoa2V5KSB7XG4gIC8vIEtleWZyYW1lcyBpcyBhbHJlYWR5IHByZWZpeGVkLiBlLmcuIGtleSA9ICdALXdlYmtpdC1rZXlmcmFtZXMgYSdcbiAgaWYgKGtleVsxXSA9PT0gJy0nKSByZXR1cm4ga2V5OyAvLyBObyBuZWVkIHRvIHByZWZpeCBJRS9FZGdlLiBPbGRlciBicm93c2VycyB3aWxsIGlnbm9yZSB1bnN1cHBvcnRlZCBydWxlcy5cbiAgLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWtleWZyYW1lc1xuXG4gIGlmIChwcmVmaXguanMgPT09ICdtcycpIHJldHVybiBrZXk7XG4gIHJldHVybiBcIkBcIiArIHByZWZpeC5jc3MgKyBcImtleWZyYW1lc1wiICsga2V5LnN1YnN0cigxMCk7XG59XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1hcHBlYXJhbmNlXG5cbnZhciBhcHBlYXJlbmNlID0ge1xuICBub1ByZWZpbGw6IFsnYXBwZWFyYW5jZSddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCkge1xuICAgIGlmIChwcm9wICE9PSAnYXBwZWFyYW5jZScpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocHJlZml4LmpzID09PSAnbXMnKSByZXR1cm4gXCItd2Via2l0LVwiICsgcHJvcDtcbiAgICByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1jb2xvci1hZGp1c3RcblxudmFyIGNvbG9yQWRqdXN0ID0ge1xuICBub1ByZWZpbGw6IFsnY29sb3ItYWRqdXN0J10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHByb3AgIT09ICdjb2xvci1hZGp1c3QnKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ1dlYmtpdCcpIHJldHVybiBwcmVmaXguY3NzICsgXCJwcmludC1cIiArIHByb3A7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbnZhciByZWdFeHAgPSAvWy1cXHNdKyguKT8vZztcbi8qKlxuICogUmVwbGFjZXMgdGhlIGxldHRlciB3aXRoIHRoZSBjYXBpdGFsIGxldHRlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYXRjaFxuICogQHBhcmFtIHtTdHJpbmd9IGNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHRvVXBwZXIobWF0Y2gsIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJztcbn1cbi8qKlxuICogQ29udmVydCBkYXNoIHNlcGFyYXRlZCBzdHJpbmdzIHRvIGNhbWVsLWNhc2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShyZWdFeHAsIHRvVXBwZXIpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgZGFzaCBzZXBhcmF0ZWQgc3RyaW5ncyB0byBwYXNjYWwgY2FzZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFzY2FsaXplKHN0cikge1xuICByZXR1cm4gY2FtZWxpemUoXCItXCIgKyBzdHIpO1xufVxuXG4vLyBidXQgd2UgY2FuIHVzZSBhIGxvbmdoYW5kIHByb3BlcnR5IGluc3RlYWQuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9bWFza1xuXG52YXIgbWFzayA9IHtcbiAgbm9QcmVmaWxsOiBbJ21hc2snXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlKSB7XG4gICAgaWYgKCEvXm1hc2svLnRlc3QocHJvcCkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcmVmaXguanMgPT09ICdXZWJraXQnKSB7XG4gICAgICB2YXIgbG9uZ2hhbmQgPSAnbWFzay1pbWFnZSc7XG5cbiAgICAgIGlmIChjYW1lbGl6ZShsb25naGFuZCkgaW4gc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmVmaXguanMgKyBwYXNjYWxpemUobG9uZ2hhbmQpIGluIHN0eWxlKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXRleHQtb3JpZW50YXRpb25cblxudmFyIHRleHRPcmllbnRhdGlvbiA9IHtcbiAgbm9QcmVmaWxsOiBbJ3RleHQtb3JpZW50YXRpb24nXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAocHJvcCAhPT0gJ3RleHQtb3JpZW50YXRpb24nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocHJlZml4LnZlbmRvciA9PT0gJ2FwcGxlJyAmJiAhcHJlZml4LmlzVG91Y2gpIHtcbiAgICAgIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXRyYW5zZm9ybVxuXG52YXIgdHJhbnNmb3JtID0ge1xuICBub1ByZWZpbGw6IFsndHJhbnNmb3JtJ10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChwcm9wICE9PSAndHJhbnNmb3JtJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMudHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD10cmFuc2l0aW9uXG5cbnZhciB0cmFuc2l0aW9uID0ge1xuICBub1ByZWZpbGw6IFsndHJhbnNpdGlvbiddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ3RyYW5zaXRpb24nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD13cml0aW5nLW1vZGVcblxudmFyIHdyaXRpbmdNb2RlID0ge1xuICBub1ByZWZpbGw6IFsnd3JpdGluZy1tb2RlJ10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHByb3AgIT09ICd3cml0aW5nLW1vZGUnKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocHJlZml4LmpzID09PSAnV2Via2l0JyB8fCBwcmVmaXguanMgPT09ICdtcycgJiYgcHJlZml4LmJyb3dzZXIgIT09ICdlZGdlJykge1xuICAgICAgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9dXNlci1zZWxlY3RcblxudmFyIHVzZXJTZWxlY3QgPSB7XG4gIG5vUHJlZmlsbDogWyd1c2VyLXNlbGVjdCddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCkge1xuICAgIGlmIChwcm9wICE9PSAndXNlci1zZWxlY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocHJlZml4LmpzID09PSAnTW96JyB8fCBwcmVmaXguanMgPT09ICdtcycgfHwgcHJlZml4LnZlbmRvciA9PT0gJ2FwcGxlJykge1xuICAgICAgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9bXVsdGljb2x1bW5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3N0Y3NzL2F1dG9wcmVmaXhlci9pc3N1ZXMvNDkxXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcG9zdGNzcy9hdXRvcHJlZml4ZXIvaXNzdWVzLzE3N1xuXG52YXIgYnJlYWtQcm9wc09sZCA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlKSB7XG4gICAgaWYgKCEvXmJyZWFrLS8udGVzdChwcm9wKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ1dlYmtpdCcpIHtcbiAgICAgIHZhciBqc1Byb3AgPSBcIldlYmtpdENvbHVtblwiICsgcGFzY2FsaXplKHByb3ApO1xuICAgICAgcmV0dXJuIGpzUHJvcCBpbiBzdHlsZSA/IHByZWZpeC5jc3MgKyBcImNvbHVtbi1cIiArIHByb3AgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocHJlZml4LmpzID09PSAnTW96Jykge1xuICAgICAgdmFyIF9qc1Byb3AgPSBcInBhZ2VcIiArIHBhc2NhbGl6ZShwcm9wKTtcblxuICAgICAgcmV0dXJuIF9qc1Byb3AgaW4gc3R5bGUgPyBcInBhZ2UtXCIgKyBwcm9wIDogZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Bvc3Rjc3MvYXV0b3ByZWZpeGVyL2lzc3Vlcy8zMjQuXG5cbnZhciBpbmxpbmVMb2dpY2FsT2xkID0ge1xuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUpIHtcbiAgICBpZiAoIS9eKGJvcmRlcnxtYXJnaW58cGFkZGluZyktaW5saW5lLy50ZXN0KHByb3ApKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ01veicpIHJldHVybiBwcm9wO1xuICAgIHZhciBuZXdQcm9wID0gcHJvcC5yZXBsYWNlKCctaW5saW5lJywgJycpO1xuICAgIHJldHVybiBwcmVmaXguanMgKyBwYXNjYWxpemUobmV3UHJvcCkgaW4gc3R5bGUgPyBwcmVmaXguY3NzICsgbmV3UHJvcCA6IGZhbHNlO1xuICB9XG59O1xuXG4vLyBDYW1lbGl6YXRpb24gaXMgcmVxdWlyZWQgYmVjYXVzZSB3ZSBjYW4ndCB0ZXN0IHVzaW5nLlxuLy8gQ1NTIHN5bnRheCBmb3IgZS5nLiBpbiBGRi5cblxudmFyIHVucHJlZml4ZWQgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSkge1xuICAgIHJldHVybiBjYW1lbGl6ZShwcm9wKSBpbiBzdHlsZSA/IHByb3AgOiBmYWxzZTtcbiAgfVxufTtcblxudmFyIHByZWZpeGVkID0ge1xuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUpIHtcbiAgICB2YXIgcGFzY2FsaXplZCA9IHBhc2NhbGl6ZShwcm9wKTsgLy8gUmV0dXJuIGN1c3RvbSBDU1MgdmFyaWFibGUgd2l0aG91dCBwcmVmaXhpbmcuXG5cbiAgICBpZiAocHJvcFswXSA9PT0gJy0nKSByZXR1cm4gcHJvcDsgLy8gUmV0dXJuIGFscmVhZHkgcHJlZml4ZWQgdmFsdWUgd2l0aG91dCBwcmVmaXhpbmcuXG5cbiAgICBpZiAocHJvcFswXSA9PT0gJy0nICYmIHByb3BbMV0gPT09ICctJykgcmV0dXJuIHByb3A7XG4gICAgaWYgKHByZWZpeC5qcyArIHBhc2NhbGl6ZWQgaW4gc3R5bGUpIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDsgLy8gVHJ5IHdlYmtpdCBmYWxsYmFjay5cblxuICAgIGlmIChwcmVmaXguanMgIT09ICdXZWJraXQnICYmIFwiV2Via2l0XCIgKyBwYXNjYWxpemVkIGluIHN0eWxlKSByZXR1cm4gXCItd2Via2l0LVwiICsgcHJvcDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zY3JvbGwtc25hcFxuXG52YXIgc2Nyb2xsU25hcCA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAocHJvcC5zdWJzdHJpbmcoMCwgMTEpICE9PSAnc2Nyb2xsLXNuYXAnKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocHJlZml4LmpzID09PSAnbXMnKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHByZWZpeC5jc3MgKyBwcm9wO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9b3ZlcnNjcm9sbC1iZWhhdmlvclxuXG52YXIgb3ZlcnNjcm9sbEJlaGF2aW9yID0ge1xuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCkge1xuICAgIGlmIChwcm9wICE9PSAnb3ZlcnNjcm9sbC1iZWhhdmlvcicpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcmVmaXguanMgPT09ICdtcycpIHtcbiAgICAgIHJldHVybiBwcmVmaXguY3NzICsgXCJzY3JvbGwtY2hhaW5pbmdcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxudmFyIHByb3BNYXAgPSB7XG4gICdmbGV4LWdyb3cnOiAnZmxleC1wb3NpdGl2ZScsXG4gICdmbGV4LXNocmluayc6ICdmbGV4LW5lZ2F0aXZlJyxcbiAgJ2ZsZXgtYmFzaXMnOiAnZmxleC1wcmVmZXJyZWQtc2l6ZScsXG4gICdqdXN0aWZ5LWNvbnRlbnQnOiAnZmxleC1wYWNrJyxcbiAgb3JkZXI6ICdmbGV4LW9yZGVyJyxcbiAgJ2FsaWduLWl0ZW1zJzogJ2ZsZXgtYWxpZ24nLFxuICAnYWxpZ24tY29udGVudCc6ICdmbGV4LWxpbmUtcGFjaycgLy8gJ2FsaWduLXNlbGYnIGlzIGhhbmRsZWQgYnkgJ2FsaWduLXNlbGYnIHBsdWdpbi5cblxufTsgLy8gU3VwcG9ydCBvbGQgZmxleCBzcGVjIGZyb20gMjAxMi5cblxudmFyIGZsZXgyMDEyID0ge1xuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUpIHtcbiAgICB2YXIgbmV3UHJvcCA9IHByb3BNYXBbcHJvcF07XG4gICAgaWYgKCFuZXdQcm9wKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHByZWZpeC5qcyArIHBhc2NhbGl6ZShuZXdQcm9wKSBpbiBzdHlsZSA/IHByZWZpeC5jc3MgKyBuZXdQcm9wIDogZmFsc2U7XG4gIH1cbn07XG5cbnZhciBwcm9wTWFwJDEgPSB7XG4gIGZsZXg6ICdib3gtZmxleCcsXG4gICdmbGV4LWdyb3cnOiAnYm94LWZsZXgnLFxuICAnZmxleC1kaXJlY3Rpb24nOiBbJ2JveC1vcmllbnQnLCAnYm94LWRpcmVjdGlvbiddLFxuICBvcmRlcjogJ2JveC1vcmRpbmFsLWdyb3VwJyxcbiAgJ2FsaWduLWl0ZW1zJzogJ2JveC1hbGlnbicsXG4gICdmbGV4LWZsb3cnOiBbJ2JveC1vcmllbnQnLCAnYm94LWRpcmVjdGlvbiddLFxuICAnanVzdGlmeS1jb250ZW50JzogJ2JveC1wYWNrJ1xufTtcbnZhciBwcm9wS2V5cyA9IE9iamVjdC5rZXlzKHByb3BNYXAkMSk7XG5cbnZhciBwcmVmaXhDc3MgPSBmdW5jdGlvbiBwcmVmaXhDc3MocCkge1xuICByZXR1cm4gcHJlZml4LmNzcyArIHA7XG59OyAvLyBTdXBwb3J0IG9sZCBmbGV4IHNwZWMgZnJvbSAyMDA5LlxuXG5cbnZhciBmbGV4MjAwOSA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlLCBfcmVmKSB7XG4gICAgdmFyIG11bHRpcGxlID0gX3JlZi5tdWx0aXBsZTtcblxuICAgIGlmIChwcm9wS2V5cy5pbmRleE9mKHByb3ApID4gLTEpIHtcbiAgICAgIHZhciBuZXdQcm9wID0gcHJvcE1hcCQxW3Byb3BdO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobmV3UHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeC5qcyArIHBhc2NhbGl6ZShuZXdQcm9wKSBpbiBzdHlsZSA/IHByZWZpeC5jc3MgKyBuZXdQcm9wIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghbXVsdGlwbGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQcm9wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghKHByZWZpeC5qcyArIHBhc2NhbGl6ZShuZXdQcm9wWzBdKSBpbiBzdHlsZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1Byb3AubWFwKHByZWZpeENzcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBwbHVnaW5zID0gW1xuLy8gICAuLi5wbHVnaW5zLFxuLy8gICAgYnJlYWtQcm9wc09sZCxcbi8vICAgIGlubGluZUxvZ2ljYWxPbGQsXG4vLyAgICB1bnByZWZpeGVkLFxuLy8gICAgcHJlZml4ZWQsXG4vLyAgICBzY3JvbGxTbmFwLFxuLy8gICAgZmxleDIwMTIsXG4vLyAgICBmbGV4MjAwOVxuLy8gXVxuLy8gUGx1Z2lucyB3aXRob3V0ICdub1ByZWZpbGwnIHZhbHVlLCBnb2luZyBsYXN0LlxuLy8gJ2ZsZXgtKicgcGx1Z2lucyBzaG91bGQgYmUgYXQgdGhlIGJvdHRvbS5cbi8vICdmbGV4MjAwOScgZ29pbmcgYWZ0ZXIgJ2ZsZXgyMDEyJy5cbi8vICdwcmVmaXhlZCcgZ29pbmcgYWZ0ZXIgJ3VucHJlZml4ZWQnXG5cbnZhciBwbHVnaW5zID0gW2FwcGVhcmVuY2UsIGNvbG9yQWRqdXN0LCBtYXNrLCB0ZXh0T3JpZW50YXRpb24sIHRyYW5zZm9ybSwgdHJhbnNpdGlvbiwgd3JpdGluZ01vZGUsIHVzZXJTZWxlY3QsIGJyZWFrUHJvcHNPbGQsIGlubGluZUxvZ2ljYWxPbGQsIHVucHJlZml4ZWQsIHByZWZpeGVkLCBzY3JvbGxTbmFwLCBvdmVyc2Nyb2xsQmVoYXZpb3IsIGZsZXgyMDEyLCBmbGV4MjAwOV07XG52YXIgcHJvcGVydHlEZXRlY3RvcnMgPSBwbHVnaW5zLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcC5zdXBwb3J0ZWRQcm9wZXJ0eTtcbn0pLm1hcChmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcC5zdXBwb3J0ZWRQcm9wZXJ0eTtcbn0pO1xudmFyIG5vUHJlZmlsbCA9IHBsdWdpbnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwLm5vUHJlZmlsbDtcbn0pLnJlZHVjZShmdW5jdGlvbiAoYSwgcCkge1xuICBhLnB1c2guYXBwbHkoYSwgX3RvQ29uc3VtYWJsZUFycmF5KHAubm9QcmVmaWxsKSk7XG4gIHJldHVybiBhO1xufSwgW10pO1xuXG52YXIgZWw7XG52YXIgY2FjaGUgPSB7fTtcblxuaWYgKGlzSW5Ccm93c2VyKSB7XG4gIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpOyAvLyBXZSB0ZXN0IGV2ZXJ5IHByb3BlcnR5IG9uIHZlbmRvciBwcmVmaXggcmVxdWlyZW1lbnQuXG4gIC8vIE9uY2UgdGVzdGVkLCByZXN1bHQgaXMgY2FjaGVkLiBJdCBnaXZlcyB1cyB1cCB0byA3MCUgcGVyZiBib29zdC5cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vZWxlbWVudC1zdHlsZS1vYmplY3QtYWNjZXNzLXZzLXBsYWluLW9iamVjdFxuICAvL1xuICAvLyBQcmVmaWxsIGNhY2hlIHdpdGgga25vd24gY3NzIHByb3BlcnRpZXMgdG8gcmVkdWNlIGFtb3VudCBvZlxuICAvLyBwcm9wZXJ0aWVzIHdlIG5lZWQgdG8gZmVhdHVyZSB0ZXN0IGF0IHJ1bnRpbWUuXG4gIC8vIGh0dHA6Ly9kYXZpZHdhbHNoLm5hbWUvdmVuZG9yLXByZWZpeFxuXG4gIHZhciBjb21wdXRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpO1xuXG4gIGZvciAodmFyIGtleSQxIGluIGNvbXB1dGVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGlmICghaXNOYU4oa2V5JDEpKSBjYWNoZVtjb21wdXRlZFtrZXkkMV1dID0gY29tcHV0ZWRba2V5JDFdO1xuICB9IC8vIFByb3BlcnRpZXMgdGhhdCBjYW5ub3QgYmUgY29ycmVjdGx5IGRldGVjdGVkIHVzaW5nIHRoZVxuICAvLyBjYWNoZSBwcmVmaWxsIG1ldGhvZC5cblxuXG4gIG5vUHJlZmlsbC5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGRlbGV0ZSBjYWNoZVt4XTtcbiAgfSk7XG59XG4vKipcbiAqIFRlc3QgaWYgYSBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQsIHJldHVybnMgc3VwcG9ydGVkIHByb3BlcnR5IHdpdGggdmVuZG9yXG4gKiBwcmVmaXggaWYgcmVxdWlyZWQuIFJldHVybnMgYGZhbHNlYCBpZiBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIGRhc2ggc2VwYXJhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtTdHJpbmd8Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICAvLyBGb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICBpZiAoIWVsKSByZXR1cm4gcHJvcDsgLy8gUmVtb3ZlIGNhY2hlIGZvciBiZW5jaG1hcmsgdGVzdHMgb3IgcmV0dXJuIHByb3BlcnR5IGZyb20gdGhlIGNhY2hlLlxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2JlbmNobWFyaycgJiYgY2FjaGVbcHJvcF0gIT0gbnVsbCkge1xuICAgIHJldHVybiBjYWNoZVtwcm9wXTtcbiAgfSAvLyBDaGVjayBpZiAndHJhbnNpdGlvbicgb3IgJ3RyYW5zZm9ybScgbmF0aXZlbHkgc3VwcG9ydGVkIGluIGJyb3dzZXIuXG5cblxuICBpZiAocHJvcCA9PT0gJ3RyYW5zaXRpb24nIHx8IHByb3AgPT09ICd0cmFuc2Zvcm0nKSB7XG4gICAgb3B0aW9uc1twcm9wXSA9IHByb3AgaW4gZWwuc3R5bGU7XG4gIH0gLy8gRmluZCBhIHBsdWdpbiBmb3IgY3VycmVudCBwcmVmaXggcHJvcGVydHkuXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5RGV0ZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FjaGVbcHJvcF0gPSBwcm9wZXJ0eURldGVjdG9yc1tpXShwcm9wLCBlbC5zdHlsZSwgb3B0aW9ucyk7IC8vIEJyZWFrIGxvb3AsIGlmIHZhbHVlIGZvdW5kLlxuXG4gICAgaWYgKGNhY2hlW3Byb3BdKSBicmVhaztcbiAgfSAvLyBSZXNldCBzdHlsZXMgZm9yIGN1cnJlbnQgcHJvcGVydHkuXG4gIC8vIEZpcmVmb3ggY2FuIGV2ZW4gdGhyb3cgYW4gZXJyb3IgZm9yIGludmFsaWQgcHJvcGVydGllcywgZS5nLiwgXCIwXCIuXG5cblxuICB0cnkge1xuICAgIGVsLnN0eWxlW3Byb3BdID0gJyc7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZVtwcm9wXTtcbn1cblxudmFyIGNhY2hlJDEgPSB7fTtcbnZhciB0cmFuc2l0aW9uUHJvcGVydGllcyA9IHtcbiAgdHJhbnNpdGlvbjogMSxcbiAgJ3RyYW5zaXRpb24tcHJvcGVydHknOiAxLFxuICAnLXdlYmtpdC10cmFuc2l0aW9uJzogMSxcbiAgJy13ZWJraXQtdHJhbnNpdGlvbi1wcm9wZXJ0eSc6IDFcbn07XG52YXIgdHJhbnNQcm9wc1JlZ0V4cCA9IC8oXlxccypbXFx3LV0rKXwsIChcXHMqW1xcdy1dKykoPyFbXigpXSpcXCkpL2c7XG52YXIgZWwkMTtcbi8qKlxuICogUmV0dXJucyBwcmVmaXhlZCB2YWx1ZSB0cmFuc2l0aW9uL3RyYW5zZm9ybSBpZiBuZWVkZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ30gcDFcbiAqIEBwYXJhbSB7U3RyaW5nfSBwMlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4VHJhbnNpdGlvbkNhbGxiYWNrKG1hdGNoLCBwMSwgcDIpIHtcbiAgaWYgKHAxID09PSAndmFyJykgcmV0dXJuICd2YXInO1xuICBpZiAocDEgPT09ICdhbGwnKSByZXR1cm4gJ2FsbCc7XG4gIGlmIChwMiA9PT0gJ2FsbCcpIHJldHVybiAnLCBhbGwnO1xuICB2YXIgcHJlZml4ZWRWYWx1ZSA9IHAxID8gc3VwcG9ydGVkUHJvcGVydHkocDEpIDogXCIsIFwiICsgc3VwcG9ydGVkUHJvcGVydHkocDIpO1xuICBpZiAoIXByZWZpeGVkVmFsdWUpIHJldHVybiBwMSB8fCBwMjtcbiAgcmV0dXJuIHByZWZpeGVkVmFsdWU7XG59XG5cbmlmIChpc0luQnJvd3NlcikgZWwkMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbi8qKlxuICogUmV0dXJucyBwcmVmaXhlZCB2YWx1ZSBpZiBuZWVkZWQuIFJldHVybnMgYGZhbHNlYCBpZiB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd8Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydGVkVmFsdWUocHJvcGVydHksIHZhbHVlKSB7XG4gIC8vIEZvciBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gIHZhciBwcmVmaXhlZFZhbHVlID0gdmFsdWU7XG4gIGlmICghZWwkMSB8fCBwcm9wZXJ0eSA9PT0gJ2NvbnRlbnQnKSByZXR1cm4gdmFsdWU7IC8vIEl0IGlzIGEgc3RyaW5nIG9yIGEgbnVtYmVyIGFzIGEgc3RyaW5nIGxpa2UgJzEnLlxuICAvLyBXZSB3YW50IG9ubHkgcHJlZml4YWJsZSB2YWx1ZXMgaGVyZS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuXG4gIGlmICh0eXBlb2YgcHJlZml4ZWRWYWx1ZSAhPT0gJ3N0cmluZycgfHwgIWlzTmFOKHBhcnNlSW50KHByZWZpeGVkVmFsdWUsIDEwKSkpIHtcbiAgICByZXR1cm4gcHJlZml4ZWRWYWx1ZTtcbiAgfSAvLyBDcmVhdGUgY2FjaGUga2V5IGZvciBjdXJyZW50IHZhbHVlLlxuXG5cbiAgdmFyIGNhY2hlS2V5ID0gcHJvcGVydHkgKyBwcmVmaXhlZFZhbHVlOyAvLyBSZW1vdmUgY2FjaGUgZm9yIGJlbmNobWFyayB0ZXN0cyBvciByZXR1cm4gdmFsdWUgZnJvbSBjYWNoZS5cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdiZW5jaG1hcmsnICYmIGNhY2hlJDFbY2FjaGVLZXldICE9IG51bGwpIHtcbiAgICByZXR1cm4gY2FjaGUkMVtjYWNoZUtleV07XG4gIH0gLy8gSUUgY2FuIGV2ZW4gdGhyb3cgYW4gZXJyb3IgaW4gc29tZSBjYXNlcywgZm9yIGUuZy4gc3R5bGUuY29udGVudCA9ICdiYXInLlxuXG5cbiAgdHJ5IHtcbiAgICAvLyBUZXN0IHZhbHVlIGFzIGl0IGlzLlxuICAgIGVsJDEuc3R5bGVbcHJvcGVydHldID0gcHJlZml4ZWRWYWx1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gUmV0dXJuIGZhbHNlIGlmIHZhbHVlIG5vdCBzdXBwb3J0ZWQuXG4gICAgY2FjaGUkMVtjYWNoZUtleV0gPSBmYWxzZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSWYgJ3RyYW5zaXRpb24nIG9yICd0cmFuc2l0aW9uLXByb3BlcnR5JyBwcm9wZXJ0eS5cblxuXG4gIGlmICh0cmFuc2l0aW9uUHJvcGVydGllc1twcm9wZXJ0eV0pIHtcbiAgICBwcmVmaXhlZFZhbHVlID0gcHJlZml4ZWRWYWx1ZS5yZXBsYWNlKHRyYW5zUHJvcHNSZWdFeHAsIHByZWZpeFRyYW5zaXRpb25DYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoZWwkMS5zdHlsZVtwcm9wZXJ0eV0gPT09ICcnKSB7XG4gICAgLy8gVmFsdWUgd2l0aCBhIHZlbmRvciBwcmVmaXguXG4gICAgcHJlZml4ZWRWYWx1ZSA9IHByZWZpeC5jc3MgKyBwcmVmaXhlZFZhbHVlOyAvLyBIYXJkY29kZSB0ZXN0IHRvIGNvbnZlcnQgXCJmbGV4XCIgdG8gXCItbXMtZmxleGJveFwiIGZvciBJRTEwLlxuXG4gICAgaWYgKHByZWZpeGVkVmFsdWUgPT09ICctbXMtZmxleCcpIGVsJDEuc3R5bGVbcHJvcGVydHldID0gJy1tcy1mbGV4Ym94JzsgLy8gVGVzdCBwcmVmaXhlZCB2YWx1ZS5cblxuICAgIGVsJDEuc3R5bGVbcHJvcGVydHldID0gcHJlZml4ZWRWYWx1ZTsgLy8gUmV0dXJuIGZhbHNlIGlmIHZhbHVlIG5vdCBzdXBwb3J0ZWQuXG5cbiAgICBpZiAoZWwkMS5zdHlsZVtwcm9wZXJ0eV0gPT09ICcnKSB7XG4gICAgICBjYWNoZSQxW2NhY2hlS2V5XSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBSZXNldCBzdHlsZXMgZm9yIGN1cnJlbnQgcHJvcGVydHkuXG5cblxuICBlbCQxLnN0eWxlW3Byb3BlcnR5XSA9ICcnOyAvLyBXcml0ZSBjdXJyZW50IHZhbHVlIHRvIGNhY2hlLlxuXG4gIGNhY2hlJDFbY2FjaGVLZXldID0gcHJlZml4ZWRWYWx1ZTtcbiAgcmV0dXJuIGNhY2hlJDFbY2FjaGVLZXldO1xufVxuXG5leHBvcnQgeyBwcmVmaXgsIHN1cHBvcnRlZEtleWZyYW1lcywgc3VwcG9ydGVkUHJvcGVydHksIHN1cHBvcnRlZFZhbHVlIH07XG4iLCJpbXBvcnQgeyBzdXBwb3J0ZWRLZXlmcmFtZXMsIHN1cHBvcnRlZFZhbHVlLCBzdXBwb3J0ZWRQcm9wZXJ0eSB9IGZyb20gJ2Nzcy12ZW5kb3InO1xuaW1wb3J0IHsgdG9Dc3NWYWx1ZSB9IGZyb20gJ2pzcyc7XG5cbi8qKlxuICogQWRkIHZlbmRvciBwcmVmaXggdG8gYSBwcm9wZXJ0eSBuYW1lIHdoZW4gbmVlZGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24ganNzVmVuZG9yUHJlZml4ZXIoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICB2YXIgYXRSdWxlID0gcnVsZTtcbiAgICAgIGF0UnVsZS5hdCA9IHN1cHBvcnRlZEtleWZyYW1lcyhhdFJ1bGUuYXQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZpeFN0eWxlKHN0eWxlKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG5cbiAgICAgIGlmIChwcm9wID09PSAnZmFsbGJhY2tzJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBzdHlsZVtwcm9wXSA9IHZhbHVlLm1hcChwcmVmaXhTdHlsZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlUHJvcCA9IGZhbHNlO1xuICAgICAgdmFyIHN1cHBvcnRlZFByb3AgPSBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKTtcbiAgICAgIGlmIChzdXBwb3J0ZWRQcm9wICYmIHN1cHBvcnRlZFByb3AgIT09IHByb3ApIGNoYW5nZVByb3AgPSB0cnVlO1xuICAgICAgdmFyIGNoYW5nZVZhbHVlID0gZmFsc2U7XG4gICAgICB2YXIgc3VwcG9ydGVkVmFsdWUkMSA9IHN1cHBvcnRlZFZhbHVlKHN1cHBvcnRlZFByb3AsIHRvQ3NzVmFsdWUodmFsdWUpKTtcbiAgICAgIGlmIChzdXBwb3J0ZWRWYWx1ZSQxICYmIHN1cHBvcnRlZFZhbHVlJDEgIT09IHZhbHVlKSBjaGFuZ2VWYWx1ZSA9IHRydWU7XG5cbiAgICAgIGlmIChjaGFuZ2VQcm9wIHx8IGNoYW5nZVZhbHVlKSB7XG4gICAgICAgIGlmIChjaGFuZ2VQcm9wKSBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICAgIHN0eWxlW3N1cHBvcnRlZFByb3AgfHwgcHJvcF0gPSBzdXBwb3J0ZWRWYWx1ZSQxIHx8IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuICAgIHJldHVybiBwcmVmaXhTdHlsZShzdHlsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZFZhbHVlKHByb3AsIHRvQ3NzVmFsdWUodmFsdWUpKSB8fCB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzUnVsZTogb25Qcm9jZXNzUnVsZSxcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBqc3NWZW5kb3JQcmVmaXhlcjtcbiIsIi8qKlxuICogU29ydCBwcm9wcyBieSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGpzc1Byb3BzU29ydCgpIHtcbiAgdmFyIHNvcnQgPSBmdW5jdGlvbiBzb3J0KHByb3AwLCBwcm9wMSkge1xuICAgIGlmIChwcm9wMC5sZW5ndGggPT09IHByb3AxLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHByb3AwID4gcHJvcDEgPyAxIDogLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3AwLmxlbmd0aCAtIHByb3AxLmxlbmd0aDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1N0eWxlOiBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuICAgICAgdmFyIG5ld1N0eWxlID0ge307XG4gICAgICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyhzdHlsZSkuc29ydChzb3J0KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdTdHlsZVtwcm9wc1tpXV0gPSBzdHlsZVtwcm9wc1tpXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdTdHlsZTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGpzc1Byb3BzU29ydDtcbiIsImltcG9ydCBmdW5jdGlvbnMgZnJvbSAnanNzLXBsdWdpbi1ydWxlLXZhbHVlLWZ1bmN0aW9uJztcbmltcG9ydCBnbG9iYWwgZnJvbSAnanNzLXBsdWdpbi1nbG9iYWwnO1xuaW1wb3J0IG5lc3RlZCBmcm9tICdqc3MtcGx1Z2luLW5lc3RlZCc7XG5pbXBvcnQgY2FtZWxDYXNlIGZyb20gJ2pzcy1wbHVnaW4tY2FtZWwtY2FzZSc7XG5pbXBvcnQgZGVmYXVsdFVuaXQgZnJvbSAnanNzLXBsdWdpbi1kZWZhdWx0LXVuaXQnO1xuaW1wb3J0IHZlbmRvclByZWZpeGVyIGZyb20gJ2pzcy1wbHVnaW4tdmVuZG9yLXByZWZpeGVyJztcbmltcG9ydCBwcm9wc1NvcnQgZnJvbSAnanNzLXBsdWdpbi1wcm9wcy1zb3J0JzsgLy8gU3Vic2V0IG9mIGpzcy1wcmVzZXQtZGVmYXVsdCB3aXRoIG9ubHkgdGhlIHBsdWdpbnMgdGhlIE1hdGVyaWFsLVVJIGNvbXBvbmVudHMgYXJlIHVzaW5nLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBqc3NQcmVzZXQoKSB7XG4gIHJldHVybiB7XG4gICAgcGx1Z2luczogW2Z1bmN0aW9ucygpLCBnbG9iYWwoKSwgbmVzdGVkKCksIGNhbWVsQ2FzZSgpLCBkZWZhdWx0VW5pdCgpLCAvLyBEaXNhYmxlIHRoZSB2ZW5kb3IgcHJlZml4ZXIgc2VydmVyLXNpZGUsIGl0IGRvZXMgbm90aGluZy5cbiAgICAvLyBUaGlzIHdheSwgd2UgY2FuIGdldCBhIHBlcmZvcm1hbmNlIGJvb3N0LlxuICAgIC8vIEluIHRoZSBkb2N1bWVudGF0aW9uLCB3ZSBhcmUgdXNpbmcgYGF1dG9wcmVmaXhlcmAgdG8gc29sdmUgdGhpcyBwcm9ibGVtLlxuICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHZlbmRvclByZWZpeGVyKCksIHByb3BzU29ydCgpXVxuICB9O1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZXhhY3RQcm9wIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBjcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSBmcm9tICcuLi9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSc7XG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tICdqc3MnO1xuaW1wb3J0IGpzc1ByZXNldCBmcm9tICcuLi9qc3NQcmVzZXQnOyAvLyBEZWZhdWx0IEpTUyBpbnN0YW5jZS5cblxudmFyIGpzcyA9IGNyZWF0ZShqc3NQcmVzZXQoKSk7IC8vIFVzZSBhIHNpbmdsZXRvbiBvciB0aGUgcHJvdmlkZWQgb25lIGJ5IHRoZSBjb250ZXh0LlxuLy9cbi8vIFRoZSBjb3VudGVyLWJhc2VkIGFwcHJvYWNoIGRvZXNuJ3QgdG9sZXJhdGUgYW55IG1pc3Rha2UuXG4vLyBJdCdzIG11Y2ggc2FmZXIgdG8gdXNlIHRoZSBzYW1lIGNvdW50ZXIgZXZlcnl3aGVyZS5cblxudmFyIGdlbmVyYXRlQ2xhc3NOYW1lID0gY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUoKTsgLy8gRXhwb3J0ZWQgZm9yIHRlc3QgcHVycG9zZXNcblxuZXhwb3J0IHZhciBzaGVldHNNYW5hZ2VyID0gbmV3IE1hcCgpO1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBkaXNhYmxlR2VuZXJhdGlvbjogZmFsc2UsXG4gIGdlbmVyYXRlQ2xhc3NOYW1lOiBnZW5lcmF0ZUNsYXNzTmFtZSxcbiAganNzOiBqc3MsXG4gIHNoZWV0c0NhY2hlOiBudWxsLFxuICBzaGVldHNNYW5hZ2VyOiBzaGVldHNNYW5hZ2VyLFxuICBzaGVldHNSZWdpc3RyeTogbnVsbFxufTtcbmV4cG9ydCB2YXIgU3R5bGVzQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoZGVmYXVsdE9wdGlvbnMpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBTdHlsZXNDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1N0eWxlc0NvbnRleHQnO1xufVxuXG52YXIgaW5qZWN0Rmlyc3ROb2RlO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3R5bGVzUHJvdmlkZXIocHJvcHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBfcHJvcHMkaW5qZWN0Rmlyc3QgPSBwcm9wcy5pbmplY3RGaXJzdCxcbiAgICAgIGluamVjdEZpcnN0ID0gX3Byb3BzJGluamVjdEZpcnN0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRpbmplY3RGaXJzdCxcbiAgICAgIF9wcm9wcyRkaXNhYmxlR2VuZXJhdCA9IHByb3BzLmRpc2FibGVHZW5lcmF0aW9uLFxuICAgICAgZGlzYWJsZUdlbmVyYXRpb24gPSBfcHJvcHMkZGlzYWJsZUdlbmVyYXQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVHZW5lcmF0LFxuICAgICAgbG9jYWxPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImluamVjdEZpcnN0XCIsIFwiZGlzYWJsZUdlbmVyYXRpb25cIl0pO1xuXG4gIHZhciBvdXRlck9wdGlvbnMgPSBSZWFjdC51c2VDb250ZXh0KFN0eWxlc0NvbnRleHQpO1xuXG4gIHZhciBjb250ZXh0ID0gX2V4dGVuZHMoX2V4dGVuZHMoe30sIG91dGVyT3B0aW9ucyksIHt9LCB7XG4gICAgZGlzYWJsZUdlbmVyYXRpb246IGRpc2FibGVHZW5lcmF0aW9uXG4gIH0sIGxvY2FsT3B0aW9ucyk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgJiYgIWNvbnRleHQuc2hlZXRzTWFuYWdlcikge1xuICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IFlvdSBuZWVkIHRvIHVzZSB0aGUgU2VydmVyU3R5bGVTaGVldHMgQVBJIHdoZW4gcmVuZGVyaW5nIG9uIHRoZSBzZXJ2ZXIuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoY29udGV4dC5qc3Mub3B0aW9ucy5pbnNlcnRpb25Qb2ludCAmJiBpbmplY3RGaXJzdCkge1xuICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IFlvdSBjYW5ub3QgdXNlIGEgY3VzdG9tIGluc2VydGlvblBvaW50IGFuZCA8U3R5bGVzQ29udGV4dCBpbmplY3RGaXJzdD4gYXQgdGhlIHNhbWUgdGltZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChpbmplY3RGaXJzdCAmJiBsb2NhbE9wdGlvbnMuanNzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNYXRlcmlhbC1VSTogWW91IGNhbm5vdCB1c2UgdGhlIGpzcyBhbmQgaW5qZWN0Rmlyc3QgcHJvcHMgYXQgdGhlIHNhbWUgdGltZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRleHQuanNzLm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgJiYgaW5qZWN0Rmlyc3QgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoIWluamVjdEZpcnN0Tm9kZSkge1xuICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkO1xuICAgICAgaW5qZWN0Rmlyc3ROb2RlID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnbXVpLWluamVjdC1maXJzdCcpO1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoaW5qZWN0Rmlyc3ROb2RlLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIGNvbnRleHQuanNzID0gY3JlYXRlKHtcbiAgICAgIHBsdWdpbnM6IGpzc1ByZXNldCgpLnBsdWdpbnMsXG4gICAgICBpbnNlcnRpb25Qb2ludDogaW5qZWN0Rmlyc3ROb2RlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3R5bGVzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIGNoaWxkcmVuKTtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFN0eWxlc1Byb3ZpZGVyLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFlvdXIgY29tcG9uZW50IHRyZWUuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogWW91IGNhbiBkaXNhYmxlIHRoZSBnZW5lcmF0aW9uIG9mIHRoZSBzdHlsZXMgd2l0aCB0aGlzIG9wdGlvbi5cbiAgICogSXQgY2FuIGJlIHVzZWZ1bCB3aGVuIHRyYXZlcnNpbmcgdGhlIFJlYWN0IHRyZWUgb3V0c2lkZSBvZiB0aGUgSFRNTFxuICAgKiByZW5kZXJpbmcgc3RlcCBvbiB0aGUgc2VydmVyLlxuICAgKiBMZXQncyBzYXkgeW91IGFyZSB1c2luZyByZWFjdC1hcG9sbG8gdG8gZXh0cmFjdCBhbGxcbiAgICogdGhlIHF1ZXJpZXMgbWFkZSBieSB0aGUgaW50ZXJmYWNlIHNlcnZlci1zaWRlIC0geW91IGNhbiBzaWduaWZpY2FudGx5IHNwZWVkIHVwIHRoZSB0cmF2ZXJzYWwgd2l0aCB0aGlzIHByb3AuXG4gICAqL1xuICBkaXNhYmxlR2VuZXJhdGlvbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEpTUydzIGNsYXNzIG5hbWUgZ2VuZXJhdG9yLlxuICAgKi9cbiAgZ2VuZXJhdGVDbGFzc05hbWU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgc3R5bGVzIGFyZSBpbmplY3RlZCBsYXN0IGluIHRoZSA8aGVhZD4gZWxlbWVudCBvZiB0aGUgcGFnZS5cbiAgICogQXMgYSByZXN1bHQsIHRoZXkgZ2FpbiBtb3JlIHNwZWNpZmljaXR5IHRoYW4gYW55IG90aGVyIHN0eWxlIHNoZWV0LlxuICAgKiBJZiB5b3Ugd2FudCB0byBvdmVycmlkZSBNYXRlcmlhbC1VSSdzIHN0eWxlcywgc2V0IHRoaXMgcHJvcC5cbiAgICovXG4gIGluamVjdEZpcnN0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSlNTJ3MgaW5zdGFuY2UuXG4gICAqL1xuICBqc3M6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHNlcnZlckdlbmVyYXRlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKlxuICAgKiBCZXRhIGZlYXR1cmUuXG4gICAqXG4gICAqIENhY2hlIGZvciB0aGUgc2hlZXRzLlxuICAgKi9cbiAgc2hlZXRzQ2FjaGU6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICpcbiAgICogVGhlIHNoZWV0c01hbmFnZXIgaXMgdXNlZCB0byBkZWR1cGxpY2F0ZSBzdHlsZSBzaGVldCBpbmplY3Rpb24gaW4gdGhlIHBhZ2UuXG4gICAqIEl0J3MgZGVkdXBsaWNhdGluZyB1c2luZyB0aGUgKHRoZW1lLCBzdHlsZXMpIGNvdXBsZS5cbiAgICogT24gdGhlIHNlcnZlciwgeW91IHNob3VsZCBwcm92aWRlIGEgbmV3IGluc3RhbmNlIGZvciBlYWNoIHJlcXVlc3QuXG4gICAqL1xuICBzaGVldHNNYW5hZ2VyOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqXG4gICAqIENvbGxlY3QgdGhlIHNoZWV0cy5cbiAgICovXG4gIHNoZWV0c1JlZ2lzdHJ5OiBQcm9wVHlwZXMub2JqZWN0XG59IDogdm9pZCAwO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBTdHlsZXNQcm92aWRlci5wcm9wVHlwZXMgPSBleGFjdFByb3AoU3R5bGVzUHJvdmlkZXIucHJvcFR5cGVzKSA6IHZvaWQgMDtcbn0iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0ICovXG4vLyBHbG9iYWwgaW5kZXggY291bnRlciB0byBwcmVzZXJ2ZSBzb3VyY2Ugb3JkZXIuXG4vLyBXZSBjcmVhdGUgdGhlIHN0eWxlIHNoZWV0IGR1cmluZyB0aGUgY3JlYXRpb24gb2YgdGhlIGNvbXBvbmVudCxcbi8vIGNoaWxkcmVuIGFyZSBoYW5kbGVkIGFmdGVyIHRoZSBwYXJlbnRzLCBzbyB0aGUgb3JkZXIgb2Ygc3R5bGUgZWxlbWVudHMgd291bGQgYmUgcGFyZW50LT5jaGlsZC5cbi8vIEl0IGlzIGEgcHJvYmxlbSB0aG91Z2ggd2hlbiBhIHBhcmVudCBwYXNzZXMgYSBjbGFzc05hbWVcbi8vIHdoaWNoIG5lZWRzIHRvIG92ZXJyaWRlIGFueSBjaGlsZCdzIHN0eWxlcy5cbi8vIFN0eWxlU2hlZXQgb2YgdGhlIGNoaWxkIGhhcyBhIGhpZ2hlciBzcGVjaWZpY2l0eSwgYmVjYXVzZSBvZiB0aGUgc291cmNlIG9yZGVyLlxuLy8gU28gb3VyIHNvbHV0aW9uIGlzIHRvIHJlbmRlciBzaGVldHMgdGhlbSBpbiB0aGUgcmV2ZXJzZSBvcmRlciBjaGlsZC0+c2hlZXQsIHNvXG4vLyB0aGF0IHBhcmVudCBoYXMgYSBoaWdoZXIgc3BlY2lmaWNpdHkuXG52YXIgaW5kZXhDb3VudGVyID0gLTFlOTtcbmV4cG9ydCBmdW5jdGlvbiBpbmNyZW1lbnQoKSB7XG4gIGluZGV4Q291bnRlciArPSAxO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGluZGV4Q291bnRlciA+PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oWydNYXRlcmlhbC1VSTogWW91IG1pZ2h0IGhhdmUgYSBtZW1vcnkgbGVhay4nLCAnVGhlIGluZGV4Q291bnRlciBpcyBub3Qgc3VwcG9zZWQgdG8gZ3JvdyB0aGF0IG11Y2guJ10uam9pbignXFxuJykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleENvdW50ZXI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF90eXBlb2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoaXRlbSkge1xuICByZXR1cm4gaXRlbSAmJiBfdHlwZW9mKGl0ZW0pID09PSAnb2JqZWN0JyAmJiBpdGVtLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHtcbiAgICBjbG9uZTogdHJ1ZVxuICB9O1xuICB2YXIgb3V0cHV0ID0gb3B0aW9ucy5jbG9uZSA/IF9leHRlbmRzKHt9LCB0YXJnZXQpIDogdGFyZ2V0O1xuXG4gIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8vIEF2b2lkIHByb3RvdHlwZSBwb2xsdXRpb25cbiAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pICYmIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgb3V0cHV0W2tleV0gPSBkZWVwbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF90eXBlb2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZlwiO1xuaW1wb3J0IHsgZGVlcG1lcmdlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBub29wVGhlbWUgZnJvbSAnLi9ub29wVGhlbWUnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U3R5bGVzQ3JlYXRvcihzdHlsZXNPckNyZWF0b3IpIHtcbiAgdmFyIHRoZW1pbmdFbmFibGVkID0gdHlwZW9mIHN0eWxlc09yQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChfdHlwZW9mKHN0eWxlc09yQ3JlYXRvcikgIT09ICdvYmplY3QnICYmICF0aGVtaW5nRW5hYmxlZCkge1xuICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiBUaGUgYHN0eWxlc2AgYXJndW1lbnQgcHJvdmlkZWQgaXMgaW52YWxpZC4nLCAnWW91IG5lZWQgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIGdlbmVyYXRpbmcgdGhlIHN0eWxlcyBvciBhIHN0eWxlcyBvYmplY3QuJ10uam9pbignXFxuJykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUodGhlbWUsIG5hbWUpIHtcbiAgICAgIHZhciBzdHlsZXM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0eWxlcyA9IHRoZW1pbmdFbmFibGVkID8gc3R5bGVzT3JDcmVhdG9yKHRoZW1lKSA6IHN0eWxlc09yQ3JlYXRvcjtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0aGVtaW5nRW5hYmxlZCA9PT0gdHJ1ZSAmJiB0aGVtZSA9PT0gbm9vcFRoZW1lKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBwcmVwZW5kIGVycm9yIG1lc3NhZ2UvbmFtZSBpbnN0ZWFkXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFsnTWF0ZXJpYWwtVUk6IFRoZSBgc3R5bGVzYCBhcmd1bWVudCBwcm92aWRlZCBpcyBpbnZhbGlkLicsICdZb3UgYXJlIHByb3ZpZGluZyBhIGZ1bmN0aW9uIHdpdGhvdXQgYSB0aGVtZSBpbiB0aGUgY29udGV4dC4nLCAnT25lIG9mIHRoZSBwYXJlbnQgZWxlbWVudHMgbmVlZHMgdG8gdXNlIGEgVGhlbWVQcm92aWRlci4nXS5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW5hbWUgfHwgIXRoZW1lLm92ZXJyaWRlcyB8fCAhdGhlbWUub3ZlcnJpZGVzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdmVycmlkZXMgPSB0aGVtZS5vdmVycmlkZXNbbmFtZV07XG5cbiAgICAgIHZhciBzdHlsZXNXaXRoT3ZlcnJpZGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcyk7XG5cbiAgICAgIE9iamVjdC5rZXlzKG92ZXJyaWRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZXNXaXRoT3ZlcnJpZGVzW2tleV0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihbJ01hdGVyaWFsLVVJOiBZb3UgYXJlIHRyeWluZyB0byBvdmVycmlkZSBhIHN0eWxlIHRoYXQgZG9lcyBub3QgZXhpc3QuJywgXCJGaXggdGhlIGBcIi5jb25jYXQoa2V5LCBcImAga2V5IG9mIGB0aGVtZS5vdmVycmlkZXMuXCIpLmNvbmNhdChuYW1lLCBcImAuXCIpXS5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGVzV2l0aE92ZXJyaWRlc1trZXldID0gZGVlcG1lcmdlKHN0eWxlc1dpdGhPdmVycmlkZXNba2V5XSwgb3ZlcnJpZGVzW2tleV0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3R5bGVzV2l0aE92ZXJyaWRlcztcbiAgICB9LFxuICAgIG9wdGlvbnM6IHt9XG4gIH07XG59IiwiLy8gV2UgdXNlIHRoZSBzYW1lIGVtcHR5IG9iamVjdCB0byByZWYgY291bnQgdGhlIHN0eWxlcyB0aGF0IGRvbid0IG5lZWQgYSB0aGVtZSBvYmplY3QuXG52YXIgbm9vcFRoZW1lID0ge307XG5leHBvcnQgZGVmYXVsdCBub29wVGhlbWU7IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldER5bmFtaWNTdHlsZXMgfSBmcm9tICdqc3MnO1xuaW1wb3J0IG1lcmdlQ2xhc3NlcyBmcm9tICcuLi9tZXJnZUNsYXNzZXMnO1xuaW1wb3J0IG11bHRpS2V5U3RvcmUgZnJvbSAnLi9tdWx0aUtleVN0b3JlJztcbmltcG9ydCB1c2VUaGVtZSBmcm9tICcuLi91c2VUaGVtZSc7XG5pbXBvcnQgeyBTdHlsZXNDb250ZXh0IH0gZnJvbSAnLi4vU3R5bGVzUHJvdmlkZXInO1xuaW1wb3J0IHsgaW5jcmVtZW50IH0gZnJvbSAnLi9pbmRleENvdW50ZXInO1xuaW1wb3J0IGdldFN0eWxlc0NyZWF0b3IgZnJvbSAnLi4vZ2V0U3R5bGVzQ3JlYXRvcic7XG5pbXBvcnQgbm9vcFRoZW1lIGZyb20gJy4uL2dldFN0eWxlc0NyZWF0b3Ivbm9vcFRoZW1lJztcblxuZnVuY3Rpb24gZ2V0Q2xhc3NlcyhfcmVmLCBjbGFzc2VzLCBDb21wb25lbnQpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIHN0eWxlc09wdGlvbnMgPSBfcmVmLnN0eWxlc09wdGlvbnM7XG5cbiAgaWYgKHN0eWxlc09wdGlvbnMuZGlzYWJsZUdlbmVyYXRpb24pIHtcbiAgICByZXR1cm4gY2xhc3NlcyB8fCB7fTtcbiAgfVxuXG4gIGlmICghc3RhdGUuY2FjaGVDbGFzc2VzKSB7XG4gICAgc3RhdGUuY2FjaGVDbGFzc2VzID0ge1xuICAgICAgLy8gQ2FjaGUgZm9yIHRoZSBmaW5hbGl6ZWQgY2xhc3NlcyB2YWx1ZS5cbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgLy8gQ2FjaGUgZm9yIHRoZSBsYXN0IHVzZWQgY2xhc3NlcyBwcm9wIHBvaW50ZXIuXG4gICAgICBsYXN0UHJvcDogbnVsbCxcbiAgICAgIC8vIENhY2hlIGZvciB0aGUgbGFzdCB1c2VkIHJlbmRlcmVkIGNsYXNzZXMgcG9pbnRlci5cbiAgICAgIGxhc3RKU1M6IHt9XG4gICAgfTtcbiAgfSAvLyBUcmFja3MgaWYgZWl0aGVyIHRoZSByZW5kZXJlZCBjbGFzc2VzIG9yIGNsYXNzZXMgcHJvcCBoYXMgY2hhbmdlZCxcbiAgLy8gcmVxdWlyaW5nIHRoZSBnZW5lcmF0aW9uIG9mIGEgbmV3IGZpbmFsaXplZCBjbGFzc2VzIG9iamVjdC5cblxuXG4gIHZhciBnZW5lcmF0ZSA9IGZhbHNlO1xuXG4gIGlmIChzdGF0ZS5jbGFzc2VzICE9PSBzdGF0ZS5jYWNoZUNsYXNzZXMubGFzdEpTUykge1xuICAgIHN0YXRlLmNhY2hlQ2xhc3Nlcy5sYXN0SlNTID0gc3RhdGUuY2xhc3NlcztcbiAgICBnZW5lcmF0ZSA9IHRydWU7XG4gIH1cblxuICBpZiAoY2xhc3NlcyAhPT0gc3RhdGUuY2FjaGVDbGFzc2VzLmxhc3RQcm9wKSB7XG4gICAgc3RhdGUuY2FjaGVDbGFzc2VzLmxhc3RQcm9wID0gY2xhc3NlcztcbiAgICBnZW5lcmF0ZSA9IHRydWU7XG4gIH1cblxuICBpZiAoZ2VuZXJhdGUpIHtcbiAgICBzdGF0ZS5jYWNoZUNsYXNzZXMudmFsdWUgPSBtZXJnZUNsYXNzZXMoe1xuICAgICAgYmFzZUNsYXNzZXM6IHN0YXRlLmNhY2hlQ2xhc3Nlcy5sYXN0SlNTLFxuICAgICAgbmV3Q2xhc3NlczogY2xhc3NlcyxcbiAgICAgIENvbXBvbmVudDogQ29tcG9uZW50XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuY2FjaGVDbGFzc2VzLnZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdHRhY2goX3JlZjIsIHByb3BzKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgdGhlbWUgPSBfcmVmMi50aGVtZSxcbiAgICAgIHN0eWxlc09wdGlvbnMgPSBfcmVmMi5zdHlsZXNPcHRpb25zLFxuICAgICAgc3R5bGVzQ3JlYXRvciA9IF9yZWYyLnN0eWxlc0NyZWF0b3IsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcblxuICBpZiAoc3R5bGVzT3B0aW9ucy5kaXNhYmxlR2VuZXJhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzaGVldE1hbmFnZXIgPSBtdWx0aUtleVN0b3JlLmdldChzdHlsZXNPcHRpb25zLnNoZWV0c01hbmFnZXIsIHN0eWxlc0NyZWF0b3IsIHRoZW1lKTtcblxuICBpZiAoIXNoZWV0TWFuYWdlcikge1xuICAgIHNoZWV0TWFuYWdlciA9IHtcbiAgICAgIHJlZnM6IDAsXG4gICAgICBzdGF0aWNTaGVldDogbnVsbCxcbiAgICAgIGR5bmFtaWNTdHlsZXM6IG51bGxcbiAgICB9O1xuICAgIG11bHRpS2V5U3RvcmUuc2V0KHN0eWxlc09wdGlvbnMuc2hlZXRzTWFuYWdlciwgc3R5bGVzQ3JlYXRvciwgdGhlbWUsIHNoZWV0TWFuYWdlcik7XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IF9leHRlbmRzKF9leHRlbmRzKF9leHRlbmRzKHt9LCBzdHlsZXNDcmVhdG9yLm9wdGlvbnMpLCBzdHlsZXNPcHRpb25zKSwge30sIHtcbiAgICB0aGVtZTogdGhlbWUsXG4gICAgZmxpcDogdHlwZW9mIHN0eWxlc09wdGlvbnMuZmxpcCA9PT0gJ2Jvb2xlYW4nID8gc3R5bGVzT3B0aW9ucy5mbGlwIDogdGhlbWUuZGlyZWN0aW9uID09PSAncnRsJ1xuICB9KTtcblxuICBvcHRpb25zLmdlbmVyYXRlSWQgPSBvcHRpb25zLnNlcnZlckdlbmVyYXRlQ2xhc3NOYW1lIHx8IG9wdGlvbnMuZ2VuZXJhdGVDbGFzc05hbWU7XG4gIHZhciBzaGVldHNSZWdpc3RyeSA9IHN0eWxlc09wdGlvbnMuc2hlZXRzUmVnaXN0cnk7XG5cbiAgaWYgKHNoZWV0TWFuYWdlci5yZWZzID09PSAwKSB7XG4gICAgdmFyIHN0YXRpY1NoZWV0O1xuXG4gICAgaWYgKHN0eWxlc09wdGlvbnMuc2hlZXRzQ2FjaGUpIHtcbiAgICAgIHN0YXRpY1NoZWV0ID0gbXVsdGlLZXlTdG9yZS5nZXQoc3R5bGVzT3B0aW9ucy5zaGVldHNDYWNoZSwgc3R5bGVzQ3JlYXRvciwgdGhlbWUpO1xuICAgIH1cblxuICAgIHZhciBzdHlsZXMgPSBzdHlsZXNDcmVhdG9yLmNyZWF0ZSh0aGVtZSwgbmFtZSk7XG5cbiAgICBpZiAoIXN0YXRpY1NoZWV0KSB7XG4gICAgICBzdGF0aWNTaGVldCA9IHN0eWxlc09wdGlvbnMuanNzLmNyZWF0ZVN0eWxlU2hlZXQoc3R5bGVzLCBfZXh0ZW5kcyh7XG4gICAgICAgIGxpbms6IGZhbHNlXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgICBzdGF0aWNTaGVldC5hdHRhY2goKTtcblxuICAgICAgaWYgKHN0eWxlc09wdGlvbnMuc2hlZXRzQ2FjaGUpIHtcbiAgICAgICAgbXVsdGlLZXlTdG9yZS5zZXQoc3R5bGVzT3B0aW9ucy5zaGVldHNDYWNoZSwgc3R5bGVzQ3JlYXRvciwgdGhlbWUsIHN0YXRpY1NoZWV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hlZXRzUmVnaXN0cnkpIHtcbiAgICAgIHNoZWV0c1JlZ2lzdHJ5LmFkZChzdGF0aWNTaGVldCk7XG4gICAgfVxuXG4gICAgc2hlZXRNYW5hZ2VyLnN0YXRpY1NoZWV0ID0gc3RhdGljU2hlZXQ7XG4gICAgc2hlZXRNYW5hZ2VyLmR5bmFtaWNTdHlsZXMgPSBnZXREeW5hbWljU3R5bGVzKHN0eWxlcyk7XG4gIH1cblxuICBpZiAoc2hlZXRNYW5hZ2VyLmR5bmFtaWNTdHlsZXMpIHtcbiAgICB2YXIgZHluYW1pY1NoZWV0ID0gc3R5bGVzT3B0aW9ucy5qc3MuY3JlYXRlU3R5bGVTaGVldChzaGVldE1hbmFnZXIuZHluYW1pY1N0eWxlcywgX2V4dGVuZHMoe1xuICAgICAgbGluazogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpKTtcbiAgICBkeW5hbWljU2hlZXQudXBkYXRlKHByb3BzKTtcbiAgICBkeW5hbWljU2hlZXQuYXR0YWNoKCk7XG4gICAgc3RhdGUuZHluYW1pY1NoZWV0ID0gZHluYW1pY1NoZWV0O1xuICAgIHN0YXRlLmNsYXNzZXMgPSBtZXJnZUNsYXNzZXMoe1xuICAgICAgYmFzZUNsYXNzZXM6IHNoZWV0TWFuYWdlci5zdGF0aWNTaGVldC5jbGFzc2VzLFxuICAgICAgbmV3Q2xhc3NlczogZHluYW1pY1NoZWV0LmNsYXNzZXNcbiAgICB9KTtcblxuICAgIGlmIChzaGVldHNSZWdpc3RyeSkge1xuICAgICAgc2hlZXRzUmVnaXN0cnkuYWRkKGR5bmFtaWNTaGVldCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNsYXNzZXMgPSBzaGVldE1hbmFnZXIuc3RhdGljU2hlZXQuY2xhc3NlcztcbiAgfVxuXG4gIHNoZWV0TWFuYWdlci5yZWZzICs9IDE7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZShfcmVmMywgcHJvcHMpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjMuc3RhdGU7XG5cbiAgaWYgKHN0YXRlLmR5bmFtaWNTaGVldCkge1xuICAgIHN0YXRlLmR5bmFtaWNTaGVldC51cGRhdGUocHJvcHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaChfcmVmNCkge1xuICB2YXIgc3RhdGUgPSBfcmVmNC5zdGF0ZSxcbiAgICAgIHRoZW1lID0gX3JlZjQudGhlbWUsXG4gICAgICBzdHlsZXNPcHRpb25zID0gX3JlZjQuc3R5bGVzT3B0aW9ucyxcbiAgICAgIHN0eWxlc0NyZWF0b3IgPSBfcmVmNC5zdHlsZXNDcmVhdG9yO1xuXG4gIGlmIChzdHlsZXNPcHRpb25zLmRpc2FibGVHZW5lcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoZWV0TWFuYWdlciA9IG11bHRpS2V5U3RvcmUuZ2V0KHN0eWxlc09wdGlvbnMuc2hlZXRzTWFuYWdlciwgc3R5bGVzQ3JlYXRvciwgdGhlbWUpO1xuICBzaGVldE1hbmFnZXIucmVmcyAtPSAxO1xuICB2YXIgc2hlZXRzUmVnaXN0cnkgPSBzdHlsZXNPcHRpb25zLnNoZWV0c1JlZ2lzdHJ5O1xuXG4gIGlmIChzaGVldE1hbmFnZXIucmVmcyA9PT0gMCkge1xuICAgIG11bHRpS2V5U3RvcmUuZGVsZXRlKHN0eWxlc09wdGlvbnMuc2hlZXRzTWFuYWdlciwgc3R5bGVzQ3JlYXRvciwgdGhlbWUpO1xuICAgIHN0eWxlc09wdGlvbnMuanNzLnJlbW92ZVN0eWxlU2hlZXQoc2hlZXRNYW5hZ2VyLnN0YXRpY1NoZWV0KTtcblxuICAgIGlmIChzaGVldHNSZWdpc3RyeSkge1xuICAgICAgc2hlZXRzUmVnaXN0cnkucmVtb3ZlKHNoZWV0TWFuYWdlci5zdGF0aWNTaGVldCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLmR5bmFtaWNTaGVldCkge1xuICAgIHN0eWxlc09wdGlvbnMuanNzLnJlbW92ZVN0eWxlU2hlZXQoc3RhdGUuZHluYW1pY1NoZWV0KTtcblxuICAgIGlmIChzaGVldHNSZWdpc3RyeSkge1xuICAgICAgc2hlZXRzUmVnaXN0cnkucmVtb3ZlKHN0YXRlLmR5bmFtaWNTaGVldCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZVN5bmNocm9ub3VzRWZmZWN0KGZ1bmMsIHZhbHVlcykge1xuICB2YXIga2V5ID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgdmFyIG91dHB1dDsgLy8gU3RvcmUgXCJnZW5lcmF0aW9uXCIga2V5LiBKdXN0IHJldHVybnMgYSBuZXcgb2JqZWN0IGV2ZXJ5IHRpbWVcblxuICB2YXIgY3VycmVudEtleSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7fTtcbiAgfSwgdmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgLy8gXCJ0aGUgZmlyc3QgcmVuZGVyXCIsIG9yIFwibWVtbyBkcm9wcGVkIHRoZSB2YWx1ZVwiXG5cbiAgaWYgKGtleS5jdXJyZW50ICE9PSBjdXJyZW50S2V5KSB7XG4gICAga2V5LmN1cnJlbnQgPSBjdXJyZW50S2V5O1xuICAgIG91dHB1dCA9IGZ1bmMoKTtcbiAgfVxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRLZXldIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1ha2VTdHlsZXMoc3R5bGVzT3JDcmVhdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSxcbiAgICAgIGNsYXNzTmFtZVByZWZpeE9wdGlvbiA9IG9wdGlvbnMuY2xhc3NOYW1lUHJlZml4LFxuICAgICAgQ29tcG9uZW50ID0gb3B0aW9ucy5Db21wb25lbnQsXG4gICAgICBfb3B0aW9ucyRkZWZhdWx0VGhlbWUgPSBvcHRpb25zLmRlZmF1bHRUaGVtZSxcbiAgICAgIGRlZmF1bHRUaGVtZSA9IF9vcHRpb25zJGRlZmF1bHRUaGVtZSA9PT0gdm9pZCAwID8gbm9vcFRoZW1lIDogX29wdGlvbnMkZGVmYXVsdFRoZW1lLFxuICAgICAgc3R5bGVzT3B0aW9uczIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3B0aW9ucywgW1wibmFtZVwiLCBcImNsYXNzTmFtZVByZWZpeFwiLCBcIkNvbXBvbmVudFwiLCBcImRlZmF1bHRUaGVtZVwiXSk7XG5cbiAgdmFyIHN0eWxlc0NyZWF0b3IgPSBnZXRTdHlsZXNDcmVhdG9yKHN0eWxlc09yQ3JlYXRvcik7XG4gIHZhciBjbGFzc05hbWVQcmVmaXggPSBuYW1lIHx8IGNsYXNzTmFtZVByZWZpeE9wdGlvbiB8fCAnbWFrZVN0eWxlcyc7XG4gIHN0eWxlc0NyZWF0b3Iub3B0aW9ucyA9IHtcbiAgICBpbmRleDogaW5jcmVtZW50KCksXG4gICAgbmFtZTogbmFtZSxcbiAgICBtZXRhOiBjbGFzc05hbWVQcmVmaXgsXG4gICAgY2xhc3NOYW1lUHJlZml4OiBjbGFzc05hbWVQcmVmaXhcbiAgfTtcblxuICB2YXIgdXNlU3R5bGVzID0gZnVuY3Rpb24gdXNlU3R5bGVzKCkge1xuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIHRoZW1lID0gdXNlVGhlbWUoKSB8fCBkZWZhdWx0VGhlbWU7XG5cbiAgICB2YXIgc3R5bGVzT3B0aW9ucyA9IF9leHRlbmRzKF9leHRlbmRzKHt9LCBSZWFjdC51c2VDb250ZXh0KFN0eWxlc0NvbnRleHQpKSwgc3R5bGVzT3B0aW9uczIpO1xuXG4gICAgdmFyIGluc3RhbmNlID0gUmVhY3QudXNlUmVmKCk7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IFJlYWN0LnVzZVJlZigpO1xuICAgIHVzZVN5bmNocm9ub3VzRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBzdGF0ZToge30sXG4gICAgICAgIHN0eWxlc0NyZWF0b3I6IHN0eWxlc0NyZWF0b3IsXG4gICAgICAgIHN0eWxlc09wdGlvbnM6IHN0eWxlc09wdGlvbnMsXG4gICAgICAgIHRoZW1lOiB0aGVtZVxuICAgICAgfTtcbiAgICAgIGF0dGFjaChjdXJyZW50LCBwcm9wcyk7XG4gICAgICBzaG91bGRVcGRhdGUuY3VycmVudCA9IGZhbHNlO1xuICAgICAgaW5zdGFuY2UuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBkZXRhY2goY3VycmVudCk7XG4gICAgICB9O1xuICAgIH0sIFt0aGVtZSwgc3R5bGVzQ3JlYXRvcl0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlLmN1cnJlbnQpIHtcbiAgICAgICAgdXBkYXRlKGluc3RhbmNlLmN1cnJlbnQsIHByb3BzKTtcbiAgICAgIH1cblxuICAgICAgc2hvdWxkVXBkYXRlLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHZhciBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhpbnN0YW5jZS5jdXJyZW50LCBwcm9wcy5jbGFzc2VzLCBDb21wb25lbnQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgUmVhY3QudXNlRGVidWdWYWx1ZShjbGFzc2VzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NlcztcbiAgfTtcblxuICByZXR1cm4gdXNlU3R5bGVzO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbi8vIFNvcnRlZCBBU0MgYnkgc2l6ZS4gVGhhdCdzIGltcG9ydGFudC5cbi8vIEl0IGNhbid0IGJlIGNvbmZpZ3VyZWQgYXMgaXQncyB1c2VkIHN0YXRpY2FsbHkgZm9yIHByb3BUeXBlcy5cbmV4cG9ydCB2YXIga2V5cyA9IFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXTsgLy8gS2VlcCBpbiBtaW5kIHRoYXQgQG1lZGlhIGlzIGluY2x1c2l2ZSBieSB0aGUgQ1NTIHNwZWNpZmljYXRpb24uXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzKSB7XG4gIHZhciBfYnJlYWtwb2ludHMkdmFsdWVzID0gYnJlYWtwb2ludHMudmFsdWVzLFxuICAgICAgdmFsdWVzID0gX2JyZWFrcG9pbnRzJHZhbHVlcyA9PT0gdm9pZCAwID8ge1xuICAgIHhzOiAwLFxuICAgIHNtOiA2MDAsXG4gICAgbWQ6IDk2MCxcbiAgICBsZzogMTI4MCxcbiAgICB4bDogMTkyMFxuICB9IDogX2JyZWFrcG9pbnRzJHZhbHVlcyxcbiAgICAgIF9icmVha3BvaW50cyR1bml0ID0gYnJlYWtwb2ludHMudW5pdCxcbiAgICAgIHVuaXQgPSBfYnJlYWtwb2ludHMkdW5pdCA9PT0gdm9pZCAwID8gJ3B4JyA6IF9icmVha3BvaW50cyR1bml0LFxuICAgICAgX2JyZWFrcG9pbnRzJHN0ZXAgPSBicmVha3BvaW50cy5zdGVwLFxuICAgICAgc3RlcCA9IF9icmVha3BvaW50cyRzdGVwID09PSB2b2lkIDAgPyA1IDogX2JyZWFrcG9pbnRzJHN0ZXAsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhicmVha3BvaW50cywgW1widmFsdWVzXCIsIFwidW5pdFwiLCBcInN0ZXBcIl0pO1xuXG4gIGZ1bmN0aW9uIHVwKGtleSkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiB2YWx1ZXNba2V5XSA9PT0gJ251bWJlcicgPyB2YWx1ZXNba2V5XSA6IGtleTtcbiAgICByZXR1cm4gXCJAbWVkaWEgKG1pbi13aWR0aDpcIi5jb25jYXQodmFsdWUpLmNvbmNhdCh1bml0LCBcIilcIik7XG4gIH1cblxuICBmdW5jdGlvbiBkb3duKGtleSkge1xuICAgIHZhciBlbmRJbmRleCA9IGtleXMuaW5kZXhPZihrZXkpICsgMTtcbiAgICB2YXIgdXBwZXJib3VuZCA9IHZhbHVlc1trZXlzW2VuZEluZGV4XV07XG5cbiAgICBpZiAoZW5kSW5kZXggPT09IGtleXMubGVuZ3RoKSB7XG4gICAgICAvLyB4bCBkb3duIGFwcGxpZXMgdG8gYWxsIHNpemVzXG4gICAgICByZXR1cm4gdXAoJ3hzJyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIHVwcGVyYm91bmQgPT09ICdudW1iZXInICYmIGVuZEluZGV4ID4gMCA/IHVwcGVyYm91bmQgOiBrZXk7XG4gICAgcmV0dXJuIFwiQG1lZGlhIChtYXgtd2lkdGg6XCIuY29uY2F0KHZhbHVlIC0gc3RlcCAvIDEwMCkuY29uY2F0KHVuaXQsIFwiKVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJldHdlZW4oc3RhcnQsIGVuZCkge1xuICAgIHZhciBlbmRJbmRleCA9IGtleXMuaW5kZXhPZihlbmQpO1xuXG4gICAgaWYgKGVuZEluZGV4ID09PSBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiB1cChzdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiQG1lZGlhIChtaW4td2lkdGg6XCIuY29uY2F0KHR5cGVvZiB2YWx1ZXNbc3RhcnRdID09PSAnbnVtYmVyJyA/IHZhbHVlc1tzdGFydF0gOiBzdGFydCkuY29uY2F0KHVuaXQsIFwiKSBhbmQgXCIpICsgXCIobWF4LXdpZHRoOlwiLmNvbmNhdCgoZW5kSW5kZXggIT09IC0xICYmIHR5cGVvZiB2YWx1ZXNba2V5c1tlbmRJbmRleCArIDFdXSA9PT0gJ251bWJlcicgPyB2YWx1ZXNba2V5c1tlbmRJbmRleCArIDFdXSA6IGVuZCkgLSBzdGVwIC8gMTAwKS5jb25jYXQodW5pdCwgXCIpXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25seShrZXkpIHtcbiAgICByZXR1cm4gYmV0d2VlbihrZXksIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiB3aWR0aChrZXkpIHtcbiAgICByZXR1cm4gdmFsdWVzW2tleV07XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIGtleXM6IGtleXMsXG4gICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgdXA6IHVwLFxuICAgIGRvd246IGRvd24sXG4gICAgYmV0d2VlbjogYmV0d2VlbixcbiAgICBvbmx5OiBvbmx5LFxuICAgIHdpZHRoOiB3aWR0aFxuICB9LCBvdGhlcik7XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlTWl4aW5zKGJyZWFrcG9pbnRzLCBzcGFjaW5nLCBtaXhpbnMpIHtcbiAgdmFyIF90b29sYmFyO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgZ3V0dGVyczogZnVuY3Rpb24gZ3V0dGVycygpIHtcbiAgICAgIHZhciBzdHlsZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgLy8gVG8gZGVwcmVjYXRlIGluIHY0LjFcbiAgICAgIC8vICAgICAgIHdhcm5pbmcoXG4gICAgICAvLyAgICAgICAgIGZhbHNlLFxuICAgICAgLy8gICAgICAgICBbXG4gICAgICAvLyAgICAgICAgICAgJ01hdGVyaWFsLVVJOiBUaGVtZS5taXhpbnMuZ3V0dGVycygpIGlzIGRlcHJlY2F0ZWQuJyxcbiAgICAgIC8vICAgICAgICAgICAnWW91IGNhbiB1c2UgdGhlIHNvdXJjZSBvZiB0aGUgbWl4aW4gZGlyZWN0bHk6JyxcbiAgICAgIC8vICAgICAgICAgICBgXG4gICAgICAvLyBwYWRkaW5nTGVmdDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIC8vIHBhZGRpbmdSaWdodDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIC8vIFt0aGVtZS5icmVha3BvaW50cy51cCgnc20nKV06IHtcbiAgICAgIC8vICAgcGFkZGluZ0xlZnQ6IHRoZW1lLnNwYWNpbmcoMyksXG4gICAgICAvLyAgIHBhZGRpbmdSaWdodDogdGhlbWUuc3BhY2luZygzKSxcbiAgICAgIC8vIH0sXG4gICAgICAvLyBgLFxuICAgICAgLy8gICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgLy8gICAgICAgKTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIHBhZGRpbmdMZWZ0OiBzcGFjaW5nKDIpLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IHNwYWNpbmcoMilcbiAgICAgIH0sIHN0eWxlcywgX2RlZmluZVByb3BlcnR5KHt9LCBicmVha3BvaW50cy51cCgnc20nKSwgX2V4dGVuZHMoe1xuICAgICAgICBwYWRkaW5nTGVmdDogc3BhY2luZygzKSxcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiBzcGFjaW5nKDMpXG4gICAgICB9LCBzdHlsZXNbYnJlYWtwb2ludHMudXAoJ3NtJyldKSkpO1xuICAgIH0sXG4gICAgdG9vbGJhcjogKF90b29sYmFyID0ge1xuICAgICAgbWluSGVpZ2h0OiA1NlxuICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfdG9vbGJhciwgXCJcIi5jb25jYXQoYnJlYWtwb2ludHMudXAoJ3hzJyksIFwiIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSlcIiksIHtcbiAgICAgIG1pbkhlaWdodDogNDhcbiAgICB9KSwgX2RlZmluZVByb3BlcnR5KF90b29sYmFyLCBicmVha3BvaW50cy51cCgnc20nKSwge1xuICAgICAgbWluSGVpZ2h0OiA2NFxuICAgIH0pLCBfdG9vbGJhcilcbiAgfSwgbWl4aW5zKTtcbn0iLCIvKipcbiAqIFdBUk5JTkc6IERvbid0IGltcG9ydCB0aGlzIGRpcmVjdGx5LlxuICogVXNlIGBNdWlFcnJvcmAgZnJvbSBgQG1hdGVyaWFsLXVpL3V0aWxzL21hY3Jvcy9NdWlFcnJvci5tYWNyb2AgaW5zdGVhZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdE11aUVycm9yTWVzc2FnZShjb2RlKSB7XG4gIC8vIEFwcGx5IGJhYmVsLXBsdWdpbi10cmFuc2Zvcm0tdGVtcGxhdGUtbGl0ZXJhbHMgaW4gbG9vc2UgbW9kZVxuICAvLyBsb29zZSBtb2RlIGlzIHNhZmUgaWZmIHdlJ3JlIGNvbmNhdGVuYXRpbmcgcHJpbWl0aXZlc1xuICAvLyBzZWUgaHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS10ZW1wbGF0ZS1saXRlcmFscyNsb29zZVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci10ZW1wbGF0ZSAqL1xuICB2YXIgdXJsID0gJ2h0dHBzOi8vbWF0ZXJpYWwtdWkuY29tL3Byb2R1Y3Rpb24tZXJyb3IvP2NvZGU9JyArIGNvZGU7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAvLyByZXN0IHBhcmFtcyBvdmVyLXRyYW5zcGlsZSBmb3IgdGhpcyBjYXNlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgIHVybCArPSAnJmFyZ3NbXT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tpXSk7XG4gIH1cblxuICByZXR1cm4gJ01pbmlmaWVkIE1hdGVyaWFsLVVJIGVycm9yICMnICsgY29kZSArICc7IHZpc2l0ICcgKyB1cmwgKyAnIGZvciB0aGUgZnVsbCBtZXNzYWdlLic7XG4gIC8qIGVzbGludC1lbmFibGUgcHJlZmVyLXRlbXBsYXRlICovXG59IiwidmFyIGNvbW1vbiA9IHtcbiAgYmxhY2s6ICcjMDAwJyxcbiAgd2hpdGU6ICcjZmZmJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGNvbW1vbjsiLCJ2YXIgZ3JleSA9IHtcbiAgNTA6ICcjZmFmYWZhJyxcbiAgMTAwOiAnI2Y1ZjVmNScsXG4gIDIwMDogJyNlZWVlZWUnLFxuICAzMDA6ICcjZTBlMGUwJyxcbiAgNDAwOiAnI2JkYmRiZCcsXG4gIDUwMDogJyM5ZTllOWUnLFxuICA2MDA6ICcjNzU3NTc1JyxcbiAgNzAwOiAnIzYxNjE2MScsXG4gIDgwMDogJyM0MjQyNDInLFxuICA5MDA6ICcjMjEyMTIxJyxcbiAgQTEwMDogJyNkNWQ1ZDUnLFxuICBBMjAwOiAnI2FhYWFhYScsXG4gIEE0MDA6ICcjMzAzMDMwJyxcbiAgQTcwMDogJyM2MTYxNjEnXG59O1xuZXhwb3J0IGRlZmF1bHQgZ3JleTsiLCJ2YXIgaW5kaWdvID0ge1xuICA1MDogJyNlOGVhZjYnLFxuICAxMDA6ICcjYzVjYWU5JyxcbiAgMjAwOiAnIzlmYThkYScsXG4gIDMwMDogJyM3OTg2Y2InLFxuICA0MDA6ICcjNWM2YmMwJyxcbiAgNTAwOiAnIzNmNTFiNScsXG4gIDYwMDogJyMzOTQ5YWInLFxuICA3MDA6ICcjMzAzZjlmJyxcbiAgODAwOiAnIzI4MzU5MycsXG4gIDkwMDogJyMxYTIzN2UnLFxuICBBMTAwOiAnIzhjOWVmZicsXG4gIEEyMDA6ICcjNTM2ZGZlJyxcbiAgQTQwMDogJyMzZDVhZmUnLFxuICBBNzAwOiAnIzMwNGZmZSdcbn07XG5leHBvcnQgZGVmYXVsdCBpbmRpZ287IiwidmFyIHBpbmsgPSB7XG4gIDUwOiAnI2ZjZTRlYycsXG4gIDEwMDogJyNmOGJiZDAnLFxuICAyMDA6ICcjZjQ4ZmIxJyxcbiAgMzAwOiAnI2YwNjI5MicsXG4gIDQwMDogJyNlYzQwN2EnLFxuICA1MDA6ICcjZTkxZTYzJyxcbiAgNjAwOiAnI2Q4MWI2MCcsXG4gIDcwMDogJyNjMjE4NWInLFxuICA4MDA6ICcjYWQxNDU3JyxcbiAgOTAwOiAnIzg4MGU0ZicsXG4gIEExMDA6ICcjZmY4MGFiJyxcbiAgQTIwMDogJyNmZjQwODEnLFxuICBBNDAwOiAnI2Y1MDA1NycsXG4gIEE3MDA6ICcjYzUxMTYyJ1xufTtcbmV4cG9ydCBkZWZhdWx0IHBpbms7IiwidmFyIHJlZCA9IHtcbiAgNTA6ICcjZmZlYmVlJyxcbiAgMTAwOiAnI2ZmY2RkMicsXG4gIDIwMDogJyNlZjlhOWEnLFxuICAzMDA6ICcjZTU3MzczJyxcbiAgNDAwOiAnI2VmNTM1MCcsXG4gIDUwMDogJyNmNDQzMzYnLFxuICA2MDA6ICcjZTUzOTM1JyxcbiAgNzAwOiAnI2QzMmYyZicsXG4gIDgwMDogJyNjNjI4MjgnLFxuICA5MDA6ICcjYjcxYzFjJyxcbiAgQTEwMDogJyNmZjhhODAnLFxuICBBMjAwOiAnI2ZmNTI1MicsXG4gIEE0MDA6ICcjZmYxNzQ0JyxcbiAgQTcwMDogJyNkNTAwMDAnXG59O1xuZXhwb3J0IGRlZmF1bHQgcmVkOyIsInZhciBvcmFuZ2UgPSB7XG4gIDUwOiAnI2ZmZjNlMCcsXG4gIDEwMDogJyNmZmUwYjInLFxuICAyMDA6ICcjZmZjYzgwJyxcbiAgMzAwOiAnI2ZmYjc0ZCcsXG4gIDQwMDogJyNmZmE3MjYnLFxuICA1MDA6ICcjZmY5ODAwJyxcbiAgNjAwOiAnI2ZiOGMwMCcsXG4gIDcwMDogJyNmNTdjMDAnLFxuICA4MDA6ICcjZWY2YzAwJyxcbiAgOTAwOiAnI2U2NTEwMCcsXG4gIEExMDA6ICcjZmZkMTgwJyxcbiAgQTIwMDogJyNmZmFiNDAnLFxuICBBNDAwOiAnI2ZmOTEwMCcsXG4gIEE3MDA6ICcjZmY2ZDAwJ1xufTtcbmV4cG9ydCBkZWZhdWx0IG9yYW5nZTsiLCJ2YXIgYmx1ZSA9IHtcbiAgNTA6ICcjZTNmMmZkJyxcbiAgMTAwOiAnI2JiZGVmYicsXG4gIDIwMDogJyM5MGNhZjknLFxuICAzMDA6ICcjNjRiNWY2JyxcbiAgNDAwOiAnIzQyYTVmNScsXG4gIDUwMDogJyMyMTk2ZjMnLFxuICA2MDA6ICcjMWU4OGU1JyxcbiAgNzAwOiAnIzE5NzZkMicsXG4gIDgwMDogJyMxNTY1YzAnLFxuICA5MDA6ICcjMGQ0N2ExJyxcbiAgQTEwMDogJyM4MmIxZmYnLFxuICBBMjAwOiAnIzQ0OGFmZicsXG4gIEE0MDA6ICcjMjk3OWZmJyxcbiAgQTcwMDogJyMyOTYyZmYnXG59O1xuZXhwb3J0IGRlZmF1bHQgYmx1ZTsiLCJ2YXIgZ3JlZW4gPSB7XG4gIDUwOiAnI2U4ZjVlOScsXG4gIDEwMDogJyNjOGU2YzknLFxuICAyMDA6ICcjYTVkNmE3JyxcbiAgMzAwOiAnIzgxYzc4NCcsXG4gIDQwMDogJyM2NmJiNmEnLFxuICA1MDA6ICcjNGNhZjUwJyxcbiAgNjAwOiAnIzQzYTA0NycsXG4gIDcwMDogJyMzODhlM2MnLFxuICA4MDA6ICcjMmU3ZDMyJyxcbiAgOTAwOiAnIzFiNWUyMCcsXG4gIEExMDA6ICcjYjlmNmNhJyxcbiAgQTIwMDogJyM2OWYwYWUnLFxuICBBNDAwOiAnIzAwZTY3NicsXG4gIEE3MDA6ICcjMDBjODUzJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGdyZWVuOyIsImltcG9ydCB7IGZvcm1hdE11aUVycm9yTWVzc2FnZSBhcyBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkBtYXRlcmlhbC11aS91dGlsc1wiO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgd2hvc2UgdmFsdWUgaXMgbGltaXRlZCB0byB0aGUgZ2l2ZW4gcmFuZ2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgb3V0cHV0IHJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgb3V0cHV0IHJhbmdlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIG51bWJlciBpbiB0aGUgcmFuZ2UgW21pbiwgbWF4XVxuICovXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSkge1xuICB2YXIgbWluID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgbWF4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTWF0ZXJpYWwtVUk6IFRoZSB2YWx1ZSBwcm92aWRlZCBcIi5jb25jYXQodmFsdWUsIFwiIGlzIG91dCBvZiByYW5nZSBbXCIpLmNvbmNhdChtaW4sIFwiLCBcIikuY29uY2F0KG1heCwgXCJdLlwiKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgdmFsdWUpLCBtYXgpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGNvbG9yIGZyb20gQ1NTIGhleCBmb3JtYXQgdG8gQ1NTIHJnYiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gSGV4IGNvbG9yLCBpLmUuICNubm4gb3IgI25ubm5ublxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgcmdiIGNvbG9yIHN0cmluZ1xuICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvUmdiKGNvbG9yKSB7XG4gIGNvbG9yID0gY29sb3Iuc3Vic3RyKDEpO1xuICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiLnsxLFwiLmNvbmNhdChjb2xvci5sZW5ndGggPj0gNiA/IDIgOiAxLCBcIn1cIiksICdnJyk7XG4gIHZhciBjb2xvcnMgPSBjb2xvci5tYXRjaChyZSk7XG5cbiAgaWYgKGNvbG9ycyAmJiBjb2xvcnNbMF0ubGVuZ3RoID09PSAxKSB7XG4gICAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIG4gKyBuO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNvbG9ycyA/IFwicmdiXCIuY29uY2F0KGNvbG9ycy5sZW5ndGggPT09IDQgPyAnYScgOiAnJywgXCIoXCIpLmNvbmNhdChjb2xvcnMubWFwKGZ1bmN0aW9uIChuLCBpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8IDMgPyBwYXJzZUludChuLCAxNikgOiBNYXRoLnJvdW5kKHBhcnNlSW50KG4sIDE2KSAvIDI1NSAqIDEwMDApIC8gMTAwMDtcbiAgfSkuam9pbignLCAnKSwgXCIpXCIpIDogJyc7XG59XG5cbmZ1bmN0aW9uIGludFRvSGV4KGludCkge1xuICB2YXIgaGV4ID0gaW50LnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyBcIjBcIi5jb25jYXQoaGV4KSA6IGhleDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBjb2xvciBmcm9tIENTUyByZ2IgZm9ybWF0IHRvIENTUyBoZXggZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIFJHQiBjb2xvciwgaS5lLiByZ2IobiwgbiwgbilcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIHJnYiBjb2xvciBzdHJpbmcsIGkuZS4gI25ubm5ublxuICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYlRvSGV4KGNvbG9yKSB7XG4gIC8vIElkZW1wb3RlbnRcbiAgaWYgKGNvbG9yLmluZGV4T2YoJyMnKSA9PT0gMCkge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIHZhciBfZGVjb21wb3NlQ29sb3IgPSBkZWNvbXBvc2VDb2xvcihjb2xvciksXG4gICAgICB2YWx1ZXMgPSBfZGVjb21wb3NlQ29sb3IudmFsdWVzO1xuXG4gIHJldHVybiBcIiNcIi5jb25jYXQodmFsdWVzLm1hcChmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBpbnRUb0hleChuKTtcbiAgfSkuam9pbignJykpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGNvbG9yIGZyb20gaHNsIGZvcm1hdCB0byByZ2IgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIEhTTCBjb2xvciB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHJnYiBjb2xvciB2YWx1ZXNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaHNsVG9SZ2IoY29sb3IpIHtcbiAgY29sb3IgPSBkZWNvbXBvc2VDb2xvcihjb2xvcik7XG4gIHZhciBfY29sb3IgPSBjb2xvcixcbiAgICAgIHZhbHVlcyA9IF9jb2xvci52YWx1ZXM7XG4gIHZhciBoID0gdmFsdWVzWzBdO1xuICB2YXIgcyA9IHZhbHVlc1sxXSAvIDEwMDtcbiAgdmFyIGwgPSB2YWx1ZXNbMl0gLyAxMDA7XG4gIHZhciBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcblxuICB2YXIgZiA9IGZ1bmN0aW9uIGYobikge1xuICAgIHZhciBrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAobiArIGggLyAzMCkgJSAxMjtcbiAgICByZXR1cm4gbCAtIGEgKiBNYXRoLm1heChNYXRoLm1pbihrIC0gMywgOSAtIGssIDEpLCAtMSk7XG4gIH07XG5cbiAgdmFyIHR5cGUgPSAncmdiJztcbiAgdmFyIHJnYiA9IFtNYXRoLnJvdW5kKGYoMCkgKiAyNTUpLCBNYXRoLnJvdW5kKGYoOCkgKiAyNTUpLCBNYXRoLnJvdW5kKGYoNCkgKiAyNTUpXTtcblxuICBpZiAoY29sb3IudHlwZSA9PT0gJ2hzbGEnKSB7XG4gICAgdHlwZSArPSAnYSc7XG4gICAgcmdiLnB1c2godmFsdWVzWzNdKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbXBvc2VDb2xvcih7XG4gICAgdHlwZTogdHlwZSxcbiAgICB2YWx1ZXM6IHJnYlxuICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgdHlwZSBhbmQgdmFsdWVzIG9mIGEgY29sb3IuXG4gKlxuICogTm90ZTogRG9lcyBub3Qgc3VwcG9ydCByZ2IgJSB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKVxuICogQHJldHVybnMge29iamVjdH0gLSBBIE1VSSBjb2xvciBvYmplY3Q6IHt0eXBlOiBzdHJpbmcsIHZhbHVlczogbnVtYmVyW119XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcG9zZUNvbG9yKGNvbG9yKSB7XG4gIC8vIElkZW1wb3RlbnRcbiAgaWYgKGNvbG9yLnR5cGUpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBpZiAoY29sb3IuY2hhckF0KDApID09PSAnIycpIHtcbiAgICByZXR1cm4gZGVjb21wb3NlQ29sb3IoaGV4VG9SZ2IoY29sb3IpKTtcbiAgfVxuXG4gIHZhciBtYXJrZXIgPSBjb2xvci5pbmRleE9mKCcoJyk7XG4gIHZhciB0eXBlID0gY29sb3Iuc3Vic3RyaW5nKDAsIG1hcmtlcik7XG5cbiAgaWYgKFsncmdiJywgJ3JnYmEnLCAnaHNsJywgJ2hzbGEnXS5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk1hdGVyaWFsLVVJOiBVbnN1cHBvcnRlZCBgXCIuY29uY2F0KGNvbG9yLCBcImAgY29sb3IuXFxuV2Ugc3VwcG9ydCB0aGUgZm9sbG93aW5nIGZvcm1hdHM6ICNubm4sICNubm5ubm4sIHJnYigpLCByZ2JhKCksIGhzbCgpLCBoc2xhKCkuXCIpIDogX2Zvcm1hdE11aUVycm9yTWVzc2FnZSgzLCBjb2xvcikpO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IGNvbG9yLnN1YnN0cmluZyhtYXJrZXIgKyAxLCBjb2xvci5sZW5ndGggLSAxKS5zcGxpdCgnLCcpO1xuICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB2YWx1ZXM6IHZhbHVlc1xuICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGNvbG9yIG9iamVjdCB3aXRoIHR5cGUgYW5kIHZhbHVlcyB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29sb3IgLSBEZWNvbXBvc2VkIGNvbG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IudHlwZSAtIE9uZSBvZjogJ3JnYicsICdyZ2JhJywgJ2hzbCcsICdoc2xhJ1xuICogQHBhcmFtIHthcnJheX0gY29sb3IudmFsdWVzIC0gW24sbixuXSBvciBbbixuLG4sbl1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZ1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByZWNvbXBvc2VDb2xvcihjb2xvcikge1xuICB2YXIgdHlwZSA9IGNvbG9yLnR5cGU7XG4gIHZhciB2YWx1ZXMgPSBjb2xvci52YWx1ZXM7XG5cbiAgaWYgKHR5cGUuaW5kZXhPZigncmdiJykgIT09IC0xKSB7XG4gICAgLy8gT25seSBjb252ZXJ0IHRoZSBmaXJzdCAzIHZhbHVlcyB0byBpbnQgKGkuZS4gbm90IGFscGhhKVxuICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKG4sIGkpIHtcbiAgICAgIHJldHVybiBpIDwgMyA/IHBhcnNlSW50KG4sIDEwKSA6IG47XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZS5pbmRleE9mKCdoc2wnKSAhPT0gLTEpIHtcbiAgICB2YWx1ZXNbMV0gPSBcIlwiLmNvbmNhdCh2YWx1ZXNbMV0sIFwiJVwiKTtcbiAgICB2YWx1ZXNbMl0gPSBcIlwiLmNvbmNhdCh2YWx1ZXNbMl0sIFwiJVwiKTtcbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdCh0eXBlLCBcIihcIikuY29uY2F0KHZhbHVlcy5qb2luKCcsICcpLCBcIilcIik7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbnRyYXN0IHJhdGlvIGJldHdlZW4gdHdvIGNvbG9ycy5cbiAqXG4gKiBGb3JtdWxhOiBodHRwczovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0cxNy5odG1sI0cxNy10ZXN0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JlZ3JvdW5kIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKVxuICogQHBhcmFtIHtzdHJpbmd9IGJhY2tncm91bmQgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIGNvbnRyYXN0IHJhdGlvIHZhbHVlIGluIHRoZSByYW5nZSAwIC0gMjEuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRyYXN0UmF0aW8oZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkge1xuICB2YXIgbHVtQSA9IGdldEx1bWluYW5jZShmb3JlZ3JvdW5kKTtcbiAgdmFyIGx1bUIgPSBnZXRMdW1pbmFuY2UoYmFja2dyb3VuZCk7XG4gIHJldHVybiAoTWF0aC5tYXgobHVtQSwgbHVtQikgKyAwLjA1KSAvIChNYXRoLm1pbihsdW1BLCBsdW1CKSArIDAuMDUpO1xufVxuLyoqXG4gKiBUaGUgcmVsYXRpdmUgYnJpZ2h0bmVzcyBvZiBhbnkgcG9pbnQgaW4gYSBjb2xvciBzcGFjZSxcbiAqIG5vcm1hbGl6ZWQgdG8gMCBmb3IgZGFya2VzdCBibGFjayBhbmQgMSBmb3IgbGlnaHRlc3Qgd2hpdGUuXG4gKlxuICogRm9ybXVsYTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1dDQUcyMC1URUNIUy9HMTcuaHRtbCNHMTctdGVzdHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVsYXRpdmUgYnJpZ2h0bmVzcyBvZiB0aGUgY29sb3IgaW4gdGhlIHJhbmdlIDAgLSAxXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEx1bWluYW5jZShjb2xvcikge1xuICBjb2xvciA9IGRlY29tcG9zZUNvbG9yKGNvbG9yKTtcbiAgdmFyIHJnYiA9IGNvbG9yLnR5cGUgPT09ICdoc2wnID8gZGVjb21wb3NlQ29sb3IoaHNsVG9SZ2IoY29sb3IpKS52YWx1ZXMgOiBjb2xvci52YWx1ZXM7XG4gIHJnYiA9IHJnYi5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCAvPSAyNTU7IC8vIG5vcm1hbGl6ZWRcblxuICAgIHJldHVybiB2YWwgPD0gMC4wMzkyOCA/IHZhbCAvIDEyLjkyIDogTWF0aC5wb3coKHZhbCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICB9KTsgLy8gVHJ1bmNhdGUgYXQgMyBkaWdpdHNcblxuICByZXR1cm4gTnVtYmVyKCgwLjIxMjYgKiByZ2JbMF0gKyAwLjcxNTIgKiByZ2JbMV0gKyAwLjA3MjIgKiByZ2JbMl0pLnRvRml4ZWQoMykpO1xufVxuLyoqXG4gKiBEYXJrZW4gb3IgbGlnaHRlbiBhIGNvbG9yLCBkZXBlbmRpbmcgb24gaXRzIGx1bWluYW5jZS5cbiAqIExpZ2h0IGNvbG9ycyBhcmUgZGFya2VuZWQsIGRhcmsgY29sb3JzIGFyZSBsaWdodGVuZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZWZmaWNpZW50PTAuMTUgLSBtdWx0aXBsaWVyIGluIHRoZSByYW5nZSAwIC0gMVxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLiBIZXggaW5wdXQgdmFsdWVzIGFyZSByZXR1cm5lZCBhcyByZ2JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZW1waGFzaXplKGNvbG9yKSB7XG4gIHZhciBjb2VmZmljaWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMC4xNTtcbiAgcmV0dXJuIGdldEx1bWluYW5jZShjb2xvcikgPiAwLjUgPyBkYXJrZW4oY29sb3IsIGNvZWZmaWNpZW50KSA6IGxpZ2h0ZW4oY29sb3IsIGNvZWZmaWNpZW50KTtcbn1cbi8qKlxuICogU2V0IHRoZSBhYnNvbHV0ZSB0cmFuc3BhcmVuY3kgb2YgYSBjb2xvci5cbiAqIEFueSBleGlzdGluZyBhbHBoYSB2YWx1ZXMgYXJlIG92ZXJ3cml0dGVuLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIENTUyBjb2xvciwgaS5lLiBvbmUgb2Y6ICNubm4sICNubm5ubm4sIHJnYigpLCByZ2JhKCksIGhzbCgpLCBoc2xhKClcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIHNldCB0aGUgYWxwaGEgY2hhbm5lbCB0byBpbiB0aGUgcmFuZ2UgMCAtMVxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLiBIZXggaW5wdXQgdmFsdWVzIGFyZSByZXR1cm5lZCBhcyByZ2JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmFkZShjb2xvciwgdmFsdWUpIHtcbiAgY29sb3IgPSBkZWNvbXBvc2VDb2xvcihjb2xvcik7XG4gIHZhbHVlID0gY2xhbXAodmFsdWUpO1xuXG4gIGlmIChjb2xvci50eXBlID09PSAncmdiJyB8fCBjb2xvci50eXBlID09PSAnaHNsJykge1xuICAgIGNvbG9yLnR5cGUgKz0gJ2EnO1xuICB9XG5cbiAgY29sb3IudmFsdWVzWzNdID0gdmFsdWU7XG4gIHJldHVybiByZWNvbXBvc2VDb2xvcihjb2xvcik7XG59XG4vKipcbiAqIERhcmtlbnMgYSBjb2xvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpXG4gKiBAcGFyYW0ge251bWJlcn0gY29lZmZpY2llbnQgLSBtdWx0aXBsaWVyIGluIHRoZSByYW5nZSAwIC0gMVxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLiBIZXggaW5wdXQgdmFsdWVzIGFyZSByZXR1cm5lZCBhcyByZ2JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGFya2VuKGNvbG9yLCBjb2VmZmljaWVudCkge1xuICBjb2xvciA9IGRlY29tcG9zZUNvbG9yKGNvbG9yKTtcbiAgY29lZmZpY2llbnQgPSBjbGFtcChjb2VmZmljaWVudCk7XG5cbiAgaWYgKGNvbG9yLnR5cGUuaW5kZXhPZignaHNsJykgIT09IC0xKSB7XG4gICAgY29sb3IudmFsdWVzWzJdICo9IDEgLSBjb2VmZmljaWVudDtcbiAgfSBlbHNlIGlmIChjb2xvci50eXBlLmluZGV4T2YoJ3JnYicpICE9PSAtMSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSArPSAxKSB7XG4gICAgICBjb2xvci52YWx1ZXNbaV0gKj0gMSAtIGNvZWZmaWNpZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWNvbXBvc2VDb2xvcihjb2xvcik7XG59XG4vKipcbiAqIExpZ2h0ZW5zIGEgY29sb3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZWZmaWNpZW50IC0gbXVsdGlwbGllciBpbiB0aGUgcmFuZ2UgMCAtIDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy4gSGV4IGlucHV0IHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgcmdiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxpZ2h0ZW4oY29sb3IsIGNvZWZmaWNpZW50KSB7XG4gIGNvbG9yID0gZGVjb21wb3NlQ29sb3IoY29sb3IpO1xuICBjb2VmZmljaWVudCA9IGNsYW1wKGNvZWZmaWNpZW50KTtcblxuICBpZiAoY29sb3IudHlwZS5pbmRleE9mKCdoc2wnKSAhPT0gLTEpIHtcbiAgICBjb2xvci52YWx1ZXNbMl0gKz0gKDEwMCAtIGNvbG9yLnZhbHVlc1syXSkgKiBjb2VmZmljaWVudDtcbiAgfSBlbHNlIGlmIChjb2xvci50eXBlLmluZGV4T2YoJ3JnYicpICE9PSAtMSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSArPSAxKSB7XG4gICAgICBjb2xvci52YWx1ZXNbaV0gKz0gKDI1NSAtIGNvbG9yLnZhbHVlc1tpXSkgKiBjb2VmZmljaWVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVjb21wb3NlQ29sb3IoY29sb3IpO1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCB7IGZvcm1hdE11aUVycm9yTWVzc2FnZSBhcyBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkBtYXRlcmlhbC11aS91dGlsc1wiO1xuaW1wb3J0IHsgZGVlcG1lcmdlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBjb21tb24gZnJvbSAnLi4vY29sb3JzL2NvbW1vbic7XG5pbXBvcnQgZ3JleSBmcm9tICcuLi9jb2xvcnMvZ3JleSc7XG5pbXBvcnQgaW5kaWdvIGZyb20gJy4uL2NvbG9ycy9pbmRpZ28nO1xuaW1wb3J0IHBpbmsgZnJvbSAnLi4vY29sb3JzL3BpbmsnO1xuaW1wb3J0IHJlZCBmcm9tICcuLi9jb2xvcnMvcmVkJztcbmltcG9ydCBvcmFuZ2UgZnJvbSAnLi4vY29sb3JzL29yYW5nZSc7XG5pbXBvcnQgYmx1ZSBmcm9tICcuLi9jb2xvcnMvYmx1ZSc7XG5pbXBvcnQgZ3JlZW4gZnJvbSAnLi4vY29sb3JzL2dyZWVuJztcbmltcG9ydCB7IGRhcmtlbiwgZ2V0Q29udHJhc3RSYXRpbywgbGlnaHRlbiB9IGZyb20gJy4vY29sb3JNYW5pcHVsYXRvcic7XG5leHBvcnQgdmFyIGxpZ2h0ID0ge1xuICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gc3R5bGUgdGhlIHRleHQuXG4gIHRleHQ6IHtcbiAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgdGV4dC5cbiAgICBwcmltYXJ5OiAncmdiYSgwLCAwLCAwLCAwLjg3KScsXG4gICAgLy8gU2Vjb25kYXJ5IHRleHQuXG4gICAgc2Vjb25kYXJ5OiAncmdiYSgwLCAwLCAwLCAwLjU0KScsXG4gICAgLy8gRGlzYWJsZWQgdGV4dCBoYXZlIGV2ZW4gbG93ZXIgdmlzdWFsIHByb21pbmVuY2UuXG4gICAgZGlzYWJsZWQ6ICdyZ2JhKDAsIDAsIDAsIDAuMzgpJyxcbiAgICAvLyBUZXh0IGhpbnRzLlxuICAgIGhpbnQ6ICdyZ2JhKDAsIDAsIDAsIDAuMzgpJ1xuICB9LFxuICAvLyBUaGUgY29sb3IgdXNlZCB0byBkaXZpZGUgZGlmZmVyZW50IGVsZW1lbnRzLlxuICBkaXZpZGVyOiAncmdiYSgwLCAwLCAwLCAwLjEyKScsXG4gIC8vIFRoZSBiYWNrZ3JvdW5kIGNvbG9ycyB1c2VkIHRvIHN0eWxlIHRoZSBzdXJmYWNlcy5cbiAgLy8gQ29uc2lzdGVuY3kgYmV0d2VlbiB0aGVzZSB2YWx1ZXMgaXMgaW1wb3J0YW50LlxuICBiYWNrZ3JvdW5kOiB7XG4gICAgcGFwZXI6IGNvbW1vbi53aGl0ZSxcbiAgICBkZWZhdWx0OiBncmV5WzUwXVxuICB9LFxuICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gc3R5bGUgdGhlIGFjdGlvbiBlbGVtZW50cy5cbiAgYWN0aW9uOiB7XG4gICAgLy8gVGhlIGNvbG9yIG9mIGFuIGFjdGl2ZSBhY3Rpb24gbGlrZSBhbiBpY29uIGJ1dHRvbi5cbiAgICBhY3RpdmU6ICdyZ2JhKDAsIDAsIDAsIDAuNTQpJyxcbiAgICAvLyBUaGUgY29sb3Igb2YgYW4gaG92ZXJlZCBhY3Rpb24uXG4gICAgaG92ZXI6ICdyZ2JhKDAsIDAsIDAsIDAuMDQpJyxcbiAgICBob3Zlck9wYWNpdHk6IDAuMDQsXG4gICAgLy8gVGhlIGNvbG9yIG9mIGEgc2VsZWN0ZWQgYWN0aW9uLlxuICAgIHNlbGVjdGVkOiAncmdiYSgwLCAwLCAwLCAwLjA4KScsXG4gICAgc2VsZWN0ZWRPcGFjaXR5OiAwLjA4LFxuICAgIC8vIFRoZSBjb2xvciBvZiBhIGRpc2FibGVkIGFjdGlvbi5cbiAgICBkaXNhYmxlZDogJ3JnYmEoMCwgMCwgMCwgMC4yNiknLFxuICAgIC8vIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIGEgZGlzYWJsZWQgYWN0aW9uLlxuICAgIGRpc2FibGVkQmFja2dyb3VuZDogJ3JnYmEoMCwgMCwgMCwgMC4xMiknLFxuICAgIGRpc2FibGVkT3BhY2l0eTogMC4zOCxcbiAgICBmb2N1czogJ3JnYmEoMCwgMCwgMCwgMC4xMiknLFxuICAgIGZvY3VzT3BhY2l0eTogMC4xMixcbiAgICBhY3RpdmF0ZWRPcGFjaXR5OiAwLjEyXG4gIH1cbn07XG5leHBvcnQgdmFyIGRhcmsgPSB7XG4gIHRleHQ6IHtcbiAgICBwcmltYXJ5OiBjb21tb24ud2hpdGUsXG4gICAgc2Vjb25kYXJ5OiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJyxcbiAgICBkaXNhYmxlZDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC41KScsXG4gICAgaGludDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC41KScsXG4gICAgaWNvbjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSdcbiAgfSxcbiAgZGl2aWRlcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMiknLFxuICBiYWNrZ3JvdW5kOiB7XG4gICAgcGFwZXI6IGdyZXlbODAwXSxcbiAgICBkZWZhdWx0OiAnIzMwMzAzMCdcbiAgfSxcbiAgYWN0aW9uOiB7XG4gICAgYWN0aXZlOiBjb21tb24ud2hpdGUsXG4gICAgaG92ZXI6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDgpJyxcbiAgICBob3Zlck9wYWNpdHk6IDAuMDgsXG4gICAgc2VsZWN0ZWQ6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTYpJyxcbiAgICBzZWxlY3RlZE9wYWNpdHk6IDAuMTYsXG4gICAgZGlzYWJsZWQ6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyknLFxuICAgIGRpc2FibGVkQmFja2dyb3VuZDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMiknLFxuICAgIGRpc2FibGVkT3BhY2l0eTogMC4zOCxcbiAgICBmb2N1czogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMiknLFxuICAgIGZvY3VzT3BhY2l0eTogMC4xMixcbiAgICBhY3RpdmF0ZWRPcGFjaXR5OiAwLjI0XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFkZExpZ2h0T3JEYXJrKGludGVudCwgZGlyZWN0aW9uLCBzaGFkZSwgdG9uYWxPZmZzZXQpIHtcbiAgdmFyIHRvbmFsT2Zmc2V0TGlnaHQgPSB0b25hbE9mZnNldC5saWdodCB8fCB0b25hbE9mZnNldDtcbiAgdmFyIHRvbmFsT2Zmc2V0RGFyayA9IHRvbmFsT2Zmc2V0LmRhcmsgfHwgdG9uYWxPZmZzZXQgKiAxLjU7XG5cbiAgaWYgKCFpbnRlbnRbZGlyZWN0aW9uXSkge1xuICAgIGlmIChpbnRlbnQuaGFzT3duUHJvcGVydHkoc2hhZGUpKSB7XG4gICAgICBpbnRlbnRbZGlyZWN0aW9uXSA9IGludGVudFtzaGFkZV07XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdsaWdodCcpIHtcbiAgICAgIGludGVudC5saWdodCA9IGxpZ2h0ZW4oaW50ZW50Lm1haW4sIHRvbmFsT2Zmc2V0TGlnaHQpO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnZGFyaycpIHtcbiAgICAgIGludGVudC5kYXJrID0gZGFya2VuKGludGVudC5tYWluLCB0b25hbE9mZnNldERhcmspO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVQYWxldHRlKHBhbGV0dGUpIHtcbiAgdmFyIF9wYWxldHRlJHByaW1hcnkgPSBwYWxldHRlLnByaW1hcnksXG4gICAgICBwcmltYXJ5ID0gX3BhbGV0dGUkcHJpbWFyeSA9PT0gdm9pZCAwID8ge1xuICAgIGxpZ2h0OiBpbmRpZ29bMzAwXSxcbiAgICBtYWluOiBpbmRpZ29bNTAwXSxcbiAgICBkYXJrOiBpbmRpZ29bNzAwXVxuICB9IDogX3BhbGV0dGUkcHJpbWFyeSxcbiAgICAgIF9wYWxldHRlJHNlY29uZGFyeSA9IHBhbGV0dGUuc2Vjb25kYXJ5LFxuICAgICAgc2Vjb25kYXJ5ID0gX3BhbGV0dGUkc2Vjb25kYXJ5ID09PSB2b2lkIDAgPyB7XG4gICAgbGlnaHQ6IHBpbmsuQTIwMCxcbiAgICBtYWluOiBwaW5rLkE0MDAsXG4gICAgZGFyazogcGluay5BNzAwXG4gIH0gOiBfcGFsZXR0ZSRzZWNvbmRhcnksXG4gICAgICBfcGFsZXR0ZSRlcnJvciA9IHBhbGV0dGUuZXJyb3IsXG4gICAgICBlcnJvciA9IF9wYWxldHRlJGVycm9yID09PSB2b2lkIDAgPyB7XG4gICAgbGlnaHQ6IHJlZFszMDBdLFxuICAgIG1haW46IHJlZFs1MDBdLFxuICAgIGRhcms6IHJlZFs3MDBdXG4gIH0gOiBfcGFsZXR0ZSRlcnJvcixcbiAgICAgIF9wYWxldHRlJHdhcm5pbmcgPSBwYWxldHRlLndhcm5pbmcsXG4gICAgICB3YXJuaW5nID0gX3BhbGV0dGUkd2FybmluZyA9PT0gdm9pZCAwID8ge1xuICAgIGxpZ2h0OiBvcmFuZ2VbMzAwXSxcbiAgICBtYWluOiBvcmFuZ2VbNTAwXSxcbiAgICBkYXJrOiBvcmFuZ2VbNzAwXVxuICB9IDogX3BhbGV0dGUkd2FybmluZyxcbiAgICAgIF9wYWxldHRlJGluZm8gPSBwYWxldHRlLmluZm8sXG4gICAgICBpbmZvID0gX3BhbGV0dGUkaW5mbyA9PT0gdm9pZCAwID8ge1xuICAgIGxpZ2h0OiBibHVlWzMwMF0sXG4gICAgbWFpbjogYmx1ZVs1MDBdLFxuICAgIGRhcms6IGJsdWVbNzAwXVxuICB9IDogX3BhbGV0dGUkaW5mbyxcbiAgICAgIF9wYWxldHRlJHN1Y2Nlc3MgPSBwYWxldHRlLnN1Y2Nlc3MsXG4gICAgICBzdWNjZXNzID0gX3BhbGV0dGUkc3VjY2VzcyA9PT0gdm9pZCAwID8ge1xuICAgIGxpZ2h0OiBncmVlblszMDBdLFxuICAgIG1haW46IGdyZWVuWzUwMF0sXG4gICAgZGFyazogZ3JlZW5bNzAwXVxuICB9IDogX3BhbGV0dGUkc3VjY2VzcyxcbiAgICAgIF9wYWxldHRlJHR5cGUgPSBwYWxldHRlLnR5cGUsXG4gICAgICB0eXBlID0gX3BhbGV0dGUkdHlwZSA9PT0gdm9pZCAwID8gJ2xpZ2h0JyA6IF9wYWxldHRlJHR5cGUsXG4gICAgICBfcGFsZXR0ZSRjb250cmFzdFRocmUgPSBwYWxldHRlLmNvbnRyYXN0VGhyZXNob2xkLFxuICAgICAgY29udHJhc3RUaHJlc2hvbGQgPSBfcGFsZXR0ZSRjb250cmFzdFRocmUgPT09IHZvaWQgMCA/IDMgOiBfcGFsZXR0ZSRjb250cmFzdFRocmUsXG4gICAgICBfcGFsZXR0ZSR0b25hbE9mZnNldCA9IHBhbGV0dGUudG9uYWxPZmZzZXQsXG4gICAgICB0b25hbE9mZnNldCA9IF9wYWxldHRlJHRvbmFsT2Zmc2V0ID09PSB2b2lkIDAgPyAwLjIgOiBfcGFsZXR0ZSR0b25hbE9mZnNldCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHBhbGV0dGUsIFtcInByaW1hcnlcIiwgXCJzZWNvbmRhcnlcIiwgXCJlcnJvclwiLCBcIndhcm5pbmdcIiwgXCJpbmZvXCIsIFwic3VjY2Vzc1wiLCBcInR5cGVcIiwgXCJjb250cmFzdFRocmVzaG9sZFwiLCBcInRvbmFsT2Zmc2V0XCJdKTsgLy8gVXNlIHRoZSBzYW1lIGxvZ2ljIGFzXG4gIC8vIEJvb3RzdHJhcDogaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvMWQ2ZTM3MTBkZDQ0N2RlMWEyMDBmMjllOGZhNTIxZjhhMDkwOGY3MC9zY3NzL19mdW5jdGlvbnMuc2NzcyNMNTlcbiAgLy8gYW5kIG1hdGVyaWFsLWNvbXBvbmVudHMtd2ViIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvYWM0NmI4ODYzYzRkYWI5ZmMyMmM0YzY2MmRjNmJkMWI2NWRkNjUyZi9wYWNrYWdlcy9tZGMtdGhlbWUvX2Z1bmN0aW9ucy5zY3NzI0w1NFxuXG5cbiAgZnVuY3Rpb24gZ2V0Q29udHJhc3RUZXh0KGJhY2tncm91bmQpIHtcbiAgICB2YXIgY29udHJhc3RUZXh0ID0gZ2V0Q29udHJhc3RSYXRpbyhiYWNrZ3JvdW5kLCBkYXJrLnRleHQucHJpbWFyeSkgPj0gY29udHJhc3RUaHJlc2hvbGQgPyBkYXJrLnRleHQucHJpbWFyeSA6IGxpZ2h0LnRleHQucHJpbWFyeTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29udHJhc3QgPSBnZXRDb250cmFzdFJhdGlvKGJhY2tncm91bmQsIGNvbnRyYXN0VGV4dCk7XG5cbiAgICAgIGlmIChjb250cmFzdCA8IDMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIGNvbnRyYXN0IHJhdGlvIG9mIFwiLmNvbmNhdChjb250cmFzdCwgXCI6MSBmb3IgXCIpLmNvbmNhdChjb250cmFzdFRleHQsIFwiIG9uIFwiKS5jb25jYXQoYmFja2dyb3VuZCksICdmYWxscyBiZWxvdyB0aGUgV0NBRyByZWNvbW1lbmRlZCBhYnNvbHV0ZSBtaW5pbXVtIGNvbnRyYXN0IHJhdGlvIG9mIDM6MS4nLCAnaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jdmlzdWFsLWF1ZGlvLWNvbnRyYXN0LWNvbnRyYXN0J10uam9pbignXFxuJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb250cmFzdFRleHQ7XG4gIH1cblxuICB2YXIgYXVnbWVudENvbG9yID0gZnVuY3Rpb24gYXVnbWVudENvbG9yKGNvbG9yKSB7XG4gICAgdmFyIG1haW5TaGFkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogNTAwO1xuICAgIHZhciBsaWdodFNoYWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAzMDA7XG4gICAgdmFyIGRhcmtTaGFkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogNzAwO1xuICAgIGNvbG9yID0gX2V4dGVuZHMoe30sIGNvbG9yKTtcblxuICAgIGlmICghY29sb3IubWFpbiAmJiBjb2xvclttYWluU2hhZGVdKSB7XG4gICAgICBjb2xvci5tYWluID0gY29sb3JbbWFpblNoYWRlXTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbG9yLm1haW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk1hdGVyaWFsLVVJOiBUaGUgY29sb3IgcHJvdmlkZWQgdG8gYXVnbWVudENvbG9yKGNvbG9yKSBpcyBpbnZhbGlkLlxcblRoZSBjb2xvciBvYmplY3QgbmVlZHMgdG8gaGF2ZSBhIGBtYWluYCBwcm9wZXJ0eSBvciBhIGBcIi5jb25jYXQobWFpblNoYWRlLCBcImAgcHJvcGVydHkuXCIpIDogX2Zvcm1hdE11aUVycm9yTWVzc2FnZSg0LCBtYWluU2hhZGUpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbG9yLm1haW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJNYXRlcmlhbC1VSTogVGhlIGNvbG9yIHByb3ZpZGVkIHRvIGF1Z21lbnRDb2xvcihjb2xvcikgaXMgaW52YWxpZC5cXG5gY29sb3IubWFpbmAgc2hvdWxkIGJlIGEgc3RyaW5nLCBidXQgYFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShjb2xvci5tYWluKSwgXCJgIHdhcyBwcm92aWRlZCBpbnN0ZWFkLlxcblxcbkRpZCB5b3UgaW50ZW5kIHRvIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBhcHByb2FjaGVzP1xcblxcbmltcG9ydCB7XFx4QTBncmVlbiB9IGZyb20gXFxcIkBtYXRlcmlhbC11aS9jb3JlL2NvbG9yc1xcXCI7XFxuXFxuY29uc3QgdGhlbWUxID0gY3JlYXRlTXVpVGhlbWUoeyBwYWxldHRlOiB7XFxuICBwcmltYXJ5OiBncmVlbixcXG59IH0pO1xcblxcbmNvbnN0IHRoZW1lMiA9IGNyZWF0ZU11aVRoZW1lKHsgcGFsZXR0ZToge1xcbiAgcHJpbWFyeTogeyBtYWluOiBncmVlbls1MDBdIH0sXFxufSB9KTtcIikgOiBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlKDUsIEpTT04uc3RyaW5naWZ5KGNvbG9yLm1haW4pKSk7XG4gICAgfVxuXG4gICAgYWRkTGlnaHRPckRhcmsoY29sb3IsICdsaWdodCcsIGxpZ2h0U2hhZGUsIHRvbmFsT2Zmc2V0KTtcbiAgICBhZGRMaWdodE9yRGFyayhjb2xvciwgJ2RhcmsnLCBkYXJrU2hhZGUsIHRvbmFsT2Zmc2V0KTtcblxuICAgIGlmICghY29sb3IuY29udHJhc3RUZXh0KSB7XG4gICAgICBjb2xvci5jb250cmFzdFRleHQgPSBnZXRDb250cmFzdFRleHQoY29sb3IubWFpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yO1xuICB9O1xuXG4gIHZhciB0eXBlcyA9IHtcbiAgICBkYXJrOiBkYXJrLFxuICAgIGxpZ2h0OiBsaWdodFxuICB9O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCF0eXBlc1t0eXBlXSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIk1hdGVyaWFsLVVJOiBUaGUgcGFsZXR0ZSB0eXBlIGBcIi5jb25jYXQodHlwZSwgXCJgIGlzIG5vdCBzdXBwb3J0ZWQuXCIpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGFsZXR0ZU91dHB1dCA9IGRlZXBtZXJnZShfZXh0ZW5kcyh7XG4gICAgLy8gQSBjb2xsZWN0aW9uIG9mIGNvbW1vbiBjb2xvcnMuXG4gICAgY29tbW9uOiBjb21tb24sXG4gICAgLy8gVGhlIHBhbGV0dGUgdHlwZSwgY2FuIGJlIGxpZ2h0IG9yIGRhcmsuXG4gICAgdHlwZTogdHlwZSxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gcmVwcmVzZW50IHByaW1hcnkgaW50ZXJmYWNlIGVsZW1lbnRzIGZvciBhIHVzZXIuXG4gICAgcHJpbWFyeTogYXVnbWVudENvbG9yKHByaW1hcnkpLFxuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byByZXByZXNlbnQgc2Vjb25kYXJ5IGludGVyZmFjZSBlbGVtZW50cyBmb3IgYSB1c2VyLlxuICAgIHNlY29uZGFyeTogYXVnbWVudENvbG9yKHNlY29uZGFyeSwgJ0E0MDAnLCAnQTIwMCcsICdBNzAwJyksXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHJlcHJlc2VudCBpbnRlcmZhY2UgZWxlbWVudHMgdGhhdCB0aGUgdXNlciBzaG91bGQgYmUgbWFkZSBhd2FyZSBvZi5cbiAgICBlcnJvcjogYXVnbWVudENvbG9yKGVycm9yKSxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gcmVwcmVzZW50IHBvdGVudGlhbGx5IGRhbmdlcm91cyBhY3Rpb25zIG9yIGltcG9ydGFudCBtZXNzYWdlcy5cbiAgICB3YXJuaW5nOiBhdWdtZW50Q29sb3Iod2FybmluZyksXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHByZXNlbnQgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIgdGhhdCBpcyBuZXV0cmFsIGFuZCBub3QgbmVjZXNzYXJpbHkgaW1wb3J0YW50LlxuICAgIGluZm86IGF1Z21lbnRDb2xvcihpbmZvKSxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gaW5kaWNhdGUgdGhlIHN1Y2Nlc3NmdWwgY29tcGxldGlvbiBvZiBhbiBhY3Rpb24gdGhhdCB1c2VyIHRyaWdnZXJlZC5cbiAgICBzdWNjZXNzOiBhdWdtZW50Q29sb3Ioc3VjY2VzcyksXG4gICAgLy8gVGhlIGdyZXkgY29sb3JzLlxuICAgIGdyZXk6IGdyZXksXG4gICAgLy8gVXNlZCBieSBgZ2V0Q29udHJhc3RUZXh0KClgIHRvIG1heGltaXplIHRoZSBjb250cmFzdCBiZXR3ZWVuXG4gICAgLy8gdGhlIGJhY2tncm91bmQgYW5kIHRoZSB0ZXh0LlxuICAgIGNvbnRyYXN0VGhyZXNob2xkOiBjb250cmFzdFRocmVzaG9sZCxcbiAgICAvLyBUYWtlcyBhIGJhY2tncm91bmQgY29sb3IgYW5kIHJldHVybnMgdGhlIHRleHQgY29sb3IgdGhhdCBtYXhpbWl6ZXMgdGhlIGNvbnRyYXN0LlxuICAgIGdldENvbnRyYXN0VGV4dDogZ2V0Q29udHJhc3RUZXh0LFxuICAgIC8vIEdlbmVyYXRlIGEgcmljaCBjb2xvciBvYmplY3QuXG4gICAgYXVnbWVudENvbG9yOiBhdWdtZW50Q29sb3IsXG4gICAgLy8gVXNlZCBieSB0aGUgZnVuY3Rpb25zIGJlbG93IHRvIHNoaWZ0IGEgY29sb3IncyBsdW1pbmFuY2UgYnkgYXBwcm94aW1hdGVseVxuICAgIC8vIHR3byBpbmRleGVzIHdpdGhpbiBpdHMgdG9uYWwgcGFsZXR0ZS5cbiAgICAvLyBFLmcuLCBzaGlmdCBmcm9tIFJlZCA1MDAgdG8gUmVkIDMwMCBvciBSZWQgNzAwLlxuICAgIHRvbmFsT2Zmc2V0OiB0b25hbE9mZnNldFxuICB9LCB0eXBlc1t0eXBlXSksIG90aGVyKTtcbiAgcmV0dXJuIHBhbGV0dGVPdXRwdXQ7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IHsgZGVlcG1lcmdlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcblxuZnVuY3Rpb24gcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxZTUpIC8gMWU1O1xufVxuXG52YXIgY2FzZUFsbENhcHMgPSB7XG4gIHRleHRUcmFuc2Zvcm06ICd1cHBlcmNhc2UnXG59O1xudmFyIGRlZmF1bHRGb250RmFtaWx5ID0gJ1wiUm9ib3RvXCIsIFwiSGVsdmV0aWNhXCIsIFwiQXJpYWxcIiwgc2Fucy1zZXJpZic7XG4vKipcbiAqIEBzZWUgQGxpbmt7aHR0cHM6Ly9tYXRlcmlhbC5pby9kZXNpZ24vdHlwb2dyYXBoeS90aGUtdHlwZS1zeXN0ZW0uaHRtbH1cbiAqIEBzZWUgQGxpbmt7aHR0cHM6Ly9tYXRlcmlhbC5pby9kZXNpZ24vdHlwb2dyYXBoeS91bmRlcnN0YW5kaW5nLXR5cG9ncmFwaHkuaHRtbH1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVUeXBvZ3JhcGh5KHBhbGV0dGUsIHR5cG9ncmFwaHkpIHtcbiAgdmFyIF9yZWYgPSB0eXBlb2YgdHlwb2dyYXBoeSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cG9ncmFwaHkocGFsZXR0ZSkgOiB0eXBvZ3JhcGh5LFxuICAgICAgX3JlZiRmb250RmFtaWx5ID0gX3JlZi5mb250RmFtaWx5LFxuICAgICAgZm9udEZhbWlseSA9IF9yZWYkZm9udEZhbWlseSA9PT0gdm9pZCAwID8gZGVmYXVsdEZvbnRGYW1pbHkgOiBfcmVmJGZvbnRGYW1pbHksXG4gICAgICBfcmVmJGZvbnRTaXplID0gX3JlZi5mb250U2l6ZSxcbiAgICAgIGZvbnRTaXplID0gX3JlZiRmb250U2l6ZSA9PT0gdm9pZCAwID8gMTQgOiBfcmVmJGZvbnRTaXplLFxuICAgICAgX3JlZiRmb250V2VpZ2h0TGlnaHQgPSBfcmVmLmZvbnRXZWlnaHRMaWdodCxcbiAgICAgIGZvbnRXZWlnaHRMaWdodCA9IF9yZWYkZm9udFdlaWdodExpZ2h0ID09PSB2b2lkIDAgPyAzMDAgOiBfcmVmJGZvbnRXZWlnaHRMaWdodCxcbiAgICAgIF9yZWYkZm9udFdlaWdodFJlZ3VsYSA9IF9yZWYuZm9udFdlaWdodFJlZ3VsYXIsXG4gICAgICBmb250V2VpZ2h0UmVndWxhciA9IF9yZWYkZm9udFdlaWdodFJlZ3VsYSA9PT0gdm9pZCAwID8gNDAwIDogX3JlZiRmb250V2VpZ2h0UmVndWxhLFxuICAgICAgX3JlZiRmb250V2VpZ2h0TWVkaXVtID0gX3JlZi5mb250V2VpZ2h0TWVkaXVtLFxuICAgICAgZm9udFdlaWdodE1lZGl1bSA9IF9yZWYkZm9udFdlaWdodE1lZGl1bSA9PT0gdm9pZCAwID8gNTAwIDogX3JlZiRmb250V2VpZ2h0TWVkaXVtLFxuICAgICAgX3JlZiRmb250V2VpZ2h0Qm9sZCA9IF9yZWYuZm9udFdlaWdodEJvbGQsXG4gICAgICBmb250V2VpZ2h0Qm9sZCA9IF9yZWYkZm9udFdlaWdodEJvbGQgPT09IHZvaWQgMCA/IDcwMCA6IF9yZWYkZm9udFdlaWdodEJvbGQsXG4gICAgICBfcmVmJGh0bWxGb250U2l6ZSA9IF9yZWYuaHRtbEZvbnRTaXplLFxuICAgICAgaHRtbEZvbnRTaXplID0gX3JlZiRodG1sRm9udFNpemUgPT09IHZvaWQgMCA/IDE2IDogX3JlZiRodG1sRm9udFNpemUsXG4gICAgICBhbGxWYXJpYW50cyA9IF9yZWYuYWxsVmFyaWFudHMsXG4gICAgICBweFRvUmVtMiA9IF9yZWYucHhUb1JlbSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImZvbnRGYW1pbHlcIiwgXCJmb250U2l6ZVwiLCBcImZvbnRXZWlnaHRMaWdodFwiLCBcImZvbnRXZWlnaHRSZWd1bGFyXCIsIFwiZm9udFdlaWdodE1lZGl1bVwiLCBcImZvbnRXZWlnaHRCb2xkXCIsIFwiaHRtbEZvbnRTaXplXCIsIFwiYWxsVmFyaWFudHNcIiwgXCJweFRvUmVtXCJdKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0eXBlb2YgZm9udFNpemUgIT09ICdudW1iZXInKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNYXRlcmlhbC1VSTogYGZvbnRTaXplYCBpcyByZXF1aXJlZCB0byBiZSBhIG51bWJlci4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGh0bWxGb250U2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01hdGVyaWFsLVVJOiBgaHRtbEZvbnRTaXplYCBpcyByZXF1aXJlZCB0byBiZSBhIG51bWJlci4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29lZiA9IGZvbnRTaXplIC8gMTQ7XG5cbiAgdmFyIHB4VG9SZW0gPSBweFRvUmVtMiB8fCBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChzaXplIC8gaHRtbEZvbnRTaXplICogY29lZiwgXCJyZW1cIik7XG4gIH07XG5cbiAgdmFyIGJ1aWxkVmFyaWFudCA9IGZ1bmN0aW9uIGJ1aWxkVmFyaWFudChmb250V2VpZ2h0LCBzaXplLCBsaW5lSGVpZ2h0LCBsZXR0ZXJTcGFjaW5nLCBjYXNpbmcpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgZm9udEZhbWlseTogZm9udEZhbWlseSxcbiAgICAgIGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQsXG4gICAgICBmb250U2l6ZTogcHhUb1JlbShzaXplKSxcbiAgICAgIC8vIFVuaXRsZXNzIGZvbGxvd2luZyBodHRwczovL21leWVyd2ViLmNvbS9lcmljL3Rob3VnaHRzLzIwMDYvMDIvMDgvdW5pdGxlc3MtbGluZS1oZWlnaHRzL1xuICAgICAgbGluZUhlaWdodDogbGluZUhlaWdodFxuICAgIH0sIGZvbnRGYW1pbHkgPT09IGRlZmF1bHRGb250RmFtaWx5ID8ge1xuICAgICAgbGV0dGVyU3BhY2luZzogXCJcIi5jb25jYXQocm91bmQobGV0dGVyU3BhY2luZyAvIHNpemUpLCBcImVtXCIpXG4gICAgfSA6IHt9LCBjYXNpbmcsIGFsbFZhcmlhbnRzKTtcbiAgfTtcblxuICB2YXIgdmFyaWFudHMgPSB7XG4gICAgaDE6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0TGlnaHQsIDk2LCAxLjE2NywgLTEuNSksXG4gICAgaDI6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0TGlnaHQsIDYwLCAxLjIsIC0wLjUpLFxuICAgIGgzOiBidWlsZFZhcmlhbnQoZm9udFdlaWdodFJlZ3VsYXIsIDQ4LCAxLjE2NywgMCksXG4gICAgaDQ6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0UmVndWxhciwgMzQsIDEuMjM1LCAwLjI1KSxcbiAgICBoNTogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRSZWd1bGFyLCAyNCwgMS4zMzQsIDApLFxuICAgIGg2OiBidWlsZFZhcmlhbnQoZm9udFdlaWdodE1lZGl1bSwgMjAsIDEuNiwgMC4xNSksXG4gICAgc3VidGl0bGUxOiBidWlsZFZhcmlhbnQoZm9udFdlaWdodFJlZ3VsYXIsIDE2LCAxLjc1LCAwLjE1KSxcbiAgICBzdWJ0aXRsZTI6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0TWVkaXVtLCAxNCwgMS41NywgMC4xKSxcbiAgICBib2R5MTogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRSZWd1bGFyLCAxNiwgMS41LCAwLjE1KSxcbiAgICBib2R5MjogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRSZWd1bGFyLCAxNCwgMS40MywgMC4xNSksXG4gICAgYnV0dG9uOiBidWlsZFZhcmlhbnQoZm9udFdlaWdodE1lZGl1bSwgMTQsIDEuNzUsIDAuNCwgY2FzZUFsbENhcHMpLFxuICAgIGNhcHRpb246IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0UmVndWxhciwgMTIsIDEuNjYsIDAuNCksXG4gICAgb3ZlcmxpbmU6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0UmVndWxhciwgMTIsIDIuNjYsIDEsIGNhc2VBbGxDYXBzKVxuICB9O1xuICByZXR1cm4gZGVlcG1lcmdlKF9leHRlbmRzKHtcbiAgICBodG1sRm9udFNpemU6IGh0bWxGb250U2l6ZSxcbiAgICBweFRvUmVtOiBweFRvUmVtLFxuICAgIHJvdW5kOiByb3VuZCxcbiAgICAvLyBUT0RPIHY1OiByZW1vdmVcbiAgICBmb250RmFtaWx5OiBmb250RmFtaWx5LFxuICAgIGZvbnRTaXplOiBmb250U2l6ZSxcbiAgICBmb250V2VpZ2h0TGlnaHQ6IGZvbnRXZWlnaHRMaWdodCxcbiAgICBmb250V2VpZ2h0UmVndWxhcjogZm9udFdlaWdodFJlZ3VsYXIsXG4gICAgZm9udFdlaWdodE1lZGl1bTogZm9udFdlaWdodE1lZGl1bSxcbiAgICBmb250V2VpZ2h0Qm9sZDogZm9udFdlaWdodEJvbGRcbiAgfSwgdmFyaWFudHMpLCBvdGhlciwge1xuICAgIGNsb25lOiBmYWxzZSAvLyBObyBuZWVkIHRvIGNsb25lIGRlZXBcblxuICB9KTtcbn0iLCJ2YXIgc2hhZG93S2V5VW1icmFPcGFjaXR5ID0gMC4yO1xudmFyIHNoYWRvd0tleVBlbnVtYnJhT3BhY2l0eSA9IDAuMTQ7XG52YXIgc2hhZG93QW1iaWVudFNoYWRvd09wYWNpdHkgPSAwLjEyO1xuXG5mdW5jdGlvbiBjcmVhdGVTaGFkb3coKSB7XG4gIHJldHVybiBbXCJcIi5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSAzID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzNdLCBcInB4IHJnYmEoMCwwLDAsXCIpLmNvbmNhdChzaGFkb3dLZXlVbWJyYU9wYWNpdHksIFwiKVwiKSwgXCJcIi5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSA0ID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzRdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSA1ID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzVdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSA2ID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzZdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSA3ID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzddLCBcInB4IHJnYmEoMCwwLDAsXCIpLmNvbmNhdChzaGFkb3dLZXlQZW51bWJyYU9wYWNpdHksIFwiKVwiKSwgXCJcIi5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSA4ID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzhdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSA5ID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzldLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSAxMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxMF0sIFwicHggXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDExID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzExXSwgXCJweCByZ2JhKDAsMCwwLFwiKS5jb25jYXQoc2hhZG93QW1iaWVudFNoYWRvd09wYWNpdHksIFwiKVwiKV0uam9pbignLCcpO1xufSAvLyBWYWx1ZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL2JlODc0N2Y5NDU3NDY2OWNiNWU3YWRkMWE3YzU0ZmE0MWE4OWNlYzcvcGFja2FnZXMvbWRjLWVsZXZhdGlvbi9fdmFyaWFibGVzLnNjc3NcblxuXG52YXIgc2hhZG93cyA9IFsnbm9uZScsIGNyZWF0ZVNoYWRvdygwLCAyLCAxLCAtMSwgMCwgMSwgMSwgMCwgMCwgMSwgMywgMCksIGNyZWF0ZVNoYWRvdygwLCAzLCAxLCAtMiwgMCwgMiwgMiwgMCwgMCwgMSwgNSwgMCksIGNyZWF0ZVNoYWRvdygwLCAzLCAzLCAtMiwgMCwgMywgNCwgMCwgMCwgMSwgOCwgMCksIGNyZWF0ZVNoYWRvdygwLCAyLCA0LCAtMSwgMCwgNCwgNSwgMCwgMCwgMSwgMTAsIDApLCBjcmVhdGVTaGFkb3coMCwgMywgNSwgLTEsIDAsIDUsIDgsIDAsIDAsIDEsIDE0LCAwKSwgY3JlYXRlU2hhZG93KDAsIDMsIDUsIC0xLCAwLCA2LCAxMCwgMCwgMCwgMSwgMTgsIDApLCBjcmVhdGVTaGFkb3coMCwgNCwgNSwgLTIsIDAsIDcsIDEwLCAxLCAwLCAyLCAxNiwgMSksIGNyZWF0ZVNoYWRvdygwLCA1LCA1LCAtMywgMCwgOCwgMTAsIDEsIDAsIDMsIDE0LCAyKSwgY3JlYXRlU2hhZG93KDAsIDUsIDYsIC0zLCAwLCA5LCAxMiwgMSwgMCwgMywgMTYsIDIpLCBjcmVhdGVTaGFkb3coMCwgNiwgNiwgLTMsIDAsIDEwLCAxNCwgMSwgMCwgNCwgMTgsIDMpLCBjcmVhdGVTaGFkb3coMCwgNiwgNywgLTQsIDAsIDExLCAxNSwgMSwgMCwgNCwgMjAsIDMpLCBjcmVhdGVTaGFkb3coMCwgNywgOCwgLTQsIDAsIDEyLCAxNywgMiwgMCwgNSwgMjIsIDQpLCBjcmVhdGVTaGFkb3coMCwgNywgOCwgLTQsIDAsIDEzLCAxOSwgMiwgMCwgNSwgMjQsIDQpLCBjcmVhdGVTaGFkb3coMCwgNywgOSwgLTQsIDAsIDE0LCAyMSwgMiwgMCwgNSwgMjYsIDQpLCBjcmVhdGVTaGFkb3coMCwgOCwgOSwgLTUsIDAsIDE1LCAyMiwgMiwgMCwgNiwgMjgsIDUpLCBjcmVhdGVTaGFkb3coMCwgOCwgMTAsIC01LCAwLCAxNiwgMjQsIDIsIDAsIDYsIDMwLCA1KSwgY3JlYXRlU2hhZG93KDAsIDgsIDExLCAtNSwgMCwgMTcsIDI2LCAyLCAwLCA2LCAzMiwgNSksIGNyZWF0ZVNoYWRvdygwLCA5LCAxMSwgLTUsIDAsIDE4LCAyOCwgMiwgMCwgNywgMzQsIDYpLCBjcmVhdGVTaGFkb3coMCwgOSwgMTIsIC02LCAwLCAxOSwgMjksIDIsIDAsIDcsIDM2LCA2KSwgY3JlYXRlU2hhZG93KDAsIDEwLCAxMywgLTYsIDAsIDIwLCAzMSwgMywgMCwgOCwgMzgsIDcpLCBjcmVhdGVTaGFkb3coMCwgMTAsIDEzLCAtNiwgMCwgMjEsIDMzLCAzLCAwLCA4LCA0MCwgNyksIGNyZWF0ZVNoYWRvdygwLCAxMCwgMTQsIC02LCAwLCAyMiwgMzUsIDMsIDAsIDgsIDQyLCA3KSwgY3JlYXRlU2hhZG93KDAsIDExLCAxNCwgLTcsIDAsIDIzLCAzNiwgMywgMCwgOSwgNDQsIDgpLCBjcmVhdGVTaGFkb3coMCwgMTEsIDE1LCAtNywgMCwgMjQsIDM4LCAzLCAwLCA5LCA0NiwgOCldO1xuZXhwb3J0IGRlZmF1bHQgc2hhZG93czsiLCJ2YXIgc2hhcGUgPSB7XG4gIGJvcmRlclJhZGl1czogNFxufTtcbmV4cG9ydCBkZWZhdWx0IHNoYXBlOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRoSG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRoSG9sZXNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXlMaW1pdCBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCI7XG5pbXBvcnQgbm9uSXRlcmFibGVSZXN0IGZyb20gXCIuL25vbkl0ZXJhYmxlUmVzdFwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn0iLCJpbXBvcnQgeyBkZWVwbWVyZ2UgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuXG5mdW5jdGlvbiBtZXJnZShhY2MsIGl0ZW0pIHtcbiAgaWYgKCFpdGVtKSB7XG4gICAgcmV0dXJuIGFjYztcbiAgfVxuXG4gIHJldHVybiBkZWVwbWVyZ2UoYWNjLCBpdGVtLCB7XG4gICAgY2xvbmU6IGZhbHNlIC8vIE5vIG5lZWQgdG8gY2xvbmUgZGVlcCwgaXQncyB3YXkgZmFzdGVyLlxuXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZXJnZTsiLCJpbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheVwiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mXCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IG1lcmdlIGZyb20gJy4vbWVyZ2UnOyAvLyBUaGUgYnJlYWtwb2ludCAqKnN0YXJ0KiogYXQgdGhpcyB2YWx1ZS5cbi8vIEZvciBpbnN0YW5jZSB3aXRoIHRoZSBmaXJzdCBicmVha3BvaW50IHhzOiBbeHMsIHNtWy5cblxudmFyIHZhbHVlcyA9IHtcbiAgeHM6IDAsXG4gIHNtOiA2MDAsXG4gIG1kOiA5NjAsXG4gIGxnOiAxMjgwLFxuICB4bDogMTkyMFxufTtcbnZhciBkZWZhdWx0QnJlYWtwb2ludHMgPSB7XG4gIC8vIFNvcnRlZCBBU0MgYnkgc2l6ZS4gVGhhdCdzIGltcG9ydGFudC5cbiAgLy8gSXQgY2FuJ3QgYmUgY29uZmlndXJlZCBhcyBpdCdzIHVzZWQgc3RhdGljYWxseSBmb3IgcHJvcFR5cGVzLlxuICBrZXlzOiBbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10sXG4gIHVwOiBmdW5jdGlvbiB1cChrZXkpIHtcbiAgICByZXR1cm4gXCJAbWVkaWEgKG1pbi13aWR0aDpcIi5jb25jYXQodmFsdWVzW2tleV0sIFwicHgpXCIpO1xuICB9XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUJyZWFrcG9pbnRzKHByb3BzLCBwcm9wVmFsdWUsIHN0eWxlRnJvbVByb3BWYWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghcHJvcHMudGhlbWUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01hdGVyaWFsLVVJOiBZb3UgYXJlIGNhbGxpbmcgYSBzdHlsZSBmdW5jdGlvbiB3aXRob3V0IGEgdGhlbWUgdmFsdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgIHZhciB0aGVtZUJyZWFrcG9pbnRzID0gcHJvcHMudGhlbWUuYnJlYWtwb2ludHMgfHwgZGVmYXVsdEJyZWFrcG9pbnRzO1xuICAgIHJldHVybiBwcm9wVmFsdWUucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGl0ZW0sIGluZGV4KSB7XG4gICAgICBhY2NbdGhlbWVCcmVha3BvaW50cy51cCh0aGVtZUJyZWFrcG9pbnRzLmtleXNbaW5kZXhdKV0gPSBzdHlsZUZyb21Qcm9wVmFsdWUocHJvcFZhbHVlW2luZGV4XSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIGlmIChfdHlwZW9mKHByb3BWYWx1ZSkgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIF90aGVtZUJyZWFrcG9pbnRzID0gcHJvcHMudGhlbWUuYnJlYWtwb2ludHMgfHwgZGVmYXVsdEJyZWFrcG9pbnRzO1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHByb3BWYWx1ZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGJyZWFrcG9pbnQpIHtcbiAgICAgIGFjY1tfdGhlbWVCcmVha3BvaW50cy51cChicmVha3BvaW50KV0gPSBzdHlsZUZyb21Qcm9wVmFsdWUocHJvcFZhbHVlW2JyZWFrcG9pbnRdKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG5cbiAgdmFyIG91dHB1dCA9IHN0eWxlRnJvbVByb3BWYWx1ZShwcm9wVmFsdWUpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBicmVha3BvaW50cyhzdHlsZUZ1bmN0aW9uKSB7XG4gIHZhciBuZXdTdHlsZUZ1bmN0aW9uID0gZnVuY3Rpb24gbmV3U3R5bGVGdW5jdGlvbihwcm9wcykge1xuICAgIHZhciBiYXNlID0gc3R5bGVGdW5jdGlvbihwcm9wcyk7XG4gICAgdmFyIHRoZW1lQnJlYWtwb2ludHMgPSBwcm9wcy50aGVtZS5icmVha3BvaW50cyB8fCBkZWZhdWx0QnJlYWtwb2ludHM7XG4gICAgdmFyIGV4dGVuZGVkID0gdGhlbWVCcmVha3BvaW50cy5rZXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgIGlmIChwcm9wc1trZXldKSB7XG4gICAgICAgIGFjYyA9IGFjYyB8fCB7fTtcbiAgICAgICAgYWNjW3RoZW1lQnJlYWtwb2ludHMudXAoa2V5KV0gPSBzdHlsZUZ1bmN0aW9uKF9leHRlbmRzKHtcbiAgICAgICAgICB0aGVtZTogcHJvcHMudGhlbWVcbiAgICAgICAgfSwgcHJvcHNba2V5XSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG51bGwpO1xuICAgIHJldHVybiBtZXJnZShiYXNlLCBleHRlbmRlZCk7XG4gIH07XG5cbiAgbmV3U3R5bGVGdW5jdGlvbi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2V4dGVuZHMoX2V4dGVuZHMoe30sIHN0eWxlRnVuY3Rpb24ucHJvcFR5cGVzKSwge30sIHtcbiAgICB4czogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBzbTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBtZDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBsZzogUHJvcFR5cGVzLm9iamVjdCxcbiAgICB4bDogUHJvcFR5cGVzLm9iamVjdFxuICB9KSA6IHt9O1xuICBuZXdTdHlsZUZ1bmN0aW9uLmZpbHRlclByb3BzID0gWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoc3R5bGVGdW5jdGlvbi5maWx0ZXJQcm9wcykpO1xuICByZXR1cm4gbmV3U3R5bGVGdW5jdGlvbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYnJlYWtwb2ludHM7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoY2FjaGVbYXJnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYWNoZVthcmddID0gZm4oYXJnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVbYXJnXTtcbiAgfTtcbn0iLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCByZXNwb25zaXZlUHJvcFR5cGUgZnJvbSAnLi9yZXNwb25zaXZlUHJvcFR5cGUnO1xuaW1wb3J0IHsgaGFuZGxlQnJlYWtwb2ludHMgfSBmcm9tICcuL2JyZWFrcG9pbnRzJztcbmltcG9ydCBtZXJnZSBmcm9tICcuL21lcmdlJztcbmltcG9ydCBtZW1vaXplIGZyb20gJy4vbWVtb2l6ZSc7XG52YXIgcHJvcGVydGllcyA9IHtcbiAgbTogJ21hcmdpbicsXG4gIHA6ICdwYWRkaW5nJ1xufTtcbnZhciBkaXJlY3Rpb25zID0ge1xuICB0OiAnVG9wJyxcbiAgcjogJ1JpZ2h0JyxcbiAgYjogJ0JvdHRvbScsXG4gIGw6ICdMZWZ0JyxcbiAgeDogWydMZWZ0JywgJ1JpZ2h0J10sXG4gIHk6IFsnVG9wJywgJ0JvdHRvbSddXG59O1xudmFyIGFsaWFzZXMgPSB7XG4gIG1hcmdpblg6ICdteCcsXG4gIG1hcmdpblk6ICdteScsXG4gIHBhZGRpbmdYOiAncHgnLFxuICBwYWRkaW5nWTogJ3B5J1xufTsgLy8gbWVtb2l6ZSgpIGltcGFjdDpcbi8vIEZyb20gMzAwLDAwMCBvcHMvc2VjXG4vLyBUbyAzNTAsMDAwIG9wcy9zZWNcblxudmFyIGdldENzc1Byb3BlcnRpZXMgPSBtZW1vaXplKGZ1bmN0aW9uIChwcm9wKSB7XG4gIC8vIEl0J3Mgbm90IGEgc2hvcnRoYW5kIG5vdGF0aW9uLlxuICBpZiAocHJvcC5sZW5ndGggPiAyKSB7XG4gICAgaWYgKGFsaWFzZXNbcHJvcF0pIHtcbiAgICAgIHByb3AgPSBhbGlhc2VzW3Byb3BdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvcCRzcGxpdCA9IHByb3Auc3BsaXQoJycpLFxuICAgICAgX3Byb3Akc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3Byb3Akc3BsaXQsIDIpLFxuICAgICAgYSA9IF9wcm9wJHNwbGl0MlswXSxcbiAgICAgIGIgPSBfcHJvcCRzcGxpdDJbMV07XG5cbiAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1thXTtcbiAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvbnNbYl0gfHwgJyc7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRpcmVjdGlvbikgPyBkaXJlY3Rpb24ubWFwKGZ1bmN0aW9uIChkaXIpIHtcbiAgICByZXR1cm4gcHJvcGVydHkgKyBkaXI7XG4gIH0pIDogW3Byb3BlcnR5ICsgZGlyZWN0aW9uXTtcbn0pO1xudmFyIHNwYWNpbmdLZXlzID0gWydtJywgJ210JywgJ21yJywgJ21iJywgJ21sJywgJ214JywgJ215JywgJ3AnLCAncHQnLCAncHInLCAncGInLCAncGwnLCAncHgnLCAncHknLCAnbWFyZ2luJywgJ21hcmdpblRvcCcsICdtYXJnaW5SaWdodCcsICdtYXJnaW5Cb3R0b20nLCAnbWFyZ2luTGVmdCcsICdtYXJnaW5YJywgJ21hcmdpblknLCAncGFkZGluZycsICdwYWRkaW5nVG9wJywgJ3BhZGRpbmdSaWdodCcsICdwYWRkaW5nQm90dG9tJywgJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdYJywgJ3BhZGRpbmdZJ107XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVW5hcnlTcGFjaW5nKHRoZW1lKSB7XG4gIHZhciB0aGVtZVNwYWNpbmcgPSB0aGVtZS5zcGFjaW5nIHx8IDg7XG5cbiAgaWYgKHR5cGVvZiB0aGVtZVNwYWNpbmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhYnMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWJzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNYXRlcmlhbC1VSTogRXhwZWN0ZWQgc3BhY2luZyBhcmd1bWVudCB0byBiZSBhIG51bWJlciwgZ290IFwiLmNvbmNhdChhYnMsIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoZW1lU3BhY2luZyAqIGFicztcbiAgICB9O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGhlbWVTcGFjaW5nKSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYWJzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYWJzID4gdGhlbWVTcGFjaW5nLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFtcIk1hdGVyaWFsLVVJOiBUaGUgdmFsdWUgcHJvdmlkZWQgKFwiLmNvbmNhdChhYnMsIFwiKSBvdmVyZmxvd3MuXCIpLCBcIlRoZSBzdXBwb3J0ZWQgdmFsdWVzIGFyZTogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRoZW1lU3BhY2luZyksIFwiLlwiKSwgXCJcIi5jb25jYXQoYWJzLCBcIiA+IFwiKS5jb25jYXQodGhlbWVTcGFjaW5nLmxlbmd0aCAtIDEsIFwiLCB5b3UgbmVlZCB0byBhZGQgdGhlIG1pc3NpbmcgdmFsdWVzLlwiKV0uam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGVtZVNwYWNpbmdbYWJzXTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0aGVtZVNwYWNpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdGhlbWVTcGFjaW5nO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKFtcIk1hdGVyaWFsLVVJOiBUaGUgYHRoZW1lLnNwYWNpbmdgIHZhbHVlIChcIi5jb25jYXQodGhlbWVTcGFjaW5nLCBcIikgaXMgaW52YWxpZC5cIiksICdJdCBzaG91bGQgYmUgYSBudW1iZXIsIGFuIGFycmF5IG9yIGEgZnVuY3Rpb24uJ10uam9pbignXFxuJykpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSh0cmFuc2Zvcm1lciwgcHJvcFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwcm9wVmFsdWU7XG4gIH1cblxuICB2YXIgYWJzID0gTWF0aC5hYnMocHJvcFZhbHVlKTtcbiAgdmFyIHRyYW5zZm9ybWVkID0gdHJhbnNmb3JtZXIoYWJzKTtcblxuICBpZiAocHJvcFZhbHVlID49IDApIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHRyYW5zZm9ybWVkID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAtdHJhbnNmb3JtZWQ7XG4gIH1cblxuICByZXR1cm4gXCItXCIuY29uY2F0KHRyYW5zZm9ybWVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3R5bGVGcm9tUHJvcFZhbHVlKGNzc1Byb3BlcnRpZXMsIHRyYW5zZm9ybWVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocHJvcFZhbHVlKSB7XG4gICAgcmV0dXJuIGNzc1Byb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNzc1Byb3BlcnR5KSB7XG4gICAgICBhY2NbY3NzUHJvcGVydHldID0gZ2V0VmFsdWUodHJhbnNmb3JtZXIsIHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3BhY2luZyhwcm9wcykge1xuICB2YXIgdGhlbWUgPSBwcm9wcy50aGVtZTtcbiAgdmFyIHRyYW5zZm9ybWVyID0gY3JlYXRlVW5hcnlTcGFjaW5nKHRoZW1lKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKS5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAvLyBVc2luZyBhIGhhc2ggY29tcHV0YXRpb24gb3ZlciBhbiBhcnJheSBpdGVyYXRpb24gY291bGQgYmUgZmFzdGVyLCBidXQgd2l0aCBvbmx5IDI4IGl0ZW1zLFxuICAgIC8vIGl0J3MgZG9lc24ndCB3b3J0aCB0aGUgYnVuZGxlIHNpemUuXG4gICAgaWYgKHNwYWNpbmdLZXlzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY3NzUHJvcGVydGllcyA9IGdldENzc1Byb3BlcnRpZXMocHJvcCk7XG4gICAgdmFyIHN0eWxlRnJvbVByb3BWYWx1ZSA9IGdldFN0eWxlRnJvbVByb3BWYWx1ZShjc3NQcm9wZXJ0aWVzLCB0cmFuc2Zvcm1lcik7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgIHJldHVybiBoYW5kbGVCcmVha3BvaW50cyhwcm9wcywgcHJvcFZhbHVlLCBzdHlsZUZyb21Qcm9wVmFsdWUpO1xuICB9KS5yZWR1Y2UobWVyZ2UsIHt9KTtcbn1cblxuc3BhY2luZy5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gc3BhY2luZ0tleXMucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICBvYmpba2V5XSA9IHJlc3BvbnNpdmVQcm9wVHlwZTtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KSA6IHt9O1xuc3BhY2luZy5maWx0ZXJQcm9wcyA9IHNwYWNpbmdLZXlzO1xuZXhwb3J0IGRlZmF1bHQgc3BhY2luZzsiLCJpbXBvcnQgeyBjcmVhdGVVbmFyeVNwYWNpbmcgfSBmcm9tICdAbWF0ZXJpYWwtdWkvc3lzdGVtJztcbnZhciB3YXJuT25jZTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNwYWNpbmcoKSB7XG4gIHZhciBzcGFjaW5nSW5wdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDg7XG5cbiAgLy8gQWxyZWFkeSB0cmFuc2Zvcm1lZC5cbiAgaWYgKHNwYWNpbmdJbnB1dC5tdWkpIHtcbiAgICByZXR1cm4gc3BhY2luZ0lucHV0O1xuICB9IC8vIE1hdGVyaWFsIERlc2lnbiBsYXlvdXRzIGFyZSB2aXN1YWxseSBiYWxhbmNlZC4gTW9zdCBtZWFzdXJlbWVudHMgYWxpZ24gdG8gYW4gOGRwIGdyaWQgYXBwbGllZCwgd2hpY2ggYWxpZ25zIGJvdGggc3BhY2luZyBhbmQgdGhlIG92ZXJhbGwgbGF5b3V0LlxuICAvLyBTbWFsbGVyIGNvbXBvbmVudHMsIHN1Y2ggYXMgaWNvbnMgYW5kIHR5cGUsIGNhbiBhbGlnbiB0byBhIDRkcCBncmlkLlxuICAvLyBodHRwczovL21hdGVyaWFsLmlvL2Rlc2lnbi9sYXlvdXQvdW5kZXJzdGFuZGluZy1sYXlvdXQuaHRtbCN1c2FnZVxuXG5cbiAgdmFyIHRyYW5zZm9ybSA9IGNyZWF0ZVVuYXJ5U3BhY2luZyh7XG4gICAgc3BhY2luZzogc3BhY2luZ0lucHV0XG4gIH0pO1xuXG4gIHZhciBzcGFjaW5nID0gZnVuY3Rpb24gc3BhY2luZygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghKGFyZ3MubGVuZ3RoIDw9IDQpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNYXRlcmlhbC1VSTogVG9vIG1hbnkgYXJndW1lbnRzIHByb3ZpZGVkLCBleHBlY3RlZCBiZXR3ZWVuIDAgYW5kIDQsIGdvdCBcIi5jb25jYXQoYXJncy5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm0oMSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtKGFyZ3NbMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcmdzLm1hcChmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dHB1dCA9IHRyYW5zZm9ybShhcmd1bWVudCk7XG4gICAgICByZXR1cm4gdHlwZW9mIG91dHB1dCA9PT0gJ251bWJlcicgPyBcIlwiLmNvbmNhdChvdXRwdXQsIFwicHhcIikgOiBvdXRwdXQ7XG4gICAgfSkuam9pbignICcpO1xuICB9OyAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0byByZW1vdmUgaW4gdjUuXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3BhY2luZywgJ3VuaXQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIXdhcm5PbmNlIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFsnTWF0ZXJpYWwtVUk6IHRoZW1lLnNwYWNpbmcudW5pdCB1c2FnZSBoYXMgYmVlbiBkZXByZWNhdGVkLicsICdJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdjUuJywgJ1lvdSBjYW4gcmVwbGFjZSBgdGhlbWUuc3BhY2luZy51bml0ICogeWAgd2l0aCBgdGhlbWUuc3BhY2luZyh5KWAuJywgJycsICdZb3UgY2FuIHVzZSB0aGUgYGh0dHBzOi8vZ2l0aHViLmNvbS9tdWktb3JnL21hdGVyaWFsLXVpL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21hdGVyaWFsLXVpLWNvZGVtb2QvUkVBRE1FLm1kI3RoZW1lLXNwYWNpbmctYXBpYCBtaWdyYXRpb24gaGVscGVyIHRvIG1ha2UgdGhlIHByb2Nlc3Mgc21vb3RoZXIuJ10uam9pbignXFxuJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2Fybk9uY2UgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3BhY2luZ0lucHV0O1xuICAgIH1cbiAgfSk7XG4gIHNwYWNpbmcubXVpID0gdHJ1ZTtcbiAgcmV0dXJuIHNwYWNpbmc7XG59IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbi8vIEZvbGxvdyBodHRwczovL21hdGVyaWFsLmdvb2dsZS5jb20vbW90aW9uL2R1cmF0aW9uLWVhc2luZy5odG1sI2R1cmF0aW9uLWVhc2luZy1uYXR1cmFsLWVhc2luZy1jdXJ2ZXNcbi8vIHRvIGxlYXJuIHRoZSBjb250ZXh0IGluIHdoaWNoIGVhY2ggZWFzaW5nIHNob3VsZCBiZSB1c2VkLlxuZXhwb3J0IHZhciBlYXNpbmcgPSB7XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uIGVhc2luZyBjdXJ2ZS5cbiAgZWFzZUluT3V0OiAnY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKScsXG4gIC8vIE9iamVjdHMgZW50ZXIgdGhlIHNjcmVlbiBhdCBmdWxsIHZlbG9jaXR5IGZyb20gb2ZmLXNjcmVlbiBhbmRcbiAgLy8gc2xvd2x5IGRlY2VsZXJhdGUgdG8gYSByZXN0aW5nIHBvaW50LlxuICBlYXNlT3V0OiAnY3ViaWMtYmV6aWVyKDAuMCwgMCwgMC4yLCAxKScsXG4gIC8vIE9iamVjdHMgbGVhdmUgdGhlIHNjcmVlbiBhdCBmdWxsIHZlbG9jaXR5LiBUaGV5IGRvIG5vdCBkZWNlbGVyYXRlIHdoZW4gb2ZmLXNjcmVlbi5cbiAgZWFzZUluOiAnY3ViaWMtYmV6aWVyKDAuNCwgMCwgMSwgMSknLFxuICAvLyBUaGUgc2hhcnAgY3VydmUgaXMgdXNlZCBieSBvYmplY3RzIHRoYXQgbWF5IHJldHVybiB0byB0aGUgc2NyZWVuIGF0IGFueSB0aW1lLlxuICBzaGFycDogJ2N1YmljLWJlemllcigwLjQsIDAsIDAuNiwgMSknXG59OyAvLyBGb2xsb3cgaHR0cHM6Ly9tYXRlcmlhbC5pby9ndWlkZWxpbmVzL21vdGlvbi9kdXJhdGlvbi1lYXNpbmcuaHRtbCNkdXJhdGlvbi1lYXNpbmctY29tbW9uLWR1cmF0aW9uc1xuLy8gdG8gbGVhcm4gd2hlbiB1c2Ugd2hhdCB0aW1pbmdcblxuZXhwb3J0IHZhciBkdXJhdGlvbiA9IHtcbiAgc2hvcnRlc3Q6IDE1MCxcbiAgc2hvcnRlcjogMjAwLFxuICBzaG9ydDogMjUwLFxuICAvLyBtb3N0IGJhc2ljIHJlY29tbWVuZGVkIHRpbWluZ1xuICBzdGFuZGFyZDogMzAwLFxuICAvLyB0aGlzIGlzIHRvIGJlIHVzZWQgaW4gY29tcGxleCBhbmltYXRpb25zXG4gIGNvbXBsZXg6IDM3NSxcbiAgLy8gcmVjb21tZW5kZWQgd2hlbiBzb21ldGhpbmcgaXMgZW50ZXJpbmcgc2NyZWVuXG4gIGVudGVyaW5nU2NyZWVuOiAyMjUsXG4gIC8vIHJlY29tbWVuZGVkIHdoZW4gc29tZXRoaW5nIGlzIGxlYXZpbmcgc2NyZWVuXG4gIGxlYXZpbmdTY3JlZW46IDE5NVxufTtcblxuZnVuY3Rpb24gZm9ybWF0TXMobWlsbGlzZWNvbmRzKSB7XG4gIHJldHVybiBcIlwiLmNvbmNhdChNYXRoLnJvdW5kKG1pbGxpc2Vjb25kcyksIFwibXNcIik7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0ucHJvcFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtLmR1cmF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0uZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW0uZGVsYXlcbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZWFzaW5nOiBlYXNpbmcsXG4gIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbJ2FsbCddO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBfb3B0aW9ucyRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgIGR1cmF0aW9uT3B0aW9uID0gX29wdGlvbnMkZHVyYXRpb24gPT09IHZvaWQgMCA/IGR1cmF0aW9uLnN0YW5kYXJkIDogX29wdGlvbnMkZHVyYXRpb24sXG4gICAgICAgIF9vcHRpb25zJGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nLFxuICAgICAgICBlYXNpbmdPcHRpb24gPSBfb3B0aW9ucyRlYXNpbmcgPT09IHZvaWQgMCA/IGVhc2luZy5lYXNlSW5PdXQgOiBfb3B0aW9ucyRlYXNpbmcsXG4gICAgICAgIF9vcHRpb25zJGRlbGF5ID0gb3B0aW9ucy5kZWxheSxcbiAgICAgICAgZGVsYXkgPSBfb3B0aW9ucyRkZWxheSA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJGRlbGF5LFxuICAgICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvcHRpb25zLCBbXCJkdXJhdGlvblwiLCBcImVhc2luZ1wiLCBcImRlbGF5XCJdKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICAgIH07XG5cbiAgICAgIHZhciBpc051bWJlciA9IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgfTtcblxuICAgICAgaWYgKCFpc1N0cmluZyhwcm9wcykgJiYgIUFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01hdGVyaWFsLVVJOiBBcmd1bWVudCBcInByb3BzXCIgbXVzdCBiZSBhIHN0cmluZyBvciBBcnJheS4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc051bWJlcihkdXJhdGlvbk9wdGlvbikgJiYgIWlzU3RyaW5nKGR1cmF0aW9uT3B0aW9uKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTWF0ZXJpYWwtVUk6IEFyZ3VtZW50IFxcXCJkdXJhdGlvblxcXCIgbXVzdCBiZSBhIG51bWJlciBvciBhIHN0cmluZyBidXQgZm91bmQgXCIuY29uY2F0KGR1cmF0aW9uT3B0aW9uLCBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU3RyaW5nKGVhc2luZ09wdGlvbikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IEFyZ3VtZW50IFwiZWFzaW5nXCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc051bWJlcihkZWxheSkgJiYgIWlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdNYXRlcmlhbC1VSTogQXJndW1lbnQgXCJkZWxheVwiIG11c3QgYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhvdGhlcikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNYXRlcmlhbC1VSTogVW5yZWNvZ25pemVkIGFyZ3VtZW50KHMpIFtcIi5jb25jYXQoT2JqZWN0LmtleXMob3RoZXIpLmpvaW4oJywnKSwgXCJdLlwiKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHByb3BzKSA/IHByb3BzIDogW3Byb3BzXSkubWFwKGZ1bmN0aW9uIChhbmltYXRlZFByb3ApIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChhbmltYXRlZFByb3AsIFwiIFwiKS5jb25jYXQodHlwZW9mIGR1cmF0aW9uT3B0aW9uID09PSAnc3RyaW5nJyA/IGR1cmF0aW9uT3B0aW9uIDogZm9ybWF0TXMoZHVyYXRpb25PcHRpb24pLCBcIiBcIikuY29uY2F0KGVhc2luZ09wdGlvbiwgXCIgXCIpLmNvbmNhdCh0eXBlb2YgZGVsYXkgPT09ICdzdHJpbmcnID8gZGVsYXkgOiBmb3JtYXRNcyhkZWxheSkpO1xuICAgIH0pLmpvaW4oJywnKTtcbiAgfSxcbiAgZ2V0QXV0b0hlaWdodER1cmF0aW9uOiBmdW5jdGlvbiBnZXRBdXRvSGVpZ2h0RHVyYXRpb24oaGVpZ2h0KSB7XG4gICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBjb25zdGFudCA9IGhlaWdodCAvIDM2OyAvLyBodHRwczovL3d3dy53b2xmcmFtYWxwaGEuY29tL2lucHV0Lz9pPSg0KyUyQisxNSsqKyh4KyUyRiszNispKyoqKzAuMjUrJTJCKyh4KyUyRiszNikrJTJGKzUpKyorMTBcblxuICAgIHJldHVybiBNYXRoLnJvdW5kKCg0ICsgMTUgKiBNYXRoLnBvdyhjb25zdGFudCwgMC4yNSkgKyBjb25zdGFudCAvIDUpICogMTApO1xuICB9XG59OyIsIi8vIFdlIG5lZWQgdG8gY2VudHJhbGl6ZSB0aGUgekluZGV4IGRlZmluaXRpb25zIGFzIHRoZXkgd29ya1xuLy8gbGlrZSBnbG9iYWwgdmFsdWVzIGluIHRoZSBicm93c2VyLlxudmFyIHpJbmRleCA9IHtcbiAgbW9iaWxlU3RlcHBlcjogMTAwMCxcbiAgc3BlZWREaWFsOiAxMDUwLFxuICBhcHBCYXI6IDExMDAsXG4gIGRyYXdlcjogMTIwMCxcbiAgbW9kYWw6IDEzMDAsXG4gIHNuYWNrYmFyOiAxNDAwLFxuICB0b29sdGlwOiAxNTAwXG59O1xuZXhwb3J0IGRlZmF1bHQgekluZGV4OyIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IHsgZGVlcG1lcmdlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBjcmVhdGVCcmVha3BvaW50cyBmcm9tICcuL2NyZWF0ZUJyZWFrcG9pbnRzJztcbmltcG9ydCBjcmVhdGVNaXhpbnMgZnJvbSAnLi9jcmVhdGVNaXhpbnMnO1xuaW1wb3J0IGNyZWF0ZVBhbGV0dGUgZnJvbSAnLi9jcmVhdGVQYWxldHRlJztcbmltcG9ydCBjcmVhdGVUeXBvZ3JhcGh5IGZyb20gJy4vY3JlYXRlVHlwb2dyYXBoeSc7XG5pbXBvcnQgc2hhZG93cyBmcm9tICcuL3NoYWRvd3MnO1xuaW1wb3J0IHNoYXBlIGZyb20gJy4vc2hhcGUnO1xuaW1wb3J0IGNyZWF0ZVNwYWNpbmcgZnJvbSAnLi9jcmVhdGVTcGFjaW5nJztcbmltcG9ydCB0cmFuc2l0aW9ucyBmcm9tICcuL3RyYW5zaXRpb25zJztcbmltcG9ydCB6SW5kZXggZnJvbSAnLi96SW5kZXgnO1xuXG5mdW5jdGlvbiBjcmVhdGVNdWlUaGVtZSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBfb3B0aW9ucyRicmVha3BvaW50cyA9IG9wdGlvbnMuYnJlYWtwb2ludHMsXG4gICAgICBicmVha3BvaW50c0lucHV0ID0gX29wdGlvbnMkYnJlYWtwb2ludHMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnMkYnJlYWtwb2ludHMsXG4gICAgICBfb3B0aW9ucyRtaXhpbnMgPSBvcHRpb25zLm1peGlucyxcbiAgICAgIG1peGluc0lucHV0ID0gX29wdGlvbnMkbWl4aW5zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zJG1peGlucyxcbiAgICAgIF9vcHRpb25zJHBhbGV0dGUgPSBvcHRpb25zLnBhbGV0dGUsXG4gICAgICBwYWxldHRlSW5wdXQgPSBfb3B0aW9ucyRwYWxldHRlID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zJHBhbGV0dGUsXG4gICAgICBzcGFjaW5nSW5wdXQgPSBvcHRpb25zLnNwYWNpbmcsXG4gICAgICBfb3B0aW9ucyR0eXBvZ3JhcGh5ID0gb3B0aW9ucy50eXBvZ3JhcGh5LFxuICAgICAgdHlwb2dyYXBoeUlucHV0ID0gX29wdGlvbnMkdHlwb2dyYXBoeSA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9ucyR0eXBvZ3JhcGh5LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3B0aW9ucywgW1wiYnJlYWtwb2ludHNcIiwgXCJtaXhpbnNcIiwgXCJwYWxldHRlXCIsIFwic3BhY2luZ1wiLCBcInR5cG9ncmFwaHlcIl0pO1xuXG4gIHZhciBwYWxldHRlID0gY3JlYXRlUGFsZXR0ZShwYWxldHRlSW5wdXQpO1xuICB2YXIgYnJlYWtwb2ludHMgPSBjcmVhdGVCcmVha3BvaW50cyhicmVha3BvaW50c0lucHV0KTtcbiAgdmFyIHNwYWNpbmcgPSBjcmVhdGVTcGFjaW5nKHNwYWNpbmdJbnB1dCk7XG4gIHZhciBtdWlUaGVtZSA9IGRlZXBtZXJnZSh7XG4gICAgYnJlYWtwb2ludHM6IGJyZWFrcG9pbnRzLFxuICAgIGRpcmVjdGlvbjogJ2x0cicsXG4gICAgbWl4aW5zOiBjcmVhdGVNaXhpbnMoYnJlYWtwb2ludHMsIHNwYWNpbmcsIG1peGluc0lucHV0KSxcbiAgICBvdmVycmlkZXM6IHt9LFxuICAgIC8vIEluamVjdCBjdXN0b20gc3R5bGVzXG4gICAgcGFsZXR0ZTogcGFsZXR0ZSxcbiAgICBwcm9wczoge30sXG4gICAgLy8gUHJvdmlkZSBkZWZhdWx0IHByb3BzXG4gICAgc2hhZG93czogc2hhZG93cyxcbiAgICB0eXBvZ3JhcGh5OiBjcmVhdGVUeXBvZ3JhcGh5KHBhbGV0dGUsIHR5cG9ncmFwaHlJbnB1dCksXG4gICAgc3BhY2luZzogc3BhY2luZyxcbiAgICBzaGFwZTogc2hhcGUsXG4gICAgdHJhbnNpdGlvbnM6IHRyYW5zaXRpb25zLFxuICAgIHpJbmRleDogekluZGV4XG4gIH0sIG90aGVyKTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBtdWlUaGVtZSA9IGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGFyZ3VtZW50KSB7XG4gICAgcmV0dXJuIGRlZXBtZXJnZShhY2MsIGFyZ3VtZW50KTtcbiAgfSwgbXVpVGhlbWUpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHBzZXVkb0NsYXNzZXMgPSBbJ2NoZWNrZWQnLCAnZGlzYWJsZWQnLCAnZXJyb3InLCAnZm9jdXNlZCcsICdmb2N1c1Zpc2libGUnLCAncmVxdWlyZWQnLCAnZXhwYW5kZWQnLCAnc2VsZWN0ZWQnXTtcblxuICAgIHZhciB0cmF2ZXJzZSA9IGZ1bmN0aW9uIHRyYXZlcnNlKG5vZGUsIHBhcmVudEtleSkge1xuICAgICAgdmFyIGRlcHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgICAgdmFyIGtleTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pbiwgbm8tcmVzdHJpY3RlZC1zeW50YXhcblxuICAgICAgZm9yIChrZXkgaW4gbm9kZSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2tleV07XG5cbiAgICAgICAgaWYgKGRlcHRoID09PSAxKSB7XG4gICAgICAgICAgaWYgKGtleS5pbmRleE9mKCdNdWknKSA9PT0gMCAmJiBjaGlsZCkge1xuICAgICAgICAgICAgdHJhdmVyc2UoY2hpbGQsIGtleSwgZGVwdGggKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHNldWRvQ2xhc3Nlcy5pbmRleE9mKGtleSkgIT09IC0xICYmIE9iamVjdC5rZXlzKGNoaWxkKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IFRoZSBgXCIuY29uY2F0KHBhcmVudEtleSwgXCJgIGNvbXBvbmVudCBpbmNyZWFzZXMgXCIpICsgXCJ0aGUgQ1NTIHNwZWNpZmljaXR5IG9mIHRoZSBgXCIuY29uY2F0KGtleSwgXCJgIGludGVybmFsIHN0YXRlLlwiKSwgJ1lvdSBjYW4gbm90IG92ZXJyaWRlIGl0IGxpa2UgdGhpczogJywgSlNPTi5zdHJpbmdpZnkobm9kZSwgbnVsbCwgMiksICcnLCAnSW5zdGVhZCwgeW91IG5lZWQgdG8gdXNlIHRoZSAkcnVsZU5hbWUgc3ludGF4OicsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgcm9vdDogX2RlZmluZVByb3BlcnR5KHt9LCBcIiYkXCIuY29uY2F0KGtleSksIGNoaWxkKVxuICAgICAgICAgICAgfSwgbnVsbCwgMiksICcnLCAnaHR0cHM6Ly9tYXRlcmlhbC11aS5jb20vci9wc2V1ZG8tY2xhc3Nlcy1ndWlkZSddLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9IC8vIFJlbW92ZSB0aGUgc3R5bGUgdG8gcHJldmVudCBnbG9iYWwgY29uZmxpY3RzLlxuXG5cbiAgICAgICAgICBub2RlW2tleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0cmF2ZXJzZShtdWlUaGVtZS5vdmVycmlkZXMpO1xuICB9XG5cbiAgcmV0dXJuIG11aVRoZW1lO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVNdWlUaGVtZTsiLCJpbXBvcnQgY3JlYXRlTXVpVGhlbWUgZnJvbSAnLi9jcmVhdGVNdWlUaGVtZSc7XG52YXIgZGVmYXVsdFRoZW1lID0gY3JlYXRlTXVpVGhlbWUoKTtcbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRUaGVtZTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCB7IG1ha2VTdHlsZXMgYXMgbWFrZVN0eWxlc1dpdGhvdXREZWZhdWx0IH0gZnJvbSAnQG1hdGVyaWFsLXVpL3N0eWxlcyc7XG5pbXBvcnQgZGVmYXVsdFRoZW1lIGZyb20gJy4vZGVmYXVsdFRoZW1lJztcblxuZnVuY3Rpb24gbWFrZVN0eWxlcyhzdHlsZXNPckNyZWF0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gbWFrZVN0eWxlc1dpdGhvdXREZWZhdWx0KHN0eWxlc09yQ3JlYXRvciwgX2V4dGVuZHMoe1xuICAgIGRlZmF1bHRUaGVtZTogZGVmYXVsdFRoZW1lXG4gIH0sIG9wdGlvbnMpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFrZVN0eWxlczsiLCJmdW5jdGlvbiB0b1ZhbChtaXgpIHtcblx0dmFyIGssIHksIHN0cj0nJztcblxuXHRpZiAodHlwZW9mIG1peCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG1peCA9PT0gJ251bWJlcicpIHtcblx0XHRzdHIgKz0gbWl4O1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtaXggPT09ICdvYmplY3QnKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkobWl4KSkge1xuXHRcdFx0Zm9yIChrPTA7IGsgPCBtaXgubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0aWYgKG1peFtrXSkge1xuXHRcdFx0XHRcdGlmICh5ID0gdG9WYWwobWl4W2tdKSkge1xuXHRcdFx0XHRcdFx0c3RyICYmIChzdHIgKz0gJyAnKTtcblx0XHRcdFx0XHRcdHN0ciArPSB5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGsgaW4gbWl4KSB7XG5cdFx0XHRcdGlmIChtaXhba10pIHtcblx0XHRcdFx0XHRzdHIgJiYgKHN0ciArPSAnICcpO1xuXHRcdFx0XHRcdHN0ciArPSBrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHN0cjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuXHR2YXIgaT0wLCB0bXAsIHgsIHN0cj0nJztcblx0d2hpbGUgKGkgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0aWYgKHRtcCA9IGFyZ3VtZW50c1tpKytdKSB7XG5cdFx0XHRpZiAoeCA9IHRvVmFsKHRtcCkpIHtcblx0XHRcdFx0c3RyICYmIChzdHIgKz0gJyAnKTtcblx0XHRcdFx0c3RyICs9IHhcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHN0cjtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRUaGVtZVByb3BzKHBhcmFtcykge1xuICB2YXIgdGhlbWUgPSBwYXJhbXMudGhlbWUsXG4gICAgICBuYW1lID0gcGFyYW1zLm5hbWUsXG4gICAgICBwcm9wcyA9IHBhcmFtcy5wcm9wcztcblxuICBpZiAoIXRoZW1lIHx8ICF0aGVtZS5wcm9wcyB8fCAhdGhlbWUucHJvcHNbbmFtZV0pIHtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLCBjb2RlIGJvcnJvdyBmcm9tIFJlYWN0IHNvdXJjZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvMTVhOGYwMzE4MzhhNTUzZTQxYzBiNjZlYjFiY2YxZGE4NDQ4MTA0ZC9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RFbGVtZW50LmpzI0wyMjFcblxuXG4gIHZhciBkZWZhdWx0UHJvcHMgPSB0aGVtZS5wcm9wc1tuYW1lXTtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBob2lzdE5vblJlYWN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgeyBjaGFpblByb3BUeXBlcywgZ2V0RGlzcGxheU5hbWUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IG1ha2VTdHlsZXMgZnJvbSAnLi4vbWFrZVN0eWxlcyc7XG5pbXBvcnQgZ2V0VGhlbWVQcm9wcyBmcm9tICcuLi9nZXRUaGVtZVByb3BzJztcbmltcG9ydCB1c2VUaGVtZSBmcm9tICcuLi91c2VUaGVtZSc7IC8vIExpbmsgYSBzdHlsZSBzaGVldCB3aXRoIGEgY29tcG9uZW50LlxuLy8gSXQgZG9lcyBub3QgbW9kaWZ5IHRoZSBjb21wb25lbnQgcGFzc2VkIHRvIGl0O1xuLy8gaW5zdGVhZCwgaXQgcmV0dXJucyBhIG5ldyBjb21wb25lbnQsIHdpdGggYSBgY2xhc3Nlc2AgcHJvcGVydHkuXG5cbnZhciB3aXRoU3R5bGVzID0gZnVuY3Rpb24gd2l0aFN0eWxlcyhzdHlsZXNPckNyZWF0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgIHZhciBkZWZhdWx0VGhlbWUgPSBvcHRpb25zLmRlZmF1bHRUaGVtZSxcbiAgICAgICAgX29wdGlvbnMkd2l0aFRoZW1lID0gb3B0aW9ucy53aXRoVGhlbWUsXG4gICAgICAgIHdpdGhUaGVtZSA9IF9vcHRpb25zJHdpdGhUaGVtZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR3aXRoVGhlbWUsXG4gICAgICAgIG5hbWUgPSBvcHRpb25zLm5hbWUsXG4gICAgICAgIHN0eWxlc09wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3B0aW9ucywgW1wiZGVmYXVsdFRoZW1lXCIsIFwid2l0aFRoZW1lXCIsIFwibmFtZVwiXSk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKENvbXBvbmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihbJ1lvdSBhcmUgY2FsbGluZyB3aXRoU3R5bGVzKHN0eWxlcykoQ29tcG9uZW50KSB3aXRoIGFuIHVuZGVmaW5lZCBjb21wb25lbnQuJywgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gaW1wb3J0IGl0LiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2xhc3NOYW1lUHJlZml4ID0gbmFtZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgLy8gUHJvdmlkZSBhIGJldHRlciBEWCBvdXRzaWRlIHByb2R1Y3Rpb24uXG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lKENvbXBvbmVudCk7XG5cbiAgICAgICAgaWYgKGRpc3BsYXlOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGFzc05hbWVQcmVmaXggPSBkaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1c2VTdHlsZXMgPSBtYWtlU3R5bGVzKHN0eWxlc09yQ3JlYXRvciwgX2V4dGVuZHMoe1xuICAgICAgZGVmYXVsdFRoZW1lOiBkZWZhdWx0VGhlbWUsXG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgICAgIG5hbWU6IG5hbWUgfHwgQ29tcG9uZW50LmRpc3BsYXlOYW1lLFxuICAgICAgY2xhc3NOYW1lUHJlZml4OiBjbGFzc05hbWVQcmVmaXhcbiAgICB9LCBzdHlsZXNPcHRpb25zKSk7XG4gICAgdmFyIFdpdGhTdHlsZXMgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFdpdGhTdHlsZXMocHJvcHMsIHJlZikge1xuICAgICAgdmFyIGNsYXNzZXNQcm9wID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgICAgICBpbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxuICAgICAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjbGFzc2VzXCIsIFwiaW5uZXJSZWZcIl0pOyAvLyBUaGUgd3JhcHBlciByZWNlaXZlcyBvbmx5IHVzZXIgc3VwcGxpZWQgcHJvcHMsIHdoaWNoIGNvdWxkIGJlIGEgc3Vic2V0IG9mXG4gICAgICAvLyB0aGUgYWN0dWFsIHByb3BzIENvbXBvbmVudCBtaWdodCByZWNlaXZlIGR1ZSB0byBtZXJnaW5nIHdpdGggZGVmYXVsdFByb3BzLlxuICAgICAgLy8gU28gY29weWluZyBpdCBoZXJlIHdvdWxkIGdpdmUgdXMgdGhlIHNhbWUgcmVzdWx0IGluIHRoZSB3cmFwcGVyIGFzIHdlbGwuXG5cblxuICAgICAgdmFyIGNsYXNzZXMgPSB1c2VTdHlsZXMoX2V4dGVuZHMoX2V4dGVuZHMoe30sIENvbXBvbmVudC5kZWZhdWx0UHJvcHMpLCBwcm9wcykpO1xuICAgICAgdmFyIHRoZW1lO1xuICAgICAgdmFyIG1vcmUgPSBvdGhlcjtcblxuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyB8fCB3aXRoVGhlbWUpIHtcbiAgICAgICAgLy8gbmFtZSBhbmQgd2l0aFRoZW1lIGFyZSBpbnZhcmlhbnQgaW4gdGhlIG91dGVyIHNjb3BlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICB0aGVtZSA9IHVzZVRoZW1lKCkgfHwgZGVmYXVsdFRoZW1lO1xuXG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgbW9yZSA9IGdldFRoZW1lUHJvcHMoe1xuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHByb3BzOiBvdGhlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIFByb3ZpZGUgdGhlIHRoZW1lIHRvIHRoZSB3cmFwcGVkIGNvbXBvbmVudC5cbiAgICAgICAgLy8gU28gd2UgZG9uJ3QgaGF2ZSB0byB1c2UgdGhlIGB3aXRoVGhlbWUoKWAgSGlnaGVyLW9yZGVyIENvbXBvbmVudC5cblxuXG4gICAgICAgIGlmICh3aXRoVGhlbWUgJiYgIW1vcmUudGhlbWUpIHtcbiAgICAgICAgICBtb3JlLnRoZW1lID0gdGhlbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgICAgICByZWY6IGlubmVyUmVmIHx8IHJlZixcbiAgICAgICAgY2xhc3NlczogY2xhc3Nlc1xuICAgICAgfSwgbW9yZSkpO1xuICAgIH0pO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFdpdGhTdHlsZXMucHJvcFR5cGVzID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAgICAgKi9cbiAgICAgIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlIHRoYXQgcHJvcCB0byBwYXNzIGEgcmVmIHRvIHRoZSBkZWNvcmF0ZWQgY29tcG9uZW50LlxuICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAqL1xuICAgICAgaW5uZXJSZWY6IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSksIGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMuaW5uZXJSZWYgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIC8vICAgJ01hdGVyaWFsLVVJOiBUaGUgYGlubmVyUmVmYCBwcm9wIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2NS4gJyArXG4gICAgICAgIC8vICAgICAnUmVmcyBhcmUgbm93IGF1dG9tYXRpY2FsbHkgZm9yd2FyZGVkIHRvIHRoZSBpbm5lciBjb21wb25lbnQuJyxcbiAgICAgICAgLy8gKTtcbiAgICAgIH0pXG4gICAgfSA6IHZvaWQgMDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBXaXRoU3R5bGVzLmRpc3BsYXlOYW1lID0gXCJXaXRoU3R5bGVzKFwiLmNvbmNhdChnZXREaXNwbGF5TmFtZShDb21wb25lbnQpLCBcIilcIik7XG4gICAgfVxuXG4gICAgaG9pc3ROb25SZWFjdFN0YXRpY3MoV2l0aFN0eWxlcywgQ29tcG9uZW50KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBFeHBvc2VkIGZvciB0ZXN0IHB1cnBvc2VzLlxuICAgICAgV2l0aFN0eWxlcy5OYWtlZCA9IENvbXBvbmVudDtcbiAgICAgIFdpdGhTdHlsZXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBXaXRoU3R5bGVzLnVzZVN0eWxlcyA9IHVzZVN0eWxlcztcbiAgICB9XG5cbiAgICByZXR1cm4gV2l0aFN0eWxlcztcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXM7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgeyB3aXRoU3R5bGVzIGFzIHdpdGhTdHlsZXNXaXRob3V0RGVmYXVsdCB9IGZyb20gJ0BtYXRlcmlhbC11aS9zdHlsZXMnO1xuaW1wb3J0IGRlZmF1bHRUaGVtZSBmcm9tICcuL2RlZmF1bHRUaGVtZSc7XG5cbmZ1bmN0aW9uIHdpdGhTdHlsZXMoc3R5bGVzT3JDcmVhdG9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB3aXRoU3R5bGVzV2l0aG91dERlZmF1bHQoc3R5bGVzT3JDcmVhdG9yLCBfZXh0ZW5kcyh7XG4gICAgZGVmYXVsdFRoZW1lOiBkZWZhdWx0VGhlbWVcbiAgfSwgb3B0aW9ucykpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzOyIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IGNoYWluUHJvcFR5cGVzIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHZhciBlbGV2YXRpb25zID0ge307XG4gIHRoZW1lLnNoYWRvd3MuZm9yRWFjaChmdW5jdGlvbiAoc2hhZG93LCBpbmRleCkge1xuICAgIGVsZXZhdGlvbnNbXCJlbGV2YXRpb25cIi5jb25jYXQoaW5kZXgpXSA9IHtcbiAgICAgIGJveFNoYWRvdzogc2hhZG93XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUuYmFja2dyb3VuZC5wYXBlcixcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRleHQucHJpbWFyeSxcbiAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgnYm94LXNoYWRvdycpXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHNxdWFyZT17ZmFsc2V9YC4gKi9cbiAgICByb3VuZGVkOiB7XG4gICAgICBib3JkZXJSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1c1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGB2YXJpYW50PVwib3V0bGluZWRcImAuICovXG4gICAgb3V0bGluZWQ6IHtcbiAgICAgIGJvcmRlcjogXCIxcHggc29saWQgXCIuY29uY2F0KHRoZW1lLnBhbGV0dGUuZGl2aWRlcilcbiAgICB9XG4gIH0sIGVsZXZhdGlvbnMpO1xufTtcbnZhciBQYXBlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFBhcGVyKHByb3BzLCByZWYpIHtcbiAgdmFyIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJGNvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgIENvbXBvbmVudCA9IF9wcm9wcyRjb21wb25lbnQgPT09IHZvaWQgMCA/ICdkaXYnIDogX3Byb3BzJGNvbXBvbmVudCxcbiAgICAgIF9wcm9wcyRzcXVhcmUgPSBwcm9wcy5zcXVhcmUsXG4gICAgICBzcXVhcmUgPSBfcHJvcHMkc3F1YXJlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRzcXVhcmUsXG4gICAgICBfcHJvcHMkZWxldmF0aW9uID0gcHJvcHMuZWxldmF0aW9uLFxuICAgICAgZWxldmF0aW9uID0gX3Byb3BzJGVsZXZhdGlvbiA9PT0gdm9pZCAwID8gMSA6IF9wcm9wcyRlbGV2YXRpb24sXG4gICAgICBfcHJvcHMkdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICB2YXJpYW50ID0gX3Byb3BzJHZhcmlhbnQgPT09IHZvaWQgMCA/ICdlbGV2YXRpb24nIDogX3Byb3BzJHZhcmlhbnQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNvbXBvbmVudFwiLCBcInNxdWFyZVwiLCBcImVsZXZhdGlvblwiLCBcInZhcmlhbnRcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUsIHZhcmlhbnQgPT09ICdvdXRsaW5lZCcgPyBjbGFzc2VzLm91dGxpbmVkIDogY2xhc3Nlc1tcImVsZXZhdGlvblwiLmNvbmNhdChlbGV2YXRpb24pXSwgIXNxdWFyZSAmJiBjbGFzc2VzLnJvdW5kZWQpLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFBhcGVyLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogU2hhZG93IGRlcHRoLCBjb3JyZXNwb25kcyB0byBgZHBgIGluIHRoZSBzcGVjLlxuICAgKiBJdCBhY2NlcHRzIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDI0IGluY2x1c2l2ZS5cbiAgICovXG4gIGVsZXZhdGlvbjogY2hhaW5Qcm9wVHlwZXMoUHJvcFR5cGVzLm51bWJlciwgZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgICBlbGV2YXRpb24gPSBwcm9wcy5lbGV2YXRpb247IC8vIGluIGNhc2UgYHdpdGhTdHlsZXNgIGZhaWxzIHRvIGluamVjdCB3ZSBkb24ndCBuZWVkIHRoaXMgd2FybmluZ1xuXG4gICAgaWYgKGNsYXNzZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGVsZXZhdGlvbiAhPSBudWxsICYmIGNsYXNzZXNbXCJlbGV2YXRpb25cIi5jb25jYXQoZWxldmF0aW9uKV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIk1hdGVyaWFsLVVJOiBUaGlzIGVsZXZhdGlvbiBgXCIuY29uY2F0KGVsZXZhdGlvbiwgXCJgIGlzIG5vdCBpbXBsZW1lbnRlZC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9KSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCByb3VuZGVkIGNvcm5lcnMgYXJlIGRpc2FibGVkLlxuICAgKi9cbiAgc3F1YXJlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgdG8gdXNlLlxuICAgKi9cbiAgdmFyaWFudDogUHJvcFR5cGVzLm9uZU9mKFsnZWxldmF0aW9uJywgJ291dGxpbmVkJ10pXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aVBhcGVyJ1xufSkoUGFwZXIpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCBQYXBlciBmcm9tICcuLi9QYXBlcic7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgcm9vdDoge1xuICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICB9XG59O1xudmFyIENhcmQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDYXJkKHByb3BzLCByZWYpIHtcbiAgdmFyIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJHJhaXNlZCA9IHByb3BzLnJhaXNlZCxcbiAgICAgIHJhaXNlZCA9IF9wcm9wcyRyYWlzZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJHJhaXNlZCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwicmFpc2VkXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUGFwZXIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUpLFxuICAgIGVsZXZhdGlvbjogcmFpc2VkID8gOCA6IDEsXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gQ2FyZC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY2FyZCB3aWxsIHVzZSByYWlzZWQgc3R5bGluZy5cbiAgICovXG4gIHJhaXNlZDogUHJvcFR5cGVzLmJvb2xcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpQ2FyZCdcbn0pKENhcmQpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmV4cG9ydCB2YXIgc3R5bGVzID0ge1xuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICByb290OiB7XG4gICAgcGFkZGluZzogMTYsXG4gICAgJyY6bGFzdC1jaGlsZCc6IHtcbiAgICAgIHBhZGRpbmdCb3R0b206IDI0XG4gICAgfVxuICB9XG59O1xudmFyIENhcmRDb250ZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ2FyZENvbnRlbnQocHJvcHMsIHJlZikge1xuICB2YXIgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgQ29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2RpdicgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb21wb25lbnRcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUpLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IENhcmRDb250ZW50LnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlDYXJkQ29udGVudCdcbn0pKENhcmRDb250ZW50KTsiLCJpbXBvcnQgeyBmb3JtYXRNdWlFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdE11aUVycm9yTWVzc2FnZSB9IGZyb20gXCJAbWF0ZXJpYWwtdWkvdXRpbHNcIjtcbi8vIEl0IHNob3VsZCB0byBiZSBub3RlZCB0aGF0IHRoaXMgZnVuY3Rpb24gaXNuJ3QgZXF1aXZhbGVudCB0byBgdGV4dC10cmFuc2Zvcm06IGNhcGl0YWxpemVgLlxuLy9cbi8vIEEgc3RyaWN0IGNhcGl0YWxpemF0aW9uIHNob3VsZCB1cHBlcmNhc2UgdGhlIGZpcnN0IGxldHRlciBvZiBlYWNoIHdvcmQgYSB0aGUgc2VudGVuY2UuXG4vLyBXZSBvbmx5IGhhbmRsZSB0aGUgZmlyc3Qgd29yZC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk1hdGVyaWFsLVVJOiBjYXBpdGFsaXplKHN0cmluZykgZXhwZWN0cyBhIHN0cmluZyBhcmd1bWVudC5cIiA6IF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UoNykpO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICcuLi91dGlscy9jYXBpdGFsaXplJztcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHJldHVybiB7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiB7XG4gICAgICBtYXJnaW46IDBcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImJvZHkyXCJgLiAqL1xuICAgIGJvZHkyOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHkyLFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImJvZHkxXCJgLiAqL1xuICAgIGJvZHkxOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHkxLFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImNhcHRpb25cImAuICovXG4gICAgY2FwdGlvbjogdGhlbWUudHlwb2dyYXBoeS5jYXB0aW9uLFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImJ1dHRvblwiYC4gKi9cbiAgICBidXR0b246IHRoZW1lLnR5cG9ncmFwaHkuYnV0dG9uLFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImgxXCJgLiAqL1xuICAgIGgxOiB0aGVtZS50eXBvZ3JhcGh5LmgxLFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImgyXCJgLiAqL1xuICAgIGgyOiB0aGVtZS50eXBvZ3JhcGh5LmgyLFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImgzXCJgLiAqL1xuICAgIGgzOiB0aGVtZS50eXBvZ3JhcGh5LmgzLFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImg0XCJgLiAqL1xuICAgIGg0OiB0aGVtZS50eXBvZ3JhcGh5Lmg0LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImg1XCJgLiAqL1xuICAgIGg1OiB0aGVtZS50eXBvZ3JhcGh5Lmg1LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImg2XCJgLiAqL1xuICAgIGg2OiB0aGVtZS50eXBvZ3JhcGh5Lmg2LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cInN1YnRpdGxlMVwiYC4gKi9cbiAgICBzdWJ0aXRsZTE6IHRoZW1lLnR5cG9ncmFwaHkuc3VidGl0bGUxLFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cInN1YnRpdGxlMlwiYC4gKi9cbiAgICBzdWJ0aXRsZTI6IHRoZW1lLnR5cG9ncmFwaHkuc3VidGl0bGUyLFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cIm92ZXJsaW5lXCJgLiAqL1xuICAgIG92ZXJsaW5lOiB0aGVtZS50eXBvZ3JhcGh5Lm92ZXJsaW5lLFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cInNyT25seVwiYC4gT25seSBhY2Nlc3NpYmxlIHRvIHNjcmVlbiByZWFkZXJzLiAqL1xuICAgIHNyT25seToge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBhbGlnbj1cImxlZnRcImAuICovXG4gICAgYWxpZ25MZWZ0OiB7XG4gICAgICB0ZXh0QWxpZ246ICdsZWZ0J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBhbGlnbj1cImNlbnRlclwiYC4gKi9cbiAgICBhbGlnbkNlbnRlcjoge1xuICAgICAgdGV4dEFsaWduOiAnY2VudGVyJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBhbGlnbj1cInJpZ2h0XCJgLiAqL1xuICAgIGFsaWduUmlnaHQ6IHtcbiAgICAgIHRleHRBbGlnbjogJ3JpZ2h0J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBhbGlnbj1cImp1c3RpZnlcImAuICovXG4gICAgYWxpZ25KdXN0aWZ5OiB7XG4gICAgICB0ZXh0QWxpZ246ICdqdXN0aWZ5J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBub3dyYXA9e3RydWV9YC4gKi9cbiAgICBub1dyYXA6IHtcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGd1dHRlckJvdHRvbT17dHJ1ZX1gLiAqL1xuICAgIGd1dHRlckJvdHRvbToge1xuICAgICAgbWFyZ2luQm90dG9tOiAnMC4zNWVtJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBwYXJhZ3JhcGg9e3RydWV9YC4gKi9cbiAgICBwYXJhZ3JhcGg6IHtcbiAgICAgIG1hcmdpbkJvdHRvbTogMTZcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJpbmhlcml0XCJgLiAqL1xuICAgIGNvbG9ySW5oZXJpdDoge1xuICAgICAgY29sb3I6ICdpbmhlcml0J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBjb2xvcj1cInByaW1hcnlcImAuICovXG4gICAgY29sb3JQcmltYXJ5OiB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW5cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJzZWNvbmRhcnlcImAuICovXG4gICAgY29sb3JTZWNvbmRhcnk6IHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwidGV4dFByaW1hcnlcImAuICovXG4gICAgY29sb3JUZXh0UHJpbWFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5wcmltYXJ5XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwidGV4dFNlY29uZGFyeVwiYC4gKi9cbiAgICBjb2xvclRleHRTZWNvbmRhcnk6IHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRleHQuc2Vjb25kYXJ5XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwiZXJyb3JcImAuICovXG4gICAgY29sb3JFcnJvcjoge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuZXJyb3IubWFpblxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNwbGF5PVwiaW5saW5lXCJgLiAqL1xuICAgIGRpc3BsYXlJbmxpbmU6IHtcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc3BsYXk9XCJibG9ja1wiYC4gKi9cbiAgICBkaXNwbGF5QmxvY2s6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9XG4gIH07XG59O1xudmFyIGRlZmF1bHRWYXJpYW50TWFwcGluZyA9IHtcbiAgaDE6ICdoMScsXG4gIGgyOiAnaDInLFxuICBoMzogJ2gzJyxcbiAgaDQ6ICdoNCcsXG4gIGg1OiAnaDUnLFxuICBoNjogJ2g2JyxcbiAgc3VidGl0bGUxOiAnaDYnLFxuICBzdWJ0aXRsZTI6ICdoNicsXG4gIGJvZHkxOiAncCcsXG4gIGJvZHkyOiAncCdcbn07XG52YXIgVHlwb2dyYXBoeSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFR5cG9ncmFwaHkocHJvcHMsIHJlZikge1xuICB2YXIgX3Byb3BzJGFsaWduID0gcHJvcHMuYWxpZ24sXG4gICAgICBhbGlnbiA9IF9wcm9wcyRhbGlnbiA9PT0gdm9pZCAwID8gJ2luaGVyaXQnIDogX3Byb3BzJGFsaWduLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIGNvbG9yID0gX3Byb3BzJGNvbG9yID09PSB2b2lkIDAgPyAnaW5pdGlhbCcgOiBfcHJvcHMkY29sb3IsXG4gICAgICBjb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBfcHJvcHMkZGlzcGxheSA9IHByb3BzLmRpc3BsYXksXG4gICAgICBkaXNwbGF5ID0gX3Byb3BzJGRpc3BsYXkgPT09IHZvaWQgMCA/ICdpbml0aWFsJyA6IF9wcm9wcyRkaXNwbGF5LFxuICAgICAgX3Byb3BzJGd1dHRlckJvdHRvbSA9IHByb3BzLmd1dHRlckJvdHRvbSxcbiAgICAgIGd1dHRlckJvdHRvbSA9IF9wcm9wcyRndXR0ZXJCb3R0b20gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGd1dHRlckJvdHRvbSxcbiAgICAgIF9wcm9wcyRub1dyYXAgPSBwcm9wcy5ub1dyYXAsXG4gICAgICBub1dyYXAgPSBfcHJvcHMkbm9XcmFwID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRub1dyYXAsXG4gICAgICBfcHJvcHMkcGFyYWdyYXBoID0gcHJvcHMucGFyYWdyYXBoLFxuICAgICAgcGFyYWdyYXBoID0gX3Byb3BzJHBhcmFncmFwaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkcGFyYWdyYXBoLFxuICAgICAgX3Byb3BzJHZhcmlhbnQgPSBwcm9wcy52YXJpYW50LFxuICAgICAgdmFyaWFudCA9IF9wcm9wcyR2YXJpYW50ID09PSB2b2lkIDAgPyAnYm9keTEnIDogX3Byb3BzJHZhcmlhbnQsXG4gICAgICBfcHJvcHMkdmFyaWFudE1hcHBpbmcgPSBwcm9wcy52YXJpYW50TWFwcGluZyxcbiAgICAgIHZhcmlhbnRNYXBwaW5nID0gX3Byb3BzJHZhcmlhbnRNYXBwaW5nID09PSB2b2lkIDAgPyBkZWZhdWx0VmFyaWFudE1hcHBpbmcgOiBfcHJvcHMkdmFyaWFudE1hcHBpbmcsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYWxpZ25cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sb3JcIiwgXCJjb21wb25lbnRcIiwgXCJkaXNwbGF5XCIsIFwiZ3V0dGVyQm90dG9tXCIsIFwibm9XcmFwXCIsIFwicGFyYWdyYXBoXCIsIFwidmFyaWFudFwiLCBcInZhcmlhbnRNYXBwaW5nXCJdKTtcblxuICB2YXIgQ29tcG9uZW50ID0gY29tcG9uZW50IHx8IChwYXJhZ3JhcGggPyAncCcgOiB2YXJpYW50TWFwcGluZ1t2YXJpYW50XSB8fCBkZWZhdWx0VmFyaWFudE1hcHBpbmdbdmFyaWFudF0pIHx8ICdzcGFuJztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSwgdmFyaWFudCAhPT0gJ2luaGVyaXQnICYmIGNsYXNzZXNbdmFyaWFudF0sIGNvbG9yICE9PSAnaW5pdGlhbCcgJiYgY2xhc3Nlc1tcImNvbG9yXCIuY29uY2F0KGNhcGl0YWxpemUoY29sb3IpKV0sIG5vV3JhcCAmJiBjbGFzc2VzLm5vV3JhcCwgZ3V0dGVyQm90dG9tICYmIGNsYXNzZXMuZ3V0dGVyQm90dG9tLCBwYXJhZ3JhcGggJiYgY2xhc3Nlcy5wYXJhZ3JhcGgsIGFsaWduICE9PSAnaW5oZXJpdCcgJiYgY2xhc3Nlc1tcImFsaWduXCIuY29uY2F0KGNhcGl0YWxpemUoYWxpZ24pKV0sIGRpc3BsYXkgIT09ICdpbml0aWFsJyAmJiBjbGFzc2VzW1wiZGlzcGxheVwiLmNvbmNhdChjYXBpdGFsaXplKGRpc3BsYXkpKV0pLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFR5cG9ncmFwaHkucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogU2V0IHRoZSB0ZXh0LWFsaWduIG9uIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBhbGlnbjogUHJvcFR5cGVzLm9uZU9mKFsnaW5oZXJpdCcsICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcsICdqdXN0aWZ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC4gSXQgc3VwcG9ydHMgdGhvc2UgdGhlbWUgY29sb3JzIHRoYXQgbWFrZSBzZW5zZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnaW5pdGlhbCcsICdpbmhlcml0JywgJ3ByaW1hcnknLCAnc2Vjb25kYXJ5JywgJ3RleHRQcmltYXJ5JywgJ3RleHRTZWNvbmRhcnknLCAnZXJyb3InXSksXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICogT3ZlcnJpZGVzIHRoZSBiZWhhdmlvciBvZiB0aGUgYHZhcmlhbnRNYXBwaW5nYCBwcm9wLlxuICAgKi9cbiAgY29tcG9uZW50OiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAuZWxlbWVudFR5cGUsXG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHRoZSBkaXNwbGF5IHR5cGVcbiAgICovXG4gIGRpc3BsYXk6IFByb3BUeXBlcy5vbmVPZihbJ2luaXRpYWwnLCAnYmxvY2snLCAnaW5saW5lJ10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB0ZXh0IHdpbGwgaGF2ZSBhIGJvdHRvbSBtYXJnaW4uXG4gICAqL1xuICBndXR0ZXJCb3R0b206IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB0ZXh0IHdpbGwgbm90IHdyYXAsIGJ1dCBpbnN0ZWFkIHdpbGwgdHJ1bmNhdGUgd2l0aCBhIHRleHQgb3ZlcmZsb3cgZWxsaXBzaXMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0ZXh0IG92ZXJmbG93IGNhbiBvbmx5IGhhcHBlbiB3aXRoIGJsb2NrIG9yIGlubGluZS1ibG9jayBsZXZlbCBlbGVtZW50c1xuICAgKiAodGhlIGVsZW1lbnQgbmVlZHMgdG8gaGF2ZSBhIHdpZHRoIGluIG9yZGVyIHRvIG92ZXJmbG93KS5cbiAgICovXG4gIG5vV3JhcDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHRleHQgd2lsbCBoYXZlIGEgYm90dG9tIG1hcmdpbi5cbiAgICovXG4gIHBhcmFncmFwaDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIHRoZW1lIHR5cG9ncmFwaHkgc3R5bGVzLlxuICAgKi9cbiAgdmFyaWFudDogUHJvcFR5cGVzLm9uZU9mKFsnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnc3VidGl0bGUxJywgJ3N1YnRpdGxlMicsICdib2R5MScsICdib2R5MicsICdjYXB0aW9uJywgJ2J1dHRvbicsICdvdmVybGluZScsICdzck9ubHknLCAnaW5oZXJpdCddKSxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCBtYXBzIHRoZSB2YXJpYW50IHByb3AgdG8gYSByYW5nZSBvZiBkaWZmZXJlbnQgSFRNTCBlbGVtZW50IHR5cGVzLlxuICAgKiBGb3IgaW5zdGFuY2UsIHN1YnRpdGxlMSB0byBgPGg2PmAuXG4gICAqIElmIHlvdSB3aXNoIHRvIGNoYW5nZSB0aGF0IG1hcHBpbmcsIHlvdSBjYW4gcHJvdmlkZSB5b3VyIG93bi5cbiAgICogQWx0ZXJuYXRpdmVseSwgeW91IGNhbiB1c2UgdGhlIGBjb21wb25lbnRgIHByb3AuXG4gICAqL1xuICB2YXJpYW50TWFwcGluZzogUHJvcFR5cGVzLm9iamVjdFxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlUeXBvZ3JhcGh5J1xufSkoVHlwb2dyYXBoeSk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IFR5cG9ncmFwaHkgZnJvbSAnLi4vVHlwb2dyYXBoeSc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgcm9vdDoge1xuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBwYWRkaW5nOiAxNlxuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBhdmF0YXIgZWxlbWVudC4gKi9cbiAgYXZhdGFyOiB7XG4gICAgZmxleDogJzAgMCBhdXRvJyxcbiAgICBtYXJnaW5SaWdodDogMTZcbiAgfSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYWN0aW9uIGVsZW1lbnQuICovXG4gIGFjdGlvbjoge1xuICAgIGZsZXg6ICcwIDAgYXV0bycsXG4gICAgYWxpZ25TZWxmOiAnZmxleC1zdGFydCcsXG4gICAgbWFyZ2luVG9wOiAtOCxcbiAgICBtYXJnaW5SaWdodDogLThcbiAgfSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgY29udGVudCB3cmFwcGVyIGVsZW1lbnQuICovXG4gIGNvbnRlbnQ6IHtcbiAgICBmbGV4OiAnMSAxIGF1dG8nXG4gIH0sXG5cbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHRpdGxlIFR5cG9ncmFwaHkgZWxlbWVudC4gKi9cbiAgdGl0bGU6IHt9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBzdWJoZWFkZXIgVHlwb2dyYXBoeSBlbGVtZW50LiAqL1xuICBzdWJoZWFkZXI6IHt9XG59O1xudmFyIENhcmRIZWFkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDYXJkSGVhZGVyKHByb3BzLCByZWYpIHtcbiAgdmFyIGFjdGlvbiA9IHByb3BzLmFjdGlvbixcbiAgICAgIGF2YXRhciA9IHByb3BzLmF2YXRhcixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJGNvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgIENvbXBvbmVudCA9IF9wcm9wcyRjb21wb25lbnQgPT09IHZvaWQgMCA/ICdkaXYnIDogX3Byb3BzJGNvbXBvbmVudCxcbiAgICAgIF9wcm9wcyRkaXNhYmxlVHlwb2dyYSA9IHByb3BzLmRpc2FibGVUeXBvZ3JhcGh5LFxuICAgICAgZGlzYWJsZVR5cG9ncmFwaHkgPSBfcHJvcHMkZGlzYWJsZVR5cG9ncmEgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVUeXBvZ3JhLFxuICAgICAgc3ViaGVhZGVyUHJvcCA9IHByb3BzLnN1YmhlYWRlcixcbiAgICAgIHN1YmhlYWRlclR5cG9ncmFwaHlQcm9wcyA9IHByb3BzLnN1YmhlYWRlclR5cG9ncmFwaHlQcm9wcyxcbiAgICAgIHRpdGxlUHJvcCA9IHByb3BzLnRpdGxlLFxuICAgICAgdGl0bGVUeXBvZ3JhcGh5UHJvcHMgPSBwcm9wcy50aXRsZVR5cG9ncmFwaHlQcm9wcyxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhY3Rpb25cIiwgXCJhdmF0YXJcIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29tcG9uZW50XCIsIFwiZGlzYWJsZVR5cG9ncmFwaHlcIiwgXCJzdWJoZWFkZXJcIiwgXCJzdWJoZWFkZXJUeXBvZ3JhcGh5UHJvcHNcIiwgXCJ0aXRsZVwiLCBcInRpdGxlVHlwb2dyYXBoeVByb3BzXCJdKTtcblxuICB2YXIgdGl0bGUgPSB0aXRsZVByb3A7XG5cbiAgaWYgKHRpdGxlICE9IG51bGwgJiYgdGl0bGUudHlwZSAhPT0gVHlwb2dyYXBoeSAmJiAhZGlzYWJsZVR5cG9ncmFwaHkpIHtcbiAgICB0aXRsZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFR5cG9ncmFwaHksIF9leHRlbmRzKHtcbiAgICAgIHZhcmlhbnQ6IGF2YXRhciA/ICdib2R5MicgOiAnaDUnLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzLnRpdGxlLFxuICAgICAgY29tcG9uZW50OiBcInNwYW5cIixcbiAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgIH0sIHRpdGxlVHlwb2dyYXBoeVByb3BzKSwgdGl0bGUpO1xuICB9XG5cbiAgdmFyIHN1YmhlYWRlciA9IHN1YmhlYWRlclByb3A7XG5cbiAgaWYgKHN1YmhlYWRlciAhPSBudWxsICYmIHN1YmhlYWRlci50eXBlICE9PSBUeXBvZ3JhcGh5ICYmICFkaXNhYmxlVHlwb2dyYXBoeSkge1xuICAgIHN1YmhlYWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFR5cG9ncmFwaHksIF9leHRlbmRzKHtcbiAgICAgIHZhcmlhbnQ6IGF2YXRhciA/ICdib2R5MicgOiAnYm9keTEnLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzLnN1YmhlYWRlcixcbiAgICAgIGNvbG9yOiBcInRleHRTZWNvbmRhcnlcIixcbiAgICAgIGNvbXBvbmVudDogXCJzcGFuXCIsXG4gICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICB9LCBzdWJoZWFkZXJUeXBvZ3JhcGh5UHJvcHMpLCBzdWJoZWFkZXIpO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSksXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpLCBhdmF0YXIgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5hdmF0YXJcbiAgfSwgYXZhdGFyKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5jb250ZW50XG4gIH0sIHRpdGxlLCBzdWJoZWFkZXIpLCBhY3Rpb24gJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5hY3Rpb25cbiAgfSwgYWN0aW9uKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IENhcmRIZWFkZXIucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhlIGFjdGlvbiB0byBkaXNwbGF5IGluIHRoZSBjYXJkIGhlYWRlci5cbiAgICovXG4gIGFjdGlvbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIFRoZSBBdmF0YXIgZm9yIHRoZSBDYXJkIEhlYWRlci5cbiAgICovXG4gIGF2YXRhcjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGBzdWJoZWFkZXJgIGFuZCBgdGl0bGVgIHdvbid0IGJlIHdyYXBwZWQgYnkgYSBUeXBvZ3JhcGh5IGNvbXBvbmVudC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZnVsIHRvIHJlbmRlciBhbiBhbHRlcm5hdGl2ZSBUeXBvZ3JhcGh5IHZhcmlhbnQgYnkgd3JhcHBpbmdcbiAgICogdGhlIGB0aXRsZWAgdGV4dCwgYW5kIG9wdGlvbmFsIGBzdWJoZWFkZXJgIHRleHRcbiAgICogd2l0aCB0aGUgVHlwb2dyYXBoeSBjb21wb25lbnQuXG4gICAqL1xuICBkaXNhYmxlVHlwb2dyYXBoeTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBzdWJoZWFkZXI6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBUaGVzZSBwcm9wcyB3aWxsIGJlIGZvcndhcmRlZCB0byB0aGUgc3ViaGVhZGVyXG4gICAqIChhcyBsb25nIGFzIGRpc2FibGVUeXBvZ3JhcGh5IGlzIG5vdCBgdHJ1ZWApLlxuICAgKi9cbiAgc3ViaGVhZGVyVHlwb2dyYXBoeVByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgQ2FyZCBUaXRsZS5cbiAgICovXG4gIHRpdGxlOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogVGhlc2UgcHJvcHMgd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGhlIHRpdGxlXG4gICAqIChhcyBsb25nIGFzIGRpc2FibGVUeXBvZ3JhcGh5IGlzIG5vdCBgdHJ1ZWApLlxuICAgKi9cbiAgdGl0bGVUeXBvZ3JhcGh5UHJvcHM6IFByb3BUeXBlcy5vYmplY3Rcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpQ2FyZEhlYWRlcidcbn0pKENhcmRIZWFkZXIpOyIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0Jztcbi8qKlxuICogQGlnbm9yZSAtIGludGVybmFsIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgTGlzdENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgTGlzdENvbnRleHQuZGlzcGxheU5hbWUgPSAnTGlzdENvbnRleHQnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBMaXN0Q29udGV4dDsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgTGlzdENvbnRleHQgZnJvbSAnLi9MaXN0Q29udGV4dCc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgcm9vdDoge1xuICAgIGxpc3RTdHlsZTogJ25vbmUnLFxuICAgIG1hcmdpbjogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gIH0sXG5cbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZVBhZGRpbmc9e2ZhbHNlfWAuICovXG4gIHBhZGRpbmc6IHtcbiAgICBwYWRkaW5nVG9wOiA4LFxuICAgIHBhZGRpbmdCb3R0b206IDhcbiAgfSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGRlbnNlLiAqL1xuICBkZW5zZToge30sXG5cbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBhIGBzdWJoZWFkZXJgIGlzIHByb3ZpZGVkLiAqL1xuICBzdWJoZWFkZXI6IHtcbiAgICBwYWRkaW5nVG9wOiAwXG4gIH1cbn07XG52YXIgTGlzdCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIExpc3QocHJvcHMsIHJlZikge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJGNvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgIENvbXBvbmVudCA9IF9wcm9wcyRjb21wb25lbnQgPT09IHZvaWQgMCA/ICd1bCcgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgX3Byb3BzJGRlbnNlID0gcHJvcHMuZGVuc2UsXG4gICAgICBkZW5zZSA9IF9wcm9wcyRkZW5zZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGVuc2UsXG4gICAgICBfcHJvcHMkZGlzYWJsZVBhZGRpbmcgPSBwcm9wcy5kaXNhYmxlUGFkZGluZyxcbiAgICAgIGRpc2FibGVQYWRkaW5nID0gX3Byb3BzJGRpc2FibGVQYWRkaW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlUGFkZGluZyxcbiAgICAgIHN1YmhlYWRlciA9IHByb3BzLnN1YmhlYWRlcixcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb21wb25lbnRcIiwgXCJkZW5zZVwiLCBcImRpc2FibGVQYWRkaW5nXCIsIFwic3ViaGVhZGVyXCJdKTtcblxuICB2YXIgY29udGV4dCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZW5zZTogZGVuc2VcbiAgICB9O1xuICB9LCBbZGVuc2VdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpc3RDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCBkZW5zZSAmJiBjbGFzc2VzLmRlbnNlLCAhZGlzYWJsZVBhZGRpbmcgJiYgY2xhc3Nlcy5wYWRkaW5nLCBzdWJoZWFkZXIgJiYgY2xhc3Nlcy5zdWJoZWFkZXIpLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSwgc3ViaGVhZGVyLCBjaGlsZHJlbikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBMaXN0LnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGNvbXBhY3QgdmVydGljYWwgcGFkZGluZyBkZXNpZ25lZCBmb3Iga2V5Ym9hcmQgYW5kIG1vdXNlIGlucHV0IHdpbGwgYmUgdXNlZCBmb3JcbiAgICogdGhlIGxpc3QgYW5kIGxpc3QgaXRlbXMuXG4gICAqIFRoZSBwcm9wIGlzIGF2YWlsYWJsZSB0byBkZXNjZW5kYW50IGNvbXBvbmVudHMgYXMgdGhlIGBkZW5zZWAgY29udGV4dC5cbiAgICovXG4gIGRlbnNlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB2ZXJ0aWNhbCBwYWRkaW5nIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBsaXN0LlxuICAgKi9cbiAgZGlzYWJsZVBhZGRpbmc6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgc3ViaGVhZGVyLCBub3JtYWxseSBgTGlzdFN1YmhlYWRlcmAuXG4gICAqL1xuICBzdWJoZWFkZXI6IFByb3BUeXBlcy5ub2RlXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUxpc3QnXG59KShMaXN0KTsiLCIvLyBUT0RPIHY1OiBjb25zaWRlciB0byBtYWtlIGl0IHByaXZhdGVcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldFJlZihyZWYsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChyZWYpIHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9XG59IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHNldFJlZiBmcm9tICcuL3NldFJlZic7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VGb3JrUmVmKHJlZkEsIHJlZkIpIHtcbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gaWYgdGhlIHJlZiBwcm9wcyBjaGFuZ2UgYW5kIGFyZSBkZWZpbmVkLlxuICAgKiBUaGlzIG1lYW5zIHJlYWN0IHdpbGwgY2FsbCB0aGUgb2xkIGZvcmtSZWYgd2l0aCBgbnVsbGAgYW5kIHRoZSBuZXcgZm9ya1JlZlxuICAgKiB3aXRoIHRoZSByZWYuIENsZWFudXAgbmF0dXJhbGx5IGVtZXJnZXMgZnJvbSB0aGlzIGJlaGF2aW9yXG4gICAqL1xuICByZXR1cm4gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlZkEgPT0gbnVsbCAmJiByZWZCID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAocmVmVmFsdWUpIHtcbiAgICAgIHNldFJlZihyZWZBLCByZWZWYWx1ZSk7XG4gICAgICBzZXRSZWYocmVmQiwgcmVmVmFsdWUpO1xuICAgIH07XG4gIH0sIFtyZWZBLCByZWZCXSk7XG59IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xudmFyIHVzZUVuaGFuY2VkRWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQwOTkjaXNzdWVjb21tZW50LTQ0MDAxMzg5MlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlRXZlbnRDYWxsYmFjayhmbikge1xuICB2YXIgcmVmID0gUmVhY3QudXNlUmVmKGZuKTtcbiAgdXNlRW5oYW5jZWRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZi5jdXJyZW50ID0gZm47XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoMCwgcmVmLmN1cnJlbnQpLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSwgW10pO1xufSIsIi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2ZvY3VzLXZpc2libGUvYmxvYi92NC4xLjUvc3JjL2ZvY3VzLXZpc2libGUuanNcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG52YXIgaGFkS2V5Ym9hcmRFdmVudCA9IHRydWU7XG52YXIgaGFkRm9jdXNWaXNpYmxlUmVjZW50bHkgPSBmYWxzZTtcbnZhciBoYWRGb2N1c1Zpc2libGVSZWNlbnRseVRpbWVvdXQgPSBudWxsO1xudmFyIGlucHV0VHlwZXNXaGl0ZWxpc3QgPSB7XG4gIHRleHQ6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB0ZWw6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBkYXRlOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgd2VlazogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWVcbn07XG4vKipcbiAqIENvbXB1dGVzIHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgdHJpZ2dlciB0aGVcbiAqIGBmb2N1cy12aXNpYmxlYCBjbGFzcyBiZWluZyBhZGRlZCwgaS5lLiB3aGV0aGVyIGl0IHNob3VsZCBhbHdheXMgbWF0Y2hcbiAqIGA6Zm9jdXMtdmlzaWJsZWAgd2hlbiBmb2N1c2VkLlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGZvY3VzVHJpZ2dlcnNLZXlib2FyZE1vZGFsaXR5KG5vZGUpIHtcbiAgdmFyIHR5cGUgPSBub2RlLnR5cGUsXG4gICAgICB0YWdOYW1lID0gbm9kZS50YWdOYW1lO1xuXG4gIGlmICh0YWdOYW1lID09PSAnSU5QVVQnICYmIGlucHV0VHlwZXNXaGl0ZWxpc3RbdHlwZV0gJiYgIW5vZGUucmVhZE9ubHkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0YWdOYW1lID09PSAnVEVYVEFSRUEnICYmICFub2RlLnJlYWRPbmx5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBLZWVwIHRyYWNrIG9mIG91ciBrZXlib2FyZCBtb2RhbGl0eSBzdGF0ZSB3aXRoIGBoYWRLZXlib2FyZEV2ZW50YC5cbiAqIElmIHRoZSBtb3N0IHJlY2VudCB1c2VyIGludGVyYWN0aW9uIHdhcyB2aWEgdGhlIGtleWJvYXJkO1xuICogYW5kIHRoZSBrZXkgcHJlc3MgZGlkIG5vdCBpbmNsdWRlIGEgbWV0YSwgYWx0L29wdGlvbiwgb3IgY29udHJvbCBrZXk7XG4gKiB0aGVuIHRoZSBtb2RhbGl0eSBpcyBrZXlib2FyZC4gT3RoZXJ3aXNlLCB0aGUgbW9kYWxpdHkgaXMgbm90IGtleWJvYXJkLlxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICBpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGhhZEtleWJvYXJkRXZlbnQgPSB0cnVlO1xufVxuLyoqXG4gKiBJZiBhdCBhbnkgcG9pbnQgYSB1c2VyIGNsaWNrcyB3aXRoIGEgcG9pbnRpbmcgZGV2aWNlLCBlbnN1cmUgdGhhdCB3ZSBjaGFuZ2VcbiAqIHRoZSBtb2RhbGl0eSBhd2F5IGZyb20ga2V5Ym9hcmQuXG4gKiBUaGlzIGF2b2lkcyB0aGUgc2l0dWF0aW9uIHdoZXJlIGEgdXNlciBwcmVzc2VzIGEga2V5IG9uIGFuIGFscmVhZHkgZm9jdXNlZFxuICogZWxlbWVudCwgYW5kIHRoZW4gY2xpY2tzIG9uIGEgZGlmZmVyZW50IGVsZW1lbnQsIGZvY3VzaW5nIGl0IHdpdGggYVxuICogcG9pbnRpbmcgZGV2aWNlLCB3aGlsZSB3ZSBzdGlsbCB0aGluayB3ZSdyZSBpbiBrZXlib2FyZCBtb2RhbGl0eS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duKCkge1xuICBoYWRLZXlib2FyZEV2ZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gIGlmICh0aGlzLnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAvLyBJZiB0aGUgdGFiIGJlY29tZXMgYWN0aXZlIGFnYWluLCB0aGUgYnJvd3NlciB3aWxsIGhhbmRsZSBjYWxsaW5nIGZvY3VzXG4gICAgLy8gb24gdGhlIGVsZW1lbnQgKFNhZmFyaSBhY3R1YWxseSBjYWxscyBpdCB0d2ljZSkuXG4gICAgLy8gSWYgdGhpcyB0YWIgY2hhbmdlIGNhdXNlZCBhIGJsdXIgb24gYW4gZWxlbWVudCB3aXRoIGZvY3VzLXZpc2libGUsXG4gICAgLy8gcmUtYXBwbHkgdGhlIGNsYXNzIHdoZW4gdGhlIHVzZXIgc3dpdGNoZXMgYmFjayB0byB0aGUgdGFiLlxuICAgIGlmIChoYWRGb2N1c1Zpc2libGVSZWNlbnRseSkge1xuICAgICAgaGFkS2V5Ym9hcmRFdmVudCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmUoZG9jKSB7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93biwgdHJ1ZSk7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVQb2ludGVyRG93biwgdHJ1ZSk7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duLCB0cnVlKTtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVQb2ludGVyRG93biwgdHJ1ZSk7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZWFyZG93bihkb2MpIHtcbiAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCB0cnVlKTtcbiAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZVBvaW50ZXJEb3duLCB0cnVlKTtcbiAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24sIHRydWUpO1xuICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVBvaW50ZXJEb3duLCB0cnVlKTtcbiAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gaXNGb2N1c1Zpc2libGUoZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICB0cnkge1xuICAgIHJldHVybiB0YXJnZXQubWF0Y2hlcygnOmZvY3VzLXZpc2libGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9IC8vIGJyb3dzZXJzIG5vdCBpbXBsZW1lbnRpbmcgOmZvY3VzLXZpc2libGUgd2lsbCB0aHJvdyBhIFN5bnRheEVycm9yXG4gIC8vIHdlIHVzZSBvdXIgb3duIGhldXJpc3RpYyBmb3IgdGhvc2UgYnJvd3NlcnNcbiAgLy8gcmV0aHJvdyBtaWdodCBiZSBiZXR0ZXIgaWYgaXQncyBub3QgdGhlIGV4cGVjdGVkIGVycm9yIGJ1dCBkbyB3ZSByZWFsbHlcbiAgLy8gd2FudCB0byBjcmFzaCBpZiBmb2N1cy12aXNpYmxlIG1hbGZ1bmN0aW9uZWQ/XG4gIC8vIG5vIG5lZWQgZm9yIHZhbGlkRm9jdXNUYXJnZXQgY2hlY2suIHRoZSB1c2VyIGRvZXMgdGhhdCBieSBhdHRhY2hpbmcgaXQgdG9cbiAgLy8gZm9jdXNhYmxlIGV2ZW50cyBvbmx5XG5cblxuICByZXR1cm4gaGFkS2V5Ym9hcmRFdmVudCB8fCBmb2N1c1RyaWdnZXJzS2V5Ym9hcmRNb2RhbGl0eSh0YXJnZXQpO1xufVxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIGlmIGEgYmx1ciBldmVudCBpcyBmaXJlZCBvbiBhIGZvY3VzLXZpc2libGUgZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlQmx1clZpc2libGUoKSB7XG4gIC8vIFRvIGRldGVjdCBhIHRhYi93aW5kb3cgc3dpdGNoLCB3ZSBsb29rIGZvciBhIGJsdXIgZXZlbnQgZm9sbG93ZWRcbiAgLy8gcmFwaWRseSBieSBhIHZpc2liaWxpdHkgY2hhbmdlLlxuICAvLyBJZiB3ZSBkb24ndCBzZWUgYSB2aXNpYmlsaXR5IGNoYW5nZSB3aXRoaW4gMTAwbXMsIGl0J3MgcHJvYmFibHkgYVxuICAvLyByZWd1bGFyIGZvY3VzIGNoYW5nZS5cbiAgaGFkRm9jdXNWaXNpYmxlUmVjZW50bHkgPSB0cnVlO1xuICB3aW5kb3cuY2xlYXJUaW1lb3V0KGhhZEZvY3VzVmlzaWJsZVJlY2VudGx5VGltZW91dCk7XG4gIGhhZEZvY3VzVmlzaWJsZVJlY2VudGx5VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBoYWRGb2N1c1Zpc2libGVSZWNlbnRseSA9IGZhbHNlO1xuICB9LCAxMDApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VJc0ZvY3VzVmlzaWJsZSgpIHtcbiAgdmFyIHJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHZhciBub2RlID0gUmVhY3RET00uZmluZERPTU5vZGUoaW5zdGFuY2UpO1xuXG4gICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgcHJlcGFyZShub2RlLm93bmVyRG9jdW1lbnQpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZShpc0ZvY3VzVmlzaWJsZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzRm9jdXNWaXNpYmxlOiBpc0ZvY3VzVmlzaWJsZSxcbiAgICBvbkJsdXJWaXNpYmxlOiBoYW5kbGVCbHVyVmlzaWJsZSxcbiAgICByZWY6IHJlZlxuICB9O1xufSIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpOyIsImltcG9ydCB7IENoaWxkcmVuLCBjbG9uZUVsZW1lbnQsIGlzVmFsaWRFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBHaXZlbiBgdGhpcy5wcm9wcy5jaGlsZHJlbmAsIHJldHVybiBhbiBvYmplY3QgbWFwcGluZyBrZXkgdG8gY2hpbGQuXG4gKlxuICogQHBhcmFtIHsqfSBjaGlsZHJlbiBgdGhpcy5wcm9wcy5jaGlsZHJlbmBcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwcGluZyBvZiBrZXkgdG8gY2hpbGRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hpbGRNYXBwaW5nKGNoaWxkcmVuLCBtYXBGbikge1xuICB2YXIgbWFwcGVyID0gZnVuY3Rpb24gbWFwcGVyKGNoaWxkKSB7XG4gICAgcmV0dXJuIG1hcEZuICYmIGlzVmFsaWRFbGVtZW50KGNoaWxkKSA/IG1hcEZuKGNoaWxkKSA6IGNoaWxkO1xuICB9O1xuXG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoY2hpbGRyZW4pIENoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYztcbiAgfSkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAvLyBydW4gdGhlIG1hcCBmdW5jdGlvbiBoZXJlIGluc3RlYWQgc28gdGhhdCB0aGUga2V5IGlzIHRoZSBjb21wdXRlZCBvbmVcbiAgICByZXN1bHRbY2hpbGQua2V5XSA9IG1hcHBlcihjaGlsZCk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBXaGVuIHlvdSdyZSBhZGRpbmcgb3IgcmVtb3ZpbmcgY2hpbGRyZW4gc29tZSBtYXkgYmUgYWRkZWQgb3IgcmVtb3ZlZCBpbiB0aGVcbiAqIHNhbWUgcmVuZGVyIHBhc3MuIFdlIHdhbnQgdG8gc2hvdyAqYm90aCogc2luY2Ugd2Ugd2FudCB0byBzaW11bHRhbmVvdXNseVxuICogYW5pbWF0ZSBlbGVtZW50cyBpbiBhbmQgb3V0LiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgcHJldmlvdXMgc2V0IG9mIGtleXNcbiAqIGFuZCBhIG5ldyBzZXQgb2Yga2V5cyBhbmQgbWVyZ2VzIHRoZW0gd2l0aCBpdHMgYmVzdCBndWVzcyBvZiB0aGUgY29ycmVjdFxuICogb3JkZXJpbmcuIEluIHRoZSBmdXR1cmUgd2UgbWF5IGV4cG9zZSBzb21lIG9mIHRoZSB1dGlsaXRpZXMgaW5cbiAqIFJlYWN0TXVsdGlDaGlsZCB0byBtYWtlIHRoaXMgZWFzeSwgYnV0IGZvciBub3cgUmVhY3QgaXRzZWxmIGRvZXMgbm90XG4gKiBkaXJlY3RseSBoYXZlIHRoaXMgY29uY2VwdCBvZiB0aGUgdW5pb24gb2YgcHJldkNoaWxkcmVuIGFuZCBuZXh0Q2hpbGRyZW5cbiAqIHNvIHdlIGltcGxlbWVudCBpdCBoZXJlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2IHByZXYgY2hpbGRyZW4gYXMgcmV0dXJuZWQgZnJvbVxuICogYFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoKWAuXG4gKiBAcGFyYW0ge29iamVjdH0gbmV4dCBuZXh0IGNoaWxkcmVuIGFzIHJldHVybmVkIGZyb21cbiAqIGBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKClgLlxuICogQHJldHVybiB7b2JqZWN0fSBhIGtleSBzZXQgdGhhdCBjb250YWlucyBhbGwga2V5cyBpbiBgcHJldmAgYW5kIGFsbCBrZXlzXG4gKiBpbiBgbmV4dGAgaW4gYSByZWFzb25hYmxlIG9yZGVyLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNoaWxkTWFwcGluZ3MocHJldiwgbmV4dCkge1xuICBwcmV2ID0gcHJldiB8fCB7fTtcbiAgbmV4dCA9IG5leHQgfHwge307XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWVGb3JLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiBuZXh0ID8gbmV4dFtrZXldIDogcHJldltrZXldO1xuICB9IC8vIEZvciBlYWNoIGtleSBvZiBgbmV4dGAsIHRoZSBsaXN0IG9mIGtleXMgdG8gaW5zZXJ0IGJlZm9yZSB0aGF0IGtleSBpblxuICAvLyB0aGUgY29tYmluZWQgbGlzdFxuXG5cbiAgdmFyIG5leHRLZXlzUGVuZGluZyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBwZW5kaW5nS2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIHByZXZLZXkgaW4gcHJldikge1xuICAgIGlmIChwcmV2S2V5IGluIG5leHQpIHtcbiAgICAgIGlmIChwZW5kaW5nS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgbmV4dEtleXNQZW5kaW5nW3ByZXZLZXldID0gcGVuZGluZ0tleXM7XG4gICAgICAgIHBlbmRpbmdLZXlzID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdLZXlzLnB1c2gocHJldktleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGk7XG4gIHZhciBjaGlsZE1hcHBpbmcgPSB7fTtcblxuICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHQpIHtcbiAgICBpZiAobmV4dEtleXNQZW5kaW5nW25leHRLZXldKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbmV4dEtleXNQZW5kaW5nW25leHRLZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwZW5kaW5nTmV4dEtleSA9IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXTtcbiAgICAgICAgY2hpbGRNYXBwaW5nW25leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXV0gPSBnZXRWYWx1ZUZvcktleShwZW5kaW5nTmV4dEtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGRNYXBwaW5nW25leHRLZXldID0gZ2V0VmFsdWVGb3JLZXkobmV4dEtleSk7XG4gIH0gLy8gRmluYWxseSwgYWRkIHRoZSBrZXlzIHdoaWNoIGRpZG4ndCBhcHBlYXIgYmVmb3JlIGFueSBrZXkgaW4gYG5leHRgXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgcGVuZGluZ0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGlsZE1hcHBpbmdbcGVuZGluZ0tleXNbaV1dID0gZ2V0VmFsdWVGb3JLZXkocGVuZGluZ0tleXNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkTWFwcGluZztcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcChjaGlsZCwgcHJvcCwgcHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzW3Byb3BdICE9IG51bGwgPyBwcm9wc1twcm9wXSA6IGNoaWxkLnByb3BzW3Byb3BdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5pdGlhbENoaWxkTWFwcGluZyhwcm9wcywgb25FeGl0ZWQpIHtcbiAgcmV0dXJuIGdldENoaWxkTWFwcGluZyhwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgb25FeGl0ZWQ6IG9uRXhpdGVkLmJpbmQobnVsbCwgY2hpbGQpLFxuICAgICAgaW46IHRydWUsXG4gICAgICBhcHBlYXI6IGdldFByb3AoY2hpbGQsICdhcHBlYXInLCBwcm9wcyksXG4gICAgICBlbnRlcjogZ2V0UHJvcChjaGlsZCwgJ2VudGVyJywgcHJvcHMpLFxuICAgICAgZXhpdDogZ2V0UHJvcChjaGlsZCwgJ2V4aXQnLCBwcm9wcylcbiAgICB9KTtcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dENoaWxkTWFwcGluZyhuZXh0UHJvcHMsIHByZXZDaGlsZE1hcHBpbmcsIG9uRXhpdGVkKSB7XG4gIHZhciBuZXh0Q2hpbGRNYXBwaW5nID0gZ2V0Q2hpbGRNYXBwaW5nKG5leHRQcm9wcy5jaGlsZHJlbik7XG4gIHZhciBjaGlsZHJlbiA9IG1lcmdlQ2hpbGRNYXBwaW5ncyhwcmV2Q2hpbGRNYXBwaW5nLCBuZXh0Q2hpbGRNYXBwaW5nKTtcbiAgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2tleV07XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHJldHVybjtcbiAgICB2YXIgaGFzUHJldiA9IChrZXkgaW4gcHJldkNoaWxkTWFwcGluZyk7XG4gICAgdmFyIGhhc05leHQgPSAoa2V5IGluIG5leHRDaGlsZE1hcHBpbmcpO1xuICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRNYXBwaW5nW2tleV07XG4gICAgdmFyIGlzTGVhdmluZyA9IGlzVmFsaWRFbGVtZW50KHByZXZDaGlsZCkgJiYgIXByZXZDaGlsZC5wcm9wcy5pbjsgLy8gaXRlbSBpcyBuZXcgKGVudGVyaW5nKVxuXG4gICAgaWYgKGhhc05leHQgJiYgKCFoYXNQcmV2IHx8IGlzTGVhdmluZykpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdlbnRlcmluZycsIGtleSlcbiAgICAgIGNoaWxkcmVuW2tleV0gPSBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgb25FeGl0ZWQ6IG9uRXhpdGVkLmJpbmQobnVsbCwgY2hpbGQpLFxuICAgICAgICBpbjogdHJ1ZSxcbiAgICAgICAgZXhpdDogZ2V0UHJvcChjaGlsZCwgJ2V4aXQnLCBuZXh0UHJvcHMpLFxuICAgICAgICBlbnRlcjogZ2V0UHJvcChjaGlsZCwgJ2VudGVyJywgbmV4dFByb3BzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghaGFzTmV4dCAmJiBoYXNQcmV2ICYmICFpc0xlYXZpbmcpIHtcbiAgICAgIC8vIGl0ZW0gaXMgb2xkIChleGl0aW5nKVxuICAgICAgLy8gY29uc29sZS5sb2coJ2xlYXZpbmcnLCBrZXkpXG4gICAgICBjaGlsZHJlbltrZXldID0gY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgIGluOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChoYXNOZXh0ICYmIGhhc1ByZXYgJiYgaXNWYWxpZEVsZW1lbnQocHJldkNoaWxkKSkge1xuICAgICAgLy8gaXRlbSBoYXNuJ3QgY2hhbmdlZCB0cmFuc2l0aW9uIHN0YXRlc1xuICAgICAgLy8gY29weSBvdmVyIHRoZSBsYXN0IHRyYW5zaXRpb24gcHJvcHM7XG4gICAgICAvLyBjb25zb2xlLmxvZygndW5jaGFuZ2VkJywga2V5KVxuICAgICAgY2hpbGRyZW5ba2V5XSA9IGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICBvbkV4aXRlZDogb25FeGl0ZWQuYmluZChudWxsLCBjaGlsZCksXG4gICAgICAgIGluOiBwcmV2Q2hpbGQucHJvcHMuaW4sXG4gICAgICAgIGV4aXQ6IGdldFByb3AoY2hpbGQsICdleGl0JywgbmV4dFByb3BzKSxcbiAgICAgICAgZW50ZXI6IGdldFByb3AoY2hpbGQsICdlbnRlcicsIG5leHRQcm9wcylcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn0iLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlXCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBUcmFuc2l0aW9uR3JvdXBDb250ZXh0IGZyb20gJy4vVHJhbnNpdGlvbkdyb3VwQ29udGV4dCc7XG5pbXBvcnQgeyBnZXRDaGlsZE1hcHBpbmcsIGdldEluaXRpYWxDaGlsZE1hcHBpbmcsIGdldE5leHRDaGlsZE1hcHBpbmcgfSBmcm9tICcuL3V0aWxzL0NoaWxkTWFwcGluZyc7XG5cbnZhciB2YWx1ZXMgPSBPYmplY3QudmFsdWVzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIG9ialtrXTtcbiAgfSk7XG59O1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBjb21wb25lbnQ6ICdkaXYnLFxuICBjaGlsZEZhY3Rvcnk6IGZ1bmN0aW9uIGNoaWxkRmFjdG9yeShjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxufTtcbi8qKlxuICogVGhlIGA8VHJhbnNpdGlvbkdyb3VwPmAgY29tcG9uZW50IG1hbmFnZXMgYSBzZXQgb2YgdHJhbnNpdGlvbiBjb21wb25lbnRzXG4gKiAoYDxUcmFuc2l0aW9uPmAgYW5kIGA8Q1NTVHJhbnNpdGlvbj5gKSBpbiBhIGxpc3QuIExpa2Ugd2l0aCB0aGUgdHJhbnNpdGlvblxuICogY29tcG9uZW50cywgYDxUcmFuc2l0aW9uR3JvdXA+YCBpcyBhIHN0YXRlIG1hY2hpbmUgZm9yIG1hbmFnaW5nIHRoZSBtb3VudGluZ1xuICogYW5kIHVubW91bnRpbmcgb2YgY29tcG9uZW50cyBvdmVyIHRpbWUuXG4gKlxuICogQ29uc2lkZXIgdGhlIGV4YW1wbGUgYmVsb3cuIEFzIGl0ZW1zIGFyZSByZW1vdmVkIG9yIGFkZGVkIHRvIHRoZSBUb2RvTGlzdCB0aGVcbiAqIGBpbmAgcHJvcCBpcyB0b2dnbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGA8VHJhbnNpdGlvbkdyb3VwPmAuXG4gKlxuICogTm90ZSB0aGF0IGA8VHJhbnNpdGlvbkdyb3VwPmAgIGRvZXMgbm90IGRlZmluZSBhbnkgYW5pbWF0aW9uIGJlaGF2aW9yIVxuICogRXhhY3RseSBfaG93XyBhIGxpc3QgaXRlbSBhbmltYXRlcyBpcyB1cCB0byB0aGUgaW5kaXZpZHVhbCB0cmFuc2l0aW9uXG4gKiBjb21wb25lbnQuIFRoaXMgbWVhbnMgeW91IGNhbiBtaXggYW5kIG1hdGNoIGFuaW1hdGlvbnMgYWNyb3NzIGRpZmZlcmVudCBsaXN0XG4gKiBpdGVtcy5cbiAqL1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRyYW5zaXRpb25Hcm91cCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbkdyb3VwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XG5cbiAgICB2YXIgaGFuZGxlRXhpdGVkID0gX3RoaXMuaGFuZGxlRXhpdGVkLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOyAvLyBJbml0aWFsIGNoaWxkcmVuIHNob3VsZCBhbGwgYmUgZW50ZXJpbmcsIGRlcGVuZGVudCBvbiBhcHBlYXJcblxuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBjb250ZXh0VmFsdWU6IHtcbiAgICAgICAgaXNNb3VudGluZzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGhhbmRsZUV4aXRlZDogaGFuZGxlRXhpdGVkLFxuICAgICAgZmlyc3RSZW5kZXI6IHRydWVcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2l0aW9uR3JvdXAucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjb250ZXh0VmFsdWU6IHtcbiAgICAgICAgaXNNb3VudGluZzogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBUcmFuc2l0aW9uR3JvdXAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgX3JlZikge1xuICAgIHZhciBwcmV2Q2hpbGRNYXBwaW5nID0gX3JlZi5jaGlsZHJlbixcbiAgICAgICAgaGFuZGxlRXhpdGVkID0gX3JlZi5oYW5kbGVFeGl0ZWQsXG4gICAgICAgIGZpcnN0UmVuZGVyID0gX3JlZi5maXJzdFJlbmRlcjtcbiAgICByZXR1cm4ge1xuICAgICAgY2hpbGRyZW46IGZpcnN0UmVuZGVyID8gZ2V0SW5pdGlhbENoaWxkTWFwcGluZyhuZXh0UHJvcHMsIGhhbmRsZUV4aXRlZCkgOiBnZXROZXh0Q2hpbGRNYXBwaW5nKG5leHRQcm9wcywgcHJldkNoaWxkTWFwcGluZywgaGFuZGxlRXhpdGVkKSxcbiAgICAgIGZpcnN0UmVuZGVyOiBmYWxzZVxuICAgIH07XG4gIH0gLy8gbm9kZSBpcyBgdW5kZWZpbmVkYCB3aGVuIHVzZXIgcHJvdmlkZWQgYG5vZGVSZWZgIHByb3BcbiAgO1xuXG4gIF9wcm90by5oYW5kbGVFeGl0ZWQgPSBmdW5jdGlvbiBoYW5kbGVFeGl0ZWQoY2hpbGQsIG5vZGUpIHtcbiAgICB2YXIgY3VycmVudENoaWxkTWFwcGluZyA9IGdldENoaWxkTWFwcGluZyh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICBpZiAoY2hpbGQua2V5IGluIGN1cnJlbnRDaGlsZE1hcHBpbmcpIHJldHVybjtcblxuICAgIGlmIChjaGlsZC5wcm9wcy5vbkV4aXRlZCkge1xuICAgICAgY2hpbGQucHJvcHMub25FeGl0ZWQobm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW91bnRlZCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gX2V4dGVuZHMoe30sIHN0YXRlLmNoaWxkcmVuKTtcblxuICAgICAgICBkZWxldGUgY2hpbGRyZW5bY2hpbGQua2V5XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIENvbXBvbmVudCA9IF90aGlzJHByb3BzLmNvbXBvbmVudCxcbiAgICAgICAgY2hpbGRGYWN0b3J5ID0gX3RoaXMkcHJvcHMuY2hpbGRGYWN0b3J5LFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjb21wb25lbnRcIiwgXCJjaGlsZEZhY3RvcnlcIl0pO1xuXG4gICAgdmFyIGNvbnRleHRWYWx1ZSA9IHRoaXMuc3RhdGUuY29udGV4dFZhbHVlO1xuICAgIHZhciBjaGlsZHJlbiA9IHZhbHVlcyh0aGlzLnN0YXRlLmNoaWxkcmVuKS5tYXAoY2hpbGRGYWN0b3J5KTtcbiAgICBkZWxldGUgcHJvcHMuYXBwZWFyO1xuICAgIGRlbGV0ZSBwcm9wcy5lbnRlcjtcbiAgICBkZWxldGUgcHJvcHMuZXhpdDtcblxuICAgIGlmIChDb21wb25lbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uR3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgcHJvcHMsIGNoaWxkcmVuKSk7XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zaXRpb25Hcm91cDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuVHJhbnNpdGlvbkdyb3VwLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgLyoqXG4gICAqIGA8VHJhbnNpdGlvbkdyb3VwPmAgcmVuZGVycyBhIGA8ZGl2PmAgYnkgZGVmYXVsdC4gWW91IGNhbiBjaGFuZ2UgdGhpc1xuICAgKiBiZWhhdmlvciBieSBwcm92aWRpbmcgYSBgY29tcG9uZW50YCBwcm9wLlxuICAgKiBJZiB5b3UgdXNlIFJlYWN0IHYxNisgYW5kIHdvdWxkIGxpa2UgdG8gYXZvaWQgYSB3cmFwcGluZyBgPGRpdj5gIGVsZW1lbnRcbiAgICogeW91IGNhbiBwYXNzIGluIGBjb21wb25lbnQ9e251bGx9YC4gVGhpcyBpcyB1c2VmdWwgaWYgdGhlIHdyYXBwaW5nIGRpdlxuICAgKiBib3JrcyB5b3VyIGNzcyBzdHlsZXMuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIGA8VHJhbnNpdGlvbj5gIGNvbXBvbmVudHMsIHRoYXQgYXJlIHRvZ2dsZWQgYGluYCBhbmQgb3V0IGFzIHRoZXlcbiAgICogbGVhdmUuIHRoZSBgPFRyYW5zaXRpb25Hcm91cD5gIHdpbGwgaW5qZWN0IHNwZWNpZmljIHRyYW5zaXRpb24gcHJvcHMsIHNvXG4gICAqIHJlbWVtYmVyIHRvIHNwcmVhZCB0aGVtIHRocm91Z2ggaWYgeW91IGFyZSB3cmFwcGluZyB0aGUgYDxUcmFuc2l0aW9uPmAgYXNcbiAgICogd2l0aCBvdXIgYDxGYWRlPmAgZXhhbXBsZS5cbiAgICpcbiAgICogV2hpbGUgdGhpcyBjb21wb25lbnQgaXMgbWVhbnQgZm9yIG11bHRpcGxlIGBUcmFuc2l0aW9uYCBvciBgQ1NTVHJhbnNpdGlvbmBcbiAgICogY2hpbGRyZW4sIHNvbWV0aW1lcyB5b3UgbWF5IHdhbnQgdG8gaGF2ZSBhIHNpbmdsZSB0cmFuc2l0aW9uIGNoaWxkIHdpdGhcbiAgICogY29udGVudCB0aGF0IHlvdSB3YW50IHRvIGJlIHRyYW5zaXRpb25lZCBvdXQgYW5kIGluIHdoZW4geW91IGNoYW5nZSBpdFxuICAgKiAoZS5nLiByb3V0ZXMsIGltYWdlcyBldGMuKSBJbiB0aGF0IGNhc2UgeW91IGNhbiBjaGFuZ2UgdGhlIGBrZXlgIHByb3Agb2ZcbiAgICogdGhlIHRyYW5zaXRpb24gY2hpbGQgYXMgeW91IGNoYW5nZSBpdHMgY29udGVudCwgdGhpcyB3aWxsIGNhdXNlXG4gICAqIGBUcmFuc2l0aW9uR3JvdXBgIHRvIHRyYW5zaXRpb24gdGhlIGNoaWxkIG91dCBhbmQgYmFjayBpbi5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBwcm9wIHRoYXQgZW5hYmxlcyBvciBkaXNhYmxlcyBhcHBlYXIgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgYXBwZWFyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBwcm9wIHRoYXQgZW5hYmxlcyBvciBkaXNhYmxlcyBlbnRlciBhbmltYXRpb25zXG4gICAqIGZvciBhbGwgY2hpbGRyZW4uIE5vdGUgdGhhdCBzcGVjaWZ5aW5nIHRoaXMgd2lsbCBvdmVycmlkZSBhbnkgZGVmYXVsdHMgc2V0XG4gICAqIG9uIGluZGl2aWR1YWwgY2hpbGRyZW4gVHJhbnNpdGlvbnMuXG4gICAqL1xuICBlbnRlcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgZXhpdCBhbmltYXRpb25zXG4gICAqIGZvciBhbGwgY2hpbGRyZW4uIE5vdGUgdGhhdCBzcGVjaWZ5aW5nIHRoaXMgd2lsbCBvdmVycmlkZSBhbnkgZGVmYXVsdHMgc2V0XG4gICAqIG9uIGluZGl2aWR1YWwgY2hpbGRyZW4gVHJhbnNpdGlvbnMuXG4gICAqL1xuICBleGl0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogWW91IG1heSBuZWVkIHRvIGFwcGx5IHJlYWN0aXZlIHVwZGF0ZXMgdG8gYSBjaGlsZCBhcyBpdCBpcyBleGl0aW5nLlxuICAgKiBUaGlzIGlzIGdlbmVyYWxseSBkb25lIGJ5IHVzaW5nIGBjbG9uZUVsZW1lbnRgIGhvd2V2ZXIgaW4gdGhlIGNhc2Ugb2YgYW4gZXhpdGluZ1xuICAgKiBjaGlsZCB0aGUgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYW5kIG5vdCBhY2Nlc3NpYmxlIHRvIHRoZSBjb25zdW1lci5cbiAgICpcbiAgICogSWYgeW91IGRvIG5lZWQgdG8gdXBkYXRlIGEgY2hpbGQgYXMgaXQgbGVhdmVzIHlvdSBjYW4gcHJvdmlkZSBhIGBjaGlsZEZhY3RvcnlgXG4gICAqIHRvIHdyYXAgZXZlcnkgY2hpbGQsIGV2ZW4gdGhlIG9uZXMgdGhhdCBhcmUgbGVhdmluZy5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24oY2hpbGQ6IFJlYWN0RWxlbWVudCkgLT4gUmVhY3RFbGVtZW50XG4gICAqL1xuICBjaGlsZEZhY3Rvcnk6IFByb3BUeXBlcy5mdW5jXG59IDoge307XG5UcmFuc2l0aW9uR3JvdXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgVHJhbnNpdGlvbkdyb3VwOyIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB1c2VFdmVudENhbGxiYWNrIGZyb20gJy4uL3V0aWxzL3VzZUV2ZW50Q2FsbGJhY2snO1xudmFyIHVzZUVuaGFuY2VkRWZmZWN0ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VFZmZlY3QgOiBSZWFjdC51c2VMYXlvdXRFZmZlY3Q7XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxuZnVuY3Rpb24gUmlwcGxlKHByb3BzKSB7XG4gIHZhciBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIF9wcm9wcyRwdWxzYXRlID0gcHJvcHMucHVsc2F0ZSxcbiAgICAgIHB1bHNhdGUgPSBfcHJvcHMkcHVsc2F0ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkcHVsc2F0ZSxcbiAgICAgIHJpcHBsZVggPSBwcm9wcy5yaXBwbGVYLFxuICAgICAgcmlwcGxlWSA9IHByb3BzLnJpcHBsZVksXG4gICAgICByaXBwbGVTaXplID0gcHJvcHMucmlwcGxlU2l6ZSxcbiAgICAgIGluUHJvcCA9IHByb3BzLmluLFxuICAgICAgX3Byb3BzJG9uRXhpdGVkID0gcHJvcHMub25FeGl0ZWQsXG4gICAgICBvbkV4aXRlZCA9IF9wcm9wcyRvbkV4aXRlZCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge30gOiBfcHJvcHMkb25FeGl0ZWQsXG4gICAgICB0aW1lb3V0ID0gcHJvcHMudGltZW91dDtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgbGVhdmluZyA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldExlYXZpbmcgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIHJpcHBsZUNsYXNzTmFtZSA9IGNsc3goY2xhc3Nlcy5yaXBwbGUsIGNsYXNzZXMucmlwcGxlVmlzaWJsZSwgcHVsc2F0ZSAmJiBjbGFzc2VzLnJpcHBsZVB1bHNhdGUpO1xuICB2YXIgcmlwcGxlU3R5bGVzID0ge1xuICAgIHdpZHRoOiByaXBwbGVTaXplLFxuICAgIGhlaWdodDogcmlwcGxlU2l6ZSxcbiAgICB0b3A6IC0ocmlwcGxlU2l6ZSAvIDIpICsgcmlwcGxlWSxcbiAgICBsZWZ0OiAtKHJpcHBsZVNpemUgLyAyKSArIHJpcHBsZVhcbiAgfTtcbiAgdmFyIGNoaWxkQ2xhc3NOYW1lID0gY2xzeChjbGFzc2VzLmNoaWxkLCBsZWF2aW5nICYmIGNsYXNzZXMuY2hpbGRMZWF2aW5nLCBwdWxzYXRlICYmIGNsYXNzZXMuY2hpbGRQdWxzYXRlKTtcbiAgdmFyIGhhbmRsZUV4aXRlZCA9IHVzZUV2ZW50Q2FsbGJhY2sob25FeGl0ZWQpOyAvLyBSaXBwbGUgaXMgdXNlZCBmb3IgdXNlciBmZWVkYmFjayAoZS5nLiBjbGljayBvciBwcmVzcykgc28gd2Ugd2FudCB0byBhcHBseSBzdHlsZXMgd2l0aCB0aGUgaGlnaGVzdCBwcmlvcml0eVxuXG4gIHVzZUVuaGFuY2VkRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWluUHJvcCkge1xuICAgICAgLy8gcmVhY3QtdHJhbnNpdGlvbi1ncm91cCNvbkV4aXRcbiAgICAgIHNldExlYXZpbmcodHJ1ZSk7IC8vIHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAjb25FeGl0ZWRcblxuICAgICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoaGFuZGxlRXhpdGVkLCB0aW1lb3V0KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBbaGFuZGxlRXhpdGVkLCBpblByb3AsIHRpbWVvdXRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiByaXBwbGVDbGFzc05hbWUsXG4gICAgc3R5bGU6IHJpcHBsZVN0eWxlc1xuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogY2hpbGRDbGFzc05hbWVcbiAgfSkpO1xufVxuXG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBSaXBwbGUucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmUgLSBpbmplY3RlZCBmcm9tIFRyYW5zaXRpb25Hcm91cFxuICAgKi9cbiAgaW46IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlIC0gaW5qZWN0ZWQgZnJvbSBUcmFuc2l0aW9uR3JvdXBcbiAgICovXG4gIG9uRXhpdGVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcmlwcGxlIHB1bHNhdGVzLCB0eXBpY2FsbHkgaW5kaWNhdGluZyB0aGUga2V5Ym9hcmQgZm9jdXMgc3RhdGUgb2YgYW4gZWxlbWVudC5cbiAgICovXG4gIHB1bHNhdGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBEaWFtZXRlciBvZiB0aGUgcmlwcGxlLlxuICAgKi9cbiAgcmlwcGxlU2l6ZTogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgcmlwcGxlIGNlbnRlci5cbiAgICovXG4gIHJpcHBsZVg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSByaXBwbGUgY2VudGVyLlxuICAgKi9cbiAgcmlwcGxlWTogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogZXhpdCBkZWxheVxuICAgKi9cbiAgdGltZW91dDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgUmlwcGxlOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbkdyb3VwIH0gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cCc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCBSaXBwbGUgZnJvbSAnLi9SaXBwbGUnO1xudmFyIERVUkFUSU9OID0gNTUwO1xuZXhwb3J0IHZhciBERUxBWV9SSVBQTEUgPSA4MDtcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHJldHVybiB7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiB7XG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHpJbmRleDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIGJvcmRlclJhZGl1czogJ2luaGVyaXQnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpbnRlcm5hbCBgUmlwcGxlYCBjb21wb25lbnRzIGByaXBwbGVgIGNsYXNzLiAqL1xuICAgIHJpcHBsZToge1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpbnRlcm5hbCBgUmlwcGxlYCBjb21wb25lbnRzIGByaXBwbGVWaXNpYmxlYCBjbGFzcy4gKi9cbiAgICByaXBwbGVWaXNpYmxlOiB7XG4gICAgICBvcGFjaXR5OiAwLjMsXG4gICAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKScsXG4gICAgICBhbmltYXRpb246IFwiJGVudGVyIFwiLmNvbmNhdChEVVJBVElPTiwgXCJtcyBcIikuY29uY2F0KHRoZW1lLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlSW5PdXQpXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpbnRlcm5hbCBgUmlwcGxlYCBjb21wb25lbnRzIGByaXBwbGVQdWxzYXRlYCBjbGFzcy4gKi9cbiAgICByaXBwbGVQdWxzYXRlOiB7XG4gICAgICBhbmltYXRpb25EdXJhdGlvbjogXCJcIi5jb25jYXQodGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlciwgXCJtc1wiKVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaW50ZXJuYWwgYFJpcHBsZWAgY29tcG9uZW50cyBgY2hpbGRgIGNsYXNzLiAqL1xuICAgIGNoaWxkOiB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpbnRlcm5hbCBgUmlwcGxlYCBjb21wb25lbnRzIGBjaGlsZExlYXZpbmdgIGNsYXNzLiAqL1xuICAgIGNoaWxkTGVhdmluZzoge1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIGFuaW1hdGlvbjogXCIkZXhpdCBcIi5jb25jYXQoRFVSQVRJT04sIFwibXMgXCIpLmNvbmNhdCh0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZUluT3V0KVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaW50ZXJuYWwgYFJpcHBsZWAgY29tcG9uZW50cyBgY2hpbGRQdWxzYXRlYCBjbGFzcy4gKi9cbiAgICBjaGlsZFB1bHNhdGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGFuaW1hdGlvbjogXCIkcHVsc2F0ZSAyNTAwbXMgXCIuY29uY2F0KHRoZW1lLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlSW5PdXQsIFwiIDIwMG1zIGluZmluaXRlXCIpXG4gICAgfSxcbiAgICAnQGtleWZyYW1lcyBlbnRlcic6IHtcbiAgICAgICcwJSc6IHtcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMCknLFxuICAgICAgICBvcGFjaXR5OiAwLjFcbiAgICAgIH0sXG4gICAgICAnMTAwJSc6IHtcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknLFxuICAgICAgICBvcGFjaXR5OiAwLjNcbiAgICAgIH1cbiAgICB9LFxuICAgICdAa2V5ZnJhbWVzIGV4aXQnOiB7XG4gICAgICAnMCUnOiB7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH0sXG4gICAgICAnMTAwJSc6IHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfVxuICAgIH0sXG4gICAgJ0BrZXlmcmFtZXMgcHVsc2F0ZSc6IHtcbiAgICAgICcwJSc6IHtcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknXG4gICAgICB9LFxuICAgICAgJzUwJSc6IHtcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMC45MiknXG4gICAgICB9LFxuICAgICAgJzEwMCUnOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKlxuICogVE9ETyB2NTogTWFrZSBwcml2YXRlXG4gKi9cblxudmFyIFRvdWNoUmlwcGxlID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gVG91Y2hSaXBwbGUocHJvcHMsIHJlZikge1xuICB2YXIgX3Byb3BzJGNlbnRlciA9IHByb3BzLmNlbnRlcixcbiAgICAgIGNlbnRlclByb3AgPSBfcHJvcHMkY2VudGVyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRjZW50ZXIsXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjZW50ZXJcIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoW10pLFxuICAgICAgcmlwcGxlcyA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldFJpcHBsZXMgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIG5leHRLZXkgPSBSZWFjdC51c2VSZWYoMCk7XG4gIHZhciByaXBwbGVDYWxsYmFjayA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmlwcGxlQ2FsbGJhY2suY3VycmVudCkge1xuICAgICAgcmlwcGxlQ2FsbGJhY2suY3VycmVudCgpO1xuICAgICAgcmlwcGxlQ2FsbGJhY2suY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbcmlwcGxlc10pOyAvLyBVc2VkIHRvIGZpbHRlciBvdXQgbW91c2UgZW11bGF0ZWQgZXZlbnRzIG9uIG1vYmlsZS5cblxuICB2YXIgaWdub3JpbmdNb3VzZURvd24gPSBSZWFjdC51c2VSZWYoZmFsc2UpOyAvLyBXZSB1c2UgYSB0aW1lciBpbiBvcmRlciB0byBvbmx5IHNob3cgdGhlIHJpcHBsZXMgZm9yIHRvdWNoIFwiY2xpY2tcIiBsaWtlIGV2ZW50cy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCB0byBkaXNwbGF5IHRoZSByaXBwbGUgZm9yIHRvdWNoIHNjcm9sbCBldmVudHMuXG5cbiAgdmFyIHN0YXJ0VGltZXIgPSBSZWFjdC51c2VSZWYobnVsbCk7IC8vIFRoaXMgaXMgdGhlIGhvb2sgY2FsbGVkIG9uY2UgdGhlIHByZXZpb3VzIHRpbWVvdXQgaXMgcmVhZHkuXG5cbiAgdmFyIHN0YXJ0VGltZXJDb21taXQgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBjb250YWluZXIgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFyVGltZW91dChzdGFydFRpbWVyLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdmFyIHN0YXJ0Q29tbWl0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwdWxzYXRlID0gcGFyYW1zLnB1bHNhdGUsXG4gICAgICAgIHJpcHBsZVggPSBwYXJhbXMucmlwcGxlWCxcbiAgICAgICAgcmlwcGxlWSA9IHBhcmFtcy5yaXBwbGVZLFxuICAgICAgICByaXBwbGVTaXplID0gcGFyYW1zLnJpcHBsZVNpemUsXG4gICAgICAgIGNiID0gcGFyYW1zLmNiO1xuICAgIHNldFJpcHBsZXMoZnVuY3Rpb24gKG9sZFJpcHBsZXMpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG9sZFJpcHBsZXMpLCBbLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmlwcGxlLCB7XG4gICAgICAgIGtleTogbmV4dEtleS5jdXJyZW50LFxuICAgICAgICBjbGFzc2VzOiBjbGFzc2VzLFxuICAgICAgICB0aW1lb3V0OiBEVVJBVElPTixcbiAgICAgICAgcHVsc2F0ZTogcHVsc2F0ZSxcbiAgICAgICAgcmlwcGxlWDogcmlwcGxlWCxcbiAgICAgICAgcmlwcGxlWTogcmlwcGxlWSxcbiAgICAgICAgcmlwcGxlU2l6ZTogcmlwcGxlU2l6ZVxuICAgICAgfSldKTtcbiAgICB9KTtcbiAgICBuZXh0S2V5LmN1cnJlbnQgKz0gMTtcbiAgICByaXBwbGVDYWxsYmFjay5jdXJyZW50ID0gY2I7XG4gIH0sIFtjbGFzc2VzXSk7XG4gIHZhciBzdGFydCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgY2IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX29wdGlvbnMkcHVsc2F0ZSA9IG9wdGlvbnMucHVsc2F0ZSxcbiAgICAgICAgcHVsc2F0ZSA9IF9vcHRpb25zJHB1bHNhdGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcHVsc2F0ZSxcbiAgICAgICAgX29wdGlvbnMkY2VudGVyID0gb3B0aW9ucy5jZW50ZXIsXG4gICAgICAgIGNlbnRlciA9IF9vcHRpb25zJGNlbnRlciA9PT0gdm9pZCAwID8gY2VudGVyUHJvcCB8fCBvcHRpb25zLnB1bHNhdGUgOiBfb3B0aW9ucyRjZW50ZXIsXG4gICAgICAgIF9vcHRpb25zJGZha2VFbGVtZW50ID0gb3B0aW9ucy5mYWtlRWxlbWVudCxcbiAgICAgICAgZmFrZUVsZW1lbnQgPSBfb3B0aW9ucyRmYWtlRWxlbWVudCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRmYWtlRWxlbWVudDtcblxuICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2Vkb3duJyAmJiBpZ25vcmluZ01vdXNlRG93bi5jdXJyZW50KSB7XG4gICAgICBpZ25vcmluZ01vdXNlRG93bi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgaWdub3JpbmdNb3VzZURvd24uY3VycmVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBmYWtlRWxlbWVudCA/IG51bGwgOiBjb250YWluZXIuY3VycmVudDtcbiAgICB2YXIgcmVjdCA9IGVsZW1lbnQgPyBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTsgLy8gR2V0IHRoZSBzaXplIG9mIHRoZSByaXBwbGVcblxuICAgIHZhciByaXBwbGVYO1xuICAgIHZhciByaXBwbGVZO1xuICAgIHZhciByaXBwbGVTaXplO1xuXG4gICAgaWYgKGNlbnRlciB8fCBldmVudC5jbGllbnRYID09PSAwICYmIGV2ZW50LmNsaWVudFkgPT09IDAgfHwgIWV2ZW50LmNsaWVudFggJiYgIWV2ZW50LnRvdWNoZXMpIHtcbiAgICAgIHJpcHBsZVggPSBNYXRoLnJvdW5kKHJlY3Qud2lkdGggLyAyKTtcbiAgICAgIHJpcHBsZVkgPSBNYXRoLnJvdW5kKHJlY3QuaGVpZ2h0IC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfcmVmID0gZXZlbnQudG91Y2hlcyA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudCxcbiAgICAgICAgICBjbGllbnRYID0gX3JlZi5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmLmNsaWVudFk7XG5cbiAgICAgIHJpcHBsZVggPSBNYXRoLnJvdW5kKGNsaWVudFggLSByZWN0LmxlZnQpO1xuICAgICAgcmlwcGxlWSA9IE1hdGgucm91bmQoY2xpZW50WSAtIHJlY3QudG9wKTtcbiAgICB9XG5cbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICByaXBwbGVTaXplID0gTWF0aC5zcXJ0KCgyICogTWF0aC5wb3cocmVjdC53aWR0aCwgMikgKyBNYXRoLnBvdyhyZWN0LmhlaWdodCwgMikpIC8gMyk7IC8vIEZvciBzb21lIHJlYXNvbiB0aGUgYW5pbWF0aW9uIGlzIGJyb2tlbiBvbiBNb2JpbGUgQ2hyb21lIGlmIHRoZSBzaXplIGlmIGV2ZW4uXG5cbiAgICAgIGlmIChyaXBwbGVTaXplICUgMiA9PT0gMCkge1xuICAgICAgICByaXBwbGVTaXplICs9IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzaXplWCA9IE1hdGgubWF4KE1hdGguYWJzKChlbGVtZW50ID8gZWxlbWVudC5jbGllbnRXaWR0aCA6IDApIC0gcmlwcGxlWCksIHJpcHBsZVgpICogMiArIDI7XG4gICAgICB2YXIgc2l6ZVkgPSBNYXRoLm1heChNYXRoLmFicygoZWxlbWVudCA/IGVsZW1lbnQuY2xpZW50SGVpZ2h0IDogMCkgLSByaXBwbGVZKSwgcmlwcGxlWSkgKiAyICsgMjtcbiAgICAgIHJpcHBsZVNpemUgPSBNYXRoLnNxcnQoTWF0aC5wb3coc2l6ZVgsIDIpICsgTWF0aC5wb3coc2l6ZVksIDIpKTtcbiAgICB9IC8vIFRvdWNoZSBkZXZpY2VzXG5cblxuICAgIGlmIChldmVudC50b3VjaGVzKSB7XG4gICAgICAvLyBjaGVjayB0aGF0IHRoaXMgaXNuJ3QgYW5vdGhlciB0b3VjaHN0YXJ0IGR1ZSB0byBtdWx0aXRvdWNoXG4gICAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBvbmx5IGNsZWFyIGEgc2luZ2xlIHRpbWVyIHdoZW4gdW5tb3VudGluZyB3aGlsZSB0d29cbiAgICAgIC8vIGFyZSBydW5uaW5nXG4gICAgICBpZiAoc3RhcnRUaW1lckNvbW1pdC5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIFByZXBhcmUgdGhlIHJpcHBsZSBlZmZlY3QuXG4gICAgICAgIHN0YXJ0VGltZXJDb21taXQuY3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGFydENvbW1pdCh7XG4gICAgICAgICAgICBwdWxzYXRlOiBwdWxzYXRlLFxuICAgICAgICAgICAgcmlwcGxlWDogcmlwcGxlWCxcbiAgICAgICAgICAgIHJpcHBsZVk6IHJpcHBsZVksXG4gICAgICAgICAgICByaXBwbGVTaXplOiByaXBwbGVTaXplLFxuICAgICAgICAgICAgY2I6IGNiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07IC8vIERlbGF5IHRoZSBleGVjdXRpb24gb2YgdGhlIHJpcHBsZSBlZmZlY3QuXG5cblxuICAgICAgICBzdGFydFRpbWVyLmN1cnJlbnQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc3RhcnRUaW1lckNvbW1pdC5jdXJyZW50KSB7XG4gICAgICAgICAgICBzdGFydFRpbWVyQ29tbWl0LmN1cnJlbnQoKTtcbiAgICAgICAgICAgIHN0YXJ0VGltZXJDb21taXQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBERUxBWV9SSVBQTEUpOyAvLyBXZSBoYXZlIHRvIG1ha2UgYSB0cmFkZW9mZiB3aXRoIHRoaXMgdmFsdWUuXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0Q29tbWl0KHtcbiAgICAgICAgcHVsc2F0ZTogcHVsc2F0ZSxcbiAgICAgICAgcmlwcGxlWDogcmlwcGxlWCxcbiAgICAgICAgcmlwcGxlWTogcmlwcGxlWSxcbiAgICAgICAgcmlwcGxlU2l6ZTogcmlwcGxlU2l6ZSxcbiAgICAgICAgY2I6IGNiXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtjZW50ZXJQcm9wLCBzdGFydENvbW1pdF0pO1xuICB2YXIgcHVsc2F0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzdGFydCh7fSwge1xuICAgICAgcHVsc2F0ZTogdHJ1ZVxuICAgIH0pO1xuICB9LCBbc3RhcnRdKTtcbiAgdmFyIHN0b3AgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQsIGNiKSB7XG4gICAgY2xlYXJUaW1lb3V0KHN0YXJ0VGltZXIuY3VycmVudCk7IC8vIFRoZSB0b3VjaCBpbnRlcmFjdGlvbiBvY2N1cnMgdG9vIHF1aWNrbHkuXG4gICAgLy8gV2Ugc3RpbGwgd2FudCB0byBzaG93IHJpcHBsZSBlZmZlY3QuXG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNoZW5kJyAmJiBzdGFydFRpbWVyQ29tbWl0LmN1cnJlbnQpIHtcbiAgICAgIGV2ZW50LnBlcnNpc3QoKTtcbiAgICAgIHN0YXJ0VGltZXJDb21taXQuY3VycmVudCgpO1xuICAgICAgc3RhcnRUaW1lckNvbW1pdC5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHN0YXJ0VGltZXIuY3VycmVudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdG9wKGV2ZW50LCBjYik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGFydFRpbWVyQ29tbWl0LmN1cnJlbnQgPSBudWxsO1xuICAgIHNldFJpcHBsZXMoZnVuY3Rpb24gKG9sZFJpcHBsZXMpIHtcbiAgICAgIGlmIChvbGRSaXBwbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG9sZFJpcHBsZXMuc2xpY2UoMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvbGRSaXBwbGVzO1xuICAgIH0pO1xuICAgIHJpcHBsZUNhbGxiYWNrLmN1cnJlbnQgPSBjYjtcbiAgfSwgW10pO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwdWxzYXRlOiBwdWxzYXRlLFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgc3RvcDogc3RvcFxuICAgIH07XG4gIH0sIFtwdWxzYXRlLCBzdGFydCwgc3RvcF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUpLFxuICAgIHJlZjogY29udGFpbmVyXG4gIH0sIG90aGVyKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkdyb3VwLCB7XG4gICAgY29tcG9uZW50OiBudWxsLFxuICAgIGV4aXQ6IHRydWVcbiAgfSwgcmlwcGxlcykpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBUb3VjaFJpcHBsZS5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByaXBwbGUgc3RhcnRzIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGNvbXBvbmVudFxuICAgKiByYXRoZXIgdGhhbiBhdCB0aGUgcG9pbnQgb2YgaW50ZXJhY3Rpb24uXG4gICAqL1xuICBjZW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgZmxpcDogZmFsc2UsXG4gIG5hbWU6ICdNdWlUb3VjaFJpcHBsZSdcbn0pKCAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhUb3VjaFJpcHBsZSkpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBlbGVtZW50VHlwZUFjY2VwdGluZ1JlZiwgcmVmVHlwZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcbmltcG9ydCB1c2VFdmVudENhbGxiYWNrIGZyb20gJy4uL3V0aWxzL3VzZUV2ZW50Q2FsbGJhY2snO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IHVzZUlzRm9jdXNWaXNpYmxlIGZyb20gJy4uL3V0aWxzL3VzZUlzRm9jdXNWaXNpYmxlJztcbmltcG9ydCBUb3VjaFJpcHBsZSBmcm9tICcuL1RvdWNoUmlwcGxlJztcbmV4cG9ydCB2YXIgc3R5bGVzID0ge1xuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICByb290OiB7XG4gICAgZGlzcGxheTogJ2lubGluZS1mbGV4JyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgIC8vIFJlc2V0IGRlZmF1bHQgdmFsdWVcbiAgICAvLyBXZSBkaXNhYmxlIHRoZSBmb2N1cyByaW5nIGZvciBtb3VzZSwgdG91Y2ggYW5kIGtleWJvYXJkIHVzZXJzLlxuICAgIG91dGxpbmU6IDAsXG4gICAgYm9yZGVyOiAwLFxuICAgIG1hcmdpbjogMCxcbiAgICAvLyBSZW1vdmUgdGhlIG1hcmdpbiBpbiBTYWZhcmlcbiAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICAvLyBSZW1vdmUgdGhlIHBhZGRpbmcgaW4gRmlyZWZveFxuICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAnLW1vei1hcHBlYXJhbmNlJzogJ25vbmUnLFxuICAgIC8vIFJlc2V0XG4gICAgJy13ZWJraXQtYXBwZWFyYW5jZSc6ICdub25lJyxcbiAgICAvLyBSZXNldFxuICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXG4gICAgLy8gU28gd2UgdGFrZSBwcmVjZWRlbnQgb3ZlciB0aGUgc3R5bGUgb2YgYSBuYXRpdmUgPGEgLz4gZWxlbWVudC5cbiAgICBjb2xvcjogJ2luaGVyaXQnLFxuICAgICcmOjotbW96LWZvY3VzLWlubmVyJzoge1xuICAgICAgYm9yZGVyU3R5bGU6ICdub25lJyAvLyBSZW1vdmUgRmlyZWZveCBkb3R0ZWQgb3V0bGluZS5cblxuICAgIH0sXG4gICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAvLyBEaXNhYmxlIGxpbmsgaW50ZXJhY3Rpb25zXG4gICAgICBjdXJzb3I6ICdkZWZhdWx0J1xuICAgIH0sXG4gICAgJ0BtZWRpYSBwcmludCc6IHtcbiAgICAgIGNvbG9yQWRqdXN0OiAnZXhhY3QnXG4gICAgfVxuICB9LFxuXG4gIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVkPXt0cnVlfWAuICovXG4gIGRpc2FibGVkOiB7fSxcblxuICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGtleWJvYXJkIGZvY3VzZWQuICovXG4gIGZvY3VzVmlzaWJsZToge31cbn07XG4vKipcbiAqIGBCdXR0b25CYXNlYCBjb250YWlucyBhcyBmZXcgc3R5bGVzIGFzIHBvc3NpYmxlLlxuICogSXQgYWltcyB0byBiZSBhIHNpbXBsZSBidWlsZGluZyBibG9jayBmb3IgY3JlYXRpbmcgYSBidXR0b24uXG4gKiBJdCBjb250YWlucyBhIGxvYWQgb2Ygc3R5bGUgcmVzZXQgYW5kIHNvbWUgZm9jdXMvcmlwcGxlIGxvZ2ljLlxuICovXG5cbnZhciBCdXR0b25CYXNlID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQnV0dG9uQmFzZShwcm9wcywgcmVmKSB7XG4gIHZhciBhY3Rpb24gPSBwcm9wcy5hY3Rpb24sXG4gICAgICBidXR0b25SZWZQcm9wID0gcHJvcHMuYnV0dG9uUmVmLFxuICAgICAgX3Byb3BzJGNlbnRlclJpcHBsZSA9IHByb3BzLmNlbnRlclJpcHBsZSxcbiAgICAgIGNlbnRlclJpcHBsZSA9IF9wcm9wcyRjZW50ZXJSaXBwbGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGNlbnRlclJpcHBsZSxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBjb21wb25lbnQgPSBfcHJvcHMkY29tcG9uZW50ID09PSB2b2lkIDAgPyAnYnV0dG9uJyA6IF9wcm9wcyRjb21wb25lbnQsXG4gICAgICBfcHJvcHMkZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGRpc2FibGVkID0gX3Byb3BzJGRpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlZCxcbiAgICAgIF9wcm9wcyRkaXNhYmxlUmlwcGxlID0gcHJvcHMuZGlzYWJsZVJpcHBsZSxcbiAgICAgIGRpc2FibGVSaXBwbGUgPSBfcHJvcHMkZGlzYWJsZVJpcHBsZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVJpcHBsZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlVG91Y2hSaSA9IHByb3BzLmRpc2FibGVUb3VjaFJpcHBsZSxcbiAgICAgIGRpc2FibGVUb3VjaFJpcHBsZSA9IF9wcm9wcyRkaXNhYmxlVG91Y2hSaSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVRvdWNoUmksXG4gICAgICBfcHJvcHMkZm9jdXNSaXBwbGUgPSBwcm9wcy5mb2N1c1JpcHBsZSxcbiAgICAgIGZvY3VzUmlwcGxlID0gX3Byb3BzJGZvY3VzUmlwcGxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmb2N1c1JpcHBsZSxcbiAgICAgIGZvY3VzVmlzaWJsZUNsYXNzTmFtZSA9IHByb3BzLmZvY3VzVmlzaWJsZUNsYXNzTmFtZSxcbiAgICAgIG9uQmx1ciA9IHByb3BzLm9uQmx1cixcbiAgICAgIG9uQ2xpY2sgPSBwcm9wcy5vbkNsaWNrLFxuICAgICAgb25Gb2N1cyA9IHByb3BzLm9uRm9jdXMsXG4gICAgICBvbkZvY3VzVmlzaWJsZSA9IHByb3BzLm9uRm9jdXNWaXNpYmxlLFxuICAgICAgb25LZXlEb3duID0gcHJvcHMub25LZXlEb3duLFxuICAgICAgb25LZXlVcCA9IHByb3BzLm9uS2V5VXAsXG4gICAgICBvbk1vdXNlRG93biA9IHByb3BzLm9uTW91c2VEb3duLFxuICAgICAgb25Nb3VzZUxlYXZlID0gcHJvcHMub25Nb3VzZUxlYXZlLFxuICAgICAgb25Nb3VzZVVwID0gcHJvcHMub25Nb3VzZVVwLFxuICAgICAgb25Ub3VjaEVuZCA9IHByb3BzLm9uVG91Y2hFbmQsXG4gICAgICBvblRvdWNoTW92ZSA9IHByb3BzLm9uVG91Y2hNb3ZlLFxuICAgICAgb25Ub3VjaFN0YXJ0ID0gcHJvcHMub25Ub3VjaFN0YXJ0LFxuICAgICAgb25EcmFnTGVhdmUgPSBwcm9wcy5vbkRyYWdMZWF2ZSxcbiAgICAgIF9wcm9wcyR0YWJJbmRleCA9IHByb3BzLnRhYkluZGV4LFxuICAgICAgdGFiSW5kZXggPSBfcHJvcHMkdGFiSW5kZXggPT09IHZvaWQgMCA/IDAgOiBfcHJvcHMkdGFiSW5kZXgsXG4gICAgICBUb3VjaFJpcHBsZVByb3BzID0gcHJvcHMuVG91Y2hSaXBwbGVQcm9wcyxcbiAgICAgIF9wcm9wcyR0eXBlID0gcHJvcHMudHlwZSxcbiAgICAgIHR5cGUgPSBfcHJvcHMkdHlwZSA9PT0gdm9pZCAwID8gJ2J1dHRvbicgOiBfcHJvcHMkdHlwZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhY3Rpb25cIiwgXCJidXR0b25SZWZcIiwgXCJjZW50ZXJSaXBwbGVcIiwgXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb21wb25lbnRcIiwgXCJkaXNhYmxlZFwiLCBcImRpc2FibGVSaXBwbGVcIiwgXCJkaXNhYmxlVG91Y2hSaXBwbGVcIiwgXCJmb2N1c1JpcHBsZVwiLCBcImZvY3VzVmlzaWJsZUNsYXNzTmFtZVwiLCBcIm9uQmx1clwiLCBcIm9uQ2xpY2tcIiwgXCJvbkZvY3VzXCIsIFwib25Gb2N1c1Zpc2libGVcIiwgXCJvbktleURvd25cIiwgXCJvbktleVVwXCIsIFwib25Nb3VzZURvd25cIiwgXCJvbk1vdXNlTGVhdmVcIiwgXCJvbk1vdXNlVXBcIiwgXCJvblRvdWNoRW5kXCIsIFwib25Ub3VjaE1vdmVcIiwgXCJvblRvdWNoU3RhcnRcIiwgXCJvbkRyYWdMZWF2ZVwiLCBcInRhYkluZGV4XCIsIFwiVG91Y2hSaXBwbGVQcm9wc1wiLCBcInR5cGVcIl0pO1xuXG4gIHZhciBidXR0b25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG5cbiAgZnVuY3Rpb24gZ2V0QnV0dG9uTm9kZSgpIHtcbiAgICAvLyAjU3RyaWN0TW9kZSByZWFkeVxuICAgIHJldHVybiBSZWFjdERPTS5maW5kRE9NTm9kZShidXR0b25SZWYuY3VycmVudCk7XG4gIH1cblxuICB2YXIgcmlwcGxlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBmb2N1c1Zpc2libGUgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXRGb2N1c1Zpc2libGUgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgaWYgKGRpc2FibGVkICYmIGZvY3VzVmlzaWJsZSkge1xuICAgIHNldEZvY3VzVmlzaWJsZShmYWxzZSk7XG4gIH1cblxuICB2YXIgX3VzZUlzRm9jdXNWaXNpYmxlID0gdXNlSXNGb2N1c1Zpc2libGUoKSxcbiAgICAgIGlzRm9jdXNWaXNpYmxlID0gX3VzZUlzRm9jdXNWaXNpYmxlLmlzRm9jdXNWaXNpYmxlLFxuICAgICAgb25CbHVyVmlzaWJsZSA9IF91c2VJc0ZvY3VzVmlzaWJsZS5vbkJsdXJWaXNpYmxlLFxuICAgICAgZm9jdXNWaXNpYmxlUmVmID0gX3VzZUlzRm9jdXNWaXNpYmxlLnJlZjtcblxuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGFjdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c1Zpc2libGU6IGZ1bmN0aW9uIGZvY3VzVmlzaWJsZSgpIHtcbiAgICAgICAgc2V0Rm9jdXNWaXNpYmxlKHRydWUpO1xuICAgICAgICBidXR0b25SZWYuY3VycmVudC5mb2N1cygpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZm9jdXNWaXNpYmxlICYmIGZvY3VzUmlwcGxlICYmICFkaXNhYmxlUmlwcGxlKSB7XG4gICAgICByaXBwbGVSZWYuY3VycmVudC5wdWxzYXRlKCk7XG4gICAgfVxuICB9LCBbZGlzYWJsZVJpcHBsZSwgZm9jdXNSaXBwbGUsIGZvY3VzVmlzaWJsZV0pO1xuXG4gIGZ1bmN0aW9uIHVzZVJpcHBsZUhhbmRsZXIocmlwcGxlQWN0aW9uLCBldmVudENhbGxiYWNrKSB7XG4gICAgdmFyIHNraXBSaXBwbGVBY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGRpc2FibGVUb3VjaFJpcHBsZTtcbiAgICByZXR1cm4gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudENhbGxiYWNrKSB7XG4gICAgICAgIGV2ZW50Q2FsbGJhY2soZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWdub3JlID0gc2tpcFJpcHBsZUFjdGlvbjtcblxuICAgICAgaWYgKCFpZ25vcmUgJiYgcmlwcGxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmlwcGxlUmVmLmN1cnJlbnRbcmlwcGxlQWN0aW9uXShldmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhbmRsZU1vdXNlRG93biA9IHVzZVJpcHBsZUhhbmRsZXIoJ3N0YXJ0Jywgb25Nb3VzZURvd24pO1xuICB2YXIgaGFuZGxlRHJhZ0xlYXZlID0gdXNlUmlwcGxlSGFuZGxlcignc3RvcCcsIG9uRHJhZ0xlYXZlKTtcbiAgdmFyIGhhbmRsZU1vdXNlVXAgPSB1c2VSaXBwbGVIYW5kbGVyKCdzdG9wJywgb25Nb3VzZVVwKTtcbiAgdmFyIGhhbmRsZU1vdXNlTGVhdmUgPSB1c2VSaXBwbGVIYW5kbGVyKCdzdG9wJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGZvY3VzVmlzaWJsZSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAob25Nb3VzZUxlYXZlKSB7XG4gICAgICBvbk1vdXNlTGVhdmUoZXZlbnQpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBoYW5kbGVUb3VjaFN0YXJ0ID0gdXNlUmlwcGxlSGFuZGxlcignc3RhcnQnLCBvblRvdWNoU3RhcnQpO1xuICB2YXIgaGFuZGxlVG91Y2hFbmQgPSB1c2VSaXBwbGVIYW5kbGVyKCdzdG9wJywgb25Ub3VjaEVuZCk7XG4gIHZhciBoYW5kbGVUb3VjaE1vdmUgPSB1c2VSaXBwbGVIYW5kbGVyKCdzdG9wJywgb25Ub3VjaE1vdmUpO1xuICB2YXIgaGFuZGxlQmx1ciA9IHVzZVJpcHBsZUhhbmRsZXIoJ3N0b3AnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZm9jdXNWaXNpYmxlKSB7XG4gICAgICBvbkJsdXJWaXNpYmxlKGV2ZW50KTtcbiAgICAgIHNldEZvY3VzVmlzaWJsZShmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKG9uQmx1cikge1xuICAgICAgb25CbHVyKGV2ZW50KTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbiAgdmFyIGhhbmRsZUZvY3VzID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBGaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzc2OVxuICAgIGlmICghYnV0dG9uUmVmLmN1cnJlbnQpIHtcbiAgICAgIGJ1dHRvblJlZi5jdXJyZW50ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoaXNGb2N1c1Zpc2libGUoZXZlbnQpKSB7XG4gICAgICBzZXRGb2N1c1Zpc2libGUodHJ1ZSk7XG5cbiAgICAgIGlmIChvbkZvY3VzVmlzaWJsZSkge1xuICAgICAgICBvbkZvY3VzVmlzaWJsZShldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9uRm9jdXMpIHtcbiAgICAgIG9uRm9jdXMoZXZlbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGlzTm9uTmF0aXZlQnV0dG9uID0gZnVuY3Rpb24gaXNOb25OYXRpdmVCdXR0b24oKSB7XG4gICAgdmFyIGJ1dHRvbiA9IGdldEJ1dHRvbk5vZGUoKTtcbiAgICByZXR1cm4gY29tcG9uZW50ICYmIGNvbXBvbmVudCAhPT0gJ2J1dHRvbicgJiYgIShidXR0b24udGFnTmFtZSA9PT0gJ0EnICYmIGJ1dHRvbi5ocmVmKTtcbiAgfTtcbiAgLyoqXG4gICAqIElFIDExIHNoaW0gZm9yIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L3JlcGVhdFxuICAgKi9cblxuXG4gIHZhciBrZXlkb3duUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdmFyIGhhbmRsZUtleURvd24gPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIENoZWNrIGlmIGtleSBpcyBhbHJlYWR5IGRvd24gdG8gYXZvaWQgcmVwZWF0cyBiZWluZyBjb3VudGVkIGFzIG11bHRpcGxlIGFjdGl2YXRpb25zXG4gICAgaWYgKGZvY3VzUmlwcGxlICYmICFrZXlkb3duUmVmLmN1cnJlbnQgJiYgZm9jdXNWaXNpYmxlICYmIHJpcHBsZVJlZi5jdXJyZW50ICYmIGV2ZW50LmtleSA9PT0gJyAnKSB7XG4gICAgICBrZXlkb3duUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgZXZlbnQucGVyc2lzdCgpO1xuICAgICAgcmlwcGxlUmVmLmN1cnJlbnQuc3RvcChldmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByaXBwbGVSZWYuY3VycmVudC5zdGFydChldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBldmVudC5jdXJyZW50VGFyZ2V0ICYmIGlzTm9uTmF0aXZlQnV0dG9uKCkgJiYgZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaWYgKG9uS2V5RG93bikge1xuICAgICAgb25LZXlEb3duKGV2ZW50KTtcbiAgICB9IC8vIEtleWJvYXJkIGFjY2Vzc2liaWxpdHkgZm9yIG5vbiBpbnRlcmFjdGl2ZSBlbGVtZW50c1xuXG5cbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBldmVudC5jdXJyZW50VGFyZ2V0ICYmIGlzTm9uTmF0aXZlQnV0dG9uKCkgJiYgZXZlbnQua2V5ID09PSAnRW50ZXInICYmICFkaXNhYmxlZCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIGhhbmRsZUtleVVwID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBjYWxsaW5nIHByZXZlbnREZWZhdWx0IGluIGtleVVwIG9uIGEgPGJ1dHRvbj4gd2lsbCBub3QgZGlzcGF0Y2ggYSBjbGljayBldmVudCBpZiBTcGFjZSBpcyBwcmVzc2VkXG4gICAgLy8gaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL2J1dHRvbi1rZXl1cC1wcmV2ZW50ZGVmYXVsdC1kbjdmMFxuICAgIGlmIChmb2N1c1JpcHBsZSAmJiBldmVudC5rZXkgPT09ICcgJyAmJiByaXBwbGVSZWYuY3VycmVudCAmJiBmb2N1c1Zpc2libGUgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIGtleWRvd25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgZXZlbnQucGVyc2lzdCgpO1xuICAgICAgcmlwcGxlUmVmLmN1cnJlbnQuc3RvcChldmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByaXBwbGVSZWYuY3VycmVudC5wdWxzYXRlKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvbktleVVwKSB7XG4gICAgICBvbktleVVwKGV2ZW50KTtcbiAgICB9IC8vIEtleWJvYXJkIGFjY2Vzc2liaWxpdHkgZm9yIG5vbiBpbnRlcmFjdGl2ZSBlbGVtZW50c1xuXG5cbiAgICBpZiAob25DbGljayAmJiBldmVudC50YXJnZXQgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQgJiYgaXNOb25OYXRpdmVCdXR0b24oKSAmJiBldmVudC5rZXkgPT09ICcgJyAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgb25DbGljayhldmVudCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIENvbXBvbmVudFByb3AgPSBjb21wb25lbnQ7XG5cbiAgaWYgKENvbXBvbmVudFByb3AgPT09ICdidXR0b24nICYmIG90aGVyLmhyZWYpIHtcbiAgICBDb21wb25lbnRQcm9wID0gJ2EnO1xuICB9XG5cbiAgdmFyIGJ1dHRvblByb3BzID0ge307XG5cbiAgaWYgKENvbXBvbmVudFByb3AgPT09ICdidXR0b24nKSB7XG4gICAgYnV0dG9uUHJvcHMudHlwZSA9IHR5cGU7XG4gICAgYnV0dG9uUHJvcHMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoQ29tcG9uZW50UHJvcCAhPT0gJ2EnIHx8ICFvdGhlci5ocmVmKSB7XG4gICAgICBidXR0b25Qcm9wcy5yb2xlID0gJ2J1dHRvbic7XG4gICAgfVxuXG4gICAgYnV0dG9uUHJvcHNbJ2FyaWEtZGlzYWJsZWQnXSA9IGRpc2FibGVkO1xuICB9XG5cbiAgdmFyIGhhbmRsZVVzZXJSZWYgPSB1c2VGb3JrUmVmKGJ1dHRvblJlZlByb3AsIHJlZik7XG4gIHZhciBoYW5kbGVPd25SZWYgPSB1c2VGb3JrUmVmKGZvY3VzVmlzaWJsZVJlZiwgYnV0dG9uUmVmKTtcbiAgdmFyIGhhbmRsZVJlZiA9IHVzZUZvcmtSZWYoaGFuZGxlVXNlclJlZiwgaGFuZGxlT3duUmVmKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMiA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIG1vdW50ZWRTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRNb3VudGVkU3RhdGUgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgc2V0TW91bnRlZFN0YXRlKHRydWUpO1xuICB9LCBbXSk7XG4gIHZhciBlbmFibGVUb3VjaFJpcHBsZSA9IG1vdW50ZWRTdGF0ZSAmJiAhZGlzYWJsZVJpcHBsZSAmJiAhZGlzYWJsZWQ7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGVuYWJsZVRvdWNoUmlwcGxlICYmICFyaXBwbGVSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFsnTWF0ZXJpYWwtVUk6IFRoZSBgY29tcG9uZW50YCBwcm9wIHByb3ZpZGVkIHRvIEJ1dHRvbkJhc2UgaXMgaW52YWxpZC4nLCAnUGxlYXNlIG1ha2Ugc3VyZSB0aGUgY2hpbGRyZW4gcHJvcCBpcyByZW5kZXJlZCBpbiB0aGlzIGN1c3RvbSBjb21wb25lbnQuJ10uam9pbignXFxuJykpO1xuICAgICAgfVxuICAgIH0sIFtlbmFibGVUb3VjaFJpcHBsZV0pO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudFByb3AsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUsIGZvY3VzVmlzaWJsZSAmJiBbY2xhc3Nlcy5mb2N1c1Zpc2libGUsIGZvY3VzVmlzaWJsZUNsYXNzTmFtZV0sIGRpc2FibGVkICYmIGNsYXNzZXMuZGlzYWJsZWQpLFxuICAgIG9uQmx1cjogaGFuZGxlQmx1cixcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIG9uRm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBvbktleVVwOiBoYW5kbGVLZXlVcCxcbiAgICBvbk1vdXNlRG93bjogaGFuZGxlTW91c2VEb3duLFxuICAgIG9uTW91c2VMZWF2ZTogaGFuZGxlTW91c2VMZWF2ZSxcbiAgICBvbk1vdXNlVXA6IGhhbmRsZU1vdXNlVXAsXG4gICAgb25EcmFnTGVhdmU6IGhhbmRsZURyYWdMZWF2ZSxcbiAgICBvblRvdWNoRW5kOiBoYW5kbGVUb3VjaEVuZCxcbiAgICBvblRvdWNoTW92ZTogaGFuZGxlVG91Y2hNb3ZlLFxuICAgIG9uVG91Y2hTdGFydDogaGFuZGxlVG91Y2hTdGFydCxcbiAgICByZWY6IGhhbmRsZVJlZixcbiAgICB0YWJJbmRleDogZGlzYWJsZWQgPyAtMSA6IHRhYkluZGV4XG4gIH0sIGJ1dHRvblByb3BzLCBvdGhlciksIGNoaWxkcmVuLCBlbmFibGVUb3VjaFJpcHBsZSA/XG4gIC8qI19fUFVSRV9fKi9cblxuICAvKiBUb3VjaFJpcHBsZSBpcyBvbmx5IG5lZWRlZCBjbGllbnQtc2lkZSwgeDIgYm9vc3Qgb24gdGhlIHNlcnZlci4gKi9cbiAgUmVhY3QuY3JlYXRlRWxlbWVudChUb3VjaFJpcHBsZSwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmlwcGxlUmVmLFxuICAgIGNlbnRlcjogY2VudGVyUmlwcGxlXG4gIH0sIFRvdWNoUmlwcGxlUHJvcHMpKSA6IG51bGwpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBCdXR0b25CYXNlLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEEgcmVmIGZvciBpbXBlcmF0aXZlIGFjdGlvbnMuXG4gICAqIEl0IGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIGBmb2N1c1Zpc2libGUoKWAgYWN0aW9uLlxuICAgKi9cbiAgYWN0aW9uOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqXG4gICAqIFVzZSB0aGF0IHByb3AgdG8gcGFzcyBhIHJlZiB0byB0aGUgbmF0aXZlIGJ1dHRvbiBjb21wb25lbnQuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgcmVmYCBpbnN0ZWFkLlxuICAgKi9cbiAgYnV0dG9uUmVmOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByaXBwbGVzIHdpbGwgYmUgY2VudGVyZWQuXG4gICAqIFRoZXkgd29uJ3Qgc3RhcnQgYXQgdGhlIGN1cnNvciBpbnRlcmFjdGlvbiBwb3NpdGlvbi5cbiAgICovXG4gIGNlbnRlclJpcHBsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IGVsZW1lbnRUeXBlQWNjZXB0aW5nUmVmLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGJ1dHRvbiB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByaXBwbGUgZWZmZWN0IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqXG4gICAqIOKaoO+4jyBXaXRob3V0IGEgcmlwcGxlIHRoZXJlIGlzIG5vIHN0eWxpbmcgZm9yIDpmb2N1cy12aXNpYmxlIGJ5IGRlZmF1bHQuIEJlIHN1cmVcbiAgICogdG8gaGlnaGxpZ2h0IHRoZSBlbGVtZW50IGJ5IGFwcGx5aW5nIHNlcGFyYXRlIHN0eWxlcyB3aXRoIHRoZSBgZm9jdXNWaXNpYmxlQ2xhc3NOYW1lYC5cbiAgICovXG4gIGRpc2FibGVSaXBwbGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB0b3VjaCByaXBwbGUgZWZmZWN0IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlVG91Y2hSaXBwbGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGJ1dHRvbiB3aWxsIGhhdmUgYSBrZXlib2FyZCBmb2N1cyByaXBwbGUuXG4gICAqL1xuICBmb2N1c1JpcHBsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoaXMgcHJvcCBjYW4gaGVscCBhIHBlcnNvbiBrbm93IHdoaWNoIGVsZW1lbnQgaGFzIHRoZSBrZXlib2FyZCBmb2N1cy5cbiAgICogVGhlIGNsYXNzIG5hbWUgd2lsbCBiZSBhcHBsaWVkIHdoZW4gdGhlIGVsZW1lbnQgZ2FpbiB0aGUgZm9jdXMgdGhyb3VnaCBhIGtleWJvYXJkIGludGVyYWN0aW9uLlxuICAgKiBJdCdzIGEgcG9seWZpbGwgZm9yIHRoZSBbQ1NTIDpmb2N1cy12aXNpYmxlIHNlbGVjdG9yXShodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvc2VsZWN0b3JzLTQvI3RoZS1mb2N1cy12aXNpYmxlLXBzZXVkbykuXG4gICAqIFRoZSByYXRpb25hbGUgZm9yIHVzaW5nIHRoaXMgZmVhdHVyZSBbaXMgZXhwbGFpbmVkIGhlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2ZvY3VzLXZpc2libGUvYmxvYi9tYXN0ZXIvZXhwbGFpbmVyLm1kKS5cbiAgICogQSBbcG9seWZpbGwgY2FuIGJlIHVzZWRdKGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2ZvY3VzLXZpc2libGUpIHRvIGFwcGx5IGEgYGZvY3VzLXZpc2libGVgIGNsYXNzIHRvIG90aGVyIGNvbXBvbmVudHNcbiAgICogaWYgbmVlZGVkLlxuICAgKi9cbiAgZm9jdXNWaXNpYmxlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBocmVmOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25EcmFnTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGZvY3VzZWQgd2l0aCBhIGtleWJvYXJkLlxuICAgKiBXZSB0cmlnZ2VyIGEgYG9uRm9jdXNgIGNhbGxiYWNrIHRvby5cbiAgICovXG4gIG9uRm9jdXNWaXNpYmxlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25LZXlEb3duOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25LZXlVcDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uTW91c2VEb3duOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Nb3VzZVVwOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Ub3VjaEVuZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uVG91Y2hNb3ZlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Ub3VjaFN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdGFiSW5kZXg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgYFRvdWNoUmlwcGxlYCBlbGVtZW50LlxuICAgKi9cbiAgVG91Y2hSaXBwbGVQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdHlwZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9uZU9mKFsnYnV0dG9uJywgJ3Jlc2V0JywgJ3N1Ym1pdCddKSwgUHJvcFR5cGVzLnN0cmluZ10pXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUJ1dHRvbkJhc2UnXG59KShCdXR0b25CYXNlKTsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc011aUVsZW1lbnQoZWxlbWVudCwgbXVpTmFtZXMpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSAmJiBtdWlOYW1lcy5pbmRleE9mKGVsZW1lbnQudHlwZS5tdWlOYW1lKSAhPT0gLTE7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgY2hhaW5Qcm9wVHlwZXMgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IEJ1dHRvbkJhc2UgZnJvbSAnLi4vQnV0dG9uQmFzZSc7XG5pbXBvcnQgaXNNdWlFbGVtZW50IGZyb20gJy4uL3V0aWxzL2lzTXVpRWxlbWVudCc7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcbmltcG9ydCBMaXN0Q29udGV4dCBmcm9tICcuLi9MaXN0L0xpc3RDb250ZXh0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSAobm9ybWFsbHkgcm9vdCkgYGNvbXBvbmVudGAgZWxlbWVudC4gTWF5IGJlIHdyYXBwZWQgYnkgYSBgY29udGFpbmVyYC4gKi9cbiAgICByb290OiB7XG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtc3RhcnQnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgIHBhZGRpbmdUb3A6IDgsXG4gICAgICBwYWRkaW5nQm90dG9tOiA4LFxuICAgICAgJyYkZm9jdXNWaXNpYmxlJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkXG4gICAgICB9LFxuICAgICAgJyYkc2VsZWN0ZWQsICYkc2VsZWN0ZWQ6aG92ZXInOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRcbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgb3BhY2l0eTogMC41XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgY29udGFpbmVyYCBlbGVtZW50IGlmIGBjaGlsZHJlbmAgaW5jbHVkZXMgYExpc3RJdGVtU2Vjb25kYXJ5QWN0aW9uYC4gKi9cbiAgICBjb250YWluZXI6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSBgY29tcG9uZW50YCdzIGBmb2N1c1Zpc2libGVDbGFzc05hbWVgIHByb3AgaWYgYGJ1dHRvbj17dHJ1ZX1gLiAqL1xuICAgIGZvY3VzVmlzaWJsZToge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGNvbXBvbmVudGAgZWxlbWVudCBpZiBkZW5zZS4gKi9cbiAgICBkZW5zZToge1xuICAgICAgcGFkZGluZ1RvcDogNCxcbiAgICAgIHBhZGRpbmdCb3R0b206IDRcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBjb21wb25lbnRgIGVsZW1lbnQgaWYgYGFsaWduSXRlbXM9XCJmbGV4LXN0YXJ0XCJgLiAqL1xuICAgIGFsaWduSXRlbXNGbGV4U3RhcnQ6IHtcbiAgICAgIGFsaWduSXRlbXM6ICdmbGV4LXN0YXJ0J1xuICAgIH0sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgaW5uZXIgYGNvbXBvbmVudGAgZWxlbWVudCBpZiBgZGlzYWJsZWQ9e3RydWV9YC4gKi9cbiAgICBkaXNhYmxlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaW5uZXIgYGNvbXBvbmVudGAgZWxlbWVudCBpZiBgZGl2aWRlcj17dHJ1ZX1gLiAqL1xuICAgIGRpdmlkZXI6IHtcbiAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgXCIuY29uY2F0KHRoZW1lLnBhbGV0dGUuZGl2aWRlciksXG4gICAgICBiYWNrZ3JvdW5kQ2xpcDogJ3BhZGRpbmctYm94J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaW5uZXIgYGNvbXBvbmVudGAgZWxlbWVudCBpZiBgZGlzYWJsZUd1dHRlcnM9e2ZhbHNlfWAuICovXG4gICAgZ3V0dGVyczoge1xuICAgICAgcGFkZGluZ0xlZnQ6IDE2LFxuICAgICAgcGFkZGluZ1JpZ2h0OiAxNlxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaW5uZXIgYGNvbXBvbmVudGAgZWxlbWVudCBpZiBgYnV0dG9uPXt0cnVlfWAuICovXG4gICAgYnV0dG9uOiB7XG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ2JhY2tncm91bmQtY29sb3InLCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVzdFxuICAgICAgfSksXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgdGV4dERlY29yYXRpb246ICdub25lJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5ob3ZlcixcbiAgICAgICAgLy8gUmVzZXQgb24gdG91Y2ggZGV2aWNlcywgaXQgZG9lc24ndCBhZGQgc3BlY2lmaWNpdHlcbiAgICAgICAgJ0BtZWRpYSAoaG92ZXI6IG5vbmUpJzoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgY29tcG9uZW50YCBlbGVtZW50IGlmIGBjaGlsZHJlbmAgaW5jbHVkZXMgYExpc3RJdGVtU2Vjb25kYXJ5QWN0aW9uYC4gKi9cbiAgICBzZWNvbmRhcnlBY3Rpb246IHtcbiAgICAgIC8vIEFkZCBzb21lIHNwYWNlIHRvIGF2b2lkIGNvbGxpc2lvbiBhcyBgTGlzdEl0ZW1TZWNvbmRhcnlBY3Rpb25gXG4gICAgICAvLyBpcyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQuXG4gICAgICBwYWRkaW5nUmlnaHQ6IDQ4XG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHNlbGVjdGVkPXt0cnVlfWAuICovXG4gICAgc2VsZWN0ZWQ6IHt9XG4gIH07XG59O1xudmFyIHVzZUVuaGFuY2VkRWZmZWN0ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VFZmZlY3QgOiBSZWFjdC51c2VMYXlvdXRFZmZlY3Q7XG4vKipcbiAqIFVzZXMgYW4gYWRkaXRpb25hbCBjb250YWluZXIgY29tcG9uZW50IGlmIGBMaXN0SXRlbVNlY29uZGFyeUFjdGlvbmAgaXMgdGhlIGxhc3QgY2hpbGQuXG4gKi9cblxudmFyIExpc3RJdGVtID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTGlzdEl0ZW0ocHJvcHMsIHJlZikge1xuICB2YXIgX3Byb3BzJGFsaWduSXRlbXMgPSBwcm9wcy5hbGlnbkl0ZW1zLFxuICAgICAgYWxpZ25JdGVtcyA9IF9wcm9wcyRhbGlnbkl0ZW1zID09PSB2b2lkIDAgPyAnY2VudGVyJyA6IF9wcm9wcyRhbGlnbkl0ZW1zLFxuICAgICAgX3Byb3BzJGF1dG9Gb2N1cyA9IHByb3BzLmF1dG9Gb2N1cyxcbiAgICAgIGF1dG9Gb2N1cyA9IF9wcm9wcyRhdXRvRm9jdXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGF1dG9Gb2N1cyxcbiAgICAgIF9wcm9wcyRidXR0b24gPSBwcm9wcy5idXR0b24sXG4gICAgICBidXR0b24gPSBfcHJvcHMkYnV0dG9uID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRidXR0b24sXG4gICAgICBjaGlsZHJlblByb3AgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY29tcG9uZW50UHJvcCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgIF9wcm9wcyRDb250YWluZXJDb21wbyA9IHByb3BzLkNvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgIENvbnRhaW5lckNvbXBvbmVudCA9IF9wcm9wcyRDb250YWluZXJDb21wbyA9PT0gdm9pZCAwID8gJ2xpJyA6IF9wcm9wcyRDb250YWluZXJDb21wbyxcbiAgICAgIF9wcm9wcyRDb250YWluZXJQcm9wcyA9IHByb3BzLkNvbnRhaW5lclByb3BzO1xuICBfcHJvcHMkQ29udGFpbmVyUHJvcHMgPSBfcHJvcHMkQ29udGFpbmVyUHJvcHMgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJENvbnRhaW5lclByb3BzO1xuXG4gIHZhciBDb250YWluZXJDbGFzc05hbWUgPSBfcHJvcHMkQ29udGFpbmVyUHJvcHMuY2xhc3NOYW1lLFxuICAgICAgQ29udGFpbmVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzJENvbnRhaW5lclByb3BzLCBbXCJjbGFzc05hbWVcIl0pLFxuICAgICAgX3Byb3BzJGRlbnNlID0gcHJvcHMuZGVuc2UsXG4gICAgICBkZW5zZSA9IF9wcm9wcyRkZW5zZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGVuc2UsXG4gICAgICBfcHJvcHMkZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGRpc2FibGVkID0gX3Byb3BzJGRpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlZCxcbiAgICAgIF9wcm9wcyRkaXNhYmxlR3V0dGVycyA9IHByb3BzLmRpc2FibGVHdXR0ZXJzLFxuICAgICAgZGlzYWJsZUd1dHRlcnMgPSBfcHJvcHMkZGlzYWJsZUd1dHRlcnMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVHdXR0ZXJzLFxuICAgICAgX3Byb3BzJGRpdmlkZXIgPSBwcm9wcy5kaXZpZGVyLFxuICAgICAgZGl2aWRlciA9IF9wcm9wcyRkaXZpZGVyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXZpZGVyLFxuICAgICAgZm9jdXNWaXNpYmxlQ2xhc3NOYW1lID0gcHJvcHMuZm9jdXNWaXNpYmxlQ2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJHNlbGVjdGVkID0gcHJvcHMuc2VsZWN0ZWQsXG4gICAgICBzZWxlY3RlZCA9IF9wcm9wcyRzZWxlY3RlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkc2VsZWN0ZWQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYWxpZ25JdGVtc1wiLCBcImF1dG9Gb2N1c1wiLCBcImJ1dHRvblwiLCBcImNoaWxkcmVuXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNvbXBvbmVudFwiLCBcIkNvbnRhaW5lckNvbXBvbmVudFwiLCBcIkNvbnRhaW5lclByb3BzXCIsIFwiZGVuc2VcIiwgXCJkaXNhYmxlZFwiLCBcImRpc2FibGVHdXR0ZXJzXCIsIFwiZGl2aWRlclwiLCBcImZvY3VzVmlzaWJsZUNsYXNzTmFtZVwiLCBcInNlbGVjdGVkXCJdKTtcblxuICB2YXIgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTGlzdENvbnRleHQpO1xuICB2YXIgY2hpbGRDb250ZXh0ID0ge1xuICAgIGRlbnNlOiBkZW5zZSB8fCBjb250ZXh0LmRlbnNlIHx8IGZhbHNlLFxuICAgIGFsaWduSXRlbXM6IGFsaWduSXRlbXNcbiAgfTtcbiAgdmFyIGxpc3RJdGVtUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB1c2VFbmhhbmNlZEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGF1dG9Gb2N1cykge1xuICAgICAgaWYgKGxpc3RJdGVtUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbGlzdEl0ZW1SZWYuY3VycmVudC5mb2N1cygpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01hdGVyaWFsLVVJOiBVbmFibGUgdG8gc2V0IGZvY3VzIHRvIGEgTGlzdEl0ZW0gd2hvc2UgY29tcG9uZW50IGhhcyBub3QgYmVlbiByZW5kZXJlZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFthdXRvRm9jdXNdKTtcbiAgdmFyIGNoaWxkcmVuID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlblByb3ApO1xuICB2YXIgaGFzU2Vjb25kYXJ5QWN0aW9uID0gY2hpbGRyZW4ubGVuZ3RoICYmIGlzTXVpRWxlbWVudChjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSwgWydMaXN0SXRlbVNlY29uZGFyeUFjdGlvbiddKTtcbiAgdmFyIGhhbmRsZU93blJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIC8vICNTdHJpY3RNb2RlIHJlYWR5XG4gICAgbGlzdEl0ZW1SZWYuY3VycmVudCA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKGluc3RhbmNlKTtcbiAgfSwgW10pO1xuICB2YXIgaGFuZGxlUmVmID0gdXNlRm9ya1JlZihoYW5kbGVPd25SZWYsIHJlZik7XG5cbiAgdmFyIGNvbXBvbmVudFByb3BzID0gX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSwgY2hpbGRDb250ZXh0LmRlbnNlICYmIGNsYXNzZXMuZGVuc2UsICFkaXNhYmxlR3V0dGVycyAmJiBjbGFzc2VzLmd1dHRlcnMsIGRpdmlkZXIgJiYgY2xhc3Nlcy5kaXZpZGVyLCBkaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkLCBidXR0b24gJiYgY2xhc3Nlcy5idXR0b24sIGFsaWduSXRlbXMgIT09IFwiY2VudGVyXCIgJiYgY2xhc3Nlcy5hbGlnbkl0ZW1zRmxleFN0YXJ0LCBoYXNTZWNvbmRhcnlBY3Rpb24gJiYgY2xhc3Nlcy5zZWNvbmRhcnlBY3Rpb24sIHNlbGVjdGVkICYmIGNsYXNzZXMuc2VsZWN0ZWQpLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZFxuICB9LCBvdGhlcik7XG5cbiAgdmFyIENvbXBvbmVudCA9IGNvbXBvbmVudFByb3AgfHwgJ2xpJztcblxuICBpZiAoYnV0dG9uKSB7XG4gICAgY29tcG9uZW50UHJvcHMuY29tcG9uZW50ID0gY29tcG9uZW50UHJvcCB8fCAnZGl2JztcbiAgICBjb21wb25lbnRQcm9wcy5mb2N1c1Zpc2libGVDbGFzc05hbWUgPSBjbHN4KGNsYXNzZXMuZm9jdXNWaXNpYmxlLCBmb2N1c1Zpc2libGVDbGFzc05hbWUpO1xuICAgIENvbXBvbmVudCA9IEJ1dHRvbkJhc2U7XG4gIH1cblxuICBpZiAoaGFzU2Vjb25kYXJ5QWN0aW9uKSB7XG4gICAgLy8gVXNlIGRpdiBieSBkZWZhdWx0LlxuICAgIENvbXBvbmVudCA9ICFjb21wb25lbnRQcm9wcy5jb21wb25lbnQgJiYgIWNvbXBvbmVudFByb3AgPyAnZGl2JyA6IENvbXBvbmVudDsgLy8gQXZvaWQgbmVzdGluZyBvZiBsaSA+IGxpLlxuXG4gICAgaWYgKENvbnRhaW5lckNvbXBvbmVudCA9PT0gJ2xpJykge1xuICAgICAgaWYgKENvbXBvbmVudCA9PT0gJ2xpJykge1xuICAgICAgICBDb21wb25lbnQgPSAnZGl2JztcbiAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50UHJvcHMuY29tcG9uZW50ID09PSAnbGknKSB7XG4gICAgICAgIGNvbXBvbmVudFByb3BzLmNvbXBvbmVudCA9ICdkaXYnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNoaWxkQ29udGV4dFxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbnRhaW5lckNvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMuY29udGFpbmVyLCBDb250YWluZXJDbGFzc05hbWUpLFxuICAgICAgcmVmOiBoYW5kbGVSZWZcbiAgICB9LCBDb250YWluZXJQcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgY29tcG9uZW50UHJvcHMsIGNoaWxkcmVuKSwgY2hpbGRyZW4ucG9wKCkpKTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjaGlsZENvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBoYW5kbGVSZWZcbiAgfSwgY29tcG9uZW50UHJvcHMpLCBjaGlsZHJlbikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBMaXN0SXRlbS5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBgYWxpZ24taXRlbXNgIHN0eWxlIHByb3BlcnR5LlxuICAgKi9cbiAgYWxpZ25JdGVtczogUHJvcFR5cGVzLm9uZU9mKFsnZmxleC1zdGFydCcsICdjZW50ZXInXSksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxpc3QgaXRlbSB3aWxsIGJlIGZvY3VzZWQgZHVyaW5nIHRoZSBmaXJzdCBtb3VudC5cbiAgICogRm9jdXMgd2lsbCBhbHNvIGJlIHRyaWdnZXJlZCBpZiB0aGUgdmFsdWUgY2hhbmdlcyBmcm9tIGZhbHNlIHRvIHRydWUuXG4gICAqL1xuICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsaXN0IGl0ZW0gd2lsbCBiZSBhIGJ1dHRvbiAodXNpbmcgYEJ1dHRvbkJhc2VgKS4gUHJvcHMgaW50ZW5kZWRcbiAgICogZm9yIGBCdXR0b25CYXNlYCBjYW4gdGhlbiBiZSBhcHBsaWVkIHRvIGBMaXN0SXRlbWAuXG4gICAqL1xuICBidXR0b246IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LiBJZiBhIGBMaXN0SXRlbVNlY29uZGFyeUFjdGlvbmAgaXMgdXNlZCBpdCBtdXN0XG4gICAqIGJlIHRoZSBsYXN0IGNoaWxkLlxuICAgKi9cbiAgY2hpbGRyZW46IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5ub2RlLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KHByb3BzLmNoaWxkcmVuKTsgLy8gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShwcm9wcy5jaGlsZHJlbikuZmluZExhc3RJbmRleChpc0xpc3RJdGVtU2Vjb25kYXJ5QWN0aW9uKVxuXG4gICAgdmFyIHNlY29uZGFyeUFjdGlvbkluZGV4ID0gLTE7XG5cbiAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoaXNNdWlFbGVtZW50KGNoaWxkLCBbJ0xpc3RJdGVtU2Vjb25kYXJ5QWN0aW9uJ10pKSB7XG4gICAgICAgIHNlY29uZGFyeUFjdGlvbkluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyAgaXMgTGlzdEl0ZW1TZWNvbmRhcnlBY3Rpb24gdGhlIGxhc3QgY2hpbGQgb2YgTGlzdEl0ZW1cblxuXG4gICAgaWYgKHNlY29uZGFyeUFjdGlvbkluZGV4ICE9PSAtMSAmJiBzZWNvbmRhcnlBY3Rpb25JbmRleCAhPT0gY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWF0ZXJpYWwtVUk6IFlvdSB1c2VkIGFuIGVsZW1lbnQgYWZ0ZXIgTGlzdEl0ZW1TZWNvbmRhcnlBY3Rpb24uICcgKyAnRm9yIExpc3RJdGVtIHRvIGRldGVjdCB0aGF0IGl0IGhhcyBhIHNlY29uZGFyeSBhY3Rpb24gJyArICd5b3UgbXVzdCBwYXNzIGl0IGFzIHRoZSBsYXN0IGNoaWxkIHRvIExpc3RJdGVtLicpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9KSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKiBCeSBkZWZhdWx0LCBpdCdzIGEgYGxpYCB3aGVuIGBidXR0b25gIGlzIGBmYWxzZWAgYW5kIGEgYGRpdmAgd2hlbiBgYnV0dG9uYCBpcyBgdHJ1ZWAuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogVGhlIGNvbnRhaW5lciBjb21wb25lbnQgdXNlZCB3aGVuIGEgYExpc3RJdGVtU2Vjb25kYXJ5QWN0aW9uYCBpcyB0aGUgbGFzdCBjaGlsZC5cbiAgICovXG4gIENvbnRhaW5lckNvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBjb250YWluZXIgY29tcG9uZW50IGlmIHVzZWQuXG4gICAqL1xuICBDb250YWluZXJQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBjb21wYWN0IHZlcnRpY2FsIHBhZGRpbmcgZGVzaWduZWQgZm9yIGtleWJvYXJkIGFuZCBtb3VzZSBpbnB1dCB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBkZW5zZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxpc3QgaXRlbSB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsZWZ0IGFuZCByaWdodCBwYWRkaW5nIGlzIHJlbW92ZWQuXG4gICAqL1xuICBkaXNhYmxlR3V0dGVyczogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYSAxcHggbGlnaHQgYm9yZGVyIGlzIGFkZGVkIHRvIHRoZSBib3R0b20gb2YgdGhlIGxpc3QgaXRlbS5cbiAgICovXG4gIGRpdmlkZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmb2N1c1Zpc2libGVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFVzZSB0byBhcHBseSBzZWxlY3RlZCBzdHlsaW5nLlxuICAgKi9cbiAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5ib29sXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUxpc3RJdGVtJ1xufSkoTGlzdEl0ZW0pOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCBUeXBvZ3JhcGh5IGZyb20gJy4uL1R5cG9ncmFwaHknO1xuaW1wb3J0IExpc3RDb250ZXh0IGZyb20gJy4uL0xpc3QvTGlzdENvbnRleHQnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gIHJvb3Q6IHtcbiAgICBmbGV4OiAnMSAxIGF1dG8nLFxuICAgIG1pbldpZHRoOiAwLFxuICAgIG1hcmdpblRvcDogNCxcbiAgICBtYXJnaW5Cb3R0b206IDRcbiAgfSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYFR5cG9ncmFwaHlgIGNvbXBvbmVudHMgaWYgcHJpbWFyeSBhbmQgc2Vjb25kYXJ5IGFyZSBzZXQuICovXG4gIG11bHRpbGluZToge1xuICAgIG1hcmdpblRvcDogNixcbiAgICBtYXJnaW5Cb3R0b206IDZcbiAgfSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYFR5cG9ncmFwaHlgIGNvbXBvbmVudHMgaWYgZGVuc2UuICovXG4gIGRlbnNlOiB7fSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBpbnNldD17dHJ1ZX1gLiAqL1xuICBpbnNldDoge1xuICAgIHBhZGRpbmdMZWZ0OiA1NlxuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBwcmltYXJ5IGBUeXBvZ3JhcGh5YCBjb21wb25lbnQuICovXG4gIHByaW1hcnk6IHt9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBzZWNvbmRhcnkgYFR5cG9ncmFwaHlgIGNvbXBvbmVudC4gKi9cbiAgc2Vjb25kYXJ5OiB7fVxufTtcbnZhciBMaXN0SXRlbVRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBMaXN0SXRlbVRleHQocHJvcHMsIHJlZikge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJGRpc2FibGVUeXBvZ3JhID0gcHJvcHMuZGlzYWJsZVR5cG9ncmFwaHksXG4gICAgICBkaXNhYmxlVHlwb2dyYXBoeSA9IF9wcm9wcyRkaXNhYmxlVHlwb2dyYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVR5cG9ncmEsXG4gICAgICBfcHJvcHMkaW5zZXQgPSBwcm9wcy5pbnNldCxcbiAgICAgIGluc2V0ID0gX3Byb3BzJGluc2V0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRpbnNldCxcbiAgICAgIHByaW1hcnlQcm9wID0gcHJvcHMucHJpbWFyeSxcbiAgICAgIHByaW1hcnlUeXBvZ3JhcGh5UHJvcHMgPSBwcm9wcy5wcmltYXJ5VHlwb2dyYXBoeVByb3BzLFxuICAgICAgc2Vjb25kYXJ5UHJvcCA9IHByb3BzLnNlY29uZGFyeSxcbiAgICAgIHNlY29uZGFyeVR5cG9ncmFwaHlQcm9wcyA9IHByb3BzLnNlY29uZGFyeVR5cG9ncmFwaHlQcm9wcyxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJkaXNhYmxlVHlwb2dyYXBoeVwiLCBcImluc2V0XCIsIFwicHJpbWFyeVwiLCBcInByaW1hcnlUeXBvZ3JhcGh5UHJvcHNcIiwgXCJzZWNvbmRhcnlcIiwgXCJzZWNvbmRhcnlUeXBvZ3JhcGh5UHJvcHNcIl0pO1xuXG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTGlzdENvbnRleHQpLFxuICAgICAgZGVuc2UgPSBfUmVhY3QkdXNlQ29udGV4dC5kZW5zZTtcblxuICB2YXIgcHJpbWFyeSA9IHByaW1hcnlQcm9wICE9IG51bGwgPyBwcmltYXJ5UHJvcCA6IGNoaWxkcmVuO1xuXG4gIGlmIChwcmltYXJ5ICE9IG51bGwgJiYgcHJpbWFyeS50eXBlICE9PSBUeXBvZ3JhcGh5ICYmICFkaXNhYmxlVHlwb2dyYXBoeSkge1xuICAgIHByaW1hcnkgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUeXBvZ3JhcGh5LCBfZXh0ZW5kcyh7XG4gICAgICB2YXJpYW50OiBkZW5zZSA/ICdib2R5MicgOiAnYm9keTEnLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzLnByaW1hcnksXG4gICAgICBjb21wb25lbnQ6IFwic3BhblwiLFxuICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgfSwgcHJpbWFyeVR5cG9ncmFwaHlQcm9wcyksIHByaW1hcnkpO1xuICB9XG5cbiAgdmFyIHNlY29uZGFyeSA9IHNlY29uZGFyeVByb3A7XG5cbiAgaWYgKHNlY29uZGFyeSAhPSBudWxsICYmIHNlY29uZGFyeS50eXBlICE9PSBUeXBvZ3JhcGh5ICYmICFkaXNhYmxlVHlwb2dyYXBoeSkge1xuICAgIHNlY29uZGFyeSA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFR5cG9ncmFwaHksIF9leHRlbmRzKHtcbiAgICAgIHZhcmlhbnQ6IFwiYm9keTJcIixcbiAgICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5zZWNvbmRhcnksXG4gICAgICBjb2xvcjogXCJ0ZXh0U2Vjb25kYXJ5XCIsXG4gICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICB9LCBzZWNvbmRhcnlUeXBvZ3JhcGh5UHJvcHMpLCBzZWNvbmRhcnkpO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUsIGRlbnNlICYmIGNsYXNzZXMuZGVuc2UsIGluc2V0ICYmIGNsYXNzZXMuaW5zZXQsIHByaW1hcnkgJiYgc2Vjb25kYXJ5ICYmIGNsYXNzZXMubXVsdGlsaW5lKSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlciksIHByaW1hcnksIHNlY29uZGFyeSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IExpc3RJdGVtVGV4dC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgdGhlIGBwcmltYXJ5YCBwcm9wLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY2hpbGRyZW4gd29uJ3QgYmUgd3JhcHBlZCBieSBhIFR5cG9ncmFwaHkgY29tcG9uZW50LlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gcmVuZGVyIGFuIGFsdGVybmF0aXZlIFR5cG9ncmFwaHkgdmFyaWFudCBieSB3cmFwcGluZ1xuICAgKiB0aGUgYGNoaWxkcmVuYCAob3IgYHByaW1hcnlgKSB0ZXh0LCBhbmQgb3B0aW9uYWwgYHNlY29uZGFyeWAgdGV4dFxuICAgKiB3aXRoIHRoZSBUeXBvZ3JhcGh5IGNvbXBvbmVudC5cbiAgICovXG4gIGRpc2FibGVUeXBvZ3JhcGh5OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY2hpbGRyZW4gd2lsbCBiZSBpbmRlbnRlZC5cbiAgICogVGhpcyBzaG91bGQgYmUgdXNlZCBpZiB0aGVyZSBpcyBubyBsZWZ0IGF2YXRhciBvciBsZWZ0IGljb24uXG4gICAqL1xuICBpbnNldDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIGNvbnRlbnQgZWxlbWVudC5cbiAgICovXG4gIHByaW1hcnk6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBUaGVzZSBwcm9wcyB3aWxsIGJlIGZvcndhcmRlZCB0byB0aGUgcHJpbWFyeSB0eXBvZ3JhcGh5IGNvbXBvbmVudFxuICAgKiAoYXMgbG9uZyBhcyBkaXNhYmxlVHlwb2dyYXBoeSBpcyBub3QgYHRydWVgKS5cbiAgICovXG4gIHByaW1hcnlUeXBvZ3JhcGh5UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFRoZSBzZWNvbmRhcnkgY29udGVudCBlbGVtZW50LlxuICAgKi9cbiAgc2Vjb25kYXJ5OiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogVGhlc2UgcHJvcHMgd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGhlIHNlY29uZGFyeSB0eXBvZ3JhcGh5IGNvbXBvbmVudFxuICAgKiAoYXMgbG9uZyBhcyBkaXNhYmxlVHlwb2dyYXBoeSBpcyBub3QgYHRydWVgKS5cbiAgICovXG4gIHNlY29uZGFyeVR5cG9ncmFwaHlQcm9wczogUHJvcFR5cGVzLm9iamVjdFxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlMaXN0SXRlbVRleHQnXG59KShMaXN0SXRlbVRleHQpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCB7IGZhZGUgfSBmcm9tICcuLi9zdHlsZXMvY29sb3JNYW5pcHVsYXRvcic7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgaGVpZ2h0OiAxLFxuICAgICAgbWFyZ2luOiAwLFxuICAgICAgLy8gUmVzZXQgYnJvd3NlciBkZWZhdWx0IHN0eWxlLlxuICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLmRpdmlkZXJcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgYWJzb2x1dGU9e3RydWV9YC4gKi9cbiAgICBhYnNvbHV0ZToge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGB2YXJpYW50PVwiaW5zZXRcImAuICovXG4gICAgaW5zZXQ6IHtcbiAgICAgIG1hcmdpbkxlZnQ6IDcyXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGxpZ2h0PXt0cnVlfWAuICovXG4gICAgbGlnaHQ6IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogZmFkZSh0aGVtZS5wYWxldHRlLmRpdmlkZXIsIDAuMDgpXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJtaWRkbGVcImAuICovXG4gICAgbWlkZGxlOiB7XG4gICAgICBtYXJnaW5MZWZ0OiB0aGVtZS5zcGFjaW5nKDIpLFxuICAgICAgbWFyZ2luUmlnaHQ6IHRoZW1lLnNwYWNpbmcoMilcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgb3JpZW50YXRpb249XCJ2ZXJ0aWNhbFwiYC4gKi9cbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICB3aWR0aDogMVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBmbGV4SXRlbT17dHJ1ZX1gLiAqL1xuICAgIGZsZXhJdGVtOiB7XG4gICAgICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgICAgIGhlaWdodDogJ2F1dG8nXG4gICAgfVxuICB9O1xufTtcbnZhciBEaXZpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRGl2aWRlcihwcm9wcywgcmVmKSB7XG4gIHZhciBfcHJvcHMkYWJzb2x1dGUgPSBwcm9wcy5hYnNvbHV0ZSxcbiAgICAgIGFic29sdXRlID0gX3Byb3BzJGFic29sdXRlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRhYnNvbHV0ZSxcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJGNvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgIENvbXBvbmVudCA9IF9wcm9wcyRjb21wb25lbnQgPT09IHZvaWQgMCA/ICdocicgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgX3Byb3BzJGZsZXhJdGVtID0gcHJvcHMuZmxleEl0ZW0sXG4gICAgICBmbGV4SXRlbSA9IF9wcm9wcyRmbGV4SXRlbSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZmxleEl0ZW0sXG4gICAgICBfcHJvcHMkbGlnaHQgPSBwcm9wcy5saWdodCxcbiAgICAgIGxpZ2h0ID0gX3Byb3BzJGxpZ2h0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRsaWdodCxcbiAgICAgIF9wcm9wcyRvcmllbnRhdGlvbiA9IHByb3BzLm9yaWVudGF0aW9uLFxuICAgICAgb3JpZW50YXRpb24gPSBfcHJvcHMkb3JpZW50YXRpb24gPT09IHZvaWQgMCA/ICdob3Jpem9udGFsJyA6IF9wcm9wcyRvcmllbnRhdGlvbixcbiAgICAgIF9wcm9wcyRyb2xlID0gcHJvcHMucm9sZSxcbiAgICAgIHJvbGUgPSBfcHJvcHMkcm9sZSA9PT0gdm9pZCAwID8gQ29tcG9uZW50ICE9PSAnaHInID8gJ3NlcGFyYXRvcicgOiB1bmRlZmluZWQgOiBfcHJvcHMkcm9sZSxcbiAgICAgIF9wcm9wcyR2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIHZhcmlhbnQgPSBfcHJvcHMkdmFyaWFudCA9PT0gdm9pZCAwID8gJ2Z1bGxXaWR0aCcgOiBfcHJvcHMkdmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhYnNvbHV0ZVwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb21wb25lbnRcIiwgXCJmbGV4SXRlbVwiLCBcImxpZ2h0XCIsIFwib3JpZW50YXRpb25cIiwgXCJyb2xlXCIsIFwidmFyaWFudFwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSwgdmFyaWFudCAhPT0gJ2Z1bGxXaWR0aCcgJiYgY2xhc3Nlc1t2YXJpYW50XSwgYWJzb2x1dGUgJiYgY2xhc3Nlcy5hYnNvbHV0ZSwgZmxleEl0ZW0gJiYgY2xhc3Nlcy5mbGV4SXRlbSwgbGlnaHQgJiYgY2xhc3Nlcy5saWdodCwgb3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgY2xhc3Nlcy52ZXJ0aWNhbCksXG4gICAgcm9sZTogcm9sZSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlcikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBEaXZpZGVyLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEFic29sdXRlbHkgcG9zaXRpb24gdGhlIGVsZW1lbnQuXG4gICAqL1xuICBhYnNvbHV0ZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGEgdmVydGljYWwgZGl2aWRlciB3aWxsIGhhdmUgdGhlIGNvcnJlY3QgaGVpZ2h0IHdoZW4gdXNlZCBpbiBmbGV4IGNvbnRhaW5lci5cbiAgICogKEJ5IGRlZmF1bHQsIGEgdmVydGljYWwgZGl2aWRlciB3aWxsIGhhdmUgYSBjYWxjdWxhdGVkIGhlaWdodCBvZiBgMHB4YCBpZiBpdCBpcyB0aGUgY2hpbGQgb2YgYSBmbGV4IGNvbnRhaW5lci4pXG4gICAqL1xuICBmbGV4SXRlbTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGRpdmlkZXIgd2lsbCBoYXZlIGEgbGlnaHRlciBjb2xvci5cbiAgICovXG4gIGxpZ2h0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGRpdmlkZXIgb3JpZW50YXRpb24uXG4gICAqL1xuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddKSxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgcm9sZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgdG8gdXNlLlxuICAgKi9cbiAgdmFyaWFudDogUHJvcFR5cGVzLm9uZU9mKFsnZnVsbFdpZHRoJywgJ2luc2V0JywgJ21pZGRsZSddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlEaXZpZGVyJ1xufSkoRGl2aWRlcik7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IExpc3RDb250ZXh0IGZyb20gJy4uL0xpc3QvTGlzdENvbnRleHQnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIG1pbldpZHRoOiA1NixcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5hY3RpdmUsXG4gICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1mbGV4J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IHdoZW4gdGhlIHBhcmVudCBgTGlzdEl0ZW1gIHVzZXMgYGFsaWduSXRlbXM9XCJmbGV4LXN0YXJ0XCJgLiAqL1xuICAgIGFsaWduSXRlbXNGbGV4U3RhcnQ6IHtcbiAgICAgIG1hcmdpblRvcDogOFxuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEEgc2ltcGxlIHdyYXBwZXIgdG8gYXBwbHkgYExpc3RgIHN0eWxlcyB0byBhbiBgSWNvbmAgb3IgYFN2Z0ljb25gLlxuICovXG5cbnZhciBMaXN0SXRlbUljb24gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBMaXN0SXRlbUljb24ocHJvcHMsIHJlZikge1xuICB2YXIgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgdmFyIGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KExpc3RDb250ZXh0KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUsIGNvbnRleHQuYWxpZ25JdGVtcyA9PT0gJ2ZsZXgtc3RhcnQnICYmIGNsYXNzZXMuYWxpZ25JdGVtc0ZsZXhTdGFydCksXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gTGlzdEl0ZW1JY29uLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQsIG5vcm1hbGx5IGBJY29uYCwgYFN2Z0ljb25gLFxuICAgKiBvciBhIGBAbWF0ZXJpYWwtdWkvaWNvbnNgIFNWRyBpY29uIGVsZW1lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUxpc3RJdGVtSWNvbidcbn0pKExpc3RJdGVtSWNvbik7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybUNvbnRyb2xTdGF0ZShfcmVmKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICBzdGF0ZXMgPSBfcmVmLnN0YXRlcyxcbiAgICAgIG11aUZvcm1Db250cm9sID0gX3JlZi5tdWlGb3JtQ29udHJvbDtcbiAgcmV0dXJuIHN0YXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc3RhdGUpIHtcbiAgICBhY2Nbc3RhdGVdID0gcHJvcHNbc3RhdGVdO1xuXG4gICAgaWYgKG11aUZvcm1Db250cm9sKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzW3N0YXRlXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYWNjW3N0YXRlXSA9IG11aUZvcm1Db250cm9sW3N0YXRlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5cbnZhciBGb3JtQ29udHJvbENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEZvcm1Db250cm9sQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdGb3JtQ29udHJvbENvbnRleHQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9ybUNvbnRyb2woKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KEZvcm1Db250cm9sQ29udGV4dCk7XG59XG5leHBvcnQgZGVmYXVsdCBGb3JtQ29udHJvbENvbnRleHQ7IiwiLy8gQ29ycmVzcG9uZHMgdG8gMTAgZnJhbWVzIGF0IDYwIEh6LlxuLy8gQSBmZXcgYnl0ZXMgcGF5bG9hZCBvdmVyaGVhZCB3aGVuIGxvZGFzaC9kZWJvdW5jZSBpcyB+MyBrQiBhbmQgZGVib3VuY2UgfjMwMCBCLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZnVuYykge1xuICB2YXIgd2FpdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTY2O1xuICB2YXIgdGltZW91dDtcblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXRoaXNcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICAgIGZ1bmMuYXBwbHkodGhhdCwgYXJncyk7XG4gICAgfTtcblxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gIH1cblxuICBkZWJvdW5jZWQuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB9O1xuXG4gIHJldHVybiBkZWJvdW5jZWQ7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICcuLi91dGlscy9kZWJvdW5jZSc7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcblxuZnVuY3Rpb24gZ2V0U3R5bGVWYWx1ZShjb21wdXRlZFN0eWxlLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVtwcm9wZXJ0eV0sIDEwKSB8fCAwO1xufVxuXG52YXIgdXNlRW5oYW5jZWRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbnZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBzaGFkb3cgdGV4dGFyZWEgZWxlbWVudC4gKi9cbiAgc2hhZG93OiB7XG4gICAgLy8gVmlzaWJpbGl0eSBuZWVkZWQgdG8gaGlkZSB0aGUgZXh0cmEgdGV4dCBhcmVhIG9uIGlQYWRzXG4gICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgLy8gUmVtb3ZlIGZyb20gdGhlIGNvbnRlbnQgZmxvd1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIC8vIElnbm9yZSB0aGUgc2Nyb2xsYmFyIHdpZHRoXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIGhlaWdodDogMCxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICAvLyBDcmVhdGUgYSBuZXcgbGF5ZXIsIGluY3JlYXNlIHRoZSBpc29sYXRpb24gb2YgdGhlIGNvbXB1dGVkIHZhbHVlc1xuICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVooMCknXG4gIH1cbn07XG52YXIgVGV4dGFyZWFBdXRvc2l6ZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFRleHRhcmVhQXV0b3NpemUocHJvcHMsIHJlZikge1xuICB2YXIgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZSxcbiAgICAgIHJvd3MgPSBwcm9wcy5yb3dzLFxuICAgICAgcm93c01heCA9IHByb3BzLnJvd3NNYXgsXG4gICAgICBfcHJvcHMkcm93c01pbiA9IHByb3BzLnJvd3NNaW4sXG4gICAgICByb3dzTWluUHJvcCA9IF9wcm9wcyRyb3dzTWluID09PSB2b2lkIDAgPyAxIDogX3Byb3BzJHJvd3NNaW4sXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJvbkNoYW5nZVwiLCBcInJvd3NcIiwgXCJyb3dzTWF4XCIsIFwicm93c01pblwiLCBcInN0eWxlXCIsIFwidmFsdWVcIl0pO1xuXG4gIHZhciByb3dzTWluID0gcm93cyB8fCByb3dzTWluUHJvcDtcblxuICB2YXIgX1JlYWN0JHVzZVJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSAhPSBudWxsKSxcbiAgICAgIGlzQ29udHJvbGxlZCA9IF9SZWFjdCR1c2VSZWYuY3VycmVudDtcblxuICB2YXIgaW5wdXRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBoYW5kbGVSZWYgPSB1c2VGb3JrUmVmKHJlZiwgaW5wdXRSZWYpO1xuICB2YXIgc2hhZG93UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgcmVuZGVycyA9IFJlYWN0LnVzZVJlZigwKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoe30pLFxuICAgICAgc3RhdGUgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXRTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgc3luY0hlaWdodCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5wdXQgPSBpbnB1dFJlZi5jdXJyZW50O1xuICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaW5wdXQpO1xuICAgIHZhciBpbnB1dFNoYWxsb3cgPSBzaGFkb3dSZWYuY3VycmVudDtcbiAgICBpbnB1dFNoYWxsb3cuc3R5bGUud2lkdGggPSBjb21wdXRlZFN0eWxlLndpZHRoO1xuICAgIGlucHV0U2hhbGxvdy52YWx1ZSA9IGlucHV0LnZhbHVlIHx8IHByb3BzLnBsYWNlaG9sZGVyIHx8ICd4JztcblxuICAgIGlmIChpbnB1dFNoYWxsb3cudmFsdWUuc2xpY2UoLTEpID09PSAnXFxuJykge1xuICAgICAgLy8gQ2VydGFpbiBmb250cyB3aGljaCBvdmVyZmxvdyB0aGUgbGluZSBoZWlnaHQgd2lsbCBjYXVzZSB0aGUgdGV4dGFyZWFcbiAgICAgIC8vIHRvIHJlcG9ydCBhIGRpZmZlcmVudCBzY3JvbGxIZWlnaHQgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGxhc3QgbGluZVxuICAgICAgLy8gaXMgZW1wdHkuIE1ha2UgaXQgbm9uLWVtcHR5IHRvIGF2b2lkIHRoaXMgaXNzdWUuXG4gICAgICBpbnB1dFNoYWxsb3cudmFsdWUgKz0gJyAnO1xuICAgIH1cblxuICAgIHZhciBib3hTaXppbmcgPSBjb21wdXRlZFN0eWxlWydib3gtc2l6aW5nJ107XG4gICAgdmFyIHBhZGRpbmcgPSBnZXRTdHlsZVZhbHVlKGNvbXB1dGVkU3R5bGUsICdwYWRkaW5nLWJvdHRvbScpICsgZ2V0U3R5bGVWYWx1ZShjb21wdXRlZFN0eWxlLCAncGFkZGluZy10b3AnKTtcbiAgICB2YXIgYm9yZGVyID0gZ2V0U3R5bGVWYWx1ZShjb21wdXRlZFN0eWxlLCAnYm9yZGVyLWJvdHRvbS13aWR0aCcpICsgZ2V0U3R5bGVWYWx1ZShjb21wdXRlZFN0eWxlLCAnYm9yZGVyLXRvcC13aWR0aCcpOyAvLyBUaGUgaGVpZ2h0IG9mIHRoZSBpbm5lciBjb250ZW50XG5cbiAgICB2YXIgaW5uZXJIZWlnaHQgPSBpbnB1dFNoYWxsb3cuc2Nyb2xsSGVpZ2h0IC0gcGFkZGluZzsgLy8gTWVhc3VyZSBoZWlnaHQgb2YgYSB0ZXh0YXJlYSB3aXRoIGEgc2luZ2xlIHJvd1xuXG4gICAgaW5wdXRTaGFsbG93LnZhbHVlID0gJ3gnO1xuICAgIHZhciBzaW5nbGVSb3dIZWlnaHQgPSBpbnB1dFNoYWxsb3cuc2Nyb2xsSGVpZ2h0IC0gcGFkZGluZzsgLy8gVGhlIGhlaWdodCBvZiB0aGUgb3V0ZXIgY29udGVudFxuXG4gICAgdmFyIG91dGVySGVpZ2h0ID0gaW5uZXJIZWlnaHQ7XG5cbiAgICBpZiAocm93c01pbikge1xuICAgICAgb3V0ZXJIZWlnaHQgPSBNYXRoLm1heChOdW1iZXIocm93c01pbikgKiBzaW5nbGVSb3dIZWlnaHQsIG91dGVySGVpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAocm93c01heCkge1xuICAgICAgb3V0ZXJIZWlnaHQgPSBNYXRoLm1pbihOdW1iZXIocm93c01heCkgKiBzaW5nbGVSb3dIZWlnaHQsIG91dGVySGVpZ2h0KTtcbiAgICB9XG5cbiAgICBvdXRlckhlaWdodCA9IE1hdGgubWF4KG91dGVySGVpZ2h0LCBzaW5nbGVSb3dIZWlnaHQpOyAvLyBUYWtlIHRoZSBib3ggc2l6aW5nIGludG8gYWNjb3VudCBmb3IgYXBwbHlpbmcgdGhpcyB2YWx1ZSBhcyBhIHN0eWxlLlxuXG4gICAgdmFyIG91dGVySGVpZ2h0U3R5bGUgPSBvdXRlckhlaWdodCArIChib3hTaXppbmcgPT09ICdib3JkZXItYm94JyA/IHBhZGRpbmcgKyBib3JkZXIgOiAwKTtcbiAgICB2YXIgb3ZlcmZsb3cgPSBNYXRoLmFicyhvdXRlckhlaWdodCAtIGlubmVySGVpZ2h0KSA8PSAxO1xuICAgIHNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgIC8vIE5lZWQgYSBsYXJnZSBlbm91Z2ggZGlmZmVyZW5jZSB0byB1cGRhdGUgdGhlIGhlaWdodC5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgaW5maW5pdGUgcmVuZGVyaW5nIGxvb3AuXG4gICAgICBpZiAocmVuZGVycy5jdXJyZW50IDwgMjAgJiYgKG91dGVySGVpZ2h0U3R5bGUgPiAwICYmIE1hdGguYWJzKChwcmV2U3RhdGUub3V0ZXJIZWlnaHRTdHlsZSB8fCAwKSAtIG91dGVySGVpZ2h0U3R5bGUpID4gMSB8fCBwcmV2U3RhdGUub3ZlcmZsb3cgIT09IG92ZXJmbG93KSkge1xuICAgICAgICByZW5kZXJzLmN1cnJlbnQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvdmVyZmxvdzogb3ZlcmZsb3csXG4gICAgICAgICAgb3V0ZXJIZWlnaHRTdHlsZTogb3V0ZXJIZWlnaHRTdHlsZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAocmVuZGVycy5jdXJyZW50ID09PSAyMCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoWydNYXRlcmlhbC1VSTogVG9vIG1hbnkgcmUtcmVuZGVycy4gVGhlIGxheW91dCBpcyB1bnN0YWJsZS4nLCAnVGV4dGFyZWFBdXRvc2l6ZSBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC4nXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICB9KTtcbiAgfSwgW3Jvd3NNYXgsIHJvd3NNaW4sIHByb3BzLnBsYWNlaG9sZGVyXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZVJlc2l6ZSA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbmRlcnMuY3VycmVudCA9IDA7XG4gICAgICBzeW5jSGVpZ2h0KCk7XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGhhbmRsZVJlc2l6ZS5jbGVhcigpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgfTtcbiAgfSwgW3N5bmNIZWlnaHRdKTtcbiAgdXNlRW5oYW5jZWRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHN5bmNIZWlnaHQoKTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVuZGVycy5jdXJyZW50ID0gMDtcbiAgfSwgW3ZhbHVlXSk7XG5cbiAgdmFyIGhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShldmVudCkge1xuICAgIHJlbmRlcnMuY3VycmVudCA9IDA7XG5cbiAgICBpZiAoIWlzQ29udHJvbGxlZCkge1xuICAgICAgc3luY0hlaWdodCgpO1xuICAgIH1cblxuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgb25DaGFuZ2UoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIiwgX2V4dGVuZHMoe1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLFxuICAgIHJlZjogaGFuZGxlUmVmIC8vIEFwcGx5IHRoZSByb3dzIHByb3AgdG8gZ2V0IGEgXCJjb3JyZWN0XCIgZmlyc3QgU1NSIHBhaW50XG4gICAgLFxuICAgIHJvd3M6IHJvd3NNaW4sXG4gICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgIGhlaWdodDogc3RhdGUub3V0ZXJIZWlnaHRTdHlsZSxcbiAgICAgIC8vIE5lZWQgYSBsYXJnZSBlbm91Z2ggZGlmZmVyZW5jZSB0byBhbGxvdyBzY3JvbGxpbmcuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIGluZmluaXRlIHJlbmRlcmluZyBsb29wLlxuICAgICAgb3ZlcmZsb3c6IHN0YXRlLm92ZXJmbG93ID8gJ2hpZGRlbicgOiBudWxsXG4gICAgfSwgc3R5bGUpXG4gIH0sIG90aGVyKSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIiwge1xuICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICBjbGFzc05hbWU6IHByb3BzLmNsYXNzTmFtZSxcbiAgICByZWFkT25seTogdHJ1ZSxcbiAgICByZWY6IHNoYWRvd1JlZixcbiAgICB0YWJJbmRleDogLTEsXG4gICAgc3R5bGU6IF9leHRlbmRzKHt9LCBzdHlsZXMuc2hhZG93LCBzdHlsZSlcbiAgfSkpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBUZXh0YXJlYUF1dG9zaXplLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVXNlIGByb3dzTWluYCBpbnN0ZWFkLiBUaGUgcHJvcCB3aWxsIGJlIHJlbW92ZWQgaW4gdjUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICByb3dzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheS5cbiAgICovXG4gIHJvd3NNYXg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5LlxuICAgKi9cbiAgcm93c01pbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCBUZXh0YXJlYUF1dG9zaXplOyIsIi8vIFN1cHBvcnRzIGRldGVybWluYXRpb24gb2YgaXNDb250cm9sbGVkKCkuXG4vLyBDb250cm9sbGVkIGlucHV0IGFjY2VwdHMgaXRzIGN1cnJlbnQgdmFsdWUgYXMgYSBwcm9wLlxuLy9cbi8vIEBzZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9mb3Jtcy5odG1sI2NvbnRyb2xsZWQtY29tcG9uZW50c1xuLy8gQHBhcmFtIHZhbHVlXG4vLyBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBzdHJpbmcgKGluY2x1ZGluZyAnJykgb3IgbnVtYmVyIChpbmNsdWRpbmcgemVybylcbmV4cG9ydCBmdW5jdGlvbiBoYXNWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAhKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCk7XG59IC8vIERldGVybWluZSBpZiBmaWVsZCBpcyBlbXB0eSBvciBmaWxsZWQuXG4vLyBSZXNwb25zZSBkZXRlcm1pbmVzIGlmIGxhYmVsIGlzIHByZXNlbnRlZCBhYm92ZSBmaWVsZCBvciBhcyBwbGFjZWhvbGRlci5cbi8vXG4vLyBAcGFyYW0gb2JqXG4vLyBAcGFyYW0gU1NSXG4vLyBAcmV0dXJucyB7Ym9vbGVhbn0gRmFsc2Ugd2hlbiBub3QgcHJlc2VudCBvciBlbXB0eSBzdHJpbmcuXG4vLyAgICAgICAgICAgICAgICAgICAgVHJ1ZSB3aGVuIGFueSBudW1iZXIgb3Igc3RyaW5nIHdpdGggbGVuZ3RoLlxuXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxsZWQob2JqKSB7XG4gIHZhciBTU1IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICByZXR1cm4gb2JqICYmIChoYXNWYWx1ZShvYmoudmFsdWUpICYmIG9iai52YWx1ZSAhPT0gJycgfHwgU1NSICYmIGhhc1ZhbHVlKG9iai5kZWZhdWx0VmFsdWUpICYmIG9iai5kZWZhdWx0VmFsdWUgIT09ICcnKTtcbn0gLy8gRGV0ZXJtaW5lIGlmIGFuIElucHV0IGlzIGFkb3JuZWQgb24gc3RhcnQuXG4vLyBJdCdzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGxlZnQgd2l0aCBMVFIuXG4vL1xuLy8gQHBhcmFtIG9ialxuLy8gQHJldHVybnMge2Jvb2xlYW59IEZhbHNlIHdoZW4gbm8gYWRvcm5tZW50cy5cbi8vICAgICAgICAgICAgICAgICAgICBUcnVlIHdoZW4gYWRvcm5lZCBhdCB0aGUgc3RhcnQuXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fkb3JuZWRTdGFydChvYmopIHtcbiAgcmV0dXJuIG9iai5zdGFydEFkb3JubWVudDtcbn0iLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgeyBmb3JtYXRNdWlFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdE11aUVycm9yTWVzc2FnZSB9IGZyb20gXCJAbWF0ZXJpYWwtdWkvdXRpbHNcIjtcblxuLyogZXNsaW50LWRpc2FibGUganN4LWExMXkvY2xpY2stZXZlbnRzLWhhdmUta2V5LWV2ZW50cywganN4LWExMXkvbm8tc3RhdGljLWVsZW1lbnQtaW50ZXJhY3Rpb25zICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyByZWZUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBmb3JtQ29udHJvbFN0YXRlIGZyb20gJy4uL0Zvcm1Db250cm9sL2Zvcm1Db250cm9sU3RhdGUnO1xuaW1wb3J0IEZvcm1Db250cm9sQ29udGV4dCwgeyB1c2VGb3JtQ29udHJvbCB9IGZyb20gJy4uL0Zvcm1Db250cm9sL0Zvcm1Db250cm9sQ29udGV4dCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICcuLi91dGlscy9jYXBpdGFsaXplJztcbmltcG9ydCB1c2VGb3JrUmVmIGZyb20gJy4uL3V0aWxzL3VzZUZvcmtSZWYnO1xuaW1wb3J0IFRleHRhcmVhQXV0b3NpemUgZnJvbSAnLi4vVGV4dGFyZWFBdXRvc2l6ZSc7XG5pbXBvcnQgeyBpc0ZpbGxlZCB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgdmFyIGxpZ2h0ID0gdGhlbWUucGFsZXR0ZS50eXBlID09PSAnbGlnaHQnO1xuICB2YXIgcGxhY2Vob2xkZXIgPSB7XG4gICAgY29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgIG9wYWNpdHk6IGxpZ2h0ID8gMC40MiA6IDAuNSxcbiAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ29wYWNpdHknLCB7XG4gICAgICBkdXJhdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlclxuICAgIH0pXG4gIH07XG4gIHZhciBwbGFjZWhvbGRlckhpZGRlbiA9IHtcbiAgICBvcGFjaXR5OiAnMCAhaW1wb3J0YW50J1xuICB9O1xuICB2YXIgcGxhY2Vob2xkZXJWaXNpYmxlID0ge1xuICAgIG9wYWNpdHk6IGxpZ2h0ID8gMC40MiA6IDAuNVxuICB9O1xuICByZXR1cm4ge1xuICAgICdAZ2xvYmFsJzoge1xuICAgICAgJ0BrZXlmcmFtZXMgbXVpLWF1dG8tZmlsbCc6IHt9LFxuICAgICAgJ0BrZXlmcmFtZXMgbXVpLWF1dG8tZmlsbC1jYW5jZWwnOiB7fVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IF9leHRlbmRzKHt9LCB0aGVtZS50eXBvZ3JhcGh5LmJvZHkxLCB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50ZXh0LnByaW1hcnksXG4gICAgICBsaW5lSGVpZ2h0OiAnMS4xODc2ZW0nLFxuICAgICAgLy8gUmVzZXQgKDE5cHgpLCBtYXRjaCB0aGUgbmF0aXZlIGlucHV0IGxpbmUtaGVpZ2h0XG4gICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgIC8vIFByZXZlbnQgcGFkZGluZyBpc3N1ZSB3aXRoIGZ1bGxXaWR0aC5cbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgY3Vyc29yOiAndGV4dCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5kaXNhYmxlZCxcbiAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcbiAgICAgIH1cbiAgICB9KSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgdGhlIGNvbXBvbmVudCBpcyBhIGRlc2NlbmRhbnQgb2YgYEZvcm1Db250cm9sYC4gKi9cbiAgICBmb3JtQ29udHJvbDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb21wb25lbnQgaXMgZm9jdXNlZC4gKi9cbiAgICBmb2N1c2VkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVkPXt0cnVlfWAuICovXG4gICAgZGlzYWJsZWQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgc3RhcnRBZG9ybm1lbnRgIGlzIHByb3ZpZGVkLiAqL1xuICAgIGFkb3JuZWRTdGFydDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBlbmRBZG9ybm1lbnRgIGlzIHByb3ZpZGVkLiAqL1xuICAgIGFkb3JuZWRFbmQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZXJyb3I9e3RydWV9YC4gKi9cbiAgICBlcnJvcjoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtYXJnaW49XCJkZW5zZVwiYC4gKi9cbiAgICBtYXJnaW5EZW5zZToge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBtdWx0aWxpbmU9e3RydWV9YC4gKi9cbiAgICBtdWx0aWxpbmU6IHtcbiAgICAgIHBhZGRpbmc6IFwiXCIuY29uY2F0KDggLSAyLCBcInB4IDAgXCIpLmNvbmNhdCg4IC0gMSwgXCJweFwiKSxcbiAgICAgICcmJG1hcmdpbkRlbnNlJzoge1xuICAgICAgICBwYWRkaW5nVG9wOiA0IC0gMVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb2xvciBpcyBzZWNvbmRhcnkuICovXG4gICAgY29sb3JTZWNvbmRhcnk6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZnVsbFdpZHRoPXt0cnVlfWAuICovXG4gICAgZnVsbFdpZHRoOiB7XG4gICAgICB3aWR0aDogJzEwMCUnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuICovXG4gICAgaW5wdXQ6IHtcbiAgICAgIGZvbnQ6ICdpbmhlcml0JyxcbiAgICAgIGxldHRlclNwYWNpbmc6ICdpbmhlcml0JyxcbiAgICAgIGNvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHBhZGRpbmc6IFwiXCIuY29uY2F0KDggLSAyLCBcInB4IDAgXCIpLmNvbmNhdCg4IC0gMSwgXCJweFwiKSxcbiAgICAgIGJvcmRlcjogMCxcbiAgICAgIGJveFNpemluZzogJ2NvbnRlbnQtYm94JyxcbiAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgIGhlaWdodDogJzEuMTg3NmVtJyxcbiAgICAgIC8vIFJlc2V0ICgxOXB4KSwgbWF0Y2ggdGhlIG5hdGl2ZSBpbnB1dCBsaW5lLWhlaWdodFxuICAgICAgbWFyZ2luOiAwLFxuICAgICAgLy8gUmVzZXQgZm9yIFNhZmFyaVxuICAgICAgV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgLy8gTWFrZSB0aGUgZmxleCBpdGVtIHNocmluayB3aXRoIEZpcmVmb3hcbiAgICAgIG1pbldpZHRoOiAwLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIC8vIEZpeCBJRSAxMSB3aWR0aCBpc3N1ZVxuICAgICAgYW5pbWF0aW9uTmFtZTogJ211aS1hdXRvLWZpbGwtY2FuY2VsJyxcbiAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAnMTBtcycsXG4gICAgICAnJjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVyLFxuICAgICAgJyY6Oi1tb3otcGxhY2Vob2xkZXInOiBwbGFjZWhvbGRlcixcbiAgICAgIC8vIEZpcmVmb3ggMTkrXG4gICAgICAnJjotbXMtaW5wdXQtcGxhY2Vob2xkZXInOiBwbGFjZWhvbGRlcixcbiAgICAgIC8vIElFIDExXG4gICAgICAnJjo6LW1zLWlucHV0LXBsYWNlaG9sZGVyJzogcGxhY2Vob2xkZXIsXG4gICAgICAvLyBFZGdlXG4gICAgICAnJjpmb2N1cyc6IHtcbiAgICAgICAgb3V0bGluZTogMFxuICAgICAgfSxcbiAgICAgIC8vIFJlc2V0IEZpcmVmb3ggaW52YWxpZCByZXF1aXJlZCBpbnB1dCBzdHlsZVxuICAgICAgJyY6aW52YWxpZCc6IHtcbiAgICAgICAgYm94U2hhZG93OiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICAnJjo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbic6IHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBwYWRkaW5nIHdoZW4gdHlwZT1zZWFyY2guXG4gICAgICAgICctd2Via2l0LWFwcGVhcmFuY2UnOiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICAvLyBTaG93IGFuZCBoaWRlIHRoZSBwbGFjZWhvbGRlciBsb2dpY1xuICAgICAgJ2xhYmVsW2RhdGEtc2hyaW5rPWZhbHNlXSArICRmb3JtQ29udHJvbCAmJzoge1xuICAgICAgICAnJjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVySGlkZGVuLFxuICAgICAgICAnJjo6LW1vei1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVySGlkZGVuLFxuICAgICAgICAvLyBGaXJlZm94IDE5K1xuICAgICAgICAnJjotbXMtaW5wdXQtcGxhY2Vob2xkZXInOiBwbGFjZWhvbGRlckhpZGRlbixcbiAgICAgICAgLy8gSUUgMTFcbiAgICAgICAgJyY6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVySGlkZGVuLFxuICAgICAgICAvLyBFZGdlXG4gICAgICAgICcmOmZvY3VzOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyJzogcGxhY2Vob2xkZXJWaXNpYmxlLFxuICAgICAgICAnJjpmb2N1czo6LW1vei1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVyVmlzaWJsZSxcbiAgICAgICAgLy8gRmlyZWZveCAxOStcbiAgICAgICAgJyY6Zm9jdXM6LW1zLWlucHV0LXBsYWNlaG9sZGVyJzogcGxhY2Vob2xkZXJWaXNpYmxlLFxuICAgICAgICAvLyBJRSAxMVxuICAgICAgICAnJjpmb2N1czo6LW1zLWlucHV0LXBsYWNlaG9sZGVyJzogcGxhY2Vob2xkZXJWaXNpYmxlIC8vIEVkZ2VcblxuICAgICAgfSxcbiAgICAgICcmJGRpc2FibGVkJzoge1xuICAgICAgICBvcGFjaXR5OiAxIC8vIFJlc2V0IGlPUyBvcGFjaXR5XG5cbiAgICAgIH0sXG4gICAgICAnJjotd2Via2l0LWF1dG9maWxsJzoge1xuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogJzUwMDBzJyxcbiAgICAgICAgYW5pbWF0aW9uTmFtZTogJ211aS1hdXRvLWZpbGwnXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICAgIGlucHV0TWFyZ2luRGVuc2U6IHtcbiAgICAgIHBhZGRpbmdUb3A6IDQgLSAxXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG11bHRpbGluZT17dHJ1ZX1gLiAqL1xuICAgIGlucHV0TXVsdGlsaW5lOiB7XG4gICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgIHJlc2l6ZTogJ25vbmUnLFxuICAgICAgcGFkZGluZzogMFxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGB0eXBlPVwic2VhcmNoXCJgLiAqL1xuICAgIGlucHV0VHlwZVNlYXJjaDoge1xuICAgICAgLy8gSW1wcm92ZSB0eXBlIHNlYXJjaCBzdHlsZS5cbiAgICAgICctbW96LWFwcGVhcmFuY2UnOiAndGV4dGZpZWxkJyxcbiAgICAgICctd2Via2l0LWFwcGVhcmFuY2UnOiAndGV4dGZpZWxkJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBzdGFydEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgaW5wdXRBZG9ybmVkU3RhcnQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgZW5kQWRvcm5tZW50YCBpcyBwcm92aWRlZC4gKi9cbiAgICBpbnB1dEFkb3JuZWRFbmQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgaGlkZGVuTGFiZWw9e3RydWV9YC4gKi9cbiAgICBpbnB1dEhpZGRlbkxhYmVsOiB7fVxuICB9O1xufTtcbnZhciB1c2VFbmhhbmNlZEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlRWZmZWN0IDogUmVhY3QudXNlTGF5b3V0RWZmZWN0O1xuLyoqXG4gKiBgSW5wdXRCYXNlYCBjb250YWlucyBhcyBmZXcgc3R5bGVzIGFzIHBvc3NpYmxlLlxuICogSXQgYWltcyB0byBiZSBhIHNpbXBsZSBidWlsZGluZyBibG9jayBmb3IgY3JlYXRpbmcgYW4gaW5wdXQuXG4gKiBJdCBjb250YWlucyBhIGxvYWQgb2Ygc3R5bGUgcmVzZXQgYW5kIHNvbWUgc3RhdGUgbG9naWMuXG4gKi9cblxudmFyIElucHV0QmFzZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIElucHV0QmFzZShwcm9wcywgcmVmKSB7XG4gIHZhciBhcmlhRGVzY3JpYmVkYnkgPSBwcm9wc1snYXJpYS1kZXNjcmliZWRieSddLFxuICAgICAgYXV0b0NvbXBsZXRlID0gcHJvcHMuYXV0b0NvbXBsZXRlLFxuICAgICAgYXV0b0ZvY3VzID0gcHJvcHMuYXV0b0ZvY3VzLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGVuZEFkb3JubWVudCA9IHByb3BzLmVuZEFkb3JubWVudCxcbiAgICAgIGVycm9yID0gcHJvcHMuZXJyb3IsXG4gICAgICBfcHJvcHMkZnVsbFdpZHRoID0gcHJvcHMuZnVsbFdpZHRoLFxuICAgICAgZnVsbFdpZHRoID0gX3Byb3BzJGZ1bGxXaWR0aCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZnVsbFdpZHRoLFxuICAgICAgaWQgPSBwcm9wcy5pZCxcbiAgICAgIF9wcm9wcyRpbnB1dENvbXBvbmVudCA9IHByb3BzLmlucHV0Q29tcG9uZW50LFxuICAgICAgaW5wdXRDb21wb25lbnQgPSBfcHJvcHMkaW5wdXRDb21wb25lbnQgPT09IHZvaWQgMCA/ICdpbnB1dCcgOiBfcHJvcHMkaW5wdXRDb21wb25lbnQsXG4gICAgICBfcHJvcHMkaW5wdXRQcm9wcyA9IHByb3BzLmlucHV0UHJvcHMsXG4gICAgICBpbnB1dFByb3BzUHJvcCA9IF9wcm9wcyRpbnB1dFByb3BzID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRpbnB1dFByb3BzLFxuICAgICAgaW5wdXRSZWZQcm9wID0gcHJvcHMuaW5wdXRSZWYsXG4gICAgICBtYXJnaW4gPSBwcm9wcy5tYXJnaW4sXG4gICAgICBfcHJvcHMkbXVsdGlsaW5lID0gcHJvcHMubXVsdGlsaW5lLFxuICAgICAgbXVsdGlsaW5lID0gX3Byb3BzJG11bHRpbGluZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkbXVsdGlsaW5lLFxuICAgICAgbmFtZSA9IHByb3BzLm5hbWUsXG4gICAgICBvbkJsdXIgPSBwcm9wcy5vbkJsdXIsXG4gICAgICBvbkNoYW5nZSA9IHByb3BzLm9uQ2hhbmdlLFxuICAgICAgb25DbGljayA9IHByb3BzLm9uQ2xpY2ssXG4gICAgICBvbkZvY3VzID0gcHJvcHMub25Gb2N1cyxcbiAgICAgIG9uS2V5RG93biA9IHByb3BzLm9uS2V5RG93bixcbiAgICAgIG9uS2V5VXAgPSBwcm9wcy5vbktleVVwLFxuICAgICAgcGxhY2Vob2xkZXIgPSBwcm9wcy5wbGFjZWhvbGRlcixcbiAgICAgIHJlYWRPbmx5ID0gcHJvcHMucmVhZE9ubHksXG4gICAgICByZW5kZXJTdWZmaXggPSBwcm9wcy5yZW5kZXJTdWZmaXgsXG4gICAgICByb3dzID0gcHJvcHMucm93cyxcbiAgICAgIHJvd3NNYXggPSBwcm9wcy5yb3dzTWF4LFxuICAgICAgcm93c01pbiA9IHByb3BzLnJvd3NNaW4sXG4gICAgICBzdGFydEFkb3JubWVudCA9IHByb3BzLnN0YXJ0QWRvcm5tZW50LFxuICAgICAgX3Byb3BzJHR5cGUgPSBwcm9wcy50eXBlLFxuICAgICAgdHlwZSA9IF9wcm9wcyR0eXBlID09PSB2b2lkIDAgPyAndGV4dCcgOiBfcHJvcHMkdHlwZSxcbiAgICAgIHZhbHVlUHJvcCA9IHByb3BzLnZhbHVlLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImFyaWEtZGVzY3JpYmVkYnlcIiwgXCJhdXRvQ29tcGxldGVcIiwgXCJhdXRvRm9jdXNcIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sb3JcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJkaXNhYmxlZFwiLCBcImVuZEFkb3JubWVudFwiLCBcImVycm9yXCIsIFwiZnVsbFdpZHRoXCIsIFwiaWRcIiwgXCJpbnB1dENvbXBvbmVudFwiLCBcImlucHV0UHJvcHNcIiwgXCJpbnB1dFJlZlwiLCBcIm1hcmdpblwiLCBcIm11bHRpbGluZVwiLCBcIm5hbWVcIiwgXCJvbkJsdXJcIiwgXCJvbkNoYW5nZVwiLCBcIm9uQ2xpY2tcIiwgXCJvbkZvY3VzXCIsIFwib25LZXlEb3duXCIsIFwib25LZXlVcFwiLCBcInBsYWNlaG9sZGVyXCIsIFwicmVhZE9ubHlcIiwgXCJyZW5kZXJTdWZmaXhcIiwgXCJyb3dzXCIsIFwicm93c01heFwiLCBcInJvd3NNaW5cIiwgXCJzdGFydEFkb3JubWVudFwiLCBcInR5cGVcIiwgXCJ2YWx1ZVwiXSk7XG5cbiAgdmFyIHZhbHVlID0gaW5wdXRQcm9wc1Byb3AudmFsdWUgIT0gbnVsbCA/IGlucHV0UHJvcHNQcm9wLnZhbHVlIDogdmFsdWVQcm9wO1xuXG4gIHZhciBfUmVhY3QkdXNlUmVmID0gUmVhY3QudXNlUmVmKHZhbHVlICE9IG51bGwpLFxuICAgICAgaXNDb250cm9sbGVkID0gX1JlYWN0JHVzZVJlZi5jdXJyZW50O1xuXG4gIHZhciBpbnB1dFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICB2YXIgaGFuZGxlSW5wdXRSZWZXYXJuaW5nID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5ub2RlTmFtZSAhPT0gJ0lOUFVUJyAmJiAhaW5zdGFuY2UuZm9jdXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiBZb3UgaGF2ZSBwcm92aWRlZCBhIGBpbnB1dENvbXBvbmVudGAgdG8gdGhlIGlucHV0IGNvbXBvbmVudCcsICd0aGF0IGRvZXMgbm90IGNvcnJlY3RseSBoYW5kbGUgdGhlIGBpbnB1dFJlZmAgcHJvcC4nLCAnTWFrZSBzdXJlIHRoZSBgaW5wdXRSZWZgIHByb3AgaXMgY2FsbGVkIHdpdGggYSBIVE1MSW5wdXRFbGVtZW50LiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcbiAgdmFyIGhhbmRsZUlucHV0UHJvcHNSZWZQcm9wID0gdXNlRm9ya1JlZihpbnB1dFByb3BzUHJvcC5yZWYsIGhhbmRsZUlucHV0UmVmV2FybmluZyk7XG4gIHZhciBoYW5kbGVJbnB1dFJlZlByb3AgPSB1c2VGb3JrUmVmKGlucHV0UmVmUHJvcCwgaGFuZGxlSW5wdXRQcm9wc1JlZlByb3ApO1xuICB2YXIgaGFuZGxlSW5wdXRSZWYgPSB1c2VGb3JrUmVmKGlucHV0UmVmLCBoYW5kbGVJbnB1dFJlZlByb3ApO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBmb2N1c2VkID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0Rm9jdXNlZCA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgbXVpRm9ybUNvbnRyb2wgPSB1c2VGb3JtQ29udHJvbCgpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtdWlGb3JtQ29udHJvbCkge1xuICAgICAgICByZXR1cm4gbXVpRm9ybUNvbnRyb2wucmVnaXN0ZXJFZmZlY3QoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LCBbbXVpRm9ybUNvbnRyb2xdKTtcbiAgfVxuXG4gIHZhciBmY3MgPSBmb3JtQ29udHJvbFN0YXRlKHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgbXVpRm9ybUNvbnRyb2w6IG11aUZvcm1Db250cm9sLFxuICAgIHN0YXRlczogWydjb2xvcicsICdkaXNhYmxlZCcsICdlcnJvcicsICdoaWRkZW5MYWJlbCcsICdtYXJnaW4nLCAncmVxdWlyZWQnLCAnZmlsbGVkJ11cbiAgfSk7XG4gIGZjcy5mb2N1c2VkID0gbXVpRm9ybUNvbnRyb2wgPyBtdWlGb3JtQ29udHJvbC5mb2N1c2VkIDogZm9jdXNlZDsgLy8gVGhlIGJsdXIgd29uJ3QgZmlyZSB3aGVuIHRoZSBkaXNhYmxlZCBzdGF0ZSBpcyBzZXQgb24gYSBmb2N1c2VkIGlucHV0LlxuICAvLyBXZSBuZWVkIHRvIGJvb2sga2VlcCB0aGUgZm9jdXNlZCBzdGF0ZSBtYW51YWxseS5cblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghbXVpRm9ybUNvbnRyb2wgJiYgZGlzYWJsZWQgJiYgZm9jdXNlZCkge1xuICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XG5cbiAgICAgIGlmIChvbkJsdXIpIHtcbiAgICAgICAgb25CbHVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbbXVpRm9ybUNvbnRyb2wsIGRpc2FibGVkLCBmb2N1c2VkLCBvbkJsdXJdKTtcbiAgdmFyIG9uRmlsbGVkID0gbXVpRm9ybUNvbnRyb2wgJiYgbXVpRm9ybUNvbnRyb2wub25GaWxsZWQ7XG4gIHZhciBvbkVtcHR5ID0gbXVpRm9ybUNvbnRyb2wgJiYgbXVpRm9ybUNvbnRyb2wub25FbXB0eTtcbiAgdmFyIGNoZWNrRGlydHkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKGlzRmlsbGVkKG9iaikpIHtcbiAgICAgIGlmIChvbkZpbGxlZCkge1xuICAgICAgICBvbkZpbGxlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob25FbXB0eSkge1xuICAgICAgb25FbXB0eSgpO1xuICAgIH1cbiAgfSwgW29uRmlsbGVkLCBvbkVtcHR5XSk7XG4gIHVzZUVuaGFuY2VkRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNDb250cm9sbGVkKSB7XG4gICAgICBjaGVja0RpcnR5KHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFt2YWx1ZSwgY2hlY2tEaXJ0eSwgaXNDb250cm9sbGVkXSk7XG5cbiAgdmFyIGhhbmRsZUZvY3VzID0gZnVuY3Rpb24gaGFuZGxlRm9jdXMoZXZlbnQpIHtcbiAgICAvLyBGaXggYSBidWcgd2l0aCBJRSAxMSB3aGVyZSB0aGUgZm9jdXMvYmx1ciBldmVudHMgYXJlIHRyaWdnZXJlZFxuICAgIC8vIHdoaWxlIHRoZSBpbnB1dCBpcyBkaXNhYmxlZC5cbiAgICBpZiAoZmNzLmRpc2FibGVkKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob25Gb2N1cykge1xuICAgICAgb25Gb2N1cyhldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0UHJvcHNQcm9wLm9uRm9jdXMpIHtcbiAgICAgIGlucHV0UHJvcHNQcm9wLm9uRm9jdXMoZXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChtdWlGb3JtQ29udHJvbCAmJiBtdWlGb3JtQ29udHJvbC5vbkZvY3VzKSB7XG4gICAgICBtdWlGb3JtQ29udHJvbC5vbkZvY3VzKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0Rm9jdXNlZCh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKGV2ZW50KSB7XG4gICAgaWYgKG9uQmx1cikge1xuICAgICAgb25CbHVyKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRQcm9wc1Byb3Aub25CbHVyKSB7XG4gICAgICBpbnB1dFByb3BzUHJvcC5vbkJsdXIoZXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChtdWlGb3JtQ29udHJvbCAmJiBtdWlGb3JtQ29udHJvbC5vbkJsdXIpIHtcbiAgICAgIG11aUZvcm1Db250cm9sLm9uQmx1cihldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEZvY3VzZWQoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKCFpc0NvbnRyb2xsZWQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZXZlbnQudGFyZ2V0IHx8IGlucHV0UmVmLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiTWF0ZXJpYWwtVUk6IEV4cGVjdGVkIHZhbGlkIGlucHV0IHRhcmdldC4gRGlkIHlvdSB1c2UgYSBjdXN0b20gYGlucHV0Q29tcG9uZW50YCBhbmQgZm9yZ2V0IHRvIGZvcndhcmQgcmVmcz8gU2VlIGh0dHBzOi8vbWF0ZXJpYWwtdWkuY29tL3IvaW5wdXQtY29tcG9uZW50LXJlZi1pbnRlcmZhY2UgZm9yIG1vcmUgaW5mby5cIiA6IF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UoMSkpO1xuICAgICAgfVxuXG4gICAgICBjaGVja0RpcnR5KHtcbiAgICAgICAgdmFsdWU6IGVsZW1lbnQudmFsdWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChpbnB1dFByb3BzUHJvcC5vbkNoYW5nZSkge1xuICAgICAgaW5wdXRQcm9wc1Byb3Aub25DaGFuZ2UuYXBwbHkoaW5wdXRQcm9wc1Byb3AsIFtldmVudF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9IC8vIFBlcmZvcm0gaW4gdGhlIHdpbGxVcGRhdGVcblxuXG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICBvbkNoYW5nZS5hcHBseSh2b2lkIDAsIFtldmVudF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07IC8vIENoZWNrIHRoZSBpbnB1dCBzdGF0ZSBvbiBtb3VudCwgaW4gY2FzZSBpdCB3YXMgZmlsbGVkIGJ5IHRoZSB1c2VyXG4gIC8vIG9yIGF1dG8gZmlsbGVkIGJ5IHRoZSBicm93c2VyIGJlZm9yZSB0aGUgaHlkcmF0aW9uIChmb3IgU1NSKS5cblxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgY2hlY2tEaXJ0eShpbnB1dFJlZi5jdXJyZW50KTtcbiAgfSwgW10pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuXG4gIHZhciBoYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKGlucHV0UmVmLmN1cnJlbnQgJiYgZXZlbnQuY3VycmVudFRhcmdldCA9PT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICBpbnB1dFJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgIG9uQ2xpY2soZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgSW5wdXRDb21wb25lbnQgPSBpbnB1dENvbXBvbmVudDtcblxuICB2YXIgaW5wdXRQcm9wcyA9IF9leHRlbmRzKHt9LCBpbnB1dFByb3BzUHJvcCwge1xuICAgIHJlZjogaGFuZGxlSW5wdXRSZWZcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBJbnB1dENvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICBpbnB1dFByb3BzID0gX2V4dGVuZHMoe1xuICAgICAgLy8gUmVuYW1lIHJlZiB0byBpbnB1dFJlZiBhcyB3ZSBkb24ndCBrbm93IHRoZVxuICAgICAgLy8gcHJvdmlkZWQgYGlucHV0Q29tcG9uZW50YCBzdHJ1Y3R1cmUuXG4gICAgICBpbnB1dFJlZjogaGFuZGxlSW5wdXRSZWYsXG4gICAgICB0eXBlOiB0eXBlXG4gICAgfSwgaW5wdXRQcm9wcywge1xuICAgICAgcmVmOiBudWxsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobXVsdGlsaW5lKSB7XG4gICAgaWYgKHJvd3MgJiYgIXJvd3NNYXggJiYgIXJvd3NNaW4pIHtcbiAgICAgIElucHV0Q29tcG9uZW50ID0gJ3RleHRhcmVhJztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXRQcm9wcyA9IF9leHRlbmRzKHtcbiAgICAgICAgcm93czogcm93cyxcbiAgICAgICAgcm93c01heDogcm93c01heFxuICAgICAgfSwgaW5wdXRQcm9wcyk7XG4gICAgICBJbnB1dENvbXBvbmVudCA9IFRleHRhcmVhQXV0b3NpemU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlucHV0UHJvcHMgPSBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiB0eXBlXG4gICAgfSwgaW5wdXRQcm9wcyk7XG4gIH1cblxuICB2YXIgaGFuZGxlQXV0b0ZpbGwgPSBmdW5jdGlvbiBoYW5kbGVBdXRvRmlsbChldmVudCkge1xuICAgIC8vIFByb3ZpZGUgYSBmYWtlIHZhbHVlIGFzIENocm9tZSBtaWdodCBub3QgbGV0IHlvdSBhY2Nlc3MgaXQgZm9yIHNlY3VyaXR5IHJlYXNvbnMuXG4gICAgY2hlY2tEaXJ0eShldmVudC5hbmltYXRpb25OYW1lID09PSAnbXVpLWF1dG8tZmlsbC1jYW5jZWwnID8gaW5wdXRSZWYuY3VycmVudCA6IHtcbiAgICAgIHZhbHVlOiAneCdcbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChtdWlGb3JtQ29udHJvbCkge1xuICAgICAgbXVpRm9ybUNvbnRyb2wuc2V0QWRvcm5lZFN0YXJ0KEJvb2xlYW4oc3RhcnRBZG9ybm1lbnQpKTtcbiAgICB9XG4gIH0sIFttdWlGb3JtQ29udHJvbCwgc3RhcnRBZG9ybm1lbnRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc2VzW1wiY29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShmY3MuY29sb3IgfHwgJ3ByaW1hcnknKSldLCBjbGFzc05hbWUsIGZjcy5kaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkLCBmY3MuZXJyb3IgJiYgY2xhc3Nlcy5lcnJvciwgZnVsbFdpZHRoICYmIGNsYXNzZXMuZnVsbFdpZHRoLCBmY3MuZm9jdXNlZCAmJiBjbGFzc2VzLmZvY3VzZWQsIG11aUZvcm1Db250cm9sICYmIGNsYXNzZXMuZm9ybUNvbnRyb2wsIG11bHRpbGluZSAmJiBjbGFzc2VzLm11bHRpbGluZSwgc3RhcnRBZG9ybm1lbnQgJiYgY2xhc3Nlcy5hZG9ybmVkU3RhcnQsIGVuZEFkb3JubWVudCAmJiBjbGFzc2VzLmFkb3JuZWRFbmQsIGZjcy5tYXJnaW4gPT09ICdkZW5zZScgJiYgY2xhc3Nlcy5tYXJnaW5EZW5zZSksXG4gICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpLCBzdGFydEFkb3JubWVudCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUNvbnRyb2xDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG51bGxcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBcImFyaWEtaW52YWxpZFwiOiBmY3MuZXJyb3IsXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGFyaWFEZXNjcmliZWRieSxcbiAgICBhdXRvQ29tcGxldGU6IGF1dG9Db21wbGV0ZSxcbiAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyxcbiAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBkaXNhYmxlZDogZmNzLmRpc2FibGVkLFxuICAgIGlkOiBpZCxcbiAgICBvbkFuaW1hdGlvblN0YXJ0OiBoYW5kbGVBdXRvRmlsbCxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICByZWFkT25seTogcmVhZE9ubHksXG4gICAgcmVxdWlyZWQ6IGZjcy5yZXF1aXJlZCxcbiAgICByb3dzOiByb3dzLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBvbktleURvd246IG9uS2V5RG93bixcbiAgICBvbktleVVwOiBvbktleVVwXG4gIH0sIGlucHV0UHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5pbnB1dCwgaW5wdXRQcm9wc1Byb3AuY2xhc3NOYW1lLCBmY3MuZGlzYWJsZWQgJiYgY2xhc3Nlcy5kaXNhYmxlZCwgbXVsdGlsaW5lICYmIGNsYXNzZXMuaW5wdXRNdWx0aWxpbmUsIGZjcy5oaWRkZW5MYWJlbCAmJiBjbGFzc2VzLmlucHV0SGlkZGVuTGFiZWwsIHN0YXJ0QWRvcm5tZW50ICYmIGNsYXNzZXMuaW5wdXRBZG9ybmVkU3RhcnQsIGVuZEFkb3JubWVudCAmJiBjbGFzc2VzLmlucHV0QWRvcm5lZEVuZCwgdHlwZSA9PT0gJ3NlYXJjaCcgJiYgY2xhc3Nlcy5pbnB1dFR5cGVTZWFyY2gsIGZjcy5tYXJnaW4gPT09ICdkZW5zZScgJiYgY2xhc3Nlcy5pbnB1dE1hcmdpbkRlbnNlKSxcbiAgICBvbkJsdXI6IGhhbmRsZUJsdXIsXG4gICAgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZSxcbiAgICBvbkZvY3VzOiBoYW5kbGVGb2N1c1xuICB9KSkpLCBlbmRBZG9ybm1lbnQsIHJlbmRlclN1ZmZpeCA/IHJlbmRlclN1ZmZpeChfZXh0ZW5kcyh7fSwgZmNzLCB7XG4gICAgc3RhcnRBZG9ybm1lbnQ6IHN0YXJ0QWRvcm5tZW50XG4gIH0pKSA6IG51bGwpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBJbnB1dEJhc2UucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGlzIHByb3AgaGVscHMgdXNlcnMgdG8gZmlsbCBmb3JtcyBmYXN0ZXIsIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZXMuXG4gICAqIFRoZSBuYW1lIGNhbiBiZSBjb25mdXNpbmcsIGFzIGl0J3MgbW9yZSBsaWtlIGFuIGF1dG9maWxsLlxuICAgKiBZb3UgY2FuIGxlYXJuIG1vcmUgYWJvdXQgaXQgW2ZvbGxvd2luZyB0aGUgc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjYXV0b2ZpbGwpLlxuICAgKi9cbiAgYXV0b0NvbXBsZXRlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSBmb2N1c2VkIGR1cmluZyB0aGUgZmlyc3QgbW91bnQuXG4gICAqL1xuICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBgaW5wdXRgIGVsZW1lbnQgdmFsdWUuIFVzZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGNvbnRyb2xsZWQuXG4gICAqL1xuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmQgYElucHV0QWRvcm5tZW50YCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBlbmRBZG9ybm1lbnQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCB3aWxsIGluZGljYXRlIGFuIGVycm9yLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBlcnJvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiBpdHMgY29udGFpbmVyLlxuICAgKi9cbiAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgaW5wdXRDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogW0F0dHJpYnV0ZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNBdHRyaWJ1dGVzKSBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBQYXNzIGEgcmVmIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFJlZjogcmVmVHlwZSxcblxuICAvKipcbiAgICogSWYgYGRlbnNlYCwgd2lsbCBhZGp1c3QgdmVydGljYWwgc3BhY2luZy4gVGhpcyBpcyBub3JtYWxseSBvYnRhaW5lZCB2aWEgY29udGV4dCBmcm9tXG4gICAqIEZvcm1Db250cm9sLlxuICAgKi9cbiAgbWFyZ2luOiBQcm9wVHlwZXMub25lT2YoWydkZW5zZScsICdub25lJ10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGEgdGV4dGFyZWEgZWxlbWVudCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVsdGlsaW5lOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTmFtZSBhdHRyaWJ1dGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGlucHV0IGlzIGJsdXJyZWQuXG4gICAqXG4gICAqIE5vdGljZSB0aGF0IHRoZSBmaXJzdCBhcmd1bWVudCAoZXZlbnQpIG1pZ2h0IGJlIHVuZGVmaW5lZC5cbiAgICovXG4gIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICogWW91IGNhbiBwdWxsIG91dCB0aGUgbmV3IHZhbHVlIGJ5IGFjY2Vzc2luZyBgZXZlbnQudGFyZ2V0LnZhbHVlYCAoc3RyaW5nKS5cbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbktleVVwOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogVGhlIHNob3J0IGhpbnQgZGlzcGxheWVkIGluIHRoZSBpbnB1dCBiZWZvcmUgdGhlIHVzZXIgZW50ZXJzIGEgdmFsdWUuXG4gICAqL1xuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSXQgcHJldmVudHMgdGhlIHVzZXIgZnJvbSBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkXG4gICAqIChub3QgZnJvbSBpbnRlcmFjdGluZyB3aXRoIHRoZSBmaWVsZCkuXG4gICAqL1xuICByZWFkT25seTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHJlbmRlclN1ZmZpeDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IHdoZW4gbXVsdGlsaW5lIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICovXG4gIHJvd3M6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IHdoZW4gbXVsdGlsaW5lIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICovXG4gIHJvd3NNYXg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IHdoZW4gbXVsdGlsaW5lIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICovXG4gIHJvd3NNaW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogU3RhcnQgYElucHV0QWRvcm5tZW50YCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBzdGFydEFkb3JubWVudDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC4gSXQgc2hvdWxkIGJlIFthIHZhbGlkIEhUTUw1IGlucHV0IHR5cGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNGb3JtXyUzQ2lucHV0JTNFX3R5cGVzKS5cbiAgICovXG4gIHR5cGU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LCByZXF1aXJlZCBmb3IgYSBjb250cm9sbGVkIGNvbXBvbmVudC5cbiAgICovXG4gIHZhbHVlOiBQcm9wVHlwZXMuYW55XG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUlucHV0QmFzZSdcbn0pKElucHV0QmFzZSk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgcmVmVHlwZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgSW5wdXRCYXNlIGZyb20gJy4uL0lucHV0QmFzZSc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICB2YXIgbGlnaHQgPSB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCc7XG4gIHZhciBib3R0b21MaW5lQ29sb3IgPSBsaWdodCA/ICdyZ2JhKDAsIDAsIDAsIDAuNDIpJyA6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknO1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiB0aGUgY29tcG9uZW50IGlzIGEgZGVzY2VuZGFudCBvZiBgRm9ybUNvbnRyb2xgLiAqL1xuICAgIGZvcm1Db250cm9sOiB7XG4gICAgICAnbGFiZWwgKyAmJzoge1xuICAgICAgICBtYXJnaW5Ub3A6IDE2XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgdGhlIGNvbXBvbmVudCBpcyBmb2N1c2VkLiAqL1xuICAgIGZvY3VzZWQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZWQ9e3RydWV9YC4gKi9cbiAgICBkaXNhYmxlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGNvbG9yIHNlY29uZGFyeS4gKi9cbiAgICBjb2xvclNlY29uZGFyeToge1xuICAgICAgJyYkdW5kZXJsaW5lOmFmdGVyJzoge1xuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpblxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlVW5kZXJsaW5lPXtmYWxzZX1gLiAqL1xuICAgIHVuZGVybGluZToge1xuICAgICAgJyY6YWZ0ZXInOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIycHggc29saWQgXCIuY29uY2F0KHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluKSxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAvLyBEb2luZyB0aGUgb3RoZXIgd2F5IGFyb3VuZCBjcmFzaCBvbiBJRSAxMSBcIicnXCIgaHR0cHM6Ly9naXRodWIuY29tL2Nzc2luanMvanNzL2lzc3Vlcy8yNDJcbiAgICAgICAgY29udGVudDogJ1wiXCInLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlWCgwKScsXG4gICAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgndHJhbnNmb3JtJywge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVyLFxuICAgICAgICAgIGVhc2luZzogdGhlbWUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VPdXRcbiAgICAgICAgfSksXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyAvLyBUcmFuc3BhcmVudCB0byB0aGUgaG92ZXIgc3R5bGUuXG5cbiAgICAgIH0sXG4gICAgICAnJiRmb2N1c2VkOmFmdGVyJzoge1xuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVgoMSknXG4gICAgICB9LFxuICAgICAgJyYkZXJyb3I6YWZ0ZXInOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0aGVtZS5wYWxldHRlLmVycm9yLm1haW4sXG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlWCgxKScgLy8gZXJyb3IgaXMgYWx3YXlzIHVuZGVybGluZWQgaW4gcmVkXG5cbiAgICAgIH0sXG4gICAgICAnJjpiZWZvcmUnOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgXCIuY29uY2F0KGJvdHRvbUxpbmVDb2xvciksXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgLy8gRG9pbmcgdGhlIG90aGVyIHdheSBhcm91bmQgY3Jhc2ggb24gSUUgMTEgXCInJ1wiIGh0dHBzOi8vZ2l0aHViLmNvbS9jc3NpbmpzL2pzcy9pc3N1ZXMvMjQyXG4gICAgICAgIGNvbnRlbnQ6ICdcIlxcXFwwMGEwXCInLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgnYm9yZGVyLWJvdHRvbS1jb2xvcicsIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlclxuICAgICAgICB9KSxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnIC8vIFRyYW5zcGFyZW50IHRvIHRoZSBob3ZlciBzdHlsZS5cblxuICAgICAgfSxcbiAgICAgICcmOmhvdmVyOm5vdCgkZGlzYWJsZWQpOmJlZm9yZSc6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjJweCBzb2xpZCBcIi5jb25jYXQodGhlbWUucGFsZXR0ZS50ZXh0LnByaW1hcnkpLFxuICAgICAgICAvLyBSZXNldCBvbiB0b3VjaCBkZXZpY2VzLCBpdCBkb2Vzbid0IGFkZCBzcGVjaWZpY2l0eVxuICAgICAgICAnQG1lZGlhIChob3Zlcjogbm9uZSknOiB7XG4gICAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCBcIi5jb25jYXQoYm90dG9tTGluZUNvbG9yKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJyYkZGlzYWJsZWQ6YmVmb3JlJzoge1xuICAgICAgICBib3JkZXJCb3R0b21TdHlsZTogJ2RvdHRlZCdcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZXJyb3I9e3RydWV9YC4gKi9cbiAgICBlcnJvcjoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtYXJnaW49XCJkZW5zZVwiYC4gKi9cbiAgICBtYXJnaW5EZW5zZToge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBtdWx0aWxpbmU9e3RydWV9YC4gKi9cbiAgICBtdWx0aWxpbmU6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZnVsbFdpZHRoPXt0cnVlfWAuICovXG4gICAgZnVsbFdpZHRoOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuICovXG4gICAgaW5wdXQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgbWFyZ2luPVwiZGVuc2VcImAuICovXG4gICAgaW5wdXRNYXJnaW5EZW5zZToge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtdWx0aWxpbmU9e3RydWV9YC4gKi9cbiAgICBpbnB1dE11bHRpbGluZToge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGB0eXBlPVwic2VhcmNoXCJgLiAqL1xuICAgIGlucHV0VHlwZVNlYXJjaDoge31cbiAgfTtcbn07XG52YXIgSW5wdXQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBJbnB1dChwcm9wcywgcmVmKSB7XG4gIHZhciBkaXNhYmxlVW5kZXJsaW5lID0gcHJvcHMuZGlzYWJsZVVuZGVybGluZSxcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgX3Byb3BzJGZ1bGxXaWR0aCA9IHByb3BzLmZ1bGxXaWR0aCxcbiAgICAgIGZ1bGxXaWR0aCA9IF9wcm9wcyRmdWxsV2lkdGggPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZ1bGxXaWR0aCxcbiAgICAgIF9wcm9wcyRpbnB1dENvbXBvbmVudCA9IHByb3BzLmlucHV0Q29tcG9uZW50LFxuICAgICAgaW5wdXRDb21wb25lbnQgPSBfcHJvcHMkaW5wdXRDb21wb25lbnQgPT09IHZvaWQgMCA/ICdpbnB1dCcgOiBfcHJvcHMkaW5wdXRDb21wb25lbnQsXG4gICAgICBfcHJvcHMkbXVsdGlsaW5lID0gcHJvcHMubXVsdGlsaW5lLFxuICAgICAgbXVsdGlsaW5lID0gX3Byb3BzJG11bHRpbGluZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkbXVsdGlsaW5lLFxuICAgICAgX3Byb3BzJHR5cGUgPSBwcm9wcy50eXBlLFxuICAgICAgdHlwZSA9IF9wcm9wcyR0eXBlID09PSB2b2lkIDAgPyAndGV4dCcgOiBfcHJvcHMkdHlwZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJkaXNhYmxlVW5kZXJsaW5lXCIsIFwiY2xhc3Nlc1wiLCBcImZ1bGxXaWR0aFwiLCBcImlucHV0Q29tcG9uZW50XCIsIFwibXVsdGlsaW5lXCIsIFwidHlwZVwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KElucHV0QmFzZSwgX2V4dGVuZHMoe1xuICAgIGNsYXNzZXM6IF9leHRlbmRzKHt9LCBjbGFzc2VzLCB7XG4gICAgICByb290OiBjbHN4KGNsYXNzZXMucm9vdCwgIWRpc2FibGVVbmRlcmxpbmUgJiYgY2xhc3Nlcy51bmRlcmxpbmUpLFxuICAgICAgdW5kZXJsaW5lOiBudWxsXG4gICAgfSksXG4gICAgZnVsbFdpZHRoOiBmdWxsV2lkdGgsXG4gICAgaW5wdXRDb21wb25lbnQ6IGlucHV0Q29tcG9uZW50LFxuICAgIG11bHRpbGluZTogbXVsdGlsaW5lLFxuICAgIHJlZjogcmVmLFxuICAgIHR5cGU6IHR5cGVcbiAgfSwgb3RoZXIpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gSW5wdXQucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhpcyBwcm9wIGhlbHBzIHVzZXJzIHRvIGZpbGwgZm9ybXMgZmFzdGVyLCBlc3BlY2lhbGx5IG9uIG1vYmlsZSBkZXZpY2VzLlxuICAgKiBUaGUgbmFtZSBjYW4gYmUgY29uZnVzaW5nLCBhcyBpdCdzIG1vcmUgbGlrZSBhbiBhdXRvZmlsbC5cbiAgICogWW91IGNhbiBsZWFybiBtb3JlIGFib3V0IGl0IFtmb2xsb3dpbmcgdGhlIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI2F1dG9maWxsKS5cbiAgICovXG4gIGF1dG9Db21wbGV0ZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgZm9jdXNlZCBkdXJpbmcgdGhlIGZpcnN0IG1vdW50LlxuICAgKi9cbiAgYXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC4gSXQgc3VwcG9ydHMgdGhvc2UgdGhlbWUgY29sb3JzIHRoYXQgbWFrZSBzZW5zZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsncHJpbWFyeScsICdzZWNvbmRhcnknXSksXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGBpbnB1dGAgZWxlbWVudCB2YWx1ZS4gVXNlIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBub3QgY29udHJvbGxlZC5cbiAgICovXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgbm90IGhhdmUgYW4gdW5kZXJsaW5lLlxuICAgKi9cbiAgZGlzYWJsZVVuZGVybGluZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEVuZCBgSW5wdXRBZG9ybm1lbnRgIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIGVuZEFkb3JubWVudDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgaW5kaWNhdGUgYW4gZXJyb3IuIFRoaXMgaXMgbm9ybWFsbHkgb2J0YWluZWQgdmlhIGNvbnRleHQgZnJvbVxuICAgKiBGb3JtQ29udHJvbC5cbiAgICovXG4gIGVycm9yOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgd2lsbCB0YWtlIHVwIHRoZSBmdWxsIHdpZHRoIG9mIGl0cyBjb250YWluZXIuXG4gICAqL1xuICBmdWxsV2lkdGg6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBpbnB1dENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBbQXR0cmlidXRlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I0F0dHJpYnV0ZXMpIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlucHV0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFBhc3MgYSByZWYgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlucHV0UmVmOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVuc2VgLCB3aWxsIGFkanVzdCB2ZXJ0aWNhbCBzcGFjaW5nLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBtYXJnaW46IFByb3BUeXBlcy5vbmVPZihbJ2RlbnNlJywgJ25vbmUnXSksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYSB0ZXh0YXJlYSBlbGVtZW50IHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqL1xuICBtdWx0aWxpbmU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOYW1lIGF0dHJpYnV0ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgdmFsdWUgYnkgYWNjZXNzaW5nIGBldmVudC50YXJnZXQudmFsdWVgIChzdHJpbmcpLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBUaGUgc2hvcnQgaGludCBkaXNwbGF5ZWQgaW4gdGhlIGlucHV0IGJlZm9yZSB0aGUgdXNlciBlbnRlcnMgYSB2YWx1ZS5cbiAgICovXG4gIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJdCBwcmV2ZW50cyB0aGUgdXNlciBmcm9tIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiB0aGUgZmllbGRcbiAgICogKG5vdCBmcm9tIGludGVyYWN0aW5nIHdpdGggdGhlIGZpZWxkKS5cbiAgICovXG4gIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgcmVxdWlyZWQuXG4gICAqL1xuICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgcm93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgcm93c01heDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBTdGFydCBgSW5wdXRBZG9ybm1lbnRgIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIHN0YXJ0QWRvcm5tZW50OiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogVHlwZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LiBJdCBzaG91bGQgYmUgW2EgdmFsaWQgSFRNTDUgaW5wdXQgdHlwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I0Zvcm1fJTNDaW5wdXQlM0VfdHlwZXMpLlxuICAgKi9cbiAgdHlwZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQsIHJlcXVpcmVkIGZvciBhIGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnlcbn0gOiB2b2lkIDA7XG5JbnB1dC5tdWlOYW1lID0gJ0lucHV0JztcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlJbnB1dCdcbn0pKElucHV0KTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyByZWZUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBJbnB1dEJhc2UgZnJvbSAnLi4vSW5wdXRCYXNlJztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHZhciBsaWdodCA9IHRoZW1lLnBhbGV0dGUudHlwZSA9PT0gJ2xpZ2h0JztcbiAgdmFyIGJvdHRvbUxpbmVDb2xvciA9IGxpZ2h0ID8gJ3JnYmEoMCwgMCwgMCwgMC40MiknIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSc7XG4gIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBsaWdodCA/ICdyZ2JhKDAsIDAsIDAsIDAuMDkpJyA6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDkpJztcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiB0aGVtZS5zaGFwZS5ib3JkZXJSYWRpdXMsXG4gICAgICBib3JkZXJUb3BSaWdodFJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzLFxuICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCdiYWNrZ3JvdW5kLWNvbG9yJywge1xuICAgICAgICBkdXJhdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlcixcbiAgICAgICAgZWFzaW5nOiB0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dFxuICAgICAgfSksXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBsaWdodCA/ICdyZ2JhKDAsIDAsIDAsIDAuMTMpJyA6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTMpJyxcbiAgICAgICAgLy8gUmVzZXQgb24gdG91Y2ggZGV2aWNlcywgaXQgZG9lc24ndCBhZGQgc3BlY2lmaWNpdHlcbiAgICAgICAgJ0BtZWRpYSAoaG92ZXI6IG5vbmUpJzoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnJiRmb2N1c2VkJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0ID8gJ3JnYmEoMCwgMCwgMCwgMC4wOSknIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4wOSknXG4gICAgICB9LFxuICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogbGlnaHQgPyAncmdiYSgwLCAwLCAwLCAwLjEyKScgOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKSdcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBjb2xvciBzZWNvbmRhcnkuICovXG4gICAgY29sb3JTZWNvbmRhcnk6IHtcbiAgICAgICcmJHVuZGVybGluZTphZnRlcic6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW5cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZVVuZGVybGluZT17ZmFsc2V9YC4gKi9cbiAgICB1bmRlcmxpbmU6IHtcbiAgICAgICcmOmFmdGVyJzoge1xuICAgICAgICBib3JkZXJCb3R0b206IFwiMnB4IHNvbGlkIFwiLmNvbmNhdCh0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpbiksXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgLy8gRG9pbmcgdGhlIG90aGVyIHdheSBhcm91bmQgY3Jhc2ggb24gSUUgMTEgXCInJ1wiIGh0dHBzOi8vZ2l0aHViLmNvbS9jc3NpbmpzL2pzcy9pc3N1ZXMvMjQyXG4gICAgICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVgoMCknLFxuICAgICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ3RyYW5zZm9ybScsIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlcixcbiAgICAgICAgICBlYXNpbmc6IHRoZW1lLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlT3V0XG4gICAgICAgIH0pLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScgLy8gVHJhbnNwYXJlbnQgdG8gdGhlIGhvdmVyIHN0eWxlLlxuXG4gICAgICB9LFxuICAgICAgJyYkZm9jdXNlZDphZnRlcic6IHtcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGVYKDEpJ1xuICAgICAgfSxcbiAgICAgICcmJGVycm9yOmFmdGVyJzoge1xuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogdGhlbWUucGFsZXR0ZS5lcnJvci5tYWluLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVgoMSknIC8vIGVycm9yIGlzIGFsd2F5cyB1bmRlcmxpbmVkIGluIHJlZFxuXG4gICAgICB9LFxuICAgICAgJyY6YmVmb3JlJzoge1xuICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkIFwiLmNvbmNhdChib3R0b21MaW5lQ29sb3IpLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIC8vIERvaW5nIHRoZSBvdGhlciB3YXkgYXJvdW5kIGNyYXNoIG9uIElFIDExIFwiJydcIiBodHRwczovL2dpdGh1Yi5jb20vY3NzaW5qcy9qc3MvaXNzdWVzLzI0MlxuICAgICAgICBjb250ZW50OiAnXCJcXFxcMDBhMFwiJyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ2JvcmRlci1ib3R0b20tY29sb3InLCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXJcbiAgICAgICAgfSksXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyAvLyBUcmFuc3BhcmVudCB0byB0aGUgaG92ZXIgc3R5bGUuXG5cbiAgICAgIH0sXG4gICAgICAnJjpob3ZlcjpiZWZvcmUnOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgXCIuY29uY2F0KHRoZW1lLnBhbGV0dGUudGV4dC5wcmltYXJ5KVxuICAgICAgfSxcbiAgICAgICcmJGRpc2FibGVkOmJlZm9yZSc6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tU3R5bGU6ICdkb3R0ZWQnXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgdGhlIGNvbXBvbmVudCBpcyBmb2N1c2VkLiAqL1xuICAgIGZvY3VzZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZWQ9e3RydWV9YC4gKi9cbiAgICBkaXNhYmxlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBzdGFydEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgYWRvcm5lZFN0YXJ0OiB7XG4gICAgICBwYWRkaW5nTGVmdDogMTJcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZW5kQWRvcm5tZW50YCBpcyBwcm92aWRlZC4gKi9cbiAgICBhZG9ybmVkRW5kOiB7XG4gICAgICBwYWRkaW5nUmlnaHQ6IDEyXG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGVycm9yPXt0cnVlfWAuICovXG4gICAgZXJyb3I6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgbWFyZ2luPVwiZGVuc2VcImAuICovXG4gICAgbWFyZ2luRGVuc2U6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgbXVsdGlsaW5lPXt0cnVlfWAuICovXG4gICAgbXVsdGlsaW5lOiB7XG4gICAgICBwYWRkaW5nOiAnMjdweCAxMnB4IDEwcHgnLFxuICAgICAgJyYkbWFyZ2luRGVuc2UnOiB7XG4gICAgICAgIHBhZGRpbmdUb3A6IDIzLFxuICAgICAgICBwYWRkaW5nQm90dG9tOiA2XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuICovXG4gICAgaW5wdXQ6IHtcbiAgICAgIHBhZGRpbmc6ICcyN3B4IDEycHggMTBweCcsXG4gICAgICAnJjotd2Via2l0LWF1dG9maWxsJzoge1xuICAgICAgICBXZWJraXRCb3hTaGFkb3c6IHRoZW1lLnBhbGV0dGUudHlwZSA9PT0gJ2xpZ2h0JyA/IG51bGwgOiAnMCAwIDAgMTAwcHggIzI2Njc5OCBpbnNldCcsXG4gICAgICAgIFdlYmtpdFRleHRGaWxsQ29sb3I6IHRoZW1lLnBhbGV0dGUudHlwZSA9PT0gJ2xpZ2h0JyA/IG51bGwgOiAnI2ZmZicsXG4gICAgICAgIGNhcmV0Q29sb3I6IHRoZW1lLnBhbGV0dGUudHlwZSA9PT0gJ2xpZ2h0JyA/IG51bGwgOiAnI2ZmZicsXG4gICAgICAgIGJvcmRlclRvcExlZnRSYWRpdXM6ICdpbmhlcml0JyxcbiAgICAgICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6ICdpbmhlcml0J1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtYXJnaW49XCJkZW5zZVwiYC4gKi9cbiAgICBpbnB1dE1hcmdpbkRlbnNlOiB7XG4gICAgICBwYWRkaW5nVG9wOiAyMyxcbiAgICAgIHBhZGRpbmdCb3R0b206IDZcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgaWYgaW4gYDxGb3JtQ29udHJvbCBoaWRkZW5MYWJlbCAvPmAuICovXG4gICAgaW5wdXRIaWRkZW5MYWJlbDoge1xuICAgICAgcGFkZGluZ1RvcDogMTgsXG4gICAgICBwYWRkaW5nQm90dG9tOiAxOSxcbiAgICAgICcmJGlucHV0TWFyZ2luRGVuc2UnOiB7XG4gICAgICAgIHBhZGRpbmdUb3A6IDEwLFxuICAgICAgICBwYWRkaW5nQm90dG9tOiAxMVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtdWx0aWxpbmU9e3RydWV9YC4gKi9cbiAgICBpbnB1dE11bHRpbGluZToge1xuICAgICAgcGFkZGluZzogMFxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBzdGFydEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgaW5wdXRBZG9ybmVkU3RhcnQ6IHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAwXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYGVuZEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgaW5wdXRBZG9ybmVkRW5kOiB7XG4gICAgICBwYWRkaW5nUmlnaHQ6IDBcbiAgICB9XG4gIH07XG59O1xudmFyIEZpbGxlZElucHV0ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRmlsbGVkSW5wdXQocHJvcHMsIHJlZikge1xuICB2YXIgZGlzYWJsZVVuZGVybGluZSA9IHByb3BzLmRpc2FibGVVbmRlcmxpbmUsXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIF9wcm9wcyRmdWxsV2lkdGggPSBwcm9wcy5mdWxsV2lkdGgsXG4gICAgICBmdWxsV2lkdGggPSBfcHJvcHMkZnVsbFdpZHRoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmdWxsV2lkdGgsXG4gICAgICBfcHJvcHMkaW5wdXRDb21wb25lbnQgPSBwcm9wcy5pbnB1dENvbXBvbmVudCxcbiAgICAgIGlucHV0Q29tcG9uZW50ID0gX3Byb3BzJGlucHV0Q29tcG9uZW50ID09PSB2b2lkIDAgPyAnaW5wdXQnIDogX3Byb3BzJGlucHV0Q29tcG9uZW50LFxuICAgICAgX3Byb3BzJG11bHRpbGluZSA9IHByb3BzLm11bHRpbGluZSxcbiAgICAgIG11bHRpbGluZSA9IF9wcm9wcyRtdWx0aWxpbmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJG11bHRpbGluZSxcbiAgICAgIF9wcm9wcyR0eXBlID0gcHJvcHMudHlwZSxcbiAgICAgIHR5cGUgPSBfcHJvcHMkdHlwZSA9PT0gdm9pZCAwID8gJ3RleHQnIDogX3Byb3BzJHR5cGUsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiZGlzYWJsZVVuZGVybGluZVwiLCBcImNsYXNzZXNcIiwgXCJmdWxsV2lkdGhcIiwgXCJpbnB1dENvbXBvbmVudFwiLCBcIm11bHRpbGluZVwiLCBcInR5cGVcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnB1dEJhc2UsIF9leHRlbmRzKHtcbiAgICBjbGFzc2VzOiBfZXh0ZW5kcyh7fSwgY2xhc3Nlcywge1xuICAgICAgcm9vdDogY2xzeChjbGFzc2VzLnJvb3QsICFkaXNhYmxlVW5kZXJsaW5lICYmIGNsYXNzZXMudW5kZXJsaW5lKSxcbiAgICAgIHVuZGVybGluZTogbnVsbFxuICAgIH0pLFxuICAgIGZ1bGxXaWR0aDogZnVsbFdpZHRoLFxuICAgIGlucHV0Q29tcG9uZW50OiBpbnB1dENvbXBvbmVudCxcbiAgICBtdWx0aWxpbmU6IG11bHRpbGluZSxcbiAgICByZWY6IHJlZixcbiAgICB0eXBlOiB0eXBlXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IEZpbGxlZElucHV0LnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoaXMgcHJvcCBoZWxwcyB1c2VycyB0byBmaWxsIGZvcm1zIGZhc3RlciwgZXNwZWNpYWxseSBvbiBtb2JpbGUgZGV2aWNlcy5cbiAgICogVGhlIG5hbWUgY2FuIGJlIGNvbmZ1c2luZywgYXMgaXQncyBtb3JlIGxpa2UgYW4gYXV0b2ZpbGwuXG4gICAqIFlvdSBjYW4gbGVhcm4gbW9yZSBhYm91dCBpdCBbZm9sbG93aW5nIHRoZSBzcGVjaWZpY2F0aW9uXShodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNhdXRvZmlsbCkuXG4gICAqL1xuICBhdXRvQ29tcGxldGU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGZvY3VzZWQgZHVyaW5nIHRoZSBmaXJzdCBtb3VudC5cbiAgICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBgaW5wdXRgIGVsZW1lbnQgdmFsdWUuIFVzZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGNvbnRyb2xsZWQuXG4gICAqL1xuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCB3aWxsIG5vdCBoYXZlIGFuIHVuZGVybGluZS5cbiAgICovXG4gIGRpc2FibGVVbmRlcmxpbmU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmQgYElucHV0QWRvcm5tZW50YCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBlbmRBZG9ybm1lbnQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCB3aWxsIGluZGljYXRlIGFuIGVycm9yLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBlcnJvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiBpdHMgY29udGFpbmVyLlxuICAgKi9cbiAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgaW5wdXRDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogW0F0dHJpYnV0ZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNBdHRyaWJ1dGVzKSBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBQYXNzIGEgcmVmIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFJlZjogcmVmVHlwZSxcblxuICAvKipcbiAgICogSWYgYGRlbnNlYCwgd2lsbCBhZGp1c3QgdmVydGljYWwgc3BhY2luZy4gVGhpcyBpcyBub3JtYWxseSBvYnRhaW5lZCB2aWEgY29udGV4dCBmcm9tXG4gICAqIEZvcm1Db250cm9sLlxuICAgKi9cbiAgbWFyZ2luOiBQcm9wVHlwZXMub25lT2YoWydkZW5zZScsICdub25lJ10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGEgdGV4dGFyZWEgZWxlbWVudCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVsdGlsaW5lOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTmFtZSBhdHRyaWJ1dGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICogWW91IGNhbiBwdWxsIG91dCB0aGUgbmV3IHZhbHVlIGJ5IGFjY2Vzc2luZyBgZXZlbnQudGFyZ2V0LnZhbHVlYCAoc3RyaW5nKS5cbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogVGhlIHNob3J0IGhpbnQgZGlzcGxheWVkIGluIHRoZSBpbnB1dCBiZWZvcmUgdGhlIHVzZXIgZW50ZXJzIGEgdmFsdWUuXG4gICAqL1xuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSXQgcHJldmVudHMgdGhlIHVzZXIgZnJvbSBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkXG4gICAqIChub3QgZnJvbSBpbnRlcmFjdGluZyB3aXRoIHRoZSBmaWVsZCkuXG4gICAqL1xuICByZWFkT25seTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IHdoZW4gbXVsdGlsaW5lIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICovXG4gIHJvd3M6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IHdoZW4gbXVsdGlsaW5lIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICovXG4gIHJvd3NNYXg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogU3RhcnQgYElucHV0QWRvcm5tZW50YCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBzdGFydEFkb3JubWVudDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC4gSXQgc2hvdWxkIGJlIFthIHZhbGlkIEhUTUw1IGlucHV0IHR5cGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNGb3JtXyUzQ2lucHV0JTNFX3R5cGVzKS5cbiAgICovXG4gIHR5cGU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LCByZXF1aXJlZCBmb3IgYSBjb250cm9sbGVkIGNvbXBvbmVudC5cbiAgICovXG4gIHZhbHVlOiBQcm9wVHlwZXMuYW55XG59IDogdm9pZCAwO1xuRmlsbGVkSW5wdXQubXVpTmFtZSA9ICdJbnB1dCc7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpRmlsbGVkSW5wdXQnXG59KShGaWxsZWRJbnB1dCk7IiwiaW1wb3J0IHsgdXNlVGhlbWUgYXMgdXNlVGhlbWVXaXRob3V0RGVmYXVsdCB9IGZyb20gJ0BtYXRlcmlhbC11aS9zdHlsZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkZWZhdWx0VGhlbWUgZnJvbSAnLi9kZWZhdWx0VGhlbWUnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlVGhlbWUoKSB7XG4gIHZhciB0aGVtZSA9IHVzZVRoZW1lV2l0aG91dERlZmF1bHQoKSB8fCBkZWZhdWx0VGhlbWU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VEZWJ1Z1ZhbHVlKHRoZW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGVtZTtcbn0iLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IHVzZVRoZW1lIGZyb20gJy4uL3N0eWxlcy91c2VUaGVtZSc7XG5pbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICcuLi91dGlscy9jYXBpdGFsaXplJztcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHJldHVybiB7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAtNSxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBtYXJnaW46IDAsXG4gICAgICBwYWRkaW5nOiAnMCA4cHgnLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnaW5oZXJpdCcsXG4gICAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcbiAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBsZWdlbmQgZWxlbWVudCB3aGVuIGBsYWJlbFdpZHRoYCBpcyBwcm92aWRlZC4gKi9cbiAgICBsZWdlbmQ6IHtcbiAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIGxpbmVIZWlnaHQ6ICcxMXB4JyxcbiAgICAgIC8vIHN5bmMgd2l0aCBgaGVpZ2h0YCBpbiBgbGVnZW5kYCBzdHlsZXNcbiAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgnd2lkdGgnLCB7XG4gICAgICAgIGR1cmF0aW9uOiAxNTAsXG4gICAgICAgIGVhc2luZzogdGhlbWUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VPdXRcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBsZWdlbmQgZWxlbWVudC4gKi9cbiAgICBsZWdlbmRMYWJlbGxlZDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgIHdpZHRoOiAnYXV0bycsXG4gICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICBoZWlnaHQ6IDExLFxuICAgICAgLy8gc3luYyB3aXRoIGBsaW5lSGVpZ2h0YCBpbiBgbGVnZW5kYCBzdHlsZXNcbiAgICAgIGZvbnRTaXplOiAnMC43NWVtJyxcbiAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgbWF4V2lkdGg6IDAuMDEsXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ21heC13aWR0aCcsIHtcbiAgICAgICAgZHVyYXRpb246IDUwLFxuICAgICAgICBlYXNpbmc6IHRoZW1lLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlT3V0XG4gICAgICB9KSxcbiAgICAgICcmID4gc3Bhbic6IHtcbiAgICAgICAgcGFkZGluZ0xlZnQ6IDUsXG4gICAgICAgIHBhZGRpbmdSaWdodDogNSxcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGxlZ2VuZCBlbGVtZW50IGlzIG5vdGNoZWQuICovXG4gICAgbGVnZW5kTm90Y2hlZDoge1xuICAgICAgbWF4V2lkdGg6IDEwMDAsXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ21heC13aWR0aCcsIHtcbiAgICAgICAgZHVyYXRpb246IDEwMCxcbiAgICAgICAgZWFzaW5nOiB0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dCxcbiAgICAgICAgZGVsYXk6IDUwXG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxudmFyIE5vdGNoZWRPdXRsaW5lID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTm90Y2hlZE91dGxpbmUocHJvcHMsIHJlZikge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgbGFiZWwgPSBwcm9wcy5sYWJlbCxcbiAgICAgIGxhYmVsV2lkdGhQcm9wID0gcHJvcHMubGFiZWxXaWR0aCxcbiAgICAgIG5vdGNoZWQgPSBwcm9wcy5ub3RjaGVkLFxuICAgICAgc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJsYWJlbFwiLCBcImxhYmVsV2lkdGhcIiwgXCJub3RjaGVkXCIsIFwic3R5bGVcIl0pO1xuXG4gIHZhciB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIHZhciBhbGlnbiA9IHRoZW1lLmRpcmVjdGlvbiA9PT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuXG4gIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIiwgX2V4dGVuZHMoe1xuICAgICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lKSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgc3R5bGU6IHN0eWxlXG4gICAgfSwgb3RoZXIpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxlZ2VuZFwiLCB7XG4gICAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5sZWdlbmRMYWJlbGxlZCwgbm90Y2hlZCAmJiBjbGFzc2VzLmxlZ2VuZE5vdGNoZWQpXG4gICAgfSwgbGFiZWwgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgbGFiZWwpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogJyYjODIwMzsnXG4gICAgICB9XG4gICAgfSkpKTtcbiAgfVxuXG4gIHZhciBsYWJlbFdpZHRoID0gbGFiZWxXaWR0aFByb3AgPiAwID8gbGFiZWxXaWR0aFByb3AgKiAwLjc1ICsgOCA6IDAuMDE7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIsIF9leHRlbmRzKHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgc3R5bGU6IF9leHRlbmRzKF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYWRkaW5nXCIuY29uY2F0KGNhcGl0YWxpemUoYWxpZ24pKSwgOCksIHN0eWxlKSxcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUpLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsZWdlbmRcIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5sZWdlbmQsXG4gICAgc3R5bGU6IHtcbiAgICAgIC8vIElFIDExOiBmaWVsZHNldCB3aXRoIGxlZ2VuZCBkb2VzIG5vdCByZW5kZXJcbiAgICAgIC8vIGEgYm9yZGVyIHJhZGl1cy4gVGhpcyBtYWludGFpbnMgY29uc2lzdGVuY3lcbiAgICAgIC8vIGJ5IGFsd2F5cyBoYXZpbmcgYSBsZWdlbmQgcmVuZGVyZWRcbiAgICAgIHdpZHRoOiBub3RjaGVkID8gbGFiZWxXaWR0aCA6IDAuMDFcbiAgICB9XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgIF9faHRtbDogJyYjODIwMzsnXG4gICAgfVxuICB9KSkpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBOb3RjaGVkT3V0bGluZS5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGxhYmVsLlxuICAgKi9cbiAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIGxhYmVsLlxuICAgKi9cbiAgbGFiZWxXaWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBvdXRsaW5lIGlzIG5vdGNoZWQgdG8gYWNjb21tb2RhdGUgdGhlIGxhYmVsLlxuICAgKi9cbiAgbm90Y2hlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3Rcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnUHJpdmF0ZU5vdGNoZWRPdXRsaW5lJ1xufSkoTm90Y2hlZE91dGxpbmUpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IHJlZlR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IElucHV0QmFzZSBmcm9tICcuLi9JbnB1dEJhc2UnO1xuaW1wb3J0IE5vdGNoZWRPdXRsaW5lIGZyb20gJy4vTm90Y2hlZE91dGxpbmUnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgdmFyIGJvcmRlckNvbG9yID0gdGhlbWUucGFsZXR0ZS50eXBlID09PSAnbGlnaHQnID8gJ3JnYmEoMCwgMCwgMCwgMC4yMyknIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4yMyknO1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBib3JkZXJSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1cyxcbiAgICAgICcmOmhvdmVyICRub3RjaGVkT3V0bGluZSc6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5wcmltYXJ5XG4gICAgICB9LFxuICAgICAgLy8gUmVzZXQgb24gdG91Y2ggZGV2aWNlcywgaXQgZG9lc24ndCBhZGQgc3BlY2lmaWNpdHlcbiAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgJyY6aG92ZXIgJG5vdGNoZWRPdXRsaW5lJzoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBib3JkZXJDb2xvclxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJyYkZm9jdXNlZCAkbm90Y2hlZE91dGxpbmUnOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpbixcbiAgICAgICAgYm9yZGVyV2lkdGg6IDJcbiAgICAgIH0sXG4gICAgICAnJiRlcnJvciAkbm90Y2hlZE91dGxpbmUnOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGVtZS5wYWxldHRlLmVycm9yLm1haW5cbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZCAkbm90Y2hlZE91dGxpbmUnOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb2xvciBpcyBzZWNvbmRhcnkuICovXG4gICAgY29sb3JTZWNvbmRhcnk6IHtcbiAgICAgICcmJGZvY3VzZWQgJG5vdGNoZWRPdXRsaW5lJzoge1xuICAgICAgICBib3JkZXJDb2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpblxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb21wb25lbnQgaXMgZm9jdXNlZC4gKi9cbiAgICBmb2N1c2VkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVkPXt0cnVlfWAuICovXG4gICAgZGlzYWJsZWQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgc3RhcnRBZG9ybm1lbnRgIGlzIHByb3ZpZGVkLiAqL1xuICAgIGFkb3JuZWRTdGFydDoge1xuICAgICAgcGFkZGluZ0xlZnQ6IDE0XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGVuZEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgYWRvcm5lZEVuZDoge1xuICAgICAgcGFkZGluZ1JpZ2h0OiAxNFxuICAgIH0sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBlcnJvcj17dHJ1ZX1gLiAqL1xuICAgIGVycm9yOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICAgIG1hcmdpbkRlbnNlOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG11bHRpbGluZT17dHJ1ZX1gLiAqL1xuICAgIG11bHRpbGluZToge1xuICAgICAgcGFkZGluZzogJzE4LjVweCAxNHB4JyxcbiAgICAgICcmJG1hcmdpbkRlbnNlJzoge1xuICAgICAgICBwYWRkaW5nVG9wOiAxMC41LFxuICAgICAgICBwYWRkaW5nQm90dG9tOiAxMC41XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgTm90Y2hlZE91dGxpbmVgIGVsZW1lbnQuICovXG4gICAgbm90Y2hlZE91dGxpbmU6IHtcbiAgICAgIGJvcmRlckNvbG9yOiBib3JkZXJDb2xvclxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50LiAqL1xuICAgIGlucHV0OiB7XG4gICAgICBwYWRkaW5nOiAnMTguNXB4IDE0cHgnLFxuICAgICAgJyY6LXdlYmtpdC1hdXRvZmlsbCc6IHtcbiAgICAgICAgV2Via2l0Qm94U2hhZG93OiB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyBudWxsIDogJzAgMCAwIDEwMHB4ICMyNjY3OTggaW5zZXQnLFxuICAgICAgICBXZWJraXRUZXh0RmlsbENvbG9yOiB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyBudWxsIDogJyNmZmYnLFxuICAgICAgICBjYXJldENvbG9yOiB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyBudWxsIDogJyNmZmYnLFxuICAgICAgICBib3JkZXJSYWRpdXM6ICdpbmhlcml0J1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtYXJnaW49XCJkZW5zZVwiYC4gKi9cbiAgICBpbnB1dE1hcmdpbkRlbnNlOiB7XG4gICAgICBwYWRkaW5nVG9wOiAxMC41LFxuICAgICAgcGFkZGluZ0JvdHRvbTogMTAuNVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtdWx0aWxpbmU9e3RydWV9YC4gKi9cbiAgICBpbnB1dE11bHRpbGluZToge1xuICAgICAgcGFkZGluZzogMFxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBzdGFydEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgaW5wdXRBZG9ybmVkU3RhcnQ6IHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAwXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYGVuZEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgaW5wdXRBZG9ybmVkRW5kOiB7XG4gICAgICBwYWRkaW5nUmlnaHQ6IDBcbiAgICB9XG4gIH07XG59O1xudmFyIE91dGxpbmVkSW5wdXQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBPdXRsaW5lZElucHV0KHByb3BzLCByZWYpIHtcbiAgdmFyIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgX3Byb3BzJGZ1bGxXaWR0aCA9IHByb3BzLmZ1bGxXaWR0aCxcbiAgICAgIGZ1bGxXaWR0aCA9IF9wcm9wcyRmdWxsV2lkdGggPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZ1bGxXaWR0aCxcbiAgICAgIF9wcm9wcyRpbnB1dENvbXBvbmVudCA9IHByb3BzLmlucHV0Q29tcG9uZW50LFxuICAgICAgaW5wdXRDb21wb25lbnQgPSBfcHJvcHMkaW5wdXRDb21wb25lbnQgPT09IHZvaWQgMCA/ICdpbnB1dCcgOiBfcHJvcHMkaW5wdXRDb21wb25lbnQsXG4gICAgICBsYWJlbCA9IHByb3BzLmxhYmVsLFxuICAgICAgX3Byb3BzJGxhYmVsV2lkdGggPSBwcm9wcy5sYWJlbFdpZHRoLFxuICAgICAgbGFiZWxXaWR0aCA9IF9wcm9wcyRsYWJlbFdpZHRoID09PSB2b2lkIDAgPyAwIDogX3Byb3BzJGxhYmVsV2lkdGgsXG4gICAgICBfcHJvcHMkbXVsdGlsaW5lID0gcHJvcHMubXVsdGlsaW5lLFxuICAgICAgbXVsdGlsaW5lID0gX3Byb3BzJG11bHRpbGluZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkbXVsdGlsaW5lLFxuICAgICAgbm90Y2hlZCA9IHByb3BzLm5vdGNoZWQsXG4gICAgICBfcHJvcHMkdHlwZSA9IHByb3BzLnR5cGUsXG4gICAgICB0eXBlID0gX3Byb3BzJHR5cGUgPT09IHZvaWQgMCA/ICd0ZXh0JyA6IF9wcm9wcyR0eXBlLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNsYXNzZXNcIiwgXCJmdWxsV2lkdGhcIiwgXCJpbnB1dENvbXBvbmVudFwiLCBcImxhYmVsXCIsIFwibGFiZWxXaWR0aFwiLCBcIm11bHRpbGluZVwiLCBcIm5vdGNoZWRcIiwgXCJ0eXBlXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRCYXNlLCBfZXh0ZW5kcyh7XG4gICAgcmVuZGVyU3VmZml4OiBmdW5jdGlvbiByZW5kZXJTdWZmaXgoc3RhdGUpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChOb3RjaGVkT3V0bGluZSwge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzZXMubm90Y2hlZE91dGxpbmUsXG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgbGFiZWxXaWR0aDogbGFiZWxXaWR0aCxcbiAgICAgICAgbm90Y2hlZDogdHlwZW9mIG5vdGNoZWQgIT09ICd1bmRlZmluZWQnID8gbm90Y2hlZCA6IEJvb2xlYW4oc3RhdGUuc3RhcnRBZG9ybm1lbnQgfHwgc3RhdGUuZmlsbGVkIHx8IHN0YXRlLmZvY3VzZWQpXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNsYXNzZXM6IF9leHRlbmRzKHt9LCBjbGFzc2VzLCB7XG4gICAgICByb290OiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3Nlcy51bmRlcmxpbmUpLFxuICAgICAgbm90Y2hlZE91dGxpbmU6IG51bGxcbiAgICB9KSxcbiAgICBmdWxsV2lkdGg6IGZ1bGxXaWR0aCxcbiAgICBpbnB1dENvbXBvbmVudDogaW5wdXRDb21wb25lbnQsXG4gICAgbXVsdGlsaW5lOiBtdWx0aWxpbmUsXG4gICAgcmVmOiByZWYsXG4gICAgdHlwZTogdHlwZVxuICB9LCBvdGhlcikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBPdXRsaW5lZElucHV0LnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoaXMgcHJvcCBoZWxwcyB1c2VycyB0byBmaWxsIGZvcm1zIGZhc3RlciwgZXNwZWNpYWxseSBvbiBtb2JpbGUgZGV2aWNlcy5cbiAgICogVGhlIG5hbWUgY2FuIGJlIGNvbmZ1c2luZywgYXMgaXQncyBtb3JlIGxpa2UgYW4gYXV0b2ZpbGwuXG4gICAqIFlvdSBjYW4gbGVhcm4gbW9yZSBhYm91dCBpdCBbZm9sbG93aW5nIHRoZSBzcGVjaWZpY2F0aW9uXShodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNhdXRvZmlsbCkuXG4gICAqL1xuICBhdXRvQ29tcGxldGU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGZvY3VzZWQgZHVyaW5nIHRoZSBmaXJzdCBtb3VudC5cbiAgICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBgaW5wdXRgIGVsZW1lbnQgdmFsdWUuIFVzZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGNvbnRyb2xsZWQuXG4gICAqL1xuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmQgYElucHV0QWRvcm5tZW50YCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBlbmRBZG9ybm1lbnQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCB3aWxsIGluZGljYXRlIGFuIGVycm9yLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBlcnJvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiBpdHMgY29udGFpbmVyLlxuICAgKi9cbiAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgaW5wdXRDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogW0F0dHJpYnV0ZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNBdHRyaWJ1dGVzKSBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBQYXNzIGEgcmVmIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFJlZjogcmVmVHlwZSxcblxuICAvKipcbiAgICogVGhlIGxhYmVsIG9mIHRoZSBpbnB1dC4gSXQgaXMgb25seSB1c2VkIGZvciBsYXlvdXQuIFRoZSBhY3R1YWwgbGFiZWxsaW5nXG4gICAqIGlzIGhhbmRsZWQgYnkgYElucHV0TGFiZWxgLiBJZiBzcGVjaWZpZWQgYGxhYmVsV2lkdGhgIGlzIGlnbm9yZWQuXG4gICAqL1xuICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgbGFiZWwuIElzIGlnbm9yZWQgaWYgYGxhYmVsYCBpcyBwcm92aWRlZC4gUHJlZmVyIGBsYWJlbGBcbiAgICogaWYgdGhlIGlucHV0IGxhYmVsIGFwcGVhcnMgd2l0aCBhIHN0cmlrZSB0aHJvdWdoLlxuICAgKi9cbiAgbGFiZWxXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogSWYgYGRlbnNlYCwgd2lsbCBhZGp1c3QgdmVydGljYWwgc3BhY2luZy4gVGhpcyBpcyBub3JtYWxseSBvYnRhaW5lZCB2aWEgY29udGV4dCBmcm9tXG4gICAqIEZvcm1Db250cm9sLlxuICAgKi9cbiAgbWFyZ2luOiBQcm9wVHlwZXMub25lT2YoWydkZW5zZScsICdub25lJ10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGEgdGV4dGFyZWEgZWxlbWVudCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVsdGlsaW5lOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTmFtZSBhdHRyaWJ1dGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIG91dGxpbmUgaXMgbm90Y2hlZCB0byBhY2NvbW1vZGF0ZSB0aGUgbGFiZWwuXG4gICAqL1xuICBub3RjaGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgdmFsdWUgYnkgYWNjZXNzaW5nIGBldmVudC50YXJnZXQudmFsdWVgIChzdHJpbmcpLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBUaGUgc2hvcnQgaGludCBkaXNwbGF5ZWQgaW4gdGhlIGlucHV0IGJlZm9yZSB0aGUgdXNlciBlbnRlcnMgYSB2YWx1ZS5cbiAgICovXG4gIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJdCBwcmV2ZW50cyB0aGUgdXNlciBmcm9tIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiB0aGUgZmllbGRcbiAgICogKG5vdCBmcm9tIGludGVyYWN0aW5nIHdpdGggdGhlIGZpZWxkKS5cbiAgICovXG4gIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgcmVxdWlyZWQuXG4gICAqL1xuICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgcm93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgcm93c01heDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBTdGFydCBgSW5wdXRBZG9ybm1lbnRgIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIHN0YXJ0QWRvcm5tZW50OiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogVHlwZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LiBJdCBzaG91bGQgYmUgW2EgdmFsaWQgSFRNTDUgaW5wdXQgdHlwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I0Zvcm1fJTNDaW5wdXQlM0VfdHlwZXMpLlxuICAgKi9cbiAgdHlwZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQsIHJlcXVpcmVkIGZvciBhIGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnlcbn0gOiB2b2lkIDA7XG5PdXRsaW5lZElucHV0Lm11aU5hbWUgPSAnSW5wdXQnO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aU91dGxpbmVkSW5wdXQnXG59KShPdXRsaW5lZElucHV0KTsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRm9ybUNvbnRyb2xDb250ZXh0IGZyb20gJy4vRm9ybUNvbnRyb2xDb250ZXh0JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZUZvcm1Db250cm9sKCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChGb3JtQ29udHJvbENvbnRleHQpO1xufSIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCBmb3JtQ29udHJvbFN0YXRlIGZyb20gJy4uL0Zvcm1Db250cm9sL2Zvcm1Db250cm9sU3RhdGUnO1xuaW1wb3J0IHVzZUZvcm1Db250cm9sIGZyb20gJy4uL0Zvcm1Db250cm9sL3VzZUZvcm1Db250cm9sJztcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4uL3V0aWxzL2NhcGl0YWxpemUnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IF9leHRlbmRzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRleHQuc2Vjb25kYXJ5XG4gICAgfSwgdGhlbWUudHlwb2dyYXBoeS5ib2R5MSwge1xuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAnJiRmb2N1c2VkJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW5cbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5kaXNhYmxlZFxuICAgICAgfSxcbiAgICAgICcmJGVycm9yJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5lcnJvci5tYWluXG4gICAgICB9XG4gICAgfSksXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb2xvciBpcyBzZWNvbmRhcnkuICovXG4gICAgY29sb3JTZWNvbmRhcnk6IHtcbiAgICAgICcmJGZvY3VzZWQnOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZvY3VzZWQ9e3RydWV9YC4gKi9cbiAgICBmb2N1c2VkOiB7fSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVkPXt0cnVlfWAuICovXG4gICAgZGlzYWJsZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZXJyb3I9e3RydWV9YC4gKi9cbiAgICBlcnJvcjoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBmaWxsZWQ9e3RydWV9YC4gKi9cbiAgICBmaWxsZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgcmVxdWlyZWQ9e3RydWV9YC4gKi9cbiAgICByZXF1aXJlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYXN0ZXJpc2sgZWxlbWVudC4gKi9cbiAgICBhc3Rlcmlzazoge1xuICAgICAgJyYkZXJyb3InOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmVycm9yLm1haW5cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xudmFyIEZvcm1MYWJlbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZvcm1MYWJlbChwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgX3Byb3BzJGNvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgIENvbXBvbmVudCA9IF9wcm9wcyRjb21wb25lbnQgPT09IHZvaWQgMCA/ICdsYWJlbCcgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGVycm9yID0gcHJvcHMuZXJyb3IsXG4gICAgICBmaWxsZWQgPSBwcm9wcy5maWxsZWQsXG4gICAgICBmb2N1c2VkID0gcHJvcHMuZm9jdXNlZCxcbiAgICAgIHJlcXVpcmVkID0gcHJvcHMucmVxdWlyZWQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sb3JcIiwgXCJjb21wb25lbnRcIiwgXCJkaXNhYmxlZFwiLCBcImVycm9yXCIsIFwiZmlsbGVkXCIsIFwiZm9jdXNlZFwiLCBcInJlcXVpcmVkXCJdKTtcblxuICB2YXIgbXVpRm9ybUNvbnRyb2wgPSB1c2VGb3JtQ29udHJvbCgpO1xuICB2YXIgZmNzID0gZm9ybUNvbnRyb2xTdGF0ZSh7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIG11aUZvcm1Db250cm9sOiBtdWlGb3JtQ29udHJvbCxcbiAgICBzdGF0ZXM6IFsnY29sb3InLCAncmVxdWlyZWQnLCAnZm9jdXNlZCcsICdkaXNhYmxlZCcsICdlcnJvcicsICdmaWxsZWQnXVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzZXNbXCJjb2xvclwiLmNvbmNhdChjYXBpdGFsaXplKGZjcy5jb2xvciB8fCAncHJpbWFyeScpKV0sIGNsYXNzTmFtZSwgZmNzLmRpc2FibGVkICYmIGNsYXNzZXMuZGlzYWJsZWQsIGZjcy5lcnJvciAmJiBjbGFzc2VzLmVycm9yLCBmY3MuZmlsbGVkICYmIGNsYXNzZXMuZmlsbGVkLCBmY3MuZm9jdXNlZCAmJiBjbGFzc2VzLmZvY3VzZWQsIGZjcy5yZXF1aXJlZCAmJiBjbGFzc2VzLnJlcXVpcmVkKSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlciksIGNoaWxkcmVuLCBmY3MucmVxdWlyZWQgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMuYXN0ZXJpc2ssIGZjcy5lcnJvciAmJiBjbGFzc2VzLmVycm9yKVxuICB9LCBcIlxcdTIwMDlcIiwgJyonKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IEZvcm1MYWJlbC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGFiZWwgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiBhIGRpc2FibGVkIHN0YXRlLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbCBzaG91bGQgYmUgZGlzcGxheWVkIGluIGFuIGVycm9yIHN0YXRlLlxuICAgKi9cbiAgZXJyb3I6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbCBzaG91bGQgdXNlIGZpbGxlZCBjbGFzc2VzIGtleS5cbiAgICovXG4gIGZpbGxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IG9mIHRoaXMgbGFiZWwgaXMgZm9jdXNlZCAodXNlZCBieSBgRm9ybUdyb3VwYCBjb21wb25lbnRzKS5cbiAgICovXG4gIGZvY3VzZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbCB3aWxsIGluZGljYXRlIHRoYXQgdGhlIGlucHV0IGlzIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUZvcm1MYWJlbCdcbn0pKEZvcm1MYWJlbCk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IGZvcm1Db250cm9sU3RhdGUgZnJvbSAnLi4vRm9ybUNvbnRyb2wvZm9ybUNvbnRyb2xTdGF0ZSc7XG5pbXBvcnQgdXNlRm9ybUNvbnRyb2wgZnJvbSAnLi4vRm9ybUNvbnRyb2wvdXNlRm9ybUNvbnRyb2wnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IEZvcm1MYWJlbCBmcm9tICcuLi9Gb3JtTGFiZWwnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICB0cmFuc2Zvcm1PcmlnaW46ICd0b3AgbGVmdCdcbiAgICB9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZm9jdXNlZD17dHJ1ZX1gLiAqL1xuICAgIGZvY3VzZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZWQ9e3RydWV9YC4gKi9cbiAgICBkaXNhYmxlZDoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBlcnJvcj17dHJ1ZX1gLiAqL1xuICAgIGVycm9yOiB7fSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHJlcXVpcmVkPXt0cnVlfWAuICovXG4gICAgcmVxdWlyZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIGFzdGVyaXNrIGVsZW1lbnQuICovXG4gICAgYXN0ZXJpc2s6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiB0aGUgY29tcG9uZW50IGlzIGEgZGVzY2VuZGFudCBvZiBgRm9ybUNvbnRyb2xgLiAqL1xuICAgIGZvcm1Db250cm9sOiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICAvLyBzbGlnaHQgYWx0ZXJhdGlvbiB0byBzcGVjIHNwYWNpbmcgdG8gbWF0Y2ggdmlzdWFsIHNwZWMgcmVzdWx0XG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwgMjRweCkgc2NhbGUoMSknXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICAgIG1hcmdpbkRlbnNlOiB7XG4gICAgICAvLyBDb21wZW5zYXRpb24gZm9yIHRoZSBgSW5wdXQuaW5wdXREZW5zZWAgc3R5bGUuXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwgMjFweCkgc2NhbGUoMSknXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYHNocmluaz17dHJ1ZX1gLiAqL1xuICAgIHNocmluazoge1xuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsIDEuNXB4KSBzY2FsZSgwLjc1KScsXG4gICAgICB0cmFuc2Zvcm1PcmlnaW46ICd0b3AgbGVmdCdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgZGlzYWJsZUFuaW1hdGlvbj17ZmFsc2V9YC4gKi9cbiAgICBhbmltYXRlZDoge1xuICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKFsnY29sb3InLCAndHJhbnNmb3JtJ10sIHtcbiAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXIsXG4gICAgICAgIGVhc2luZzogdGhlbWUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VPdXRcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJmaWxsZWRcImAuICovXG4gICAgZmlsbGVkOiB7XG4gICAgICAvLyBDaHJvbWUncyBhdXRvZmlsbCBmZWF0dXJlIGdpdmVzIHRoZSBpbnB1dCBmaWVsZCBhIHllbGxvdyBiYWNrZ3JvdW5kLlxuICAgICAgLy8gU2luY2UgdGhlIGlucHV0IGZpZWxkIGlzIGJlaGluZCB0aGUgbGFiZWwgaW4gdGhlIEhUTUwgdHJlZSxcbiAgICAgIC8vIHRoZSBpbnB1dCBmaWVsZCBpcyBkcmF3biBsYXN0IGFuZCBoaWRlcyB0aGUgbGFiZWwgd2l0aCBhbiBvcGFxdWUgYmFja2dyb3VuZCBjb2xvci5cbiAgICAgIC8vIHpJbmRleDogMSB3aWxsIHJhaXNlIHRoZSBsYWJlbCBhYm92ZSBvcGFxdWUgYmFja2dyb3VuZC1jb2xvcnMgb2YgaW5wdXQuXG4gICAgICB6SW5kZXg6IDEsXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMTJweCwgMjBweCkgc2NhbGUoMSknLFxuICAgICAgJyYkbWFyZ2luRGVuc2UnOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxMnB4LCAxN3B4KSBzY2FsZSgxKSdcbiAgICAgIH0sXG4gICAgICAnJiRzaHJpbmsnOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxMnB4LCAxMHB4KSBzY2FsZSgwLjc1KScsXG4gICAgICAgICcmJG1hcmdpbkRlbnNlJzoge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxMnB4LCA3cHgpIHNjYWxlKDAuNzUpJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYC4gKi9cbiAgICBvdXRsaW5lZDoge1xuICAgICAgLy8gc2VlIGNvbW1lbnQgYWJvdmUgb24gZmlsbGVkLnpJbmRleFxuICAgICAgekluZGV4OiAxLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDE0cHgsIDIwcHgpIHNjYWxlKDEpJyxcbiAgICAgICcmJG1hcmdpbkRlbnNlJzoge1xuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMTRweCwgMTJweCkgc2NhbGUoMSknXG4gICAgICB9LFxuICAgICAgJyYkc2hyaW5rJzoge1xuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMTRweCwgLTZweCkgc2NhbGUoMC43NSknXG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbnZhciBJbnB1dExhYmVsID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gSW5wdXRMYWJlbChwcm9wcywgcmVmKSB7XG4gIHZhciBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlQW5pbWF0aSA9IHByb3BzLmRpc2FibGVBbmltYXRpb24sXG4gICAgICBkaXNhYmxlQW5pbWF0aW9uID0gX3Byb3BzJGRpc2FibGVBbmltYXRpID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlQW5pbWF0aSxcbiAgICAgIG1hcmdpbiA9IHByb3BzLm1hcmdpbixcbiAgICAgIHNocmlua1Byb3AgPSBwcm9wcy5zaHJpbmssXG4gICAgICB2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiZGlzYWJsZUFuaW1hdGlvblwiLCBcIm1hcmdpblwiLCBcInNocmlua1wiLCBcInZhcmlhbnRcIl0pO1xuXG4gIHZhciBtdWlGb3JtQ29udHJvbCA9IHVzZUZvcm1Db250cm9sKCk7XG4gIHZhciBzaHJpbmsgPSBzaHJpbmtQcm9wO1xuXG4gIGlmICh0eXBlb2Ygc2hyaW5rID09PSAndW5kZWZpbmVkJyAmJiBtdWlGb3JtQ29udHJvbCkge1xuICAgIHNocmluayA9IG11aUZvcm1Db250cm9sLmZpbGxlZCB8fCBtdWlGb3JtQ29udHJvbC5mb2N1c2VkIHx8IG11aUZvcm1Db250cm9sLmFkb3JuZWRTdGFydDtcbiAgfVxuXG4gIHZhciBmY3MgPSBmb3JtQ29udHJvbFN0YXRlKHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgbXVpRm9ybUNvbnRyb2w6IG11aUZvcm1Db250cm9sLFxuICAgIHN0YXRlczogWydtYXJnaW4nLCAndmFyaWFudCddXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUxhYmVsLCBfZXh0ZW5kcyh7XG4gICAgXCJkYXRhLXNocmlua1wiOiBzaHJpbmssXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCBtdWlGb3JtQ29udHJvbCAmJiBjbGFzc2VzLmZvcm1Db250cm9sLCAhZGlzYWJsZUFuaW1hdGlvbiAmJiBjbGFzc2VzLmFuaW1hdGVkLCBzaHJpbmsgJiYgY2xhc3Nlcy5zaHJpbmssIGZjcy5tYXJnaW4gPT09ICdkZW5zZScgJiYgY2xhc3Nlcy5tYXJnaW5EZW5zZSwge1xuICAgICAgJ2ZpbGxlZCc6IGNsYXNzZXMuZmlsbGVkLFxuICAgICAgJ291dGxpbmVkJzogY2xhc3Nlcy5vdXRsaW5lZFxuICAgIH1bZmNzLnZhcmlhbnRdKSxcbiAgICBjbGFzc2VzOiB7XG4gICAgICBmb2N1c2VkOiBjbGFzc2VzLmZvY3VzZWQsXG4gICAgICBkaXNhYmxlZDogY2xhc3Nlcy5kaXNhYmxlZCxcbiAgICAgIGVycm9yOiBjbGFzc2VzLmVycm9yLFxuICAgICAgcmVxdWlyZWQ6IGNsYXNzZXMucmVxdWlyZWQsXG4gICAgICBhc3RlcmlzazogY2xhc3Nlcy5hc3Rlcmlza1xuICAgIH0sXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gSW5wdXRMYWJlbC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGBJbnB1dExhYmVsYC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LiBJdCBzdXBwb3J0cyB0aG9zZSB0aGVtZSBjb2xvcnMgdGhhdCBtYWtlIHNlbnNlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydwcmltYXJ5JywgJ3NlY29uZGFyeSddKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgdHJhbnNpdGlvbiBhbmltYXRpb24gaXMgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlQW5pbWF0aW9uOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBhcHBseSBkaXNhYmxlZCBjbGFzcy5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGFiZWwgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gYW4gZXJyb3Igc3RhdGUuXG4gICAqL1xuICBlcnJvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IG9mIHRoaXMgbGFiZWwgaXMgZm9jdXNlZC5cbiAgICovXG4gIGZvY3VzZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVuc2VgLCB3aWxsIGFkanVzdCB2ZXJ0aWNhbCBzcGFjaW5nLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBtYXJnaW46IFByb3BUeXBlcy5vbmVPZihbJ2RlbnNlJ10pLFxuXG4gIC8qKlxuICAgKiBpZiBgdHJ1ZWAsIHRoZSBsYWJlbCB3aWxsIGluZGljYXRlIHRoYXQgdGhlIGlucHV0IGlzIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbCBpcyBzaHJ1bmsuXG4gICAqL1xuICBzaHJpbms6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydmaWxsZWQnLCAnb3V0bGluZWQnLCAnc3RhbmRhcmQnXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpSW5wdXRMYWJlbCdcbn0pKElucHV0TGFiZWwpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IGlzRmlsbGVkLCBpc0Fkb3JuZWRTdGFydCB9IGZyb20gJy4uL0lucHV0QmFzZS91dGlscyc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICcuLi91dGlscy9jYXBpdGFsaXplJztcbmltcG9ydCBpc011aUVsZW1lbnQgZnJvbSAnLi4vdXRpbHMvaXNNdWlFbGVtZW50JztcbmltcG9ydCBGb3JtQ29udHJvbENvbnRleHQgZnJvbSAnLi9Gb3JtQ29udHJvbENvbnRleHQnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gIHJvb3Q6IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWZsZXgnLFxuICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIC8vIFJlc2V0IGZpZWxkc2V0IGRlZmF1bHQgc3R5bGUuXG4gICAgbWluV2lkdGg6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBtYXJnaW46IDAsXG4gICAgYm9yZGVyOiAwLFxuICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnIC8vIEZpeCBhbGlnbm1lbnQgaXNzdWUgb24gU2FmYXJpLlxuXG4gIH0sXG5cbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgbWFyZ2luPVwibm9ybWFsXCJgLiAqL1xuICBtYXJnaW5Ob3JtYWw6IHtcbiAgICBtYXJnaW5Ub3A6IDE2LFxuICAgIG1hcmdpbkJvdHRvbTogOFxuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICBtYXJnaW5EZW5zZToge1xuICAgIG1hcmdpblRvcDogOCxcbiAgICBtYXJnaW5Cb3R0b206IDRcbiAgfSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBmdWxsV2lkdGg9e3RydWV9YC4gKi9cbiAgZnVsbFdpZHRoOiB7XG4gICAgd2lkdGg6ICcxMDAlJ1xuICB9XG59O1xuLyoqXG4gKiBQcm92aWRlcyBjb250ZXh0IHN1Y2ggYXMgZmlsbGVkL2ZvY3VzZWQvZXJyb3IvcmVxdWlyZWQgZm9yIGZvcm0gaW5wdXRzLlxuICogUmVseWluZyBvbiB0aGUgY29udGV4dCBwcm92aWRlcyBoaWdoIGZsZXhpYmlsaXR5IGFuZCBlbnN1cmVzIHRoYXQgdGhlIHN0YXRlIGFsd2F5cyBzdGF5c1xuICogY29uc2lzdGVudCBhY3Jvc3MgdGhlIGNoaWxkcmVuIG9mIHRoZSBgRm9ybUNvbnRyb2xgLlxuICogVGhpcyBjb250ZXh0IGlzIHVzZWQgYnkgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOlxuICpcbiAqICAtIEZvcm1MYWJlbFxuICogIC0gRm9ybUhlbHBlclRleHRcbiAqICAtIElucHV0XG4gKiAgLSBJbnB1dExhYmVsXG4gKlxuICogWW91IGNhbiBmaW5kIG9uZSBjb21wb3NpdGlvbiBleGFtcGxlIGJlbG93IGFuZCBtb3JlIGdvaW5nIHRvIFt0aGUgZGVtb3NdKC9jb21wb25lbnRzL3RleHQtZmllbGRzLyNjb21wb25lbnRzKS5cbiAqXG4gKiBgYGBqc3hcbiAqIDxGb3JtQ29udHJvbD5cbiAqICAgPElucHV0TGFiZWwgaHRtbEZvcj1cIm15LWlucHV0XCI+RW1haWwgYWRkcmVzczwvSW5wdXRMYWJlbD5cbiAqICAgPElucHV0IGlkPVwibXktaW5wdXRcIiBhcmlhLWRlc2NyaWJlZGJ5PVwibXktaGVscGVyLXRleHRcIiAvPlxuICogICA8Rm9ybUhlbHBlclRleHQgaWQ9XCJteS1oZWxwZXItdGV4dFwiPldlJ2xsIG5ldmVyIHNoYXJlIHlvdXIgZW1haWwuPC9Gb3JtSGVscGVyVGV4dD5cbiAqIDwvRm9ybUNvbnRyb2w+XG4gKiBgYGBcbiAqXG4gKiDimqDvuI9Pbmx5IG9uZSBpbnB1dCBjYW4gYmUgdXNlZCB3aXRoaW4gYSBGb3JtQ29udHJvbC5cbiAqL1xuXG52YXIgRm9ybUNvbnRyb2wgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGb3JtQ29udHJvbChwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIGNvbG9yID0gX3Byb3BzJGNvbG9yID09PSB2b2lkIDAgPyAncHJpbWFyeScgOiBfcHJvcHMkY29sb3IsXG4gICAgICBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgQ29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2RpdicgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgX3Byb3BzJGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsXG4gICAgICBkaXNhYmxlZCA9IF9wcm9wcyRkaXNhYmxlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZWQsXG4gICAgICBfcHJvcHMkZXJyb3IgPSBwcm9wcy5lcnJvcixcbiAgICAgIGVycm9yID0gX3Byb3BzJGVycm9yID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRlcnJvcixcbiAgICAgIF9wcm9wcyRmdWxsV2lkdGggPSBwcm9wcy5mdWxsV2lkdGgsXG4gICAgICBmdWxsV2lkdGggPSBfcHJvcHMkZnVsbFdpZHRoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmdWxsV2lkdGgsXG4gICAgICB2aXN1YWxseUZvY3VzZWQgPSBwcm9wcy5mb2N1c2VkLFxuICAgICAgX3Byb3BzJGhpZGRlbkxhYmVsID0gcHJvcHMuaGlkZGVuTGFiZWwsXG4gICAgICBoaWRkZW5MYWJlbCA9IF9wcm9wcyRoaWRkZW5MYWJlbCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkaGlkZGVuTGFiZWwsXG4gICAgICBfcHJvcHMkbWFyZ2luID0gcHJvcHMubWFyZ2luLFxuICAgICAgbWFyZ2luID0gX3Byb3BzJG1hcmdpbiA9PT0gdm9pZCAwID8gJ25vbmUnIDogX3Byb3BzJG1hcmdpbixcbiAgICAgIF9wcm9wcyRyZXF1aXJlZCA9IHByb3BzLnJlcXVpcmVkLFxuICAgICAgcmVxdWlyZWQgPSBfcHJvcHMkcmVxdWlyZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJHJlcXVpcmVkLFxuICAgICAgc2l6ZSA9IHByb3BzLnNpemUsXG4gICAgICBfcHJvcHMkdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICB2YXJpYW50ID0gX3Byb3BzJHZhcmlhbnQgPT09IHZvaWQgMCA/ICdzdGFuZGFyZCcgOiBfcHJvcHMkdmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb2xvclwiLCBcImNvbXBvbmVudFwiLCBcImRpc2FibGVkXCIsIFwiZXJyb3JcIiwgXCJmdWxsV2lkdGhcIiwgXCJmb2N1c2VkXCIsIFwiaGlkZGVuTGFiZWxcIiwgXCJtYXJnaW5cIiwgXCJyZXF1aXJlZFwiLCBcInNpemVcIiwgXCJ2YXJpYW50XCJdKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIHRoZSBjaGlsZHJlbiBhbmQgZmluZCB0aGUgSW5wdXQgaW4gb3JkZXJcbiAgICAvLyB0byBmdWxseSBzdXBwb3J0IHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgICB2YXIgaW5pdGlhbEFkb3JuZWRTdGFydCA9IGZhbHNlO1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKCFpc011aUVsZW1lbnQoY2hpbGQsIFsnSW5wdXQnLCAnU2VsZWN0J10pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlucHV0ID0gaXNNdWlFbGVtZW50KGNoaWxkLCBbJ1NlbGVjdCddKSA/IGNoaWxkLnByb3BzLmlucHV0IDogY2hpbGQ7XG5cbiAgICAgICAgaWYgKGlucHV0ICYmIGlzQWRvcm5lZFN0YXJ0KGlucHV0LnByb3BzKSkge1xuICAgICAgICAgIGluaXRpYWxBZG9ybmVkU3RhcnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5pdGlhbEFkb3JuZWRTdGFydDtcbiAgfSksXG4gICAgICBhZG9ybmVkU3RhcnQgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXRBZG9ybmVkU3RhcnQgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTIgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgLy8gV2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggdGhlIGNoaWxkcmVuIGFuZCBmaW5kIHRoZSBJbnB1dCBpbiBvcmRlclxuICAgIC8vIHRvIGZ1bGx5IHN1cHBvcnQgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIHZhciBpbml0aWFsRmlsbGVkID0gZmFsc2U7XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoIWlzTXVpRWxlbWVudChjaGlsZCwgWydJbnB1dCcsICdTZWxlY3QnXSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGaWxsZWQoY2hpbGQucHJvcHMsIHRydWUpKSB7XG4gICAgICAgICAgaW5pdGlhbEZpbGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpbml0aWFsRmlsbGVkO1xuICB9KSxcbiAgICAgIGZpbGxlZCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRGaWxsZWQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgX2ZvY3VzZWQgPSBfUmVhY3QkdXNlU3RhdGUzWzBdLFxuICAgICAgc2V0Rm9jdXNlZCA9IF9SZWFjdCR1c2VTdGF0ZTNbMV07XG5cbiAgdmFyIGZvY3VzZWQgPSB2aXN1YWxseUZvY3VzZWQgIT09IHVuZGVmaW5lZCA/IHZpc3VhbGx5Rm9jdXNlZCA6IF9mb2N1c2VkO1xuXG4gIGlmIChkaXNhYmxlZCAmJiBmb2N1c2VkKSB7XG4gICAgc2V0Rm9jdXNlZChmYWxzZSk7XG4gIH1cblxuICB2YXIgcmVnaXN0ZXJFZmZlY3Q7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB2YXIgcmVnaXN0ZXJlZElucHV0ID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcblxuICAgIHJlZ2lzdGVyRWZmZWN0ID0gZnVuY3Rpb24gcmVnaXN0ZXJFZmZlY3QoKSB7XG4gICAgICBpZiAocmVnaXN0ZXJlZElucHV0LmN1cnJlbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiBUaGVyZSBhcmUgbXVsdGlwbGUgSW5wdXRCYXNlIGNvbXBvbmVudHMgaW5zaWRlIGEgRm9ybUNvbnRyb2wuJywgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZC4gSXQgbWlnaHQgY2F1c2UgaW5maW5pdGUgcmVuZGVyaW5nIGxvb3BzLicsICdPbmx5IHVzZSBvbmUgSW5wdXRCYXNlLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cblxuICAgICAgcmVnaXN0ZXJlZElucHV0LmN1cnJlbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVnaXN0ZXJlZElucHV0LmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHZhciBvbkZpbGxlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZXRGaWxsZWQodHJ1ZSk7XG4gIH0sIFtdKTtcbiAgdmFyIG9uRW1wdHkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgc2V0RmlsbGVkKGZhbHNlKTtcbiAgfSwgW10pO1xuICB2YXIgY2hpbGRDb250ZXh0ID0ge1xuICAgIGFkb3JuZWRTdGFydDogYWRvcm5lZFN0YXJ0LFxuICAgIHNldEFkb3JuZWRTdGFydDogc2V0QWRvcm5lZFN0YXJ0LFxuICAgIGNvbG9yOiBjb2xvcixcbiAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgZXJyb3I6IGVycm9yLFxuICAgIGZpbGxlZDogZmlsbGVkLFxuICAgIGZvY3VzZWQ6IGZvY3VzZWQsXG4gICAgZnVsbFdpZHRoOiBmdWxsV2lkdGgsXG4gICAgaGlkZGVuTGFiZWw6IGhpZGRlbkxhYmVsLFxuICAgIG1hcmdpbjogKHNpemUgPT09ICdzbWFsbCcgPyAnZGVuc2UnIDogdW5kZWZpbmVkKSB8fCBtYXJnaW4sXG4gICAgb25CbHVyOiBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBzZXRGb2N1c2VkKGZhbHNlKTtcbiAgICB9LFxuICAgIG9uRW1wdHk6IG9uRW1wdHksXG4gICAgb25GaWxsZWQ6IG9uRmlsbGVkLFxuICAgIG9uRm9jdXM6IGZ1bmN0aW9uIG9uRm9jdXMoKSB7XG4gICAgICBzZXRGb2N1c2VkKHRydWUpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJFZmZlY3Q6IHJlZ2lzdGVyRWZmZWN0LFxuICAgIHJlcXVpcmVkOiByZXF1aXJlZCxcbiAgICB2YXJpYW50OiB2YXJpYW50XG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtQ29udHJvbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY2hpbGRDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSwgbWFyZ2luICE9PSAnbm9uZScgJiYgY2xhc3Nlc1tcIm1hcmdpblwiLmNvbmNhdChjYXBpdGFsaXplKG1hcmdpbikpXSwgZnVsbFdpZHRoICYmIGNsYXNzZXMuZnVsbFdpZHRoKSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlciksIGNoaWxkcmVuKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IEZvcm1Db250cm9sLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgZm9ybSBjb250cm9sLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGFiZWwsIGlucHV0IGFuZCBoZWxwZXIgdGV4dCBzaG91bGQgYmUgZGlzcGxheWVkIGluIGEgZGlzYWJsZWQgc3RhdGUuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gYW4gZXJyb3Igc3RhdGUuXG4gICAqL1xuICBlcnJvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCB3aWxsIGJlIGRpc3BsYXllZCBpbiBmb2N1c2VkIHN0YXRlLlxuICAgKi9cbiAgZm9jdXNlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCB3aWxsIHRha2UgdXAgdGhlIGZ1bGwgd2lkdGggb2YgaXRzIGNvbnRhaW5lci5cbiAgICovXG4gIGZ1bGxXaWR0aDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIHdpbGwgYmUgaGlkZGVuLlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gaW5jcmVhc2UgZGVuc2l0eSBmb3IgYSBgRmlsbGVkSW5wdXRgLlxuICAgKiBCZSBzdXJlIHRvIGFkZCBgYXJpYS1sYWJlbGAgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGhpZGRlbkxhYmVsOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYGRlbnNlYCBvciBgbm9ybWFsYCwgd2lsbCBhZGp1c3QgdmVydGljYWwgc3BhY2luZyBvZiB0aGlzIGFuZCBjb250YWluZWQgY29tcG9uZW50cy5cbiAgICovXG4gIG1hcmdpbjogUHJvcFR5cGVzLm9uZU9mKFsnZGVuc2UnLCAnbm9uZScsICdub3JtYWwnXSksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIHdpbGwgaW5kaWNhdGUgdGhhdCB0aGUgaW5wdXQgaXMgcmVxdWlyZWQuXG4gICAqL1xuICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSB0ZXh0IGZpZWxkLlxuICAgKi9cbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnbWVkaXVtJywgJ3NtYWxsJ10pLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydmaWxsZWQnLCAnb3V0bGluZWQnLCAnc3RhbmRhcmQnXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpRm9ybUNvbnRyb2wnXG59KShGb3JtQ29udHJvbCk7IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IGZvcm1Db250cm9sU3RhdGUgZnJvbSAnLi4vRm9ybUNvbnRyb2wvZm9ybUNvbnRyb2xTdGF0ZSc7XG5pbXBvcnQgdXNlRm9ybUNvbnRyb2wgZnJvbSAnLi4vRm9ybUNvbnRyb2wvdXNlRm9ybUNvbnRyb2wnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IF9leHRlbmRzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRleHQuc2Vjb25kYXJ5XG4gICAgfSwgdGhlbWUudHlwb2dyYXBoeS5jYXB0aW9uLCB7XG4gICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgIG1hcmdpblRvcDogMyxcbiAgICAgIG1hcmdpbjogMCxcbiAgICAgICcmJGRpc2FibGVkJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50ZXh0LmRpc2FibGVkXG4gICAgICB9LFxuICAgICAgJyYkZXJyb3InOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmVycm9yLm1haW5cbiAgICAgIH1cbiAgICB9KSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGVycm9yPXt0cnVlfWAuICovXG4gICAgZXJyb3I6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZWQ9e3RydWV9YC4gKi9cbiAgICBkaXNhYmxlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBtYXJnaW49XCJkZW5zZVwiYC4gKi9cbiAgICBtYXJnaW5EZW5zZToge1xuICAgICAgbWFyZ2luVG9wOiA0XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJmaWxsZWRcImAgb3IgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYC4gKi9cbiAgICBjb250YWluZWQ6IHtcbiAgICAgIG1hcmdpbkxlZnQ6IDE0LFxuICAgICAgbWFyZ2luUmlnaHQ6IDE0XG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZvY3VzZWQ9e3RydWV9YC4gKi9cbiAgICBmb2N1c2VkOiB7fSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZpbGxlZD17dHJ1ZX1gLiAqL1xuICAgIGZpbGxlZDoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGByZXF1aXJlZD17dHJ1ZX1gLiAqL1xuICAgIHJlcXVpcmVkOiB7fVxuICB9O1xufTtcbnZhciBGb3JtSGVscGVyVGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZvcm1IZWxwZXJUZXh0KHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBDb21wb25lbnQgPSBfcHJvcHMkY29tcG9uZW50ID09PSB2b2lkIDAgPyAncCcgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGVycm9yID0gcHJvcHMuZXJyb3IsXG4gICAgICBmaWxsZWQgPSBwcm9wcy5maWxsZWQsXG4gICAgICBmb2N1c2VkID0gcHJvcHMuZm9jdXNlZCxcbiAgICAgIG1hcmdpbiA9IHByb3BzLm1hcmdpbixcbiAgICAgIHJlcXVpcmVkID0gcHJvcHMucmVxdWlyZWQsXG4gICAgICB2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb21wb25lbnRcIiwgXCJkaXNhYmxlZFwiLCBcImVycm9yXCIsIFwiZmlsbGVkXCIsIFwiZm9jdXNlZFwiLCBcIm1hcmdpblwiLCBcInJlcXVpcmVkXCIsIFwidmFyaWFudFwiXSk7XG5cbiAgdmFyIG11aUZvcm1Db250cm9sID0gdXNlRm9ybUNvbnRyb2woKTtcbiAgdmFyIGZjcyA9IGZvcm1Db250cm9sU3RhdGUoe1xuICAgIHByb3BzOiBwcm9wcyxcbiAgICBtdWlGb3JtQ29udHJvbDogbXVpRm9ybUNvbnRyb2wsXG4gICAgc3RhdGVzOiBbJ3ZhcmlhbnQnLCAnbWFyZ2luJywgJ2Rpc2FibGVkJywgJ2Vycm9yJywgJ2ZpbGxlZCcsICdmb2N1c2VkJywgJ3JlcXVpcmVkJ11cbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCAoZmNzLnZhcmlhbnQgPT09ICdmaWxsZWQnIHx8IGZjcy52YXJpYW50ID09PSAnb3V0bGluZWQnKSAmJiBjbGFzc2VzLmNvbnRhaW5lZCwgY2xhc3NOYW1lLCBmY3MuZGlzYWJsZWQgJiYgY2xhc3Nlcy5kaXNhYmxlZCwgZmNzLmVycm9yICYmIGNsYXNzZXMuZXJyb3IsIGZjcy5maWxsZWQgJiYgY2xhc3Nlcy5maWxsZWQsIGZjcy5mb2N1c2VkICYmIGNsYXNzZXMuZm9jdXNlZCwgZmNzLnJlcXVpcmVkICYmIGNsYXNzZXMucmVxdWlyZWQsIGZjcy5tYXJnaW4gPT09ICdkZW5zZScgJiYgY2xhc3Nlcy5tYXJnaW5EZW5zZSksXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpLCBjaGlsZHJlbiA9PT0gJyAnID9cbiAgLyojX19QVVJFX18qL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGFuZ2VyXG4gIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiAnJiM4MjAzOydcbiAgICB9XG4gIH0pIDogY2hpbGRyZW4pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBGb3JtSGVscGVyVGV4dC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBJZiBgJyAnYCBpcyBwcm92aWRlZCwgdGhlIGNvbXBvbmVudCByZXNlcnZlcyBvbmUgbGluZSBoZWlnaHQgZm9yIGRpc3BsYXlpbmcgYSBmdXR1cmUgbWVzc2FnZS5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBoZWxwZXIgdGV4dCBzaG91bGQgYmUgZGlzcGxheWVkIGluIGEgZGlzYWJsZWQgc3RhdGUuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgaGVscGVyIHRleHQgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiBhbiBlcnJvciBzdGF0ZS5cbiAgICovXG4gIGVycm9yOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaGVscGVyIHRleHQgc2hvdWxkIHVzZSBmaWxsZWQgY2xhc3NlcyBrZXkuXG4gICAqL1xuICBmaWxsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBoZWxwZXIgdGV4dCBzaG91bGQgdXNlIGZvY3VzZWQgY2xhc3NlcyBrZXkuXG4gICAqL1xuICBmb2N1c2VkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYGRlbnNlYCwgd2lsbCBhZGp1c3QgdmVydGljYWwgc3BhY2luZy4gVGhpcyBpcyBub3JtYWxseSBvYnRhaW5lZCB2aWEgY29udGV4dCBmcm9tXG4gICAqIEZvcm1Db250cm9sLlxuICAgKi9cbiAgbWFyZ2luOiBQcm9wVHlwZXMub25lT2YoWydkZW5zZSddKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaGVscGVyIHRleHQgc2hvdWxkIHVzZSByZXF1aXJlZCBjbGFzc2VzIGtleS5cbiAgICovXG4gIHJlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgdG8gdXNlLlxuICAgKi9cbiAgdmFyaWFudDogUHJvcFR5cGVzLm9uZU9mKFsnZmlsbGVkJywgJ291dGxpbmVkJywgJ3N0YW5kYXJkJ10pXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUZvcm1IZWxwZXJUZXh0J1xufSkoRm9ybUhlbHBlclRleHQpOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG93bmVyRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG59IiwiaW1wb3J0IG93bmVyRG9jdW1lbnQgZnJvbSAnLi9vd25lckRvY3VtZW50JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG93bmVyV2luZG93KG5vZGUpIHtcbiAgdmFyIGRvYyA9IG93bmVyRG9jdW1lbnQobm9kZSk7XG4gIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xufSIsIi8qKlxuICogU2FmZSBjaGFpbmVkIGZ1bmN0aW9uXG4gKlxuICogV2lsbCBvbmx5IGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBpZiBuZWVkZWQsXG4gKiBvdGhlcndpc2Ugd2lsbCBwYXNzIGJhY2sgZXhpc3RpbmcgZnVuY3Rpb25zIG9yIG51bGwuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY3Rpb25zIHRvIGNoYWluXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb258bnVsbH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGZ1bmMpIHtcbiAgICBpZiAoZnVuYyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IEludmFsaWQgQXJndW1lbnQgVHlwZSwgbXVzdCBvbmx5IHByb3ZpZGUgZnVuY3Rpb25zLCB1bmRlZmluZWQsIG9yIG51bGwuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIGFjYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfSwgZnVuY3Rpb24gKCkge30pO1xufSIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZXhhY3RQcm9wLCBIVE1MRWxlbWVudFR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IHNldFJlZiBmcm9tICcuLi91dGlscy9zZXRSZWYnO1xuaW1wb3J0IHVzZUZvcmtSZWYgZnJvbSAnLi4vdXRpbHMvdXNlRm9ya1JlZic7XG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgY29udGFpbmVyID0gdHlwZW9mIGNvbnRhaW5lciA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnRhaW5lcigpIDogY29udGFpbmVyOyAvLyAjU3RyaWN0TW9kZSByZWFkeVxuXG4gIHJldHVybiBSZWFjdERPTS5maW5kRE9NTm9kZShjb250YWluZXIpO1xufVxuXG52YXIgdXNlRW5oYW5jZWRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbi8qKlxuICogUG9ydGFscyBwcm92aWRlIGEgZmlyc3QtY2xhc3Mgd2F5IHRvIHJlbmRlciBjaGlsZHJlbiBpbnRvIGEgRE9NIG5vZGVcbiAqIHRoYXQgZXhpc3RzIG91dHNpZGUgdGhlIERPTSBoaWVyYXJjaHkgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKi9cblxudmFyIFBvcnRhbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFBvcnRhbChwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY29udGFpbmVyID0gcHJvcHMuY29udGFpbmVyLFxuICAgICAgX3Byb3BzJGRpc2FibGVQb3J0YWwgPSBwcm9wcy5kaXNhYmxlUG9ydGFsLFxuICAgICAgZGlzYWJsZVBvcnRhbCA9IF9wcm9wcyRkaXNhYmxlUG9ydGFsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlUG9ydGFsLFxuICAgICAgb25SZW5kZXJlZCA9IHByb3BzLm9uUmVuZGVyZWQ7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgbW91bnROb2RlID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0TW91bnROb2RlID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBoYW5kbGVSZWYgPSB1c2VGb3JrUmVmKCAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gY2hpbGRyZW4ucmVmIDogbnVsbCwgcmVmKTtcbiAgdXNlRW5oYW5jZWRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghZGlzYWJsZVBvcnRhbCkge1xuICAgICAgc2V0TW91bnROb2RlKGdldENvbnRhaW5lcihjb250YWluZXIpIHx8IGRvY3VtZW50LmJvZHkpO1xuICAgIH1cbiAgfSwgW2NvbnRhaW5lciwgZGlzYWJsZVBvcnRhbF0pO1xuICB1c2VFbmhhbmNlZEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1vdW50Tm9kZSAmJiAhZGlzYWJsZVBvcnRhbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbW91bnROb2RlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFJlZihyZWYsIG51bGwpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBbcmVmLCBtb3VudE5vZGUsIGRpc2FibGVQb3J0YWxdKTtcbiAgdXNlRW5oYW5jZWRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChvblJlbmRlcmVkICYmIChtb3VudE5vZGUgfHwgZGlzYWJsZVBvcnRhbCkpIHtcbiAgICAgIG9uUmVuZGVyZWQoKTtcbiAgICB9XG4gIH0sIFtvblJlbmRlcmVkLCBtb3VudE5vZGUsIGRpc2FibGVQb3J0YWxdKTtcblxuICBpZiAoZGlzYWJsZVBvcnRhbCkge1xuICAgIGlmICggLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHtcbiAgICAgICAgcmVmOiBoYW5kbGVSZWZcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHJldHVybiBtb3VudE5vZGUgPyAvKiNfX1BVUkVfXyovUmVhY3RET00uY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBtb3VudE5vZGUpIDogbW91bnROb2RlO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBQb3J0YWwucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhlIGNoaWxkcmVuIHRvIHJlbmRlciBpbnRvIHRoZSBgY29udGFpbmVyYC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogQSBIVE1MIGVsZW1lbnQsIGNvbXBvbmVudCBpbnN0YW5jZSwgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVpdGhlci5cbiAgICogVGhlIGBjb250YWluZXJgIHdpbGwgaGF2ZSB0aGUgcG9ydGFsIGNoaWxkcmVuIGFwcGVuZGVkIHRvIGl0LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpdCB1c2VzIHRoZSBib2R5IG9mIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgb2JqZWN0LFxuICAgKiBzbyBpdCdzIHNpbXBseSBgZG9jdW1lbnQuYm9keWAgbW9zdCBvZiB0aGUgdGltZS5cbiAgICovXG4gIGNvbnRhaW5lcjogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLm9uZU9mVHlwZShbSFRNTEVsZW1lbnRUeXBlLCBQcm9wVHlwZXMuaW5zdGFuY2VPZihSZWFjdC5Db21wb25lbnQpLCBQcm9wVHlwZXMuZnVuY10pLFxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBwb3J0YWwgYmVoYXZpb3IuXG4gICAqIFRoZSBjaGlsZHJlbiBzdGF5IHdpdGhpbiBpdCdzIHBhcmVudCBET00gaGllcmFyY2h5LlxuICAgKi9cbiAgZGlzYWJsZVBvcnRhbDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIG9uY2UgdGhlIGNoaWxkcmVuIGhhcyBiZWVuIG1vdW50ZWQgaW50byB0aGUgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIFRoaXMgcHJvcCB3aWxsIGJlIGRlcHJlY2F0ZWQgYW5kIHJlbW92ZWQgaW4gdjUsIHRoZSByZWYgY2FuIGJlIHVzZWQgaW5zdGVhZC5cbiAgICovXG4gIG9uUmVuZGVyZWQ6IFByb3BUeXBlcy5mdW5jXG59IDogdm9pZCAwO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgUG9ydGFsWydwcm9wVHlwZXMnICsgJyddID0gZXhhY3RQcm9wKFBvcnRhbC5wcm9wVHlwZXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBQb3J0YWw7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn0iLCIvLyBBIGNoYW5nZSBvZiB0aGUgYnJvd3NlciB6b29tIGNoYW5nZSB0aGUgc2Nyb2xsYmFyIHNpemUuXG4vLyBDcmVkaXQgaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvM2ZmZTNhNWQ4MmY2ZjU2MWI4MmZmNzhkODJiMzJhN2QxNGFlZDU1OC9qcy9zcmMvbW9kYWwuanMjTDUxMi1MNTE5XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxiYXJTaXplKCkge1xuICB2YXIgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNjcm9sbERpdi5zdHlsZS53aWR0aCA9ICc5OXB4JztcbiAgc2Nyb2xsRGl2LnN0eWxlLmhlaWdodCA9ICc5OXB4JztcbiAgc2Nyb2xsRGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgc2Nyb2xsRGl2LnN0eWxlLnRvcCA9ICctOTk5OXB4JztcbiAgc2Nyb2xsRGl2LnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgdmFyIHNjcm9sbGJhclNpemUgPSBzY3JvbGxEaXYub2Zmc2V0V2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgcmV0dXJuIHNjcm9sbGJhclNpemU7XG59IiwiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheVwiO1xuaW1wb3J0IGdldFNjcm9sbGJhclNpemUgZnJvbSAnLi4vdXRpbHMvZ2V0U2Nyb2xsYmFyU2l6ZSc7XG5pbXBvcnQgb3duZXJEb2N1bWVudCBmcm9tICcuLi91dGlscy9vd25lckRvY3VtZW50JztcbmltcG9ydCBvd25lcldpbmRvdyBmcm9tICcuLi91dGlscy9vd25lcldpbmRvdyc7IC8vIElzIGEgdmVydGljYWwgc2Nyb2xsYmFyIGRpc3BsYXllZD9cblxuZnVuY3Rpb24gaXNPdmVyZmxvd2luZyhjb250YWluZXIpIHtcbiAgdmFyIGRvYyA9IG93bmVyRG9jdW1lbnQoY29udGFpbmVyKTtcblxuICBpZiAoZG9jLmJvZHkgPT09IGNvbnRhaW5lcikge1xuICAgIHJldHVybiBvd25lcldpbmRvdyhkb2MpLmlubmVyV2lkdGggPiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5zY3JvbGxIZWlnaHQgPiBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJpYUhpZGRlbihub2RlLCBzaG93KSB7XG4gIGlmIChzaG93KSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYWRkaW5nUmlnaHQobm9kZSkge1xuICByZXR1cm4gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSlbJ3BhZGRpbmctcmlnaHQnXSwgMTApIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGFyaWFIaWRkZW5TaWJsaW5ncyhjb250YWluZXIsIG1vdW50Tm9kZSwgY3VycmVudE5vZGUpIHtcbiAgdmFyIG5vZGVzVG9FeGNsdWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBbXTtcbiAgdmFyIHNob3cgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgdmFyIGJsYWNrbGlzdCA9IFttb3VudE5vZGUsIGN1cnJlbnROb2RlXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5vZGVzVG9FeGNsdWRlKSk7XG4gIHZhciBibGFja2xpc3RUYWdOYW1lcyA9IFsnVEVNUExBVEUnLCAnU0NSSVBUJywgJ1NUWUxFJ107XG4gIFtdLmZvckVhY2guY2FsbChjb250YWluZXIuY2hpbGRyZW4sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgYmxhY2tsaXN0LmluZGV4T2Yobm9kZSkgPT09IC0xICYmIGJsYWNrbGlzdFRhZ05hbWVzLmluZGV4T2Yobm9kZS50YWdOYW1lKSA9PT0gLTEpIHtcbiAgICAgIGFyaWFIaWRkZW4obm9kZSwgc2hvdyk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZmluZEluZGV4T2YoY29udGFpbmVySW5mbywgY2FsbGJhY2spIHtcbiAgdmFyIGlkeCA9IC0xO1xuICBjb250YWluZXJJbmZvLnNvbWUoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgaWYgKGNhbGxiYWNrKGl0ZW0pKSB7XG4gICAgICBpZHggPSBpbmRleDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIHJldHVybiBpZHg7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRhaW5lcihjb250YWluZXJJbmZvLCBwcm9wcykge1xuICB2YXIgcmVzdG9yZVN0eWxlID0gW107XG4gIHZhciByZXN0b3JlUGFkZGluZ3MgPSBbXTtcbiAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lckluZm8uY29udGFpbmVyO1xuICB2YXIgZml4ZWROb2RlcztcblxuICBpZiAoIXByb3BzLmRpc2FibGVTY3JvbGxMb2NrKSB7XG4gICAgaWYgKGlzT3ZlcmZsb3dpbmcoY29udGFpbmVyKSkge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgc2l6ZSBiZWZvcmUgYXBwbHlpbmcgb3ZlcmZsb3cgaGlkZGVuIHRvIGF2b2lkIGFueSBzY3JvbGwganVtcHMuXG4gICAgICB2YXIgc2Nyb2xsYmFyU2l6ZSA9IGdldFNjcm9sbGJhclNpemUoKTtcbiAgICAgIHJlc3RvcmVTdHlsZS5wdXNoKHtcbiAgICAgICAgdmFsdWU6IGNvbnRhaW5lci5zdHlsZS5wYWRkaW5nUmlnaHQsXG4gICAgICAgIGtleTogJ3BhZGRpbmctcmlnaHQnLFxuICAgICAgICBlbDogY29udGFpbmVyXG4gICAgICB9KTsgLy8gVXNlIGNvbXB1dGVkIHN0eWxlLCBoZXJlIHRvIGdldCB0aGUgcmVhbCBwYWRkaW5nIHRvIGFkZCBvdXIgc2Nyb2xsYmFyIHdpZHRoLlxuXG4gICAgICBjb250YWluZXIuc3R5bGVbJ3BhZGRpbmctcmlnaHQnXSA9IFwiXCIuY29uY2F0KGdldFBhZGRpbmdSaWdodChjb250YWluZXIpICsgc2Nyb2xsYmFyU2l6ZSwgXCJweFwiKTsgLy8gLm11aS1maXhlZCBpcyBhIGdsb2JhbCBoZWxwZXIuXG5cbiAgICAgIGZpeGVkTm9kZXMgPSBvd25lckRvY3VtZW50KGNvbnRhaW5lcikucXVlcnlTZWxlY3RvckFsbCgnLm11aS1maXhlZCcpO1xuICAgICAgW10uZm9yRWFjaC5jYWxsKGZpeGVkTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJlc3RvcmVQYWRkaW5ncy5wdXNoKG5vZGUuc3R5bGUucGFkZGluZ1JpZ2h0KTtcbiAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIlwiLmNvbmNhdChnZXRQYWRkaW5nUmlnaHQobm9kZSkgKyBzY3JvbGxiYXJTaXplLCBcInB4XCIpO1xuICAgICAgfSk7XG4gICAgfSAvLyBJbXByb3ZlIEdhdHNieSBzdXBwb3J0XG4gICAgLy8gaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9zbmlwcGV0cy9jc3MvZm9yY2UtdmVydGljYWwtc2Nyb2xsYmFyL1xuXG5cbiAgICB2YXIgcGFyZW50ID0gY29udGFpbmVyLnBhcmVudEVsZW1lbnQ7XG4gICAgdmFyIHNjcm9sbENvbnRhaW5lciA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudClbJ292ZXJmbG93LXknXSA9PT0gJ3Njcm9sbCcgPyBwYXJlbnQgOiBjb250YWluZXI7IC8vIEJsb2NrIHRoZSBzY3JvbGwgZXZlbiBpZiBubyBzY3JvbGxiYXIgaXMgdmlzaWJsZSB0byBhY2NvdW50IGZvciBtb2JpbGUga2V5Ym9hcmRcbiAgICAvLyBzY3JlZW5zaXplIHNocmluay5cblxuICAgIHJlc3RvcmVTdHlsZS5wdXNoKHtcbiAgICAgIHZhbHVlOiBzY3JvbGxDb250YWluZXIuc3R5bGUub3ZlcmZsb3csXG4gICAgICBrZXk6ICdvdmVyZmxvdycsXG4gICAgICBlbDogc2Nyb2xsQ29udGFpbmVyXG4gICAgfSk7XG4gICAgc2Nyb2xsQ29udGFpbmVyLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gIH1cblxuICB2YXIgcmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoKSB7XG4gICAgaWYgKGZpeGVkTm9kZXMpIHtcbiAgICAgIFtdLmZvckVhY2guY2FsbChmaXhlZE5vZGVzLCBmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgICBpZiAocmVzdG9yZVBhZGRpbmdzW2ldKSB7XG4gICAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nUmlnaHQgPSByZXN0b3JlUGFkZGluZ3NbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncGFkZGluZy1yaWdodCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXN0b3JlU3R5bGUuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgICAgICBlbCA9IF9yZWYuZWwsXG4gICAgICAgICAga2V5ID0gX3JlZi5rZXk7XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHJlc3RvcmU7XG59XG5cbmZ1bmN0aW9uIGdldEhpZGRlblNpYmxpbmdzKGNvbnRhaW5lcikge1xuICB2YXIgaGlkZGVuU2libGluZ3MgPSBbXTtcbiAgW10uZm9yRWFjaC5jYWxsKGNvbnRhaW5lci5jaGlsZHJlbiwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykgPT09ICd0cnVlJykge1xuICAgICAgaGlkZGVuU2libGluZ3MucHVzaChub2RlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaGlkZGVuU2libGluZ3M7XG59XG4vKipcbiAqIEBpZ25vcmUgLSBkbyBub3QgZG9jdW1lbnQuXG4gKlxuICogUHJvcGVyIHN0YXRlIG1hbmFnZW1lbnQgZm9yIGNvbnRhaW5lcnMgYW5kIHRoZSBtb2RhbHMgaW4gdGhvc2UgY29udGFpbmVycy5cbiAqIFNpbXBsaWZpZWQsIGJ1dCBpbnNwaXJlZCBieSByZWFjdC1vdmVybGF5J3MgTW9kYWxNYW5hZ2VyIGNsYXNzLlxuICogVXNlZCBieSB0aGUgTW9kYWwgdG8gZW5zdXJlIHByb3BlciBzdHlsaW5nIG9mIGNvbnRhaW5lcnMuXG4gKi9cblxuXG52YXIgTW9kYWxNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTW9kYWxNYW5hZ2VyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbE1hbmFnZXIpO1xuXG4gICAgLy8gdGhpcy5tb2RhbHNbbW9kYWxJbmRleF0gPSBtb2RhbFxuICAgIHRoaXMubW9kYWxzID0gW107IC8vIHRoaXMuY29udGFpbmVyc1tjb250YWluZXJJbmRleF0gPSB7XG4gICAgLy8gICBtb2RhbHM6IFtdLFxuICAgIC8vICAgY29udGFpbmVyLFxuICAgIC8vICAgcmVzdG9yZTogbnVsbCxcbiAgICAvLyB9XG5cbiAgICB0aGlzLmNvbnRhaW5lcnMgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNb2RhbE1hbmFnZXIsIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQobW9kYWwsIGNvbnRhaW5lcikge1xuICAgICAgdmFyIG1vZGFsSW5kZXggPSB0aGlzLm1vZGFscy5pbmRleE9mKG1vZGFsKTtcblxuICAgICAgaWYgKG1vZGFsSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBtb2RhbEluZGV4O1xuICAgICAgfVxuXG4gICAgICBtb2RhbEluZGV4ID0gdGhpcy5tb2RhbHMubGVuZ3RoO1xuICAgICAgdGhpcy5tb2RhbHMucHVzaChtb2RhbCk7IC8vIElmIHRoZSBtb2RhbCB3ZSBhcmUgYWRkaW5nIGlzIGFscmVhZHkgaW4gdGhlIERPTS5cblxuICAgICAgaWYgKG1vZGFsLm1vZGFsUmVmKSB7XG4gICAgICAgIGFyaWFIaWRkZW4obW9kYWwubW9kYWxSZWYsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhpZGRlblNpYmxpbmdOb2RlcyA9IGdldEhpZGRlblNpYmxpbmdzKGNvbnRhaW5lcik7XG4gICAgICBhcmlhSGlkZGVuU2libGluZ3MoY29udGFpbmVyLCBtb2RhbC5tb3VudE5vZGUsIG1vZGFsLm1vZGFsUmVmLCBoaWRkZW5TaWJsaW5nTm9kZXMsIHRydWUpO1xuICAgICAgdmFyIGNvbnRhaW5lckluZGV4ID0gZmluZEluZGV4T2YodGhpcy5jb250YWluZXJzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5jb250YWluZXIgPT09IGNvbnRhaW5lcjtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY29udGFpbmVySW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyc1tjb250YWluZXJJbmRleF0ubW9kYWxzLnB1c2gobW9kYWwpO1xuICAgICAgICByZXR1cm4gbW9kYWxJbmRleDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250YWluZXJzLnB1c2goe1xuICAgICAgICBtb2RhbHM6IFttb2RhbF0sXG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICByZXN0b3JlOiBudWxsLFxuICAgICAgICBoaWRkZW5TaWJsaW5nTm9kZXM6IGhpZGRlblNpYmxpbmdOb2Rlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbW9kYWxJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91bnQobW9kYWwsIHByb3BzKSB7XG4gICAgICB2YXIgY29udGFpbmVySW5kZXggPSBmaW5kSW5kZXhPZih0aGlzLmNvbnRhaW5lcnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLm1vZGFscy5pbmRleE9mKG1vZGFsKSAhPT0gLTE7XG4gICAgICB9KTtcbiAgICAgIHZhciBjb250YWluZXJJbmZvID0gdGhpcy5jb250YWluZXJzW2NvbnRhaW5lckluZGV4XTtcblxuICAgICAgaWYgKCFjb250YWluZXJJbmZvLnJlc3RvcmUpIHtcbiAgICAgICAgY29udGFpbmVySW5mby5yZXN0b3JlID0gaGFuZGxlQ29udGFpbmVyKGNvbnRhaW5lckluZm8sIHByb3BzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShtb2RhbCkge1xuICAgICAgdmFyIG1vZGFsSW5kZXggPSB0aGlzLm1vZGFscy5pbmRleE9mKG1vZGFsKTtcblxuICAgICAgaWYgKG1vZGFsSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBtb2RhbEluZGV4O1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGFpbmVySW5kZXggPSBmaW5kSW5kZXhPZih0aGlzLmNvbnRhaW5lcnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLm1vZGFscy5pbmRleE9mKG1vZGFsKSAhPT0gLTE7XG4gICAgICB9KTtcbiAgICAgIHZhciBjb250YWluZXJJbmZvID0gdGhpcy5jb250YWluZXJzW2NvbnRhaW5lckluZGV4XTtcbiAgICAgIGNvbnRhaW5lckluZm8ubW9kYWxzLnNwbGljZShjb250YWluZXJJbmZvLm1vZGFscy5pbmRleE9mKG1vZGFsKSwgMSk7XG4gICAgICB0aGlzLm1vZGFscy5zcGxpY2UobW9kYWxJbmRleCwgMSk7IC8vIElmIHRoYXQgd2FzIHRoZSBsYXN0IG1vZGFsIGluIGEgY29udGFpbmVyLCBjbGVhbiB1cCB0aGUgY29udGFpbmVyLlxuXG4gICAgICBpZiAoY29udGFpbmVySW5mby5tb2RhbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFRoZSBtb2RhbCBtaWdodCBiZSBjbG9zZWQgYmVmb3JlIGl0IGhhZCB0aGUgY2hhbmNlIHRvIGJlIG1vdW50ZWQgaW4gdGhlIERPTS5cbiAgICAgICAgaWYgKGNvbnRhaW5lckluZm8ucmVzdG9yZSkge1xuICAgICAgICAgIGNvbnRhaW5lckluZm8ucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGFsLm1vZGFsUmVmKSB7XG4gICAgICAgICAgLy8gSW4gY2FzZSB0aGUgbW9kYWwgd2Fzbid0IGluIHRoZSBET00geWV0LlxuICAgICAgICAgIGFyaWFIaWRkZW4obW9kYWwubW9kYWxSZWYsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJpYUhpZGRlblNpYmxpbmdzKGNvbnRhaW5lckluZm8uY29udGFpbmVyLCBtb2RhbC5tb3VudE5vZGUsIG1vZGFsLm1vZGFsUmVmLCBjb250YWluZXJJbmZvLmhpZGRlblNpYmxpbmdOb2RlcywgZmFsc2UpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lcnMuc3BsaWNlKGNvbnRhaW5lckluZGV4LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBtYWtlIHN1cmUgdGhlIG5leHQgdG9wIG1vZGFsIGlzIHZpc2libGUgdG8gYSBzY3JlZW4gcmVhZGVyLlxuICAgICAgICB2YXIgbmV4dFRvcCA9IGNvbnRhaW5lckluZm8ubW9kYWxzW2NvbnRhaW5lckluZm8ubW9kYWxzLmxlbmd0aCAtIDFdOyAvLyBhcyBzb29uIGFzIGEgbW9kYWwgaXMgYWRkaW5nIGl0cyBtb2RhbFJlZiBpcyB1bmRlZmluZWQuIGl0IGNhbid0IHNldFxuICAgICAgICAvLyBhcmlhLWhpZGRlbiBiZWNhdXNlIHRoZSBkb20gZWxlbWVudCBkb2Vzbid0IGV4aXN0IGVpdGhlclxuICAgICAgICAvLyB3aGVuIG1vZGFsIHdhcyB1bm1vdW50ZWQgYmVmb3JlIG1vZGFsUmVmIGdldHMgbnVsbFxuXG4gICAgICAgIGlmIChuZXh0VG9wLm1vZGFsUmVmKSB7XG4gICAgICAgICAgYXJpYUhpZGRlbihuZXh0VG9wLm1vZGFsUmVmLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vZGFsSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVG9wTW9kYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNUb3BNb2RhbChtb2RhbCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kYWxzLmxlbmd0aCA+IDAgJiYgdGhpcy5tb2RhbHNbdGhpcy5tb2RhbHMubGVuZ3RoIC0gMV0gPT09IG1vZGFsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNb2RhbE1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydCB7IE1vZGFsTWFuYWdlciBhcyBkZWZhdWx0IH07IiwiLyogZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4sIGpzeC1hMTF5L25vLW5vbmludGVyYWN0aXZlLXRhYmluZGV4LCBjYW1lbGNhc2UgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IG93bmVyRG9jdW1lbnQgZnJvbSAnLi4vdXRpbHMvb3duZXJEb2N1bWVudCc7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcbmltcG9ydCB7IGV4YWN0UHJvcCB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG4vKipcbiAqIFV0aWxpdHkgY29tcG9uZW50IHRoYXQgbG9ja3MgZm9jdXMgaW5zaWRlIHRoZSBjb21wb25lbnQuXG4gKi9cblxuZnVuY3Rpb24gVW5zdGFibGVfVHJhcEZvY3VzKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgX3Byb3BzJGRpc2FibGVBdXRvRm9jID0gcHJvcHMuZGlzYWJsZUF1dG9Gb2N1cyxcbiAgICAgIGRpc2FibGVBdXRvRm9jdXMgPSBfcHJvcHMkZGlzYWJsZUF1dG9Gb2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVBdXRvRm9jLFxuICAgICAgX3Byb3BzJGRpc2FibGVFbmZvcmNlID0gcHJvcHMuZGlzYWJsZUVuZm9yY2VGb2N1cyxcbiAgICAgIGRpc2FibGVFbmZvcmNlRm9jdXMgPSBfcHJvcHMkZGlzYWJsZUVuZm9yY2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVFbmZvcmNlLFxuICAgICAgX3Byb3BzJGRpc2FibGVSZXN0b3JlID0gcHJvcHMuZGlzYWJsZVJlc3RvcmVGb2N1cyxcbiAgICAgIGRpc2FibGVSZXN0b3JlRm9jdXMgPSBfcHJvcHMkZGlzYWJsZVJlc3RvcmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVSZXN0b3JlLFxuICAgICAgZ2V0RG9jID0gcHJvcHMuZ2V0RG9jLFxuICAgICAgaXNFbmFibGVkID0gcHJvcHMuaXNFbmFibGVkLFxuICAgICAgb3BlbiA9IHByb3BzLm9wZW47XG4gIHZhciBpZ25vcmVOZXh0RW5mb3JjZUZvY3VzID0gUmVhY3QudXNlUmVmKCk7XG4gIHZhciBzZW50aW5lbFN0YXJ0ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgc2VudGluZWxFbmQgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBub2RlVG9SZXN0b3JlID0gUmVhY3QudXNlUmVmKCk7XG4gIHZhciByb290UmVmID0gUmVhY3QudXNlUmVmKG51bGwpOyAvLyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHdlIGRyb3Agc3VwcG9ydCBmb3Igbm9uIHJlZiBmb3J3YXJkaW5nIGNsYXNzIGNvbXBvbmVudHNcblxuICB2YXIgaGFuZGxlT3duUmVmID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgLy8gI1N0cmljdE1vZGUgcmVhZHlcbiAgICByb290UmVmLmN1cnJlbnQgPSBSZWFjdERPTS5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG4gIH0sIFtdKTtcbiAgdmFyIGhhbmRsZVJlZiA9IHVzZUZvcmtSZWYoY2hpbGRyZW4ucmVmLCBoYW5kbGVPd25SZWYpO1xuICB2YXIgcHJldk9wZW5SZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBwcmV2T3BlblJlZi5jdXJyZW50ID0gb3BlbjtcbiAgfSwgW29wZW5dKTtcblxuICBpZiAoIXByZXZPcGVuUmVmLmN1cnJlbnQgJiYgb3BlbiAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFdBUk5JTkc6IFBvdGVudGlhbGx5IHVuc2FmZSBpbiBjb25jdXJyZW50IG1vZGUuXG4gICAgLy8gVGhlIHdheSB0aGUgcmVhZCBvbiBgbm9kZVRvUmVzdG9yZWAgaXMgc2V0dXAgY291bGQgbWFrZSB0aGlzIGFjdHVhbGx5IHNhZmUuXG4gICAgLy8gU2F5IHdlIHJlbmRlciBgb3Blbj17ZmFsc2V9YCAtPiBgb3Blbj17dHJ1ZX1gIGJ1dCBuZXZlciBjb21taXQuXG4gICAgLy8gV2UgaGF2ZSBub3cgd3JpdHRlbiBhIHN0YXRlIHRoYXQgd2Fzbid0IGNvbW1pdHRlZC4gQnV0IG5vIGNvbW1pdHRlZCBlZmZlY3RcbiAgICAvLyB3aWxsIHJlYWQgdGhpcyB3cm9uZyB2YWx1ZS4gV2Ugb25seSByZWFkIGZyb20gYG5vZGVUb1Jlc3RvcmVgIGluIGVmZmVjdHNcbiAgICAvLyB0aGF0IHdlcmUgY29tbWl0dGVkIG9uIGBvcGVuPXt0cnVlfWBcbiAgICAvLyBXQVJOSU5HOiBQcmV2ZW50cyB0aGUgaW5zdGFuY2UgZnJvbSBiZWluZyBnYXJiYWdlIGNvbGxlY3RlZC4gU2hvdWxkIG9ubHlcbiAgICAvLyBob2xkIGEgd2VhayByZWYuXG4gICAgbm9kZVRvUmVzdG9yZS5jdXJyZW50ID0gZ2V0RG9jKCkuYWN0aXZlRWxlbWVudDtcbiAgfVxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IG93bmVyRG9jdW1lbnQocm9vdFJlZi5jdXJyZW50KTsgLy8gV2UgbWlnaHQgcmVuZGVyIGFuIGVtcHR5IGNoaWxkLlxuXG4gICAgaWYgKCFkaXNhYmxlQXV0b0ZvY3VzICYmIHJvb3RSZWYuY3VycmVudCAmJiAhcm9vdFJlZi5jdXJyZW50LmNvbnRhaW5zKGRvYy5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgaWYgKCFyb290UmVmLmN1cnJlbnQuaGFzQXR0cmlidXRlKCd0YWJJbmRleCcpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiBUaGUgbW9kYWwgY29udGVudCBub2RlIGRvZXMgbm90IGFjY2VwdCBmb2N1cy4nLCAnRm9yIHRoZSBiZW5lZml0IG9mIGFzc2lzdGl2ZSB0ZWNobm9sb2dpZXMsICcgKyAndGhlIHRhYkluZGV4IG9mIHRoZSBub2RlIGlzIGJlaW5nIHNldCB0byBcIi0xXCIuJ10uam9pbignXFxuJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdFJlZi5jdXJyZW50LnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAtMSk7XG4gICAgICB9XG5cbiAgICAgIHJvb3RSZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIHZhciBjb250YWluID0gZnVuY3Rpb24gY29udGFpbigpIHtcbiAgICAgIGlmICghZG9jLmhhc0ZvY3VzKCkgfHwgZGlzYWJsZUVuZm9yY2VGb2N1cyB8fCAhaXNFbmFibGVkKCkgfHwgaWdub3JlTmV4dEVuZm9yY2VGb2N1cy5jdXJyZW50KSB7XG4gICAgICAgIGlnbm9yZU5leHRFbmZvcmNlRm9jdXMuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChyb290UmVmLmN1cnJlbnQgJiYgIXJvb3RSZWYuY3VycmVudC5jb250YWlucyhkb2MuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgcm9vdFJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsb29wRm9jdXMgPSBmdW5jdGlvbiBsb29wRm9jdXMoZXZlbnQpIHtcbiAgICAgIC8vIDkgPSBUYWJcbiAgICAgIGlmIChkaXNhYmxlRW5mb3JjZUZvY3VzIHx8ICFpc0VuYWJsZWQoKSB8fCBldmVudC5rZXlDb2RlICE9PSA5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBuZXh0IHRhYiBzdGFydHMgZnJvbSB0aGUgcmlnaHQgcGxhY2UuXG5cblxuICAgICAgaWYgKGRvYy5hY3RpdmVFbGVtZW50ID09PSByb290UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBpZ25vcmUgdGhlIG5leHQgY29udGFpbiBhc1xuICAgICAgICAvLyBpdCB3aWxsIHRyeSB0byBtb3ZlIHRoZSBmb2N1cyBiYWNrIHRvIHRoZSByb290UmVmIGVsZW1lbnQuXG4gICAgICAgIGlnbm9yZU5leHRFbmZvcmNlRm9jdXMuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgc2VudGluZWxFbmQuY3VycmVudC5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbnRpbmVsU3RhcnQuY3VycmVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGNvbnRhaW4sIHRydWUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgbG9vcEZvY3VzLCB0cnVlKTsgLy8gV2l0aCBFZGdlLCBTYWZhcmkgYW5kIEZpcmVmb3gsIG5vIGZvY3VzIHJlbGF0ZWQgZXZlbnRzIGFyZSBmaXJlZCB3aGVuIHRoZSBmb2N1c2VkIGFyZWEgc3RvcHMgYmVpbmcgYSBmb2N1c2VkIGFyZWFcbiAgICAvLyBlLmcuIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU1OTU2MS5cbiAgICAvL1xuICAgIC8vIFRoZSB3aGF0d2cgc3BlYyBkZWZpbmVzIGhvdyB0aGUgYnJvd3NlciBzaG91bGQgYmVoYXZlIGJ1dCBkb2VzIG5vdCBleHBsaWNpdGx5IG1lbnRpb24gYW55IGV2ZW50czpcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2ZvY3VzLWZpeHVwLXJ1bGUuXG5cbiAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBjb250YWluKCk7XG4gICAgfSwgNTApO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGNvbnRhaW4sIHRydWUpO1xuICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBsb29wRm9jdXMsIHRydWUpOyAvLyByZXN0b3JlTGFzdEZvY3VzKClcblxuICAgICAgaWYgKCFkaXNhYmxlUmVzdG9yZUZvY3VzKSB7XG4gICAgICAgIC8vIEluIElFIDExIGl0IGlzIHBvc3NpYmxlIGZvciBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHRvIGJlIG51bGwgcmVzdWx0aW5nXG4gICAgICAgIC8vIGluIG5vZGVUb1Jlc3RvcmUuY3VycmVudCBiZWluZyBudWxsLlxuICAgICAgICAvLyBOb3QgYWxsIGVsZW1lbnRzIGluIElFIDExIGhhdmUgYSBmb2N1cyBtZXRob2QuXG4gICAgICAgIC8vIE9uY2UgSUUgMTEgc3VwcG9ydCBpcyBkcm9wcGVkIHRoZSBmb2N1cygpIGNhbGwgY2FuIGJlIHVuY29uZGl0aW9uYWwuXG4gICAgICAgIGlmIChub2RlVG9SZXN0b3JlLmN1cnJlbnQgJiYgbm9kZVRvUmVzdG9yZS5jdXJyZW50LmZvY3VzKSB7XG4gICAgICAgICAgbm9kZVRvUmVzdG9yZS5jdXJyZW50LmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlVG9SZXN0b3JlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtkaXNhYmxlQXV0b0ZvY3VzLCBkaXNhYmxlRW5mb3JjZUZvY3VzLCBkaXNhYmxlUmVzdG9yZUZvY3VzLCBpc0VuYWJsZWQsIG9wZW5dKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgdGFiSW5kZXg6IDAsXG4gICAgcmVmOiBzZW50aW5lbFN0YXJ0LFxuICAgIFwiZGF0YS10ZXN0XCI6IFwic2VudGluZWxTdGFydFwiXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkcmVuLCB7XG4gICAgcmVmOiBoYW5kbGVSZWZcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICB0YWJJbmRleDogMCxcbiAgICByZWY6IHNlbnRpbmVsRW5kLFxuICAgIFwiZGF0YS10ZXN0XCI6IFwic2VudGluZWxFbmRcIlxuICB9KSk7XG59XG5cbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVuc3RhYmxlX1RyYXBGb2N1cy5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBBIHNpbmdsZSBjaGlsZCBjb250ZW50IGVsZW1lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHRyYXAgZm9jdXMgd2lsbCBub3QgYXV0b21hdGljYWxseSBzaGlmdCBmb2N1cyB0byBpdHNlbGYgd2hlbiBpdCBvcGVucywgYW5kXG4gICAqIHJlcGxhY2UgaXQgdG8gdGhlIGxhc3QgZm9jdXNlZCBlbGVtZW50IHdoZW4gaXQgY2xvc2VzLlxuICAgKiBUaGlzIGFsc28gd29ya3MgY29ycmVjdGx5IHdpdGggYW55IHRyYXAgZm9jdXMgY2hpbGRyZW4gdGhhdCBoYXZlIHRoZSBgZGlzYWJsZUF1dG9Gb2N1c2AgcHJvcC5cbiAgICpcbiAgICogR2VuZXJhbGx5IHRoaXMgc2hvdWxkIG5ldmVyIGJlIHNldCB0byBgdHJ1ZWAgYXMgaXQgbWFrZXMgdGhlIHRyYXAgZm9jdXMgbGVzc1xuICAgKiBhY2Nlc3NpYmxlIHRvIGFzc2lzdGl2ZSB0ZWNobm9sb2dpZXMsIGxpa2Ugc2NyZWVuIHJlYWRlcnMuXG4gICAqL1xuICBkaXNhYmxlQXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgdHJhcCBmb2N1cyB3aWxsIG5vdCBwcmV2ZW50IGZvY3VzIGZyb20gbGVhdmluZyB0aGUgdHJhcCBmb2N1cyB3aGlsZSBvcGVuLlxuICAgKlxuICAgKiBHZW5lcmFsbHkgdGhpcyBzaG91bGQgbmV2ZXIgYmUgc2V0IHRvIGB0cnVlYCBhcyBpdCBtYWtlcyB0aGUgdHJhcCBmb2N1cyBsZXNzXG4gICAqIGFjY2Vzc2libGUgdG8gYXNzaXN0aXZlIHRlY2hub2xvZ2llcywgbGlrZSBzY3JlZW4gcmVhZGVycy5cbiAgICovXG4gIGRpc2FibGVFbmZvcmNlRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB0cmFwIGZvY3VzIHdpbGwgbm90IHJlc3RvcmUgZm9jdXMgdG8gcHJldmlvdXNseSBmb2N1c2VkIGVsZW1lbnQgb25jZVxuICAgKiB0cmFwIGZvY3VzIGlzIGhpZGRlbi5cbiAgICovXG4gIGRpc2FibGVSZXN0b3JlRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRvY3VtZW50IHRvIGNvbnNpZGVyLlxuICAgKiBXZSB1c2UgaXQgdG8gaW1wbGVtZW50IHRoZSByZXN0b3JlIGZvY3VzIGJldHdlZW4gZGlmZmVyZW50IGJyb3dzZXIgZG9jdW1lbnRzLlxuICAgKi9cbiAgZ2V0RG9jOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBEbyB3ZSBzdGlsbCB3YW50IHRvIGVuZm9yY2UgdGhlIGZvY3VzP1xuICAgKiBUaGlzIHByb3AgaGVscHMgbmVzdGluZyBUcmFwRm9jdXMgZWxlbWVudHMuXG4gICAqL1xuICBpc0VuYWJsZWQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgZm9jdXMgd2lsbCBiZSBsb2NrZWQuXG4gICAqL1xuICBvcGVuOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkXG59IDogdm9pZCAwO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgVW5zdGFibGVfVHJhcEZvY3VzWydwcm9wVHlwZXMnICsgJyddID0gZXhhY3RQcm9wKFVuc3RhYmxlX1RyYXBGb2N1cy5wcm9wVHlwZXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBVbnN0YWJsZV9UcmFwRm9jdXM7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmV4cG9ydCB2YXIgc3R5bGVzID0ge1xuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICByb290OiB7XG4gICAgekluZGV4OiAtMSxcbiAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjUpJyxcbiAgICBXZWJraXRUYXBIaWdobGlnaHRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGludmlzaWJsZT17dHJ1ZX1gLiAqL1xuICBpbnZpc2libGU6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgfVxufTtcbi8qKlxuICogQGlnbm9yZSAtIGludGVybmFsIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgU2ltcGxlQmFja2Ryb3AgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBTaW1wbGVCYWNrZHJvcChwcm9wcywgcmVmKSB7XG4gIHZhciBfcHJvcHMkaW52aXNpYmxlID0gcHJvcHMuaW52aXNpYmxlLFxuICAgICAgaW52aXNpYmxlID0gX3Byb3BzJGludmlzaWJsZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkaW52aXNpYmxlLFxuICAgICAgb3BlbiA9IHByb3BzLm9wZW4sXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiaW52aXNpYmxlXCIsIFwib3BlblwiXSk7XG5cbiAgcmV0dXJuIG9wZW4gPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyLCB7XG4gICAgc3R5bGU6IF9leHRlbmRzKHt9LCBzdHlsZXMucm9vdCwgaW52aXNpYmxlID8gc3R5bGVzLmludmlzaWJsZSA6IHt9LCBvdGhlci5zdHlsZSlcbiAgfSkpIDogbnVsbDtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU2ltcGxlQmFja2Ryb3AucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYmFja2Ryb3AgaXMgaW52aXNpYmxlLlxuICAgKiBJdCBjYW4gYmUgdXNlZCB3aGVuIHJlbmRlcmluZyBhIHBvcG92ZXIgb3IgYSBjdXN0b20gc2VsZWN0IGNvbXBvbmVudC5cbiAgICovXG4gIGludmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGJhY2tkcm9wIGlzIG9wZW4uXG4gICAqL1xuICBvcGVuOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgU2ltcGxlQmFja2Ryb3A7IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBnZXRUaGVtZVByb3BzLCB1c2VUaGVtZSB9IGZyb20gJ0BtYXRlcmlhbC11aS9zdHlsZXMnO1xuaW1wb3J0IHsgZWxlbWVudEFjY2VwdGluZ1JlZiwgSFRNTEVsZW1lbnRUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBvd25lckRvY3VtZW50IGZyb20gJy4uL3V0aWxzL293bmVyRG9jdW1lbnQnO1xuaW1wb3J0IFBvcnRhbCBmcm9tICcuLi9Qb3J0YWwnO1xuaW1wb3J0IGNyZWF0ZUNoYWluZWRGdW5jdGlvbiBmcm9tICcuLi91dGlscy9jcmVhdGVDaGFpbmVkRnVuY3Rpb24nO1xuaW1wb3J0IHVzZUZvcmtSZWYgZnJvbSAnLi4vdXRpbHMvdXNlRm9ya1JlZic7XG5pbXBvcnQgdXNlRXZlbnRDYWxsYmFjayBmcm9tICcuLi91dGlscy91c2VFdmVudENhbGxiYWNrJztcbmltcG9ydCB6SW5kZXggZnJvbSAnLi4vc3R5bGVzL3pJbmRleCc7XG5pbXBvcnQgTW9kYWxNYW5hZ2VyLCB7IGFyaWFIaWRkZW4gfSBmcm9tICcuL01vZGFsTWFuYWdlcic7XG5pbXBvcnQgVHJhcEZvY3VzIGZyb20gJy4uL1Vuc3RhYmxlX1RyYXBGb2N1cyc7XG5pbXBvcnQgU2ltcGxlQmFja2Ryb3AgZnJvbSAnLi9TaW1wbGVCYWNrZHJvcCc7XG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgY29udGFpbmVyID0gdHlwZW9mIGNvbnRhaW5lciA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnRhaW5lcigpIDogY29udGFpbmVyO1xuICByZXR1cm4gUmVhY3RET00uZmluZERPTU5vZGUoY29udGFpbmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0SGFzVHJhbnNpdGlvbihwcm9wcykge1xuICByZXR1cm4gcHJvcHMuY2hpbGRyZW4gPyBwcm9wcy5jaGlsZHJlbi5wcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaW4nKSA6IGZhbHNlO1xufSAvLyBBIG1vZGFsIG1hbmFnZXIgdXNlZCB0byB0cmFjayBhbmQgbWFuYWdlIHRoZSBzdGF0ZSBvZiBvcGVuIE1vZGFscy5cbi8vIE1vZGFscyBkb24ndCBvcGVuIG9uIHRoZSBzZXJ2ZXIgc28gdGhpcyB3b24ndCBjb25mbGljdCB3aXRoIGNvbmN1cnJlbnQgcmVxdWVzdHMuXG5cblxudmFyIGRlZmF1bHRNYW5hZ2VyID0gbmV3IE1vZGFsTWFuYWdlcigpO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgekluZGV4OiB0aGVtZS56SW5kZXgubW9kYWwsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiB0aGUgYE1vZGFsYCBoYXMgZXhpdGVkLiAqL1xuICAgIGhpZGRlbjoge1xuICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbidcbiAgICB9XG4gIH07XG59O1xuLyoqXG4gKiBNb2RhbCBpcyBhIGxvd2VyLWxldmVsIGNvbnN0cnVjdCB0aGF0IGlzIGxldmVyYWdlZCBieSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6XG4gKlxuICogLSBbRGlhbG9nXSgvYXBpL2RpYWxvZy8pXG4gKiAtIFtEcmF3ZXJdKC9hcGkvZHJhd2VyLylcbiAqIC0gW01lbnVdKC9hcGkvbWVudS8pXG4gKiAtIFtQb3BvdmVyXSgvYXBpL3BvcG92ZXIvKVxuICpcbiAqIElmIHlvdSBhcmUgY3JlYXRpbmcgYSBtb2RhbCBkaWFsb2csIHlvdSBwcm9iYWJseSB3YW50IHRvIHVzZSB0aGUgW0RpYWxvZ10oL2FwaS9kaWFsb2cvKSBjb21wb25lbnRcbiAqIHJhdGhlciB0aGFuIGRpcmVjdGx5IHVzaW5nIE1vZGFsLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IHNoYXJlcyBtYW55IGNvbmNlcHRzIHdpdGggW3JlYWN0LW92ZXJsYXlzXShodHRwczovL3JlYWN0LWJvb3RzdHJhcC5naXRodWIuaW8vcmVhY3Qtb3ZlcmxheXMvI21vZGFscykuXG4gKi9cblxudmFyIE1vZGFsID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTW9kYWwoaW5Qcm9wcywgcmVmKSB7XG4gIHZhciB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIHZhciBwcm9wcyA9IGdldFRoZW1lUHJvcHMoe1xuICAgIG5hbWU6ICdNdWlNb2RhbCcsXG4gICAgcHJvcHM6IF9leHRlbmRzKHt9LCBpblByb3BzKSxcbiAgICB0aGVtZTogdGhlbWVcbiAgfSk7XG5cbiAgdmFyIF9wcm9wcyRCYWNrZHJvcENvbXBvbiA9IHByb3BzLkJhY2tkcm9wQ29tcG9uZW50LFxuICAgICAgQmFja2Ryb3BDb21wb25lbnQgPSBfcHJvcHMkQmFja2Ryb3BDb21wb24gPT09IHZvaWQgMCA/IFNpbXBsZUJhY2tkcm9wIDogX3Byb3BzJEJhY2tkcm9wQ29tcG9uLFxuICAgICAgQmFja2Ryb3BQcm9wcyA9IHByb3BzLkJhY2tkcm9wUHJvcHMsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgX3Byb3BzJGNsb3NlQWZ0ZXJUcmFuID0gcHJvcHMuY2xvc2VBZnRlclRyYW5zaXRpb24sXG4gICAgICBjbG9zZUFmdGVyVHJhbnNpdGlvbiA9IF9wcm9wcyRjbG9zZUFmdGVyVHJhbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkY2xvc2VBZnRlclRyYW4sXG4gICAgICBjb250YWluZXIgPSBwcm9wcy5jb250YWluZXIsXG4gICAgICBfcHJvcHMkZGlzYWJsZUF1dG9Gb2MgPSBwcm9wcy5kaXNhYmxlQXV0b0ZvY3VzLFxuICAgICAgZGlzYWJsZUF1dG9Gb2N1cyA9IF9wcm9wcyRkaXNhYmxlQXV0b0ZvYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUF1dG9Gb2MsXG4gICAgICBfcHJvcHMkZGlzYWJsZUJhY2tkcm8gPSBwcm9wcy5kaXNhYmxlQmFja2Ryb3BDbGljayxcbiAgICAgIGRpc2FibGVCYWNrZHJvcENsaWNrID0gX3Byb3BzJGRpc2FibGVCYWNrZHJvID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlQmFja2RybyxcbiAgICAgIF9wcm9wcyRkaXNhYmxlRW5mb3JjZSA9IHByb3BzLmRpc2FibGVFbmZvcmNlRm9jdXMsXG4gICAgICBkaXNhYmxlRW5mb3JjZUZvY3VzID0gX3Byb3BzJGRpc2FibGVFbmZvcmNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlRW5mb3JjZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlRXNjYXBlSyA9IHByb3BzLmRpc2FibGVFc2NhcGVLZXlEb3duLFxuICAgICAgZGlzYWJsZUVzY2FwZUtleURvd24gPSBfcHJvcHMkZGlzYWJsZUVzY2FwZUsgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVFc2NhcGVLLFxuICAgICAgX3Byb3BzJGRpc2FibGVQb3J0YWwgPSBwcm9wcy5kaXNhYmxlUG9ydGFsLFxuICAgICAgZGlzYWJsZVBvcnRhbCA9IF9wcm9wcyRkaXNhYmxlUG9ydGFsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlUG9ydGFsLFxuICAgICAgX3Byb3BzJGRpc2FibGVSZXN0b3JlID0gcHJvcHMuZGlzYWJsZVJlc3RvcmVGb2N1cyxcbiAgICAgIGRpc2FibGVSZXN0b3JlRm9jdXMgPSBfcHJvcHMkZGlzYWJsZVJlc3RvcmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVSZXN0b3JlLFxuICAgICAgX3Byb3BzJGRpc2FibGVTY3JvbGxMID0gcHJvcHMuZGlzYWJsZVNjcm9sbExvY2ssXG4gICAgICBkaXNhYmxlU2Nyb2xsTG9jayA9IF9wcm9wcyRkaXNhYmxlU2Nyb2xsTCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVNjcm9sbEwsXG4gICAgICBfcHJvcHMkaGlkZUJhY2tkcm9wID0gcHJvcHMuaGlkZUJhY2tkcm9wLFxuICAgICAgaGlkZUJhY2tkcm9wID0gX3Byb3BzJGhpZGVCYWNrZHJvcCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkaGlkZUJhY2tkcm9wLFxuICAgICAgX3Byb3BzJGtlZXBNb3VudGVkID0gcHJvcHMua2VlcE1vdW50ZWQsXG4gICAgICBrZWVwTW91bnRlZCA9IF9wcm9wcyRrZWVwTW91bnRlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMka2VlcE1vdW50ZWQsXG4gICAgICBfcHJvcHMkbWFuYWdlciA9IHByb3BzLm1hbmFnZXIsXG4gICAgICBtYW5hZ2VyID0gX3Byb3BzJG1hbmFnZXIgPT09IHZvaWQgMCA/IGRlZmF1bHRNYW5hZ2VyIDogX3Byb3BzJG1hbmFnZXIsXG4gICAgICBvbkJhY2tkcm9wQ2xpY2sgPSBwcm9wcy5vbkJhY2tkcm9wQ2xpY2ssXG4gICAgICBvbkNsb3NlID0gcHJvcHMub25DbG9zZSxcbiAgICAgIG9uRXNjYXBlS2V5RG93biA9IHByb3BzLm9uRXNjYXBlS2V5RG93bixcbiAgICAgIG9uUmVuZGVyZWQgPSBwcm9wcy5vblJlbmRlcmVkLFxuICAgICAgb3BlbiA9IHByb3BzLm9wZW4sXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiQmFja2Ryb3BDb21wb25lbnRcIiwgXCJCYWNrZHJvcFByb3BzXCIsIFwiY2hpbGRyZW5cIiwgXCJjbG9zZUFmdGVyVHJhbnNpdGlvblwiLCBcImNvbnRhaW5lclwiLCBcImRpc2FibGVBdXRvRm9jdXNcIiwgXCJkaXNhYmxlQmFja2Ryb3BDbGlja1wiLCBcImRpc2FibGVFbmZvcmNlRm9jdXNcIiwgXCJkaXNhYmxlRXNjYXBlS2V5RG93blwiLCBcImRpc2FibGVQb3J0YWxcIiwgXCJkaXNhYmxlUmVzdG9yZUZvY3VzXCIsIFwiZGlzYWJsZVNjcm9sbExvY2tcIiwgXCJoaWRlQmFja2Ryb3BcIiwgXCJrZWVwTW91bnRlZFwiLCBcIm1hbmFnZXJcIiwgXCJvbkJhY2tkcm9wQ2xpY2tcIiwgXCJvbkNsb3NlXCIsIFwib25Fc2NhcGVLZXlEb3duXCIsIFwib25SZW5kZXJlZFwiLCBcIm9wZW5cIl0pO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSh0cnVlKSxcbiAgICAgIGV4aXRlZCA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldEV4aXRlZCA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgbW9kYWwgPSBSZWFjdC51c2VSZWYoe30pO1xuICB2YXIgbW91bnROb2RlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgbW9kYWxSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBoYW5kbGVSZWYgPSB1c2VGb3JrUmVmKG1vZGFsUmVmLCByZWYpO1xuICB2YXIgaGFzVHJhbnNpdGlvbiA9IGdldEhhc1RyYW5zaXRpb24ocHJvcHMpO1xuXG4gIHZhciBnZXREb2MgPSBmdW5jdGlvbiBnZXREb2MoKSB7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQobW91bnROb2RlUmVmLmN1cnJlbnQpO1xuICB9O1xuXG4gIHZhciBnZXRNb2RhbCA9IGZ1bmN0aW9uIGdldE1vZGFsKCkge1xuICAgIG1vZGFsLmN1cnJlbnQubW9kYWxSZWYgPSBtb2RhbFJlZi5jdXJyZW50O1xuICAgIG1vZGFsLmN1cnJlbnQubW91bnROb2RlID0gbW91bnROb2RlUmVmLmN1cnJlbnQ7XG4gICAgcmV0dXJuIG1vZGFsLmN1cnJlbnQ7XG4gIH07XG5cbiAgdmFyIGhhbmRsZU1vdW50ZWQgPSBmdW5jdGlvbiBoYW5kbGVNb3VudGVkKCkge1xuICAgIG1hbmFnZXIubW91bnQoZ2V0TW9kYWwoKSwge1xuICAgICAgZGlzYWJsZVNjcm9sbExvY2s6IGRpc2FibGVTY3JvbGxMb2NrXG4gICAgfSk7IC8vIEZpeCBhIGJ1ZyBvbiBDaHJvbWUgd2hlcmUgdGhlIHNjcm9sbCBpc24ndCBpbml0aWFsbHkgMC5cblxuICAgIG1vZGFsUmVmLmN1cnJlbnQuc2Nyb2xsVG9wID0gMDtcbiAgfTtcblxuICB2YXIgaGFuZGxlT3BlbiA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXNvbHZlZENvbnRhaW5lciA9IGdldENvbnRhaW5lcihjb250YWluZXIpIHx8IGdldERvYygpLmJvZHk7XG4gICAgbWFuYWdlci5hZGQoZ2V0TW9kYWwoKSwgcmVzb2x2ZWRDb250YWluZXIpOyAvLyBUaGUgZWxlbWVudCB3YXMgYWxyZWFkeSBtb3VudGVkLlxuXG4gICAgaWYgKG1vZGFsUmVmLmN1cnJlbnQpIHtcbiAgICAgIGhhbmRsZU1vdW50ZWQoKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgaXNUb3BNb2RhbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbWFuYWdlci5pc1RvcE1vZGFsKGdldE1vZGFsKCkpO1xuICB9LCBbbWFuYWdlcl0pO1xuICB2YXIgaGFuZGxlUG9ydGFsUmVmID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAobm9kZSkge1xuICAgIG1vdW50Tm9kZVJlZi5jdXJyZW50ID0gbm9kZTtcblxuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvblJlbmRlcmVkKSB7XG4gICAgICBvblJlbmRlcmVkKCk7XG4gICAgfVxuXG4gICAgaWYgKG9wZW4gJiYgaXNUb3BNb2RhbCgpKSB7XG4gICAgICBoYW5kbGVNb3VudGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyaWFIaWRkZW4obW9kYWxSZWYuY3VycmVudCwgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbiAgdmFyIGhhbmRsZUNsb3NlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIG1hbmFnZXIucmVtb3ZlKGdldE1vZGFsKCkpO1xuICB9LCBbbWFuYWdlcl0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBoYW5kbGVDbG9zZSgpO1xuICAgIH07XG4gIH0sIFtoYW5kbGVDbG9zZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBoYW5kbGVPcGVuKCk7XG4gICAgfSBlbHNlIGlmICghaGFzVHJhbnNpdGlvbiB8fCAhY2xvc2VBZnRlclRyYW5zaXRpb24pIHtcbiAgICAgIGhhbmRsZUNsb3NlKCk7XG4gICAgfVxuICB9LCBbb3BlbiwgaGFuZGxlQ2xvc2UsIGhhc1RyYW5zaXRpb24sIGNsb3NlQWZ0ZXJUcmFuc2l0aW9uLCBoYW5kbGVPcGVuXSk7XG5cbiAgaWYgKCFrZWVwTW91bnRlZCAmJiAhb3BlbiAmJiAoIWhhc1RyYW5zaXRpb24gfHwgZXhpdGVkKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGhhbmRsZUVudGVyID0gZnVuY3Rpb24gaGFuZGxlRW50ZXIoKSB7XG4gICAgc2V0RXhpdGVkKGZhbHNlKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlRXhpdGVkID0gZnVuY3Rpb24gaGFuZGxlRXhpdGVkKCkge1xuICAgIHNldEV4aXRlZCh0cnVlKTtcblxuICAgIGlmIChjbG9zZUFmdGVyVHJhbnNpdGlvbikge1xuICAgICAgaGFuZGxlQ2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUJhY2tkcm9wQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVCYWNrZHJvcENsaWNrKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvbkJhY2tkcm9wQ2xpY2spIHtcbiAgICAgIG9uQmFja2Ryb3BDbGljayhldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKCFkaXNhYmxlQmFja2Ryb3BDbGljayAmJiBvbkNsb3NlKSB7XG4gICAgICBvbkNsb3NlKGV2ZW50LCAnYmFja2Ryb3BDbGljaycpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAvLyBUaGUgaGFuZGxlciBkb2Vzbid0IHRha2UgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCBpbnRvIGFjY291bnQ6XG4gICAgLy9cbiAgICAvLyBldmVudC5wcmV2ZW50RGVmYXVsdCgpIGlzIG1lYW50IHRvIHN0b3AgZGVmYXVsdCBiZWhhdmlvdXJzIGxpa2VcbiAgICAvLyBjbGlja2luZyBhIGNoZWNrYm94IHRvIGNoZWNrIGl0LCBoaXR0aW5nIGEgYnV0dG9uIHRvIHN1Ym1pdCBhIGZvcm0sXG4gICAgLy8gYW5kIGhpdHRpbmcgbGVmdCBhcnJvdyB0byBtb3ZlIHRoZSBjdXJzb3IgaW4gYSB0ZXh0IGlucHV0IGV0Yy5cbiAgICAvLyBPbmx5IHNwZWNpYWwgSFRNTCBlbGVtZW50cyBoYXZlIHRoZXNlIGRlZmF1bHQgYmVoYXZpb3JzLlxuICAgIGlmIChldmVudC5rZXkgIT09ICdFc2NhcGUnIHx8ICFpc1RvcE1vZGFsKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob25Fc2NhcGVLZXlEb3duKSB7XG4gICAgICBvbkVzY2FwZUtleURvd24oZXZlbnQpO1xuICAgIH1cblxuICAgIGlmICghZGlzYWJsZUVzY2FwZUtleURvd24pIHtcbiAgICAgIC8vIFN3YWxsb3cgdGhlIGV2ZW50LCBpbiBjYXNlIHNvbWVvbmUgaXMgbGlzdGVuaW5nIGZvciB0aGUgZXNjYXBlIGtleSBvbiB0aGUgYm9keS5cbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAob25DbG9zZSkge1xuICAgICAgICBvbkNsb3NlKGV2ZW50LCAnZXNjYXBlS2V5RG93bicpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaW5saW5lU3R5bGUgPSBzdHlsZXModGhlbWUgfHwge1xuICAgIHpJbmRleDogekluZGV4XG4gIH0pO1xuICB2YXIgY2hpbGRQcm9wcyA9IHt9O1xuXG4gIGlmIChjaGlsZHJlbi5wcm9wcy50YWJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2hpbGRQcm9wcy50YWJJbmRleCA9IGNoaWxkcmVuLnByb3BzLnRhYkluZGV4IHx8ICctMSc7XG4gIH0gLy8gSXQncyBhIFRyYW5zaXRpb24gbGlrZSBjb21wb25lbnRcblxuXG4gIGlmIChoYXNUcmFuc2l0aW9uKSB7XG4gICAgY2hpbGRQcm9wcy5vbkVudGVyID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKGhhbmRsZUVudGVyLCBjaGlsZHJlbi5wcm9wcy5vbkVudGVyKTtcbiAgICBjaGlsZFByb3BzLm9uRXhpdGVkID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKGhhbmRsZUV4aXRlZCwgY2hpbGRyZW4ucHJvcHMub25FeGl0ZWQpO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbCwge1xuICAgIHJlZjogaGFuZGxlUG9ydGFsUmVmLFxuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIGRpc2FibGVQb3J0YWw6IGRpc2FibGVQb3J0YWxcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogaGFuZGxlUmVmLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICByb2xlOiBcInByZXNlbnRhdGlvblwiXG4gIH0sIG90aGVyLCB7XG4gICAgc3R5bGU6IF9leHRlbmRzKHt9LCBpbmxpbmVTdHlsZS5yb290LCAhb3BlbiAmJiBleGl0ZWQgPyBpbmxpbmVTdHlsZS5oaWRkZW4gOiB7fSwgb3RoZXIuc3R5bGUpXG4gIH0pLCBoaWRlQmFja2Ryb3AgPyBudWxsIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQmFja2Ryb3BDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBvcGVuOiBvcGVuLFxuICAgIG9uQ2xpY2s6IGhhbmRsZUJhY2tkcm9wQ2xpY2tcbiAgfSwgQmFja2Ryb3BQcm9wcykpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUcmFwRm9jdXMsIHtcbiAgICBkaXNhYmxlRW5mb3JjZUZvY3VzOiBkaXNhYmxlRW5mb3JjZUZvY3VzLFxuICAgIGRpc2FibGVBdXRvRm9jdXM6IGRpc2FibGVBdXRvRm9jdXMsXG4gICAgZGlzYWJsZVJlc3RvcmVGb2N1czogZGlzYWJsZVJlc3RvcmVGb2N1cyxcbiAgICBnZXREb2M6IGdldERvYyxcbiAgICBpc0VuYWJsZWQ6IGlzVG9wTW9kYWwsXG4gICAgb3Blbjogb3BlblxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkcmVuLCBjaGlsZFByb3BzKSkpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gTW9kYWwucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQSBiYWNrZHJvcCBjb21wb25lbnQuIFRoaXMgcHJvcCBlbmFibGVzIGN1c3RvbSBiYWNrZHJvcCByZW5kZXJpbmcuXG4gICAqL1xuICBCYWNrZHJvcENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYEJhY2tkcm9wYF0oL2FwaS9iYWNrZHJvcC8pIGVsZW1lbnQuXG4gICAqL1xuICBCYWNrZHJvcFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBBIHNpbmdsZSBjaGlsZCBjb250ZW50IGVsZW1lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogZWxlbWVudEFjY2VwdGluZ1JlZi5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBXaGVuIHNldCB0byB0cnVlIHRoZSBNb2RhbCB3YWl0cyB1bnRpbCBhIG5lc3RlZCBUcmFuc2l0aW9uIGlzIGNvbXBsZXRlZCBiZWZvcmUgY2xvc2luZy5cbiAgICovXG4gIGNsb3NlQWZ0ZXJUcmFuc2l0aW9uOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQSBIVE1MIGVsZW1lbnQsIGNvbXBvbmVudCBpbnN0YW5jZSwgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVpdGhlci5cbiAgICogVGhlIGBjb250YWluZXJgIHdpbGwgaGF2ZSB0aGUgcG9ydGFsIGNoaWxkcmVuIGFwcGVuZGVkIHRvIGl0LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpdCB1c2VzIHRoZSBib2R5IG9mIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgb2JqZWN0LFxuICAgKiBzbyBpdCdzIHNpbXBseSBgZG9jdW1lbnQuYm9keWAgbW9zdCBvZiB0aGUgdGltZS5cbiAgICovXG4gIGNvbnRhaW5lcjogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLm9uZU9mVHlwZShbSFRNTEVsZW1lbnRUeXBlLCBQcm9wVHlwZXMuaW5zdGFuY2VPZihSZWFjdC5Db21wb25lbnQpLCBQcm9wVHlwZXMuZnVuY10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBtb2RhbCB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IHNoaWZ0IGZvY3VzIHRvIGl0c2VsZiB3aGVuIGl0IG9wZW5zLCBhbmRcbiAgICogcmVwbGFjZSBpdCB0byB0aGUgbGFzdCBmb2N1c2VkIGVsZW1lbnQgd2hlbiBpdCBjbG9zZXMuXG4gICAqIFRoaXMgYWxzbyB3b3JrcyBjb3JyZWN0bHkgd2l0aCBhbnkgbW9kYWwgY2hpbGRyZW4gdGhhdCBoYXZlIHRoZSBgZGlzYWJsZUF1dG9Gb2N1c2AgcHJvcC5cbiAgICpcbiAgICogR2VuZXJhbGx5IHRoaXMgc2hvdWxkIG5ldmVyIGJlIHNldCB0byBgdHJ1ZWAgYXMgaXQgbWFrZXMgdGhlIG1vZGFsIGxlc3NcbiAgICogYWNjZXNzaWJsZSB0byBhc3Npc3RpdmUgdGVjaG5vbG9naWVzLCBsaWtlIHNjcmVlbiByZWFkZXJzLlxuICAgKi9cbiAgZGlzYWJsZUF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgY2xpY2tpbmcgdGhlIGJhY2tkcm9wIHdpbGwgbm90IGZpcmUgYG9uQ2xvc2VgLlxuICAgKi9cbiAgZGlzYWJsZUJhY2tkcm9wQ2xpY2s6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBtb2RhbCB3aWxsIG5vdCBwcmV2ZW50IGZvY3VzIGZyb20gbGVhdmluZyB0aGUgbW9kYWwgd2hpbGUgb3Blbi5cbiAgICpcbiAgICogR2VuZXJhbGx5IHRoaXMgc2hvdWxkIG5ldmVyIGJlIHNldCB0byBgdHJ1ZWAgYXMgaXQgbWFrZXMgdGhlIG1vZGFsIGxlc3NcbiAgICogYWNjZXNzaWJsZSB0byBhc3Npc3RpdmUgdGVjaG5vbG9naWVzLCBsaWtlIHNjcmVlbiByZWFkZXJzLlxuICAgKi9cbiAgZGlzYWJsZUVuZm9yY2VGb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgaGl0dGluZyBlc2NhcGUgd2lsbCBub3QgZmlyZSBgb25DbG9zZWAuXG4gICAqL1xuICBkaXNhYmxlRXNjYXBlS2V5RG93bjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIERpc2FibGUgdGhlIHBvcnRhbCBiZWhhdmlvci5cbiAgICogVGhlIGNoaWxkcmVuIHN0YXkgd2l0aGluIGl0J3MgcGFyZW50IERPTSBoaWVyYXJjaHkuXG4gICAqL1xuICBkaXNhYmxlUG9ydGFsOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbW9kYWwgd2lsbCBub3QgcmVzdG9yZSBmb2N1cyB0byBwcmV2aW91c2x5IGZvY3VzZWQgZWxlbWVudCBvbmNlXG4gICAqIG1vZGFsIGlzIGhpZGRlbi5cbiAgICovXG4gIGRpc2FibGVSZXN0b3JlRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBzY3JvbGwgbG9jayBiZWhhdmlvci5cbiAgICovXG4gIGRpc2FibGVTY3JvbGxMb2NrOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYmFja2Ryb3AgaXMgbm90IHJlbmRlcmVkLlxuICAgKi9cbiAgaGlkZUJhY2tkcm9wOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQWx3YXlzIGtlZXAgdGhlIGNoaWxkcmVuIGluIHRoZSBET00uXG4gICAqIFRoaXMgcHJvcCBjYW4gYmUgdXNlZnVsIGluIFNFTyBzaXR1YXRpb24gb3JcbiAgICogd2hlbiB5b3Ugd2FudCB0byBtYXhpbWl6ZSB0aGUgcmVzcG9uc2l2ZW5lc3Mgb2YgdGhlIE1vZGFsLlxuICAgKi9cbiAga2VlcE1vdW50ZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBtYW5hZ2VyOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBiYWNrZHJvcCBpcyBjbGlja2VkLlxuICAgKi9cbiAgb25CYWNrZHJvcENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IHJlcXVlc3RzIHRvIGJlIGNsb3NlZC5cbiAgICogVGhlIGByZWFzb25gIHBhcmFtZXRlciBjYW4gb3B0aW9uYWxseSBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIHJlc3BvbnNlIHRvIGBvbkNsb3NlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIENhbiBiZTogYFwiZXNjYXBlS2V5RG93blwiYCwgYFwiYmFja2Ryb3BDbGlja1wiYC5cbiAgICovXG4gIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBlc2NhcGUga2V5IGlzIHByZXNzZWQsXG4gICAqIGBkaXNhYmxlRXNjYXBlS2V5RG93bmAgaXMgZmFsc2UgYW5kIHRoZSBtb2RhbCBpcyBpbiBmb2N1cy5cbiAgICovXG4gIG9uRXNjYXBlS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIG9uY2UgdGhlIGNoaWxkcmVuIGhhcyBiZWVuIG1vdW50ZWQgaW50byB0aGUgYGNvbnRhaW5lcmAuXG4gICAqIEl0IHNpZ25hbHMgdGhhdCB0aGUgYG9wZW49e3RydWV9YCBwcm9wIHRvb2sgZWZmZWN0LlxuICAgKlxuICAgKiBUaGlzIHByb3Agd2lsbCBiZSBkZXByZWNhdGVkIGFuZCByZW1vdmVkIGluIHY1LCB0aGUgcmVmIGNhbiBiZSB1c2VkIGluc3RlYWQuXG4gICAqL1xuICBvblJlbmRlcmVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbW9kYWwgaXMgb3Blbi5cbiAgICovXG4gIG9wZW46IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWRcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCBNb2RhbDsiLCJleHBvcnQgZGVmYXVsdCB7XG4gIGRpc2FibGVkOiBmYWxzZVxufTsiLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBjb25maWcgZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgdGltZW91dHNTaGFwZSB9IGZyb20gJy4vdXRpbHMvUHJvcFR5cGVzJztcbmltcG9ydCBUcmFuc2l0aW9uR3JvdXBDb250ZXh0IGZyb20gJy4vVHJhbnNpdGlvbkdyb3VwQ29udGV4dCc7XG5leHBvcnQgdmFyIFVOTU9VTlRFRCA9ICd1bm1vdW50ZWQnO1xuZXhwb3J0IHZhciBFWElURUQgPSAnZXhpdGVkJztcbmV4cG9ydCB2YXIgRU5URVJJTkcgPSAnZW50ZXJpbmcnO1xuZXhwb3J0IHZhciBFTlRFUkVEID0gJ2VudGVyZWQnO1xuZXhwb3J0IHZhciBFWElUSU5HID0gJ2V4aXRpbmcnO1xuLyoqXG4gKiBUaGUgVHJhbnNpdGlvbiBjb21wb25lbnQgbGV0cyB5b3UgZGVzY3JpYmUgYSB0cmFuc2l0aW9uIGZyb20gb25lIGNvbXBvbmVudFxuICogc3RhdGUgdG8gYW5vdGhlciBfb3ZlciB0aW1lXyB3aXRoIGEgc2ltcGxlIGRlY2xhcmF0aXZlIEFQSS4gTW9zdCBjb21tb25seVxuICogaXQncyB1c2VkIHRvIGFuaW1hdGUgdGhlIG1vdW50aW5nIGFuZCB1bm1vdW50aW5nIG9mIGEgY29tcG9uZW50LCBidXQgY2FuIGFsc29cbiAqIGJlIHVzZWQgdG8gZGVzY3JpYmUgaW4tcGxhY2UgdHJhbnNpdGlvbiBzdGF0ZXMgYXMgd2VsbC5cbiAqXG4gKiAtLS1cbiAqXG4gKiAqKk5vdGUqKjogYFRyYW5zaXRpb25gIGlzIGEgcGxhdGZvcm0tYWdub3N0aWMgYmFzZSBjb21wb25lbnQuIElmIHlvdSdyZSB1c2luZ1xuICogdHJhbnNpdGlvbnMgaW4gQ1NTLCB5b3UnbGwgcHJvYmFibHkgd2FudCB0byB1c2VcbiAqIFtgQ1NTVHJhbnNpdGlvbmBdKGh0dHBzOi8vcmVhY3Rjb21tdW5pdHkub3JnL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvY3NzLXRyYW5zaXRpb24pXG4gKiBpbnN0ZWFkLiBJdCBpbmhlcml0cyBhbGwgdGhlIGZlYXR1cmVzIG9mIGBUcmFuc2l0aW9uYCwgYnV0IGNvbnRhaW5zXG4gKiBhZGRpdGlvbmFsIGZlYXR1cmVzIG5lY2Vzc2FyeSB0byBwbGF5IG5pY2Ugd2l0aCBDU1MgdHJhbnNpdGlvbnMgKGhlbmNlIHRoZVxuICogbmFtZSBvZiB0aGUgY29tcG9uZW50KS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBCeSBkZWZhdWx0IHRoZSBgVHJhbnNpdGlvbmAgY29tcG9uZW50IGRvZXMgbm90IGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGVcbiAqIGNvbXBvbmVudCBpdCByZW5kZXJzLCBpdCBvbmx5IHRyYWNrcyBcImVudGVyXCIgYW5kIFwiZXhpdFwiIHN0YXRlcyBmb3IgdGhlXG4gKiBjb21wb25lbnRzLiBJdCdzIHVwIHRvIHlvdSB0byBnaXZlIG1lYW5pbmcgYW5kIGVmZmVjdCB0byB0aG9zZSBzdGF0ZXMuIEZvclxuICogZXhhbXBsZSB3ZSBjYW4gYWRkIHN0eWxlcyB0byBhIGNvbXBvbmVudCB3aGVuIGl0IGVudGVycyBvciBleGl0czpcbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJztcbiAqXG4gKiBjb25zdCBkdXJhdGlvbiA9IDMwMDtcbiAqXG4gKiBjb25zdCBkZWZhdWx0U3R5bGUgPSB7XG4gKiAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7ZHVyYXRpb259bXMgZWFzZS1pbi1vdXRgLFxuICogICBvcGFjaXR5OiAwLFxuICogfVxuICpcbiAqIGNvbnN0IHRyYW5zaXRpb25TdHlsZXMgPSB7XG4gKiAgIGVudGVyaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAqICAgZW50ZXJlZDogIHsgb3BhY2l0eTogMSB9LFxuICogICBleGl0aW5nOiAgeyBvcGFjaXR5OiAwIH0sXG4gKiAgIGV4aXRlZDogIHsgb3BhY2l0eTogMCB9LFxuICogfTtcbiAqXG4gKiBjb25zdCBGYWRlID0gKHsgaW46IGluUHJvcCB9KSA9PiAoXG4gKiAgIDxUcmFuc2l0aW9uIGluPXtpblByb3B9IHRpbWVvdXQ9e2R1cmF0aW9ufT5cbiAqICAgICB7c3RhdGUgPT4gKFxuICogICAgICAgPGRpdiBzdHlsZT17e1xuICogICAgICAgICAuLi5kZWZhdWx0U3R5bGUsXG4gKiAgICAgICAgIC4uLnRyYW5zaXRpb25TdHlsZXNbc3RhdGVdXG4gKiAgICAgICB9fT5cbiAqICAgICAgICAgSSdtIGEgZmFkZSBUcmFuc2l0aW9uIVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgKX1cbiAqICAgPC9UcmFuc2l0aW9uPlxuICogKTtcbiAqIGBgYFxuICpcbiAqIFRoZXJlIGFyZSA0IG1haW4gc3RhdGVzIGEgVHJhbnNpdGlvbiBjYW4gYmUgaW46XG4gKiAgLSBgJ2VudGVyaW5nJ2BcbiAqICAtIGAnZW50ZXJlZCdgXG4gKiAgLSBgJ2V4aXRpbmcnYFxuICogIC0gYCdleGl0ZWQnYFxuICpcbiAqIFRyYW5zaXRpb24gc3RhdGUgaXMgdG9nZ2xlZCB2aWEgdGhlIGBpbmAgcHJvcC4gV2hlbiBgdHJ1ZWAgdGhlIGNvbXBvbmVudFxuICogYmVnaW5zIHRoZSBcIkVudGVyXCIgc3RhZ2UuIER1cmluZyB0aGlzIHN0YWdlLCB0aGUgY29tcG9uZW50IHdpbGwgc2hpZnQgZnJvbVxuICogaXRzIGN1cnJlbnQgdHJhbnNpdGlvbiBzdGF0ZSwgdG8gYCdlbnRlcmluZydgIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlXG4gKiB0cmFuc2l0aW9uIGFuZCB0aGVuIHRvIHRoZSBgJ2VudGVyZWQnYCBzdGFnZSBvbmNlIGl0J3MgY29tcGxldGUuIExldCdzIHRha2VcbiAqIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSAod2UnbGwgdXNlIHRoZVxuICogW3VzZVN0YXRlXShodHRwczovL3JlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjdXNlc3RhdGUpIGhvb2spOlxuICpcbiAqIGBgYGpzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBbaW5Qcm9wLCBzZXRJblByb3BdID0gdXNlU3RhdGUoZmFsc2UpO1xuICogICByZXR1cm4gKFxuICogICAgIDxkaXY+XG4gKiAgICAgICA8VHJhbnNpdGlvbiBpbj17aW5Qcm9wfSB0aW1lb3V0PXs1MDB9PlxuICogICAgICAgICB7c3RhdGUgPT4gKFxuICogICAgICAgICAgIC8vIC4uLlxuICogICAgICAgICApfVxuICogICAgICAgPC9UcmFuc2l0aW9uPlxuICogICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRJblByb3AodHJ1ZSl9PlxuICogICAgICAgICBDbGljayB0byBFbnRlclxuICogICAgICAgPC9idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZCB0aGUgY29tcG9uZW50IHdpbGwgc2hpZnQgdG8gdGhlIGAnZW50ZXJpbmcnYCBzdGF0ZVxuICogYW5kIHN0YXkgdGhlcmUgZm9yIDUwMG1zICh0aGUgdmFsdWUgb2YgYHRpbWVvdXRgKSBiZWZvcmUgaXQgZmluYWxseSBzd2l0Y2hlc1xuICogdG8gYCdlbnRlcmVkJ2AuXG4gKlxuICogV2hlbiBgaW5gIGlzIGBmYWxzZWAgdGhlIHNhbWUgdGhpbmcgaGFwcGVucyBleGNlcHQgdGhlIHN0YXRlIG1vdmVzIGZyb21cbiAqIGAnZXhpdGluZydgIHRvIGAnZXhpdGVkJ2AuXG4gKi9cblxudmFyIFRyYW5zaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVHJhbnNpdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbihwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgIHZhciBwYXJlbnRHcm91cCA9IGNvbnRleHQ7IC8vIEluIHRoZSBjb250ZXh0IG9mIGEgVHJhbnNpdGlvbkdyb3VwIGFsbCBlbnRlcnMgYXJlIHJlYWxseSBhcHBlYXJzXG5cbiAgICB2YXIgYXBwZWFyID0gcGFyZW50R3JvdXAgJiYgIXBhcmVudEdyb3VwLmlzTW91bnRpbmcgPyBwcm9wcy5lbnRlciA6IHByb3BzLmFwcGVhcjtcbiAgICB2YXIgaW5pdGlhbFN0YXR1cztcbiAgICBfdGhpcy5hcHBlYXJTdGF0dXMgPSBudWxsO1xuXG4gICAgaWYgKHByb3BzLmluKSB7XG4gICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFWElURUQ7XG4gICAgICAgIF90aGlzLmFwcGVhclN0YXR1cyA9IEVOVEVSSU5HO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVOVEVSRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wcy51bm1vdW50T25FeGl0IHx8IHByb3BzLm1vdW50T25FbnRlcikge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gVU5NT1VOVEVEO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVYSVRFRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0YXR1czogaW5pdGlhbFN0YXR1c1xuICAgIH07XG4gICAgX3RoaXMubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUcmFuc2l0aW9uLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhfcmVmLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgbmV4dEluID0gX3JlZi5pbjtcblxuICAgIGlmIChuZXh0SW4gJiYgcHJldlN0YXRlLnN0YXR1cyA9PT0gVU5NT1VOVEVEKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgLy8gICBsZXQgbmV4dFN0YXR1cyA9IG51bGxcbiAgLy8gICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gIC8vICAgICBjb25zdCB7IHN0YXR1cyB9ID0gdGhpcy5zdGF0ZVxuICAvLyAgICAgaWYgKHRoaXMucHJvcHMuaW4pIHtcbiAgLy8gICAgICAgaWYgKHN0YXR1cyAhPT0gRU5URVJJTkcgJiYgc3RhdHVzICE9PSBFTlRFUkVEKSB7XG4gIC8vICAgICAgICAgbmV4dFN0YXR1cyA9IEVOVEVSSU5HXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH0gZWxzZSB7XG4gIC8vICAgICAgIGlmIChzdGF0dXMgPT09IEVOVEVSSU5HIHx8IHN0YXR1cyA9PT0gRU5URVJFRCkge1xuICAvLyAgICAgICAgIG5leHRTdGF0dXMgPSBFWElUSU5HXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vICAgcmV0dXJuIHsgbmV4dFN0YXR1cyB9XG4gIC8vIH1cbiAgO1xuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyh0cnVlLCB0aGlzLmFwcGVhclN0YXR1cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgbmV4dFN0YXR1cyA9IG51bGw7XG5cbiAgICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gICAgICB2YXIgc3RhdHVzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmluKSB7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IEVOVEVSSU5HICYmIHN0YXR1cyAhPT0gRU5URVJFRCkge1xuICAgICAgICAgIG5leHRTdGF0dXMgPSBFTlRFUklORztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gRU5URVJJTkcgfHwgc3RhdHVzID09PSBFTlRFUkVEKSB7XG4gICAgICAgICAgbmV4dFN0YXR1cyA9IEVYSVRJTkc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyhmYWxzZSwgbmV4dFN0YXR1cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5jYW5jZWxOZXh0Q2FsbGJhY2soKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGltZW91dHMgPSBmdW5jdGlvbiBnZXRUaW1lb3V0cygpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMucHJvcHMudGltZW91dDtcbiAgICB2YXIgZXhpdCwgZW50ZXIsIGFwcGVhcjtcbiAgICBleGl0ID0gZW50ZXIgPSBhcHBlYXIgPSB0aW1lb3V0O1xuXG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCAmJiB0eXBlb2YgdGltZW91dCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGV4aXQgPSB0aW1lb3V0LmV4aXQ7XG4gICAgICBlbnRlciA9IHRpbWVvdXQuZW50ZXI7IC8vIFRPRE86IHJlbW92ZSBmYWxsYmFjayBmb3IgbmV4dCBtYWpvclxuXG4gICAgICBhcHBlYXIgPSB0aW1lb3V0LmFwcGVhciAhPT0gdW5kZWZpbmVkID8gdGltZW91dC5hcHBlYXIgOiBlbnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhpdDogZXhpdCxcbiAgICAgIGVudGVyOiBlbnRlcixcbiAgICAgIGFwcGVhcjogYXBwZWFyXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlU3RhdHVzID0gZnVuY3Rpb24gdXBkYXRlU3RhdHVzKG1vdW50aW5nLCBuZXh0U3RhdHVzKSB7XG4gICAgaWYgKG1vdW50aW5nID09PSB2b2lkIDApIHtcbiAgICAgIG1vdW50aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5leHRTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgIC8vIG5leHRTdGF0dXMgd2lsbCBhbHdheXMgYmUgRU5URVJJTkcgb3IgRVhJVElORy5cbiAgICAgIHRoaXMuY2FuY2VsTmV4dENhbGxiYWNrKCk7XG5cbiAgICAgIGlmIChuZXh0U3RhdHVzID09PSBFTlRFUklORykge1xuICAgICAgICB0aGlzLnBlcmZvcm1FbnRlcihtb3VudGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBlcmZvcm1FeGl0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLnVubW91bnRPbkV4aXQgJiYgdGhpcy5zdGF0ZS5zdGF0dXMgPT09IEVYSVRFRCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogVU5NT1VOVEVEXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBlcmZvcm1FbnRlciA9IGZ1bmN0aW9uIHBlcmZvcm1FbnRlcihtb3VudGluZykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGVudGVyID0gdGhpcy5wcm9wcy5lbnRlcjtcbiAgICB2YXIgYXBwZWFyaW5nID0gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0LmlzTW91bnRpbmcgOiBtb3VudGluZztcblxuICAgIHZhciBfcmVmMiA9IHRoaXMucHJvcHMubm9kZVJlZiA/IFthcHBlYXJpbmddIDogW1JlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLCBhcHBlYXJpbmddLFxuICAgICAgICBtYXliZU5vZGUgPSBfcmVmMlswXSxcbiAgICAgICAgbWF5YmVBcHBlYXJpbmcgPSBfcmVmMlsxXTtcblxuICAgIHZhciB0aW1lb3V0cyA9IHRoaXMuZ2V0VGltZW91dHMoKTtcbiAgICB2YXIgZW50ZXJUaW1lb3V0ID0gYXBwZWFyaW5nID8gdGltZW91dHMuYXBwZWFyIDogdGltZW91dHMuZW50ZXI7IC8vIG5vIGVudGVyIGFuaW1hdGlvbiBza2lwIHJpZ2h0IHRvIEVOVEVSRURcbiAgICAvLyBpZiB3ZSBhcmUgbW91bnRpbmcgYW5kIHJ1bm5pbmcgdGhpcyBpdCBtZWFucyBhcHBlYXIgX211c3RfIGJlIHNldFxuXG4gICAgaWYgKCFtb3VudGluZyAmJiAhZW50ZXIgfHwgY29uZmlnLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogRU5URVJFRFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIucHJvcHMub25FbnRlcmVkKG1heWJlTm9kZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLm9uRW50ZXIobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyk7XG4gICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgc3RhdHVzOiBFTlRFUklOR1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyaW5nKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuXG4gICAgICBfdGhpczIub25UcmFuc2l0aW9uRW5kKGVudGVyVGltZW91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgICBzdGF0dXM6IEVOVEVSRURcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyZWQobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnBlcmZvcm1FeGl0ID0gZnVuY3Rpb24gcGVyZm9ybUV4aXQoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgZXhpdCA9IHRoaXMucHJvcHMuZXhpdDtcbiAgICB2YXIgdGltZW91dHMgPSB0aGlzLmdldFRpbWVvdXRzKCk7XG4gICAgdmFyIG1heWJlTm9kZSA9IHRoaXMucHJvcHMubm9kZVJlZiA/IHVuZGVmaW5lZCA6IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpOyAvLyBubyBleGl0IGFuaW1hdGlvbiBza2lwIHJpZ2h0IHRvIEVYSVRFRFxuXG4gICAgaWYgKCFleGl0IHx8IGNvbmZpZy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMucHJvcHMub25FeGl0ZWQobWF5YmVOb2RlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMub25FeGl0KG1heWJlTm9kZSk7XG4gICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgc3RhdHVzOiBFWElUSU5HXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMzLnByb3BzLm9uRXhpdGluZyhtYXliZU5vZGUpO1xuXG4gICAgICBfdGhpczMub25UcmFuc2l0aW9uRW5kKHRpbWVvdXRzLmV4aXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRlZChtYXliZU5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jYW5jZWxOZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiBjYW5jZWxOZXh0Q2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMubmV4dENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwoKTtcbiAgICAgIHRoaXMubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNhZmVTZXRTdGF0ZSA9IGZ1bmN0aW9uIHNhZmVTZXRTdGF0ZShuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5LCBidXQgdGhlcmUgYXJlIHdlaXJkIHJhY2UgY29uZGl0aW9ucyB3aXRoXG4gICAgLy8gc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCB1bm1vdW50aW5nIGluIHRlc3RpbmcsIHNvIGFsd2F5cyBtYWtlIHN1cmUgdGhhdFxuICAgIC8vIHdlIGNhbiBjYW5jZWwgYW55IHBlbmRpbmcgc2V0U3RhdGUgY2FsbGJhY2tzIGFmdGVyIHdlIHVubW91bnQuXG4gICAgY2FsbGJhY2sgPSB0aGlzLnNldE5leHRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0TmV4dENhbGxiYWNrID0gZnVuY3Rpb24gc2V0TmV4dENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgYWN0aXZlID0gdHJ1ZTtcblxuICAgIHRoaXMubmV4dENhbGxiYWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpczQubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMubmV4dENhbGxiYWNrO1xuICB9O1xuXG4gIF9wcm90by5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQodGltZW91dCwgaGFuZGxlcikge1xuICAgIHRoaXMuc2V0TmV4dENhbGxiYWNrKGhhbmRsZXIpO1xuICAgIHZhciBub2RlID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gdGhpcy5wcm9wcy5ub2RlUmVmLmN1cnJlbnQgOiBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICB2YXIgZG9lc05vdEhhdmVUaW1lb3V0T3JMaXN0ZW5lciA9IHRpbWVvdXQgPT0gbnVsbCAmJiAhdGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcjtcblxuICAgIGlmICghbm9kZSB8fCBkb2VzTm90SGF2ZVRpbWVvdXRPckxpc3RlbmVyKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMubmV4dENhbGxiYWNrLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcikge1xuICAgICAgdmFyIF9yZWYzID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gW3RoaXMubmV4dENhbGxiYWNrXSA6IFtub2RlLCB0aGlzLm5leHRDYWxsYmFja10sXG4gICAgICAgICAgbWF5YmVOb2RlID0gX3JlZjNbMF0sXG4gICAgICAgICAgbWF5YmVOZXh0Q2FsbGJhY2sgPSBfcmVmM1sxXTtcblxuICAgICAgdGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcihtYXliZU5vZGUsIG1heWJlTmV4dENhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMubmV4dENhbGxiYWNrLCB0aW1lb3V0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgc3RhdHVzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG5cbiAgICBpZiAoc3RhdHVzID09PSBVTk1PVU5URUQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIF9pbiA9IF90aGlzJHByb3BzLmluLFxuICAgICAgICBfbW91bnRPbkVudGVyID0gX3RoaXMkcHJvcHMubW91bnRPbkVudGVyLFxuICAgICAgICBfdW5tb3VudE9uRXhpdCA9IF90aGlzJHByb3BzLnVubW91bnRPbkV4aXQsXG4gICAgICAgIF9hcHBlYXIgPSBfdGhpcyRwcm9wcy5hcHBlYXIsXG4gICAgICAgIF9lbnRlciA9IF90aGlzJHByb3BzLmVudGVyLFxuICAgICAgICBfZXhpdCA9IF90aGlzJHByb3BzLmV4aXQsXG4gICAgICAgIF90aW1lb3V0ID0gX3RoaXMkcHJvcHMudGltZW91dCxcbiAgICAgICAgX2FkZEVuZExpc3RlbmVyID0gX3RoaXMkcHJvcHMuYWRkRW5kTGlzdGVuZXIsXG4gICAgICAgIF9vbkVudGVyID0gX3RoaXMkcHJvcHMub25FbnRlcixcbiAgICAgICAgX29uRW50ZXJpbmcgPSBfdGhpcyRwcm9wcy5vbkVudGVyaW5nLFxuICAgICAgICBfb25FbnRlcmVkID0gX3RoaXMkcHJvcHMub25FbnRlcmVkLFxuICAgICAgICBfb25FeGl0ID0gX3RoaXMkcHJvcHMub25FeGl0LFxuICAgICAgICBfb25FeGl0aW5nID0gX3RoaXMkcHJvcHMub25FeGl0aW5nLFxuICAgICAgICBfb25FeGl0ZWQgPSBfdGhpcyRwcm9wcy5vbkV4aXRlZCxcbiAgICAgICAgX25vZGVSZWYgPSBfdGhpcyRwcm9wcy5ub2RlUmVmLFxuICAgICAgICBjaGlsZFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiaW5cIiwgXCJtb3VudE9uRW50ZXJcIiwgXCJ1bm1vdW50T25FeGl0XCIsIFwiYXBwZWFyXCIsIFwiZW50ZXJcIiwgXCJleGl0XCIsIFwidGltZW91dFwiLCBcImFkZEVuZExpc3RlbmVyXCIsIFwib25FbnRlclwiLCBcIm9uRW50ZXJpbmdcIiwgXCJvbkVudGVyZWRcIiwgXCJvbkV4aXRcIiwgXCJvbkV4aXRpbmdcIiwgXCJvbkV4aXRlZFwiLCBcIm5vZGVSZWZcIl0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIC8vIGFsbG93cyBmb3IgbmVzdGVkIFRyYW5zaXRpb25zXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25Hcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0sIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHN0YXR1cywgY2hpbGRQcm9wcykgOiBSZWFjdC5jbG9uZUVsZW1lbnQoUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbiksIGNoaWxkUHJvcHMpKVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zaXRpb247XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblRyYW5zaXRpb24uY29udGV4dFR5cGUgPSBUcmFuc2l0aW9uR3JvdXBDb250ZXh0O1xuVHJhbnNpdGlvbi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIC8qKlxuICAgKiBBIFJlYWN0IHJlZmVyZW5jZSB0byBET00gZWxlbWVudCB0aGF0IG5lZWQgdG8gdHJhbnNpdGlvbjpcbiAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUxMTI3MTMwLzQ2NzE5MzJcbiAgICpcbiAgICogICAtIFdoZW4gYG5vZGVSZWZgIHByb3AgaXMgdXNlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAqICAgICAgKGUuZy4gYG9uRW50ZXJgKSBiZWNhdXNlIHVzZXIgYWxyZWFkeSBoYXMgZGlyZWN0IGFjY2VzcyB0byB0aGUgbm9kZS5cbiAgICogICAtIFdoZW4gY2hhbmdpbmcgYGtleWAgcHJvcCBvZiBgVHJhbnNpdGlvbmAgaW4gYSBgVHJhbnNpdGlvbkdyb3VwYCBhIG5ld1xuICAgKiAgICAgYG5vZGVSZWZgIG5lZWQgdG8gYmUgcHJvdmlkZWQgdG8gYFRyYW5zaXRpb25gIHdpdGggY2hhbmdlZCBga2V5YCBwcm9wXG4gICAqICAgICAoc2VlXG4gICAqICAgICBbdGVzdC9DU1NUcmFuc2l0aW9uLXRlc3QuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvYmxvYi8xMzQzNWY4OTdiM2FiNzFmNmUxOWQ3MjRmMTQ1NTk2ZjU5MTA1ODFjL3Rlc3QvQ1NTVHJhbnNpdGlvbi10ZXN0LmpzI0wzNjItTDQzNykpLlxuICAgKi9cbiAgbm9kZVJlZjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjdXJyZW50OiB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgPyBQcm9wVHlwZXMuYW55IDogUHJvcFR5cGVzLmluc3RhbmNlT2YoRWxlbWVudClcbiAgfSksXG5cbiAgLyoqXG4gICAqIEEgYGZ1bmN0aW9uYCBjaGlsZCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGEgUmVhY3QgZWxlbWVudC4gVGhpcyBmdW5jdGlvbiBpc1xuICAgKiBjYWxsZWQgd2l0aCB0aGUgY3VycmVudCB0cmFuc2l0aW9uIHN0YXR1cyAoYCdlbnRlcmluZydgLCBgJ2VudGVyZWQnYCxcbiAgICogYCdleGl0aW5nJ2AsIGAnZXhpdGVkJ2ApLCB3aGljaCBjYW4gYmUgdXNlZCB0byBhcHBseSBjb250ZXh0XG4gICAqIHNwZWNpZmljIHByb3BzIHRvIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogPFRyYW5zaXRpb24gaW49e3RoaXMuc3RhdGUuaW59IHRpbWVvdXQ9ezE1MH0+XG4gICAqICAge3N0YXRlID0+IChcbiAgICogICAgIDxNeUNvbXBvbmVudCBjbGFzc05hbWU9e2BmYWRlIGZhZGUtJHtzdGF0ZX1gfSAvPlxuICAgKiAgICl9XG4gICAqIDwvVHJhbnNpdGlvbj5cbiAgICogYGBgXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCwgUHJvcFR5cGVzLmVsZW1lbnQuaXNSZXF1aXJlZF0pLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGNvbXBvbmVudDsgdHJpZ2dlcnMgdGhlIGVudGVyIG9yIGV4aXQgc3RhdGVzXG4gICAqL1xuICBpbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBtb3VudGVkIGltbWVkaWF0ZWx5IGFsb25nIHdpdGhcbiAgICogdGhlIHBhcmVudCBgVHJhbnNpdGlvbmAgY29tcG9uZW50LiBJZiB5b3Ugd2FudCB0byBcImxhenkgbW91bnRcIiB0aGUgY29tcG9uZW50IG9uIHRoZVxuICAgKiBmaXJzdCBgaW49e3RydWV9YCB5b3UgY2FuIHNldCBgbW91bnRPbkVudGVyYC4gQWZ0ZXIgdGhlIGZpcnN0IGVudGVyIHRyYW5zaXRpb24gdGhlIGNvbXBvbmVudCB3aWxsIHN0YXlcbiAgICogbW91bnRlZCwgZXZlbiBvbiBcImV4aXRlZFwiLCB1bmxlc3MgeW91IGFsc28gc3BlY2lmeSBgdW5tb3VudE9uRXhpdGAuXG4gICAqL1xuICBtb3VudE9uRW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgc3RheXMgbW91bnRlZCBhZnRlciBpdCByZWFjaGVzIHRoZSBgJ2V4aXRlZCdgIHN0YXRlLlxuICAgKiBTZXQgYHVubW91bnRPbkV4aXRgIGlmIHlvdSdkIHByZWZlciB0byB1bm1vdW50IHRoZSBjb21wb25lbnQgYWZ0ZXIgaXQgZmluaXNoZXMgZXhpdGluZy5cbiAgICovXG4gIHVubW91bnRPbkV4aXQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgZG9lcyBub3QgcGVyZm9ybSB0aGUgZW50ZXIgdHJhbnNpdGlvbiB3aGVuXG4gICAqIGl0IGZpcnN0IG1vdW50cywgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYGluYC4gSWYgeW91IHdhbnQgdGhpc1xuICAgKiBiZWhhdmlvciwgc2V0IGJvdGggYGFwcGVhcmAgYW5kIGBpbmAgdG8gYHRydWVgLlxuICAgKlxuICAgKiA+ICoqTm90ZSoqOiB0aGVyZSBhcmUgbm8gc3BlY2lhbCBhcHBlYXIgc3RhdGVzIGxpa2UgYGFwcGVhcmluZ2AvYGFwcGVhcmVkYCwgdGhpcyBwcm9wXG4gICAqID4gb25seSBhZGRzIGFuIGFkZGl0aW9uYWwgZW50ZXIgdHJhbnNpdGlvbi4gSG93ZXZlciwgaW4gdGhlXG4gICAqID4gYDxDU1NUcmFuc2l0aW9uPmAgY29tcG9uZW50IHRoYXQgZmlyc3QgZW50ZXIgdHJhbnNpdGlvbiBkb2VzIHJlc3VsdCBpblxuICAgKiA+IGFkZGl0aW9uYWwgYC5hcHBlYXItKmAgY2xhc3NlcywgdGhhdCB3YXkgeW91IGNhbiBjaG9vc2UgdG8gc3R5bGUgaXRcbiAgICogPiBkaWZmZXJlbnRseS5cbiAgICovXG4gIGFwcGVhcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGVudGVyIHRyYW5zaXRpb25zLlxuICAgKi9cbiAgZW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBleGl0IHRyYW5zaXRpb25zLlxuICAgKi9cbiAgZXhpdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiwgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBSZXF1aXJlZCB1bmxlc3MgYGFkZEVuZExpc3RlbmVyYCBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogWW91IG1heSBzcGVjaWZ5IGEgc2luZ2xlIHRpbWVvdXQgZm9yIGFsbCB0cmFuc2l0aW9uczpcbiAgICpcbiAgICogYGBganN4XG4gICAqIHRpbWVvdXQ9ezUwMH1cbiAgICogYGBgXG4gICAqXG4gICAqIG9yIGluZGl2aWR1YWxseTpcbiAgICpcbiAgICogYGBganN4XG4gICAqIHRpbWVvdXQ9e3tcbiAgICogIGFwcGVhcjogNTAwLFxuICAgKiAgZW50ZXI6IDMwMCxcbiAgICogIGV4aXQ6IDUwMCxcbiAgICogfX1cbiAgICogYGBgXG4gICAqXG4gICAqIC0gYGFwcGVhcmAgZGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIGBlbnRlcmBcbiAgICogLSBgZW50ZXJgIGRlZmF1bHRzIHRvIGAwYFxuICAgKiAtIGBleGl0YCBkZWZhdWx0cyB0byBgMGBcbiAgICpcbiAgICogQHR5cGUge251bWJlciB8IHsgZW50ZXI/OiBudW1iZXIsIGV4aXQ/OiBudW1iZXIsIGFwcGVhcj86IG51bWJlciB9fVxuICAgKi9cbiAgdGltZW91dDogZnVuY3Rpb24gdGltZW91dChwcm9wcykge1xuICAgIHZhciBwdCA9IHRpbWVvdXRzU2hhcGU7XG4gICAgaWYgKCFwcm9wcy5hZGRFbmRMaXN0ZW5lcikgcHQgPSBwdC5pc1JlcXVpcmVkO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHB0LmFwcGx5KHZvaWQgMCwgW3Byb3BzXS5jb25jYXQoYXJncykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgYSBjdXN0b20gdHJhbnNpdGlvbiBlbmQgdHJpZ2dlci4gQ2FsbGVkIHdpdGggdGhlIHRyYW5zaXRpb25pbmdcbiAgICogRE9NIG5vZGUgYW5kIGEgYGRvbmVgIGNhbGxiYWNrLiBBbGxvd3MgZm9yIG1vcmUgZmluZSBncmFpbmVkIHRyYW5zaXRpb24gZW5kXG4gICAqIGxvZ2ljLiBUaW1lb3V0cyBhcmUgc3RpbGwgdXNlZCBhcyBhIGZhbGxiYWNrIGlmIHByb3ZpZGVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogYWRkRW5kTGlzdGVuZXI9eyhub2RlLCBkb25lKSA9PiB7XG4gICAqICAgLy8gdXNlIHRoZSBjc3MgdHJhbnNpdGlvbmVuZCBldmVudCB0byBtYXJrIHRoZSBmaW5pc2ggb2YgYSB0cmFuc2l0aW9uXG4gICAqICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZG9uZSwgZmFsc2UpO1xuICAgKiB9fVxuICAgKiBgYGBcbiAgICovXG4gIGFkZEVuZExpc3RlbmVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHRoZSBcImVudGVyaW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKSAtPiB2b2lkXG4gICAqL1xuICBvbkVudGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZW50ZXJpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyaW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZW50ZXJlZFwiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbCkgLT4gdm9pZFxuICAgKi9cbiAgb25FbnRlcmVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHRoZSBcImV4aXRpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImV4aXRpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdGluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImV4aXRlZFwiIHN0YXR1cyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXRlZDogUHJvcFR5cGVzLmZ1bmNcbn0gOiB7fTsgLy8gTmFtZSB0aGUgZnVuY3Rpb24gc28gaXQgaXMgY2xlYXJlciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuXG5mdW5jdGlvbiBub29wKCkge31cblxuVHJhbnNpdGlvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGluOiBmYWxzZSxcbiAgbW91bnRPbkVudGVyOiBmYWxzZSxcbiAgdW5tb3VudE9uRXhpdDogZmFsc2UsXG4gIGFwcGVhcjogZmFsc2UsXG4gIGVudGVyOiB0cnVlLFxuICBleGl0OiB0cnVlLFxuICBvbkVudGVyOiBub29wLFxuICBvbkVudGVyaW5nOiBub29wLFxuICBvbkVudGVyZWQ6IG5vb3AsXG4gIG9uRXhpdDogbm9vcCxcbiAgb25FeGl0aW5nOiBub29wLFxuICBvbkV4aXRlZDogbm9vcFxufTtcblRyYW5zaXRpb24uVU5NT1VOVEVEID0gVU5NT1VOVEVEO1xuVHJhbnNpdGlvbi5FWElURUQgPSBFWElURUQ7XG5UcmFuc2l0aW9uLkVOVEVSSU5HID0gRU5URVJJTkc7XG5UcmFuc2l0aW9uLkVOVEVSRUQgPSBFTlRFUkVEO1xuVHJhbnNpdGlvbi5FWElUSU5HID0gRVhJVElORztcbmV4cG9ydCBkZWZhdWx0IFRyYW5zaXRpb247IiwiZXhwb3J0IHZhciByZWZsb3cgPSBmdW5jdGlvbiByZWZsb3cobm9kZSkge1xuICByZXR1cm4gbm9kZS5zY3JvbGxUb3A7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zaXRpb25Qcm9wcyhwcm9wcywgb3B0aW9ucykge1xuICB2YXIgdGltZW91dCA9IHByb3BzLnRpbWVvdXQsXG4gICAgICBfcHJvcHMkc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICAgIHN0eWxlID0gX3Byb3BzJHN0eWxlID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRzdHlsZTtcbiAgcmV0dXJuIHtcbiAgICBkdXJhdGlvbjogc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uIHx8IHR5cGVvZiB0aW1lb3V0ID09PSAnbnVtYmVyJyA/IHRpbWVvdXQgOiB0aW1lb3V0W29wdGlvbnMubW9kZV0gfHwgMCxcbiAgICBkZWxheTogc3R5bGUudHJhbnNpdGlvbkRlbGF5XG4gIH07XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAnO1xuaW1wb3J0IHVzZVRoZW1lIGZyb20gJy4uL3N0eWxlcy91c2VUaGVtZSc7XG5pbXBvcnQgeyByZWZsb3csIGdldFRyYW5zaXRpb25Qcm9wcyB9IGZyb20gJy4uL3RyYW5zaXRpb25zL3V0aWxzJztcbmltcG9ydCB1c2VGb3JrUmVmIGZyb20gJy4uL3V0aWxzL3VzZUZvcmtSZWYnO1xuXG5mdW5jdGlvbiBnZXRTY2FsZSh2YWx1ZSkge1xuICByZXR1cm4gXCJzY2FsZShcIi5jb25jYXQodmFsdWUsIFwiLCBcIikuY29uY2F0KE1hdGgucG93KHZhbHVlLCAyKSwgXCIpXCIpO1xufVxuXG52YXIgc3R5bGVzID0ge1xuICBlbnRlcmluZzoge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgdHJhbnNmb3JtOiBnZXRTY2FsZSgxKVxuICB9LFxuICBlbnRlcmVkOiB7XG4gICAgb3BhY2l0eTogMSxcbiAgICB0cmFuc2Zvcm06ICdub25lJ1xuICB9XG59O1xuLyoqXG4gKiBUaGUgR3JvdyB0cmFuc2l0aW9uIGlzIHVzZWQgYnkgdGhlIFtUb29sdGlwXSgvY29tcG9uZW50cy90b29sdGlwcy8pIGFuZFxuICogW1BvcG92ZXJdKC9jb21wb25lbnRzL3BvcG92ZXIvKSBjb21wb25lbnRzLlxuICogSXQgdXNlcyBbcmVhY3QtdHJhbnNpdGlvbi1ncm91cF0oaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cCkgaW50ZXJuYWxseS5cbiAqL1xuXG52YXIgR3JvdyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEdyb3cocHJvcHMsIHJlZikge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIF9wcm9wcyRkaXNhYmxlU3RyaWN0TSA9IHByb3BzLmRpc2FibGVTdHJpY3RNb2RlQ29tcGF0LFxuICAgICAgZGlzYWJsZVN0cmljdE1vZGVDb21wYXQgPSBfcHJvcHMkZGlzYWJsZVN0cmljdE0gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVTdHJpY3RNLFxuICAgICAgaW5Qcm9wID0gcHJvcHMuaW4sXG4gICAgICBvbkVudGVyID0gcHJvcHMub25FbnRlcixcbiAgICAgIG9uRW50ZXJlZCA9IHByb3BzLm9uRW50ZXJlZCxcbiAgICAgIG9uRW50ZXJpbmcgPSBwcm9wcy5vbkVudGVyaW5nLFxuICAgICAgb25FeGl0ID0gcHJvcHMub25FeGl0LFxuICAgICAgb25FeGl0ZWQgPSBwcm9wcy5vbkV4aXRlZCxcbiAgICAgIG9uRXhpdGluZyA9IHByb3BzLm9uRXhpdGluZyxcbiAgICAgIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBfcHJvcHMkdGltZW91dCA9IHByb3BzLnRpbWVvdXQsXG4gICAgICB0aW1lb3V0ID0gX3Byb3BzJHRpbWVvdXQgPT09IHZvaWQgMCA/ICdhdXRvJyA6IF9wcm9wcyR0aW1lb3V0LFxuICAgICAgX3Byb3BzJFRyYW5zaXRpb25Db21wID0gcHJvcHMuVHJhbnNpdGlvbkNvbXBvbmVudCxcbiAgICAgIFRyYW5zaXRpb25Db21wb25lbnQgPSBfcHJvcHMkVHJhbnNpdGlvbkNvbXAgPT09IHZvaWQgMCA/IFRyYW5zaXRpb24gOiBfcHJvcHMkVHJhbnNpdGlvbkNvbXAsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJkaXNhYmxlU3RyaWN0TW9kZUNvbXBhdFwiLCBcImluXCIsIFwib25FbnRlclwiLCBcIm9uRW50ZXJlZFwiLCBcIm9uRW50ZXJpbmdcIiwgXCJvbkV4aXRcIiwgXCJvbkV4aXRlZFwiLCBcIm9uRXhpdGluZ1wiLCBcInN0eWxlXCIsIFwidGltZW91dFwiLCBcIlRyYW5zaXRpb25Db21wb25lbnRcIl0pO1xuXG4gIHZhciB0aW1lciA9IFJlYWN0LnVzZVJlZigpO1xuICB2YXIgYXV0b1RpbWVvdXQgPSBSZWFjdC51c2VSZWYoKTtcbiAgdmFyIHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgdmFyIGVuYWJsZVN0cmljdE1vZGVDb21wYXQgPSB0aGVtZS51bnN0YWJsZV9zdHJpY3RNb2RlICYmICFkaXNhYmxlU3RyaWN0TW9kZUNvbXBhdDtcbiAgdmFyIG5vZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBmb3JlaWduUmVmID0gdXNlRm9ya1JlZihjaGlsZHJlbi5yZWYsIHJlZik7XG4gIHZhciBoYW5kbGVSZWYgPSB1c2VGb3JrUmVmKGVuYWJsZVN0cmljdE1vZGVDb21wYXQgPyBub2RlUmVmIDogdW5kZWZpbmVkLCBmb3JlaWduUmVmKTtcblxuICB2YXIgbm9ybWFsaXplZFRyYW5zaXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uIG5vcm1hbGl6ZWRUcmFuc2l0aW9uQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGVPckFwcGVhcmluZywgbWF5YmVBcHBlYXJpbmcpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3JlZiA9IGVuYWJsZVN0cmljdE1vZGVDb21wYXQgPyBbbm9kZVJlZi5jdXJyZW50LCBub2RlT3JBcHBlYXJpbmddIDogW25vZGVPckFwcGVhcmluZywgbWF5YmVBcHBlYXJpbmddLFxuICAgICAgICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfcmVmMlswXSxcbiAgICAgICAgICAgIGlzQXBwZWFyaW5nID0gX3JlZjJbMV07IC8vIG9uRW50ZXJYeHggYW5kIG9uRXhpdFh4eCBjYWxsYmFja3MgaGF2ZSBhIGRpZmZlcmVudCBhcmd1bWVudHMubGVuZ3RoIHZhbHVlLlxuXG5cbiAgICAgICAgaWYgKGlzQXBwZWFyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhub2RlLCBpc0FwcGVhcmluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBoYW5kbGVFbnRlcmluZyA9IG5vcm1hbGl6ZWRUcmFuc2l0aW9uQ2FsbGJhY2sob25FbnRlcmluZyk7XG4gIHZhciBoYW5kbGVFbnRlciA9IG5vcm1hbGl6ZWRUcmFuc2l0aW9uQ2FsbGJhY2soZnVuY3Rpb24gKG5vZGUsIGlzQXBwZWFyaW5nKSB7XG4gICAgcmVmbG93KG5vZGUpOyAvLyBTbyB0aGUgYW5pbWF0aW9uIGFsd2F5cyBzdGFydCBmcm9tIHRoZSBzdGFydC5cblxuICAgIHZhciBfZ2V0VHJhbnNpdGlvblByb3BzID0gZ2V0VHJhbnNpdGlvblByb3BzKHtcbiAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXRcbiAgICB9LCB7XG4gICAgICBtb2RlOiAnZW50ZXInXG4gICAgfSksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9nZXRUcmFuc2l0aW9uUHJvcHMuZHVyYXRpb24sXG4gICAgICAgIGRlbGF5ID0gX2dldFRyYW5zaXRpb25Qcm9wcy5kZWxheTtcblxuICAgIHZhciBkdXJhdGlvbjtcblxuICAgIGlmICh0aW1lb3V0ID09PSAnYXV0bycpIHtcbiAgICAgIGR1cmF0aW9uID0gdGhlbWUudHJhbnNpdGlvbnMuZ2V0QXV0b0hlaWdodER1cmF0aW9uKG5vZGUuY2xpZW50SGVpZ2h0KTtcbiAgICAgIGF1dG9UaW1lb3V0LmN1cnJlbnQgPSBkdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgfVxuXG4gICAgbm9kZS5zdHlsZS50cmFuc2l0aW9uID0gW3RoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgnb3BhY2l0eScsIHtcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIGRlbGF5OiBkZWxheVxuICAgIH0pLCB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ3RyYW5zZm9ybScsIHtcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAqIDAuNjY2LFxuICAgICAgZGVsYXk6IGRlbGF5XG4gICAgfSldLmpvaW4oJywnKTtcblxuICAgIGlmIChvbkVudGVyKSB7XG4gICAgICBvbkVudGVyKG5vZGUsIGlzQXBwZWFyaW5nKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgaGFuZGxlRW50ZXJlZCA9IG5vcm1hbGl6ZWRUcmFuc2l0aW9uQ2FsbGJhY2sob25FbnRlcmVkKTtcbiAgdmFyIGhhbmRsZUV4aXRpbmcgPSBub3JtYWxpemVkVHJhbnNpdGlvbkNhbGxiYWNrKG9uRXhpdGluZyk7XG4gIHZhciBoYW5kbGVFeGl0ID0gbm9ybWFsaXplZFRyYW5zaXRpb25DYWxsYmFjayhmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBfZ2V0VHJhbnNpdGlvblByb3BzMiA9IGdldFRyYW5zaXRpb25Qcm9wcyh7XG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICB0aW1lb3V0OiB0aW1lb3V0XG4gICAgfSwge1xuICAgICAgbW9kZTogJ2V4aXQnXG4gICAgfSksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9nZXRUcmFuc2l0aW9uUHJvcHMyLmR1cmF0aW9uLFxuICAgICAgICBkZWxheSA9IF9nZXRUcmFuc2l0aW9uUHJvcHMyLmRlbGF5O1xuXG4gICAgdmFyIGR1cmF0aW9uO1xuXG4gICAgaWYgKHRpbWVvdXQgPT09ICdhdXRvJykge1xuICAgICAgZHVyYXRpb24gPSB0aGVtZS50cmFuc2l0aW9ucy5nZXRBdXRvSGVpZ2h0RHVyYXRpb24obm9kZS5jbGllbnRIZWlnaHQpO1xuICAgICAgYXV0b1RpbWVvdXQuY3VycmVudCA9IGR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICB9XG5cbiAgICBub2RlLnN0eWxlLnRyYW5zaXRpb24gPSBbdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCdvcGFjaXR5Jywge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZGVsYXk6IGRlbGF5XG4gICAgfSksIHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgndHJhbnNmb3JtJywge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uICogMC42NjYsXG4gICAgICBkZWxheTogZGVsYXkgfHwgZHVyYXRpb24gKiAwLjMzM1xuICAgIH0pXS5qb2luKCcsJyk7XG4gICAgbm9kZS5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gZ2V0U2NhbGUoMC43NSk7XG5cbiAgICBpZiAob25FeGl0KSB7XG4gICAgICBvbkV4aXQobm9kZSk7XG4gICAgfVxuICB9KTtcbiAgdmFyIGhhbmRsZUV4aXRlZCA9IG5vcm1hbGl6ZWRUcmFuc2l0aW9uQ2FsbGJhY2sob25FeGl0ZWQpO1xuXG4gIHZhciBhZGRFbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEVuZExpc3RlbmVyKG5vZGVPck5leHQsIG1heWJlTmV4dCkge1xuICAgIHZhciBuZXh0ID0gZW5hYmxlU3RyaWN0TW9kZUNvbXBhdCA/IG5vZGVPck5leHQgOiBtYXliZU5leHQ7XG5cbiAgICBpZiAodGltZW91dCA9PT0gJ2F1dG8nKSB7XG4gICAgICB0aW1lci5jdXJyZW50ID0gc2V0VGltZW91dChuZXh0LCBhdXRvVGltZW91dC5jdXJyZW50IHx8IDApO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkNvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGFwcGVhcjogdHJ1ZSxcbiAgICBpbjogaW5Qcm9wLFxuICAgIG5vZGVSZWY6IGVuYWJsZVN0cmljdE1vZGVDb21wYXQgPyBub2RlUmVmIDogdW5kZWZpbmVkLFxuICAgIG9uRW50ZXI6IGhhbmRsZUVudGVyLFxuICAgIG9uRW50ZXJlZDogaGFuZGxlRW50ZXJlZCxcbiAgICBvbkVudGVyaW5nOiBoYW5kbGVFbnRlcmluZyxcbiAgICBvbkV4aXQ6IGhhbmRsZUV4aXQsXG4gICAgb25FeGl0ZWQ6IGhhbmRsZUV4aXRlZCxcbiAgICBvbkV4aXRpbmc6IGhhbmRsZUV4aXRpbmcsXG4gICAgYWRkRW5kTGlzdGVuZXI6IGFkZEVuZExpc3RlbmVyLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQgPT09ICdhdXRvJyA/IG51bGwgOiB0aW1lb3V0XG4gIH0sIG90aGVyKSwgZnVuY3Rpb24gKHN0YXRlLCBjaGlsZFByb3BzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIF9leHRlbmRzKHtcbiAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7XG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHRyYW5zZm9ybTogZ2V0U2NhbGUoMC43NSksXG4gICAgICAgIHZpc2liaWxpdHk6IHN0YXRlID09PSAnZXhpdGVkJyAmJiAhaW5Qcm9wID8gJ2hpZGRlbicgOiB1bmRlZmluZWRcbiAgICAgIH0sIHN0eWxlc1tzdGF0ZV0sIHN0eWxlLCBjaGlsZHJlbi5wcm9wcy5zdHlsZSksXG4gICAgICByZWY6IGhhbmRsZVJlZlxuICAgIH0sIGNoaWxkUHJvcHMpKTtcbiAgfSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IEdyb3cucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQSBzaW5nbGUgY2hpbGQgY29udGVudCBlbGVtZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5lbGVtZW50LFxuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBwcm9wIGlmIHlvdSBlbmNvdW50ZXIgJ0Z1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMnLFxuICAgKiB1c2UgYHVuc3RhYmxlX2NyZWF0ZVN0cmljdE1vZGVUaGVtZWAsXG4gICAqIGFuZCBjYW4ndCBmb3J3YXJkIHRoZSByZWYgaW4gdGhlIGNoaWxkIGNvbXBvbmVudC5cbiAgICovXG4gIGRpc2FibGVTdHJpY3RNb2RlQ29tcGF0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBzaG93IHRoZSBjb21wb25lbnQ7IHRyaWdnZXJzIHRoZSBlbnRlciBvciBleGl0IGFuaW1hdGlvbi5cbiAgICovXG4gIGluOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRW50ZXJlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRW50ZXJpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkV4aXQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkV4aXRlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRXhpdGluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gZm9yIHRoZSB0cmFuc2l0aW9uLCBpbiBtaWxsaXNlY29uZHMuXG4gICAqIFlvdSBtYXkgc3BlY2lmeSBhIHNpbmdsZSB0aW1lb3V0IGZvciBhbGwgdHJhbnNpdGlvbnMsIG9yIGluZGl2aWR1YWxseSB3aXRoIGFuIG9iamVjdC5cbiAgICpcbiAgICogU2V0IHRvICdhdXRvJyB0byBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSB0cmFuc2l0aW9uIHRpbWUgYmFzZWQgb24gaGVpZ2h0LlxuICAgKi9cbiAgdGltZW91dDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9uZU9mKFsnYXV0byddKSwgUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBhcHBlYXI6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgZW50ZXI6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgZXhpdDogUHJvcFR5cGVzLm51bWJlclxuICB9KV0pXG59IDogdm9pZCAwO1xuR3Jvdy5tdWlTdXBwb3J0QXV0byA9IHRydWU7XG5leHBvcnQgZGVmYXVsdCBHcm93OyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgY2hhaW5Qcm9wVHlwZXMsIGVsZW1lbnRUeXBlQWNjZXB0aW5nUmVmLCByZWZUeXBlLCBIVE1MRWxlbWVudFR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJy4uL3V0aWxzL2RlYm91bmNlJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IG93bmVyRG9jdW1lbnQgZnJvbSAnLi4vdXRpbHMvb3duZXJEb2N1bWVudCc7XG5pbXBvcnQgb3duZXJXaW5kb3cgZnJvbSAnLi4vdXRpbHMvb3duZXJXaW5kb3cnO1xuaW1wb3J0IGNyZWF0ZUNoYWluZWRGdW5jdGlvbiBmcm9tICcuLi91dGlscy9jcmVhdGVDaGFpbmVkRnVuY3Rpb24nO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IE1vZGFsIGZyb20gJy4uL01vZGFsJztcbmltcG9ydCBHcm93IGZyb20gJy4uL0dyb3cnO1xuaW1wb3J0IFBhcGVyIGZyb20gJy4uL1BhcGVyJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRPZmZzZXRUb3AocmVjdCwgdmVydGljYWwpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgaWYgKHR5cGVvZiB2ZXJ0aWNhbCA9PT0gJ251bWJlcicpIHtcbiAgICBvZmZzZXQgPSB2ZXJ0aWNhbDtcbiAgfSBlbHNlIGlmICh2ZXJ0aWNhbCA9PT0gJ2NlbnRlcicpIHtcbiAgICBvZmZzZXQgPSByZWN0LmhlaWdodCAvIDI7XG4gIH0gZWxzZSBpZiAodmVydGljYWwgPT09ICdib3R0b20nKSB7XG4gICAgb2Zmc2V0ID0gcmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE9mZnNldExlZnQocmVjdCwgaG9yaXpvbnRhbCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcblxuICBpZiAodHlwZW9mIGhvcml6b250YWwgPT09ICdudW1iZXInKSB7XG4gICAgb2Zmc2V0ID0gaG9yaXpvbnRhbDtcbiAgfSBlbHNlIGlmIChob3Jpem9udGFsID09PSAnY2VudGVyJykge1xuICAgIG9mZnNldCA9IHJlY3Qud2lkdGggLyAyO1xuICB9IGVsc2UgaWYgKGhvcml6b250YWwgPT09ICdyaWdodCcpIHtcbiAgICBvZmZzZXQgPSByZWN0LndpZHRoO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtT3JpZ2luVmFsdWUodHJhbnNmb3JtT3JpZ2luKSB7XG4gIHJldHVybiBbdHJhbnNmb3JtT3JpZ2luLmhvcml6b250YWwsIHRyYW5zZm9ybU9yaWdpbi52ZXJ0aWNhbF0ubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJyA/IFwiXCIuY29uY2F0KG4sIFwicHhcIikgOiBuO1xuICB9KS5qb2luKCcgJyk7XG59IC8vIFN1bSB0aGUgc2Nyb2xsVG9wIGJldHdlZW4gdHdvIGVsZW1lbnRzLlxuXG5cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciBlbGVtZW50ID0gY2hpbGQ7XG4gIHZhciBzY3JvbGxUb3AgPSAwO1xuXG4gIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQgIT09IHBhcmVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgc2Nyb2xsVG9wICs9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9XG5cbiAgcmV0dXJuIHNjcm9sbFRvcDtcbn1cblxuZnVuY3Rpb24gZ2V0QW5jaG9yRWwoYW5jaG9yRWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBhbmNob3JFbCA9PT0gJ2Z1bmN0aW9uJyA/IGFuY2hvckVsKCkgOiBhbmNob3JFbDtcbn1cblxuZXhwb3J0IHZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gIHJvb3Q6IHt9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgUGFwZXJgIGNvbXBvbmVudC4gKi9cbiAgcGFwZXI6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBvdmVyZmxvd1k6ICdhdXRvJyxcbiAgICBvdmVyZmxvd1g6ICdoaWRkZW4nLFxuICAgIC8vIFNvIHdlIHNlZSB0aGUgcG9wb3ZlciB3aGVuIGl0J3MgZW1wdHkuXG4gICAgLy8gSXQncyBtb3N0IGxpa2VseSBvbiBpc3N1ZSBvbiB1c2VybGFuZC5cbiAgICBtaW5XaWR0aDogMTYsXG4gICAgbWluSGVpZ2h0OiAxNixcbiAgICBtYXhXaWR0aDogJ2NhbGMoMTAwJSAtIDMycHgpJyxcbiAgICBtYXhIZWlnaHQ6ICdjYWxjKDEwMCUgLSAzMnB4KScsXG4gICAgLy8gV2UgZGlzYWJsZSB0aGUgZm9jdXMgcmluZyBmb3IgbW91c2UsIHRvdWNoIGFuZCBrZXlib2FyZCB1c2Vycy5cbiAgICBvdXRsaW5lOiAwXG4gIH1cbn07XG52YXIgUG9wb3ZlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFBvcG92ZXIocHJvcHMsIHJlZikge1xuICB2YXIgYWN0aW9uID0gcHJvcHMuYWN0aW9uLFxuICAgICAgYW5jaG9yRWwgPSBwcm9wcy5hbmNob3JFbCxcbiAgICAgIF9wcm9wcyRhbmNob3JPcmlnaW4gPSBwcm9wcy5hbmNob3JPcmlnaW4sXG4gICAgICBhbmNob3JPcmlnaW4gPSBfcHJvcHMkYW5jaG9yT3JpZ2luID09PSB2b2lkIDAgPyB7XG4gICAgdmVydGljYWw6ICd0b3AnLFxuICAgIGhvcml6b250YWw6ICdsZWZ0J1xuICB9IDogX3Byb3BzJGFuY2hvck9yaWdpbixcbiAgICAgIGFuY2hvclBvc2l0aW9uID0gcHJvcHMuYW5jaG9yUG9zaXRpb24sXG4gICAgICBfcHJvcHMkYW5jaG9yUmVmZXJlbmMgPSBwcm9wcy5hbmNob3JSZWZlcmVuY2UsXG4gICAgICBhbmNob3JSZWZlcmVuY2UgPSBfcHJvcHMkYW5jaG9yUmVmZXJlbmMgPT09IHZvaWQgMCA/ICdhbmNob3JFbCcgOiBfcHJvcHMkYW5jaG9yUmVmZXJlbmMsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjb250YWluZXJQcm9wID0gcHJvcHMuY29udGFpbmVyLFxuICAgICAgX3Byb3BzJGVsZXZhdGlvbiA9IHByb3BzLmVsZXZhdGlvbixcbiAgICAgIGVsZXZhdGlvbiA9IF9wcm9wcyRlbGV2YXRpb24gPT09IHZvaWQgMCA/IDggOiBfcHJvcHMkZWxldmF0aW9uLFxuICAgICAgZ2V0Q29udGVudEFuY2hvckVsID0gcHJvcHMuZ2V0Q29udGVudEFuY2hvckVsLFxuICAgICAgX3Byb3BzJG1hcmdpblRocmVzaG9sID0gcHJvcHMubWFyZ2luVGhyZXNob2xkLFxuICAgICAgbWFyZ2luVGhyZXNob2xkID0gX3Byb3BzJG1hcmdpblRocmVzaG9sID09PSB2b2lkIDAgPyAxNiA6IF9wcm9wcyRtYXJnaW5UaHJlc2hvbCxcbiAgICAgIG9uRW50ZXIgPSBwcm9wcy5vbkVudGVyLFxuICAgICAgb25FbnRlcmVkID0gcHJvcHMub25FbnRlcmVkLFxuICAgICAgb25FbnRlcmluZyA9IHByb3BzLm9uRW50ZXJpbmcsXG4gICAgICBvbkV4aXQgPSBwcm9wcy5vbkV4aXQsXG4gICAgICBvbkV4aXRlZCA9IHByb3BzLm9uRXhpdGVkLFxuICAgICAgb25FeGl0aW5nID0gcHJvcHMub25FeGl0aW5nLFxuICAgICAgb3BlbiA9IHByb3BzLm9wZW4sXG4gICAgICBfcHJvcHMkUGFwZXJQcm9wcyA9IHByb3BzLlBhcGVyUHJvcHMsXG4gICAgICBQYXBlclByb3BzID0gX3Byb3BzJFBhcGVyUHJvcHMgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJFBhcGVyUHJvcHMsXG4gICAgICBfcHJvcHMkdHJhbnNmb3JtT3JpZ2kgPSBwcm9wcy50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICB0cmFuc2Zvcm1PcmlnaW4gPSBfcHJvcHMkdHJhbnNmb3JtT3JpZ2kgPT09IHZvaWQgMCA/IHtcbiAgICB2ZXJ0aWNhbDogJ3RvcCcsXG4gICAgaG9yaXpvbnRhbDogJ2xlZnQnXG4gIH0gOiBfcHJvcHMkdHJhbnNmb3JtT3JpZ2ksXG4gICAgICBfcHJvcHMkVHJhbnNpdGlvbkNvbXAgPSBwcm9wcy5UcmFuc2l0aW9uQ29tcG9uZW50LFxuICAgICAgVHJhbnNpdGlvbkNvbXBvbmVudCA9IF9wcm9wcyRUcmFuc2l0aW9uQ29tcCA9PT0gdm9pZCAwID8gR3JvdyA6IF9wcm9wcyRUcmFuc2l0aW9uQ29tcCxcbiAgICAgIF9wcm9wcyR0cmFuc2l0aW9uRHVyYSA9IHByb3BzLnRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvblByb3AgPSBfcHJvcHMkdHJhbnNpdGlvbkR1cmEgPT09IHZvaWQgMCA/ICdhdXRvJyA6IF9wcm9wcyR0cmFuc2l0aW9uRHVyYSxcbiAgICAgIF9wcm9wcyRUcmFuc2l0aW9uUHJvcCA9IHByb3BzLlRyYW5zaXRpb25Qcm9wcyxcbiAgICAgIFRyYW5zaXRpb25Qcm9wcyA9IF9wcm9wcyRUcmFuc2l0aW9uUHJvcCA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkVHJhbnNpdGlvblByb3AsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYWN0aW9uXCIsIFwiYW5jaG9yRWxcIiwgXCJhbmNob3JPcmlnaW5cIiwgXCJhbmNob3JQb3NpdGlvblwiLCBcImFuY2hvclJlZmVyZW5jZVwiLCBcImNoaWxkcmVuXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNvbnRhaW5lclwiLCBcImVsZXZhdGlvblwiLCBcImdldENvbnRlbnRBbmNob3JFbFwiLCBcIm1hcmdpblRocmVzaG9sZFwiLCBcIm9uRW50ZXJcIiwgXCJvbkVudGVyZWRcIiwgXCJvbkVudGVyaW5nXCIsIFwib25FeGl0XCIsIFwib25FeGl0ZWRcIiwgXCJvbkV4aXRpbmdcIiwgXCJvcGVuXCIsIFwiUGFwZXJQcm9wc1wiLCBcInRyYW5zZm9ybU9yaWdpblwiLCBcIlRyYW5zaXRpb25Db21wb25lbnRcIiwgXCJ0cmFuc2l0aW9uRHVyYXRpb25cIiwgXCJUcmFuc2l0aW9uUHJvcHNcIl0pO1xuXG4gIHZhciBwYXBlclJlZiA9IFJlYWN0LnVzZVJlZigpOyAvLyBSZXR1cm5zIHRoZSB0b3AvbGVmdCBvZmZzZXQgb2YgdGhlIHBvc2l0aW9uXG4gIC8vIHRvIGF0dGFjaCB0byBvbiB0aGUgYW5jaG9yIGVsZW1lbnQgKG9yIGJvZHkgaWYgbm9uZSBpcyBwcm92aWRlZClcblxuICB2YXIgZ2V0QW5jaG9yT2Zmc2V0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbnRlbnRBbmNob3JPZmZzZXQpIHtcbiAgICBpZiAoYW5jaG9yUmVmZXJlbmNlID09PSAnYW5jaG9yUG9zaXRpb24nKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIWFuY2hvclBvc2l0aW9uKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IFlvdSBuZWVkIHRvIHByb3ZpZGUgYSBgYW5jaG9yUG9zaXRpb25gIHByb3Agd2hlbiB1c2luZyAnICsgJzxQb3BvdmVyIGFuY2hvclJlZmVyZW5jZT1cImFuY2hvclBvc2l0aW9uXCIgLz4uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFuY2hvclBvc2l0aW9uO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlZEFuY2hvckVsID0gZ2V0QW5jaG9yRWwoYW5jaG9yRWwpOyAvLyBJZiBhbiBhbmNob3IgZWxlbWVudCB3YXNuJ3QgcHJvdmlkZWQsIGp1c3QgdXNlIHRoZSBwYXJlbnQgYm9keSBlbGVtZW50IG9mIHRoaXMgUG9wb3ZlclxuXG4gICAgdmFyIGFuY2hvckVsZW1lbnQgPSByZXNvbHZlZEFuY2hvckVsICYmIHJlc29sdmVkQW5jaG9yRWwubm9kZVR5cGUgPT09IDEgPyByZXNvbHZlZEFuY2hvckVsIDogb3duZXJEb2N1bWVudChwYXBlclJlZi5jdXJyZW50KS5ib2R5O1xuICAgIHZhciBhbmNob3JSZWN0ID0gYW5jaG9yRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgYm94ID0gYW5jaG9yRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgYm94LnRvcCA9PT0gMCAmJiBib3gubGVmdCA9PT0gMCAmJiBib3gucmlnaHQgPT09IDAgJiYgYm94LmJvdHRvbSA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oWydNYXRlcmlhbC1VSTogVGhlIGBhbmNob3JFbGAgcHJvcCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGlzIGludmFsaWQuJywgJ1RoZSBhbmNob3IgZWxlbWVudCBzaG91bGQgYmUgcGFydCBvZiB0aGUgZG9jdW1lbnQgbGF5b3V0LicsIFwiTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHByZXNlbnQgaW4gdGhlIGRvY3VtZW50IG9yIHRoYXQgaXQncyBub3QgZGlzcGxheSBub25lLlwiXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFuY2hvclZlcnRpY2FsID0gY29udGVudEFuY2hvck9mZnNldCA9PT0gMCA/IGFuY2hvck9yaWdpbi52ZXJ0aWNhbCA6ICdjZW50ZXInO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IGFuY2hvclJlY3QudG9wICsgZ2V0T2Zmc2V0VG9wKGFuY2hvclJlY3QsIGFuY2hvclZlcnRpY2FsKSxcbiAgICAgIGxlZnQ6IGFuY2hvclJlY3QubGVmdCArIGdldE9mZnNldExlZnQoYW5jaG9yUmVjdCwgYW5jaG9yT3JpZ2luLmhvcml6b250YWwpXG4gICAgfTtcbiAgfSwgW2FuY2hvckVsLCBhbmNob3JPcmlnaW4uaG9yaXpvbnRhbCwgYW5jaG9yT3JpZ2luLnZlcnRpY2FsLCBhbmNob3JQb3NpdGlvbiwgYW5jaG9yUmVmZXJlbmNlXSk7IC8vIFJldHVybnMgdGhlIHZlcnRpY2FsIG9mZnNldCBvZiBpbm5lciBjb250ZW50IHRvIGFuY2hvciB0aGUgdHJhbnNmb3JtIG9uIGlmIHByb3ZpZGVkXG5cbiAgdmFyIGdldENvbnRlbnRBbmNob3JPZmZzZXQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBjb250ZW50QW5jaG9yT2Zmc2V0ID0gMDtcblxuICAgIGlmIChnZXRDb250ZW50QW5jaG9yRWwgJiYgYW5jaG9yUmVmZXJlbmNlID09PSAnYW5jaG9yRWwnKSB7XG4gICAgICB2YXIgY29udGVudEFuY2hvckVsID0gZ2V0Q29udGVudEFuY2hvckVsKGVsZW1lbnQpO1xuXG4gICAgICBpZiAoY29udGVudEFuY2hvckVsICYmIGVsZW1lbnQuY29udGFpbnMoY29udGVudEFuY2hvckVsKSkge1xuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQsIGNvbnRlbnRBbmNob3JFbCk7XG4gICAgICAgIGNvbnRlbnRBbmNob3JPZmZzZXQgPSBjb250ZW50QW5jaG9yRWwub2Zmc2V0VG9wICsgY29udGVudEFuY2hvckVsLmNsaWVudEhlaWdodCAvIDIgLSBzY3JvbGxUb3AgfHwgMDtcbiAgICAgIH0gLy8gIT0gdGhlIGRlZmF1bHQgdmFsdWVcblxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYW5jaG9yT3JpZ2luLnZlcnRpY2FsICE9PSAndG9wJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoWydNYXRlcmlhbC1VSTogWW91IGNhbiBub3QgY2hhbmdlIHRoZSBkZWZhdWx0IGBhbmNob3JPcmlnaW4udmVydGljYWxgIHZhbHVlICcsICd3aGVuIGFsc28gcHJvdmlkaW5nIHRoZSBgZ2V0Q29udGVudEFuY2hvckVsYCBwcm9wIHRvIHRoZSBwb3BvdmVyIGNvbXBvbmVudC4nLCAnT25seSB1c2Ugb25lIG9mIHRoZSB0d28gcHJvcHMuJywgJ1NldCBgZ2V0Q29udGVudEFuY2hvckVsYCB0byBgbnVsbCB8IHVuZGVmaW5lZGAnICsgJyBvciBsZWF2ZSBgYW5jaG9yT3JpZ2luLnZlcnRpY2FsYCB1bmNoYW5nZWQuJ10uam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnRBbmNob3JPZmZzZXQ7XG4gIH0sIFthbmNob3JPcmlnaW4udmVydGljYWwsIGFuY2hvclJlZmVyZW5jZSwgZ2V0Q29udGVudEFuY2hvckVsXSk7IC8vIFJldHVybiB0aGUgYmFzZSB0cmFuc2Zvcm0gb3JpZ2luIHVzaW5nIHRoZSBlbGVtZW50XG4gIC8vIGFuZCB0YWtpbmcgdGhlIGNvbnRlbnQgYW5jaG9yIG9mZnNldCBpbnRvIGFjY291bnQgaWYgaW4gdXNlXG5cbiAgdmFyIGdldFRyYW5zZm9ybU9yaWdpbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlbGVtUmVjdCkge1xuICAgIHZhciBjb250ZW50QW5jaG9yT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0aWNhbDogZ2V0T2Zmc2V0VG9wKGVsZW1SZWN0LCB0cmFuc2Zvcm1PcmlnaW4udmVydGljYWwpICsgY29udGVudEFuY2hvck9mZnNldCxcbiAgICAgIGhvcml6b250YWw6IGdldE9mZnNldExlZnQoZWxlbVJlY3QsIHRyYW5zZm9ybU9yaWdpbi5ob3Jpem9udGFsKVxuICAgIH07XG4gIH0sIFt0cmFuc2Zvcm1PcmlnaW4uaG9yaXpvbnRhbCwgdHJhbnNmb3JtT3JpZ2luLnZlcnRpY2FsXSk7XG4gIHZhciBnZXRQb3NpdGlvbmluZ1N0eWxlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgcGFyZW50IGhhcyByZXF1ZXN0ZWQgYW5jaG9yaW5nIG9uIGFuIGlubmVyIGNvbnRlbnQgbm9kZVxuICAgIHZhciBjb250ZW50QW5jaG9yT2Zmc2V0ID0gZ2V0Q29udGVudEFuY2hvck9mZnNldChlbGVtZW50KTtcbiAgICB2YXIgZWxlbVJlY3QgPSB7XG4gICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICB9OyAvLyBHZXQgdGhlIHRyYW5zZm9ybSBvcmlnaW4gcG9pbnQgb24gdGhlIGVsZW1lbnQgaXRzZWxmXG5cbiAgICB2YXIgZWxlbVRyYW5zZm9ybU9yaWdpbiA9IGdldFRyYW5zZm9ybU9yaWdpbihlbGVtUmVjdCwgY29udGVudEFuY2hvck9mZnNldCk7XG5cbiAgICBpZiAoYW5jaG9yUmVmZXJlbmNlID09PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogbnVsbCxcbiAgICAgICAgbGVmdDogbnVsbCxcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBnZXRUcmFuc2Zvcm1PcmlnaW5WYWx1ZShlbGVtVHJhbnNmb3JtT3JpZ2luKVxuICAgICAgfTtcbiAgICB9IC8vIEdldCB0aGUgb2Zmc2V0IG9mIG9mIHRoZSBhbmNob3JpbmcgZWxlbWVudFxuXG5cbiAgICB2YXIgYW5jaG9yT2Zmc2V0ID0gZ2V0QW5jaG9yT2Zmc2V0KGNvbnRlbnRBbmNob3JPZmZzZXQpOyAvLyBDYWxjdWxhdGUgZWxlbWVudCBwb3NpdGlvbmluZ1xuXG4gICAgdmFyIHRvcCA9IGFuY2hvck9mZnNldC50b3AgLSBlbGVtVHJhbnNmb3JtT3JpZ2luLnZlcnRpY2FsO1xuICAgIHZhciBsZWZ0ID0gYW5jaG9yT2Zmc2V0LmxlZnQgLSBlbGVtVHJhbnNmb3JtT3JpZ2luLmhvcml6b250YWw7XG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIGVsZW1SZWN0LmhlaWdodDtcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgZWxlbVJlY3Qud2lkdGg7IC8vIFVzZSB0aGUgcGFyZW50IHdpbmRvdyBvZiB0aGUgYW5jaG9yRWwgaWYgcHJvdmlkZWRcblxuICAgIHZhciBjb250YWluZXJXaW5kb3cgPSBvd25lcldpbmRvdyhnZXRBbmNob3JFbChhbmNob3JFbCkpOyAvLyBXaW5kb3cgdGhyZXNob2xkcyB0YWtpbmcgcmVxdWlyZWQgbWFyZ2luIGludG8gYWNjb3VudFxuXG4gICAgdmFyIGhlaWdodFRocmVzaG9sZCA9IGNvbnRhaW5lcldpbmRvdy5pbm5lckhlaWdodCAtIG1hcmdpblRocmVzaG9sZDtcbiAgICB2YXIgd2lkdGhUaHJlc2hvbGQgPSBjb250YWluZXJXaW5kb3cuaW5uZXJXaWR0aCAtIG1hcmdpblRocmVzaG9sZDsgLy8gQ2hlY2sgaWYgdGhlIHZlcnRpY2FsIGF4aXMgbmVlZHMgc2hpZnRpbmdcblxuICAgIGlmICh0b3AgPCBtYXJnaW5UaHJlc2hvbGQpIHtcbiAgICAgIHZhciBkaWZmID0gdG9wIC0gbWFyZ2luVGhyZXNob2xkO1xuICAgICAgdG9wIC09IGRpZmY7XG4gICAgICBlbGVtVHJhbnNmb3JtT3JpZ2luLnZlcnRpY2FsICs9IGRpZmY7XG4gICAgfSBlbHNlIGlmIChib3R0b20gPiBoZWlnaHRUaHJlc2hvbGQpIHtcbiAgICAgIHZhciBfZGlmZiA9IGJvdHRvbSAtIGhlaWdodFRocmVzaG9sZDtcblxuICAgICAgdG9wIC09IF9kaWZmO1xuICAgICAgZWxlbVRyYW5zZm9ybU9yaWdpbi52ZXJ0aWNhbCArPSBfZGlmZjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGVsZW1SZWN0LmhlaWdodCA+IGhlaWdodFRocmVzaG9sZCAmJiBlbGVtUmVjdC5oZWlnaHQgJiYgaGVpZ2h0VGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoWydNYXRlcmlhbC1VSTogVGhlIHBvcG92ZXIgY29tcG9uZW50IGlzIHRvbyB0YWxsLicsIFwiU29tZSBwYXJ0IG9mIGl0IGNhbiBub3QgYmUgc2VlbiBvbiB0aGUgc2NyZWVuIChcIi5jb25jYXQoZWxlbVJlY3QuaGVpZ2h0IC0gaGVpZ2h0VGhyZXNob2xkLCBcInB4KS5cIiksICdQbGVhc2UgY29uc2lkZXIgYWRkaW5nIGEgYG1heC1oZWlnaHRgIHRvIGltcHJvdmUgdGhlIHVzZXItZXhwZXJpZW5jZS4nXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfSAvLyBDaGVjayBpZiB0aGUgaG9yaXpvbnRhbCBheGlzIG5lZWRzIHNoaWZ0aW5nXG5cblxuICAgIGlmIChsZWZ0IDwgbWFyZ2luVGhyZXNob2xkKSB7XG4gICAgICB2YXIgX2RpZmYyID0gbGVmdCAtIG1hcmdpblRocmVzaG9sZDtcblxuICAgICAgbGVmdCAtPSBfZGlmZjI7XG4gICAgICBlbGVtVHJhbnNmb3JtT3JpZ2luLmhvcml6b250YWwgKz0gX2RpZmYyO1xuICAgIH0gZWxzZSBpZiAocmlnaHQgPiB3aWR0aFRocmVzaG9sZCkge1xuICAgICAgdmFyIF9kaWZmMyA9IHJpZ2h0IC0gd2lkdGhUaHJlc2hvbGQ7XG5cbiAgICAgIGxlZnQgLT0gX2RpZmYzO1xuICAgICAgZWxlbVRyYW5zZm9ybU9yaWdpbi5ob3Jpem9udGFsICs9IF9kaWZmMztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBcIlwiLmNvbmNhdChNYXRoLnJvdW5kKHRvcCksIFwicHhcIiksXG4gICAgICBsZWZ0OiBcIlwiLmNvbmNhdChNYXRoLnJvdW5kKGxlZnQpLCBcInB4XCIpLFxuICAgICAgdHJhbnNmb3JtT3JpZ2luOiBnZXRUcmFuc2Zvcm1PcmlnaW5WYWx1ZShlbGVtVHJhbnNmb3JtT3JpZ2luKVxuICAgIH07XG4gIH0sIFthbmNob3JFbCwgYW5jaG9yUmVmZXJlbmNlLCBnZXRBbmNob3JPZmZzZXQsIGdldENvbnRlbnRBbmNob3JPZmZzZXQsIGdldFRyYW5zZm9ybU9yaWdpbiwgbWFyZ2luVGhyZXNob2xkXSk7XG4gIHZhciBzZXRQb3NpdGlvbmluZ1N0eWxlcyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudCA9IHBhcGVyUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb25pbmcgPSBnZXRQb3NpdGlvbmluZ1N0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKHBvc2l0aW9uaW5nLnRvcCAhPT0gbnVsbCkge1xuICAgICAgZWxlbWVudC5zdHlsZS50b3AgPSBwb3NpdGlvbmluZy50b3A7XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uaW5nLmxlZnQgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IHBvc2l0aW9uaW5nLmxlZnQ7XG4gICAgfVxuXG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBwb3NpdGlvbmluZy50cmFuc2Zvcm1PcmlnaW47XG4gIH0sIFtnZXRQb3NpdGlvbmluZ1N0eWxlXSk7XG5cbiAgdmFyIGhhbmRsZUVudGVyaW5nID0gZnVuY3Rpb24gaGFuZGxlRW50ZXJpbmcoZWxlbWVudCwgaXNBcHBlYXJpbmcpIHtcbiAgICBpZiAob25FbnRlcmluZykge1xuICAgICAgb25FbnRlcmluZyhlbGVtZW50LCBpc0FwcGVhcmluZyk7XG4gICAgfVxuXG4gICAgc2V0UG9zaXRpb25pbmdTdHlsZXMoKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUGFwZXJSZWYgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAvLyAjU3RyaWN0TW9kZSByZWFkeVxuICAgIHBhcGVyUmVmLmN1cnJlbnQgPSBSZWFjdERPTS5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAob3Blbikge1xuICAgICAgc2V0UG9zaXRpb25pbmdTdHlsZXMoKTtcbiAgICB9XG4gIH0pO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGFjdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvcGVuID8ge1xuICAgICAgdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgICBzZXRQb3NpdGlvbmluZ1N0eWxlcygpO1xuICAgICAgfVxuICAgIH0gOiBudWxsO1xuICB9LCBbb3Blbiwgc2V0UG9zaXRpb25pbmdTdHlsZXNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVJlc2l6ZSA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFBvc2l0aW9uaW5nU3R5bGVzKCk7XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGhhbmRsZVJlc2l6ZS5jbGVhcigpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgfTtcbiAgfSwgW29wZW4sIHNldFBvc2l0aW9uaW5nU3R5bGVzXSk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb25Qcm9wO1xuXG4gIGlmICh0cmFuc2l0aW9uRHVyYXRpb25Qcm9wID09PSAnYXV0bycgJiYgIVRyYW5zaXRpb25Db21wb25lbnQubXVpU3VwcG9ydEF1dG8pIHtcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSB1bmRlZmluZWQ7XG4gIH0gLy8gSWYgdGhlIGNvbnRhaW5lciBwcm9wIGlzIHByb3ZpZGVkLCB1c2UgdGhhdFxuICAvLyBJZiB0aGUgYW5jaG9yRWwgcHJvcCBpcyBwcm92aWRlZCwgdXNlIGl0cyBwYXJlbnQgYm9keSBlbGVtZW50IGFzIHRoZSBjb250YWluZXJcbiAgLy8gSWYgbmVpdGhlciBhcmUgcHJvdmlkZWQgbGV0IHRoZSBNb2RhbCB0YWtlIGNhcmUgb2YgY2hvb3NpbmcgdGhlIGNvbnRhaW5lclxuXG5cbiAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lclByb3AgfHwgKGFuY2hvckVsID8gb3duZXJEb2N1bWVudChnZXRBbmNob3JFbChhbmNob3JFbCkpLmJvZHkgOiB1bmRlZmluZWQpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTW9kYWwsIF9leHRlbmRzKHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBvcGVuOiBvcGVuLFxuICAgIHJlZjogcmVmLFxuICAgIEJhY2tkcm9wUHJvcHM6IHtcbiAgICAgIGludmlzaWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lKVxuICB9LCBvdGhlciksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25Db21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBhcHBlYXI6IHRydWUsXG4gICAgaW46IG9wZW4sXG4gICAgb25FbnRlcjogb25FbnRlcixcbiAgICBvbkVudGVyZWQ6IG9uRW50ZXJlZCxcbiAgICBvbkV4aXQ6IG9uRXhpdCxcbiAgICBvbkV4aXRlZDogb25FeGl0ZWQsXG4gICAgb25FeGl0aW5nOiBvbkV4aXRpbmcsXG4gICAgdGltZW91dDogdHJhbnNpdGlvbkR1cmF0aW9uXG4gIH0sIFRyYW5zaXRpb25Qcm9wcywge1xuICAgIG9uRW50ZXJpbmc6IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihoYW5kbGVFbnRlcmluZywgVHJhbnNpdGlvblByb3BzLm9uRW50ZXJpbmcpXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQYXBlciwgX2V4dGVuZHMoe1xuICAgIGVsZXZhdGlvbjogZWxldmF0aW9uLFxuICAgIHJlZjogaGFuZGxlUGFwZXJSZWZcbiAgfSwgUGFwZXJQcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnBhcGVyLCBQYXBlclByb3BzLmNsYXNzTmFtZSlcbiAgfSksIGNoaWxkcmVuKSkpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBQb3BvdmVyLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEEgcmVmIGZvciBpbXBlcmF0aXZlIGFjdGlvbnMuXG4gICAqIEl0IGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHVwZGF0ZVBvc2l0aW9uKCkgYWN0aW9uLlxuICAgKi9cbiAgYWN0aW9uOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBBIEhUTUwgZWxlbWVudCwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgaXQuXG4gICAqIEl0J3MgdXNlZCB0byBzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyLlxuICAgKi9cbiAgYW5jaG9yRWw6IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5vbmVPZlR5cGUoW0hUTUxFbGVtZW50VHlwZSwgUHJvcFR5cGVzLmZ1bmNdKSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLm9wZW4gJiYgKCFwcm9wcy5hbmNob3JSZWZlcmVuY2UgfHwgcHJvcHMuYW5jaG9yUmVmZXJlbmNlID09PSAnYW5jaG9yRWwnKSkge1xuICAgICAgdmFyIHJlc29sdmVkQW5jaG9yRWwgPSBnZXRBbmNob3JFbChwcm9wcy5hbmNob3JFbCk7XG5cbiAgICAgIGlmIChyZXNvbHZlZEFuY2hvckVsICYmIHJlc29sdmVkQW5jaG9yRWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgdmFyIGJveCA9IHJlc29sdmVkQW5jaG9yRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgYm94LnRvcCA9PT0gMCAmJiBib3gubGVmdCA9PT0gMCAmJiBib3gucmlnaHQgPT09IDAgJiYgYm94LmJvdHRvbSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoWydNYXRlcmlhbC1VSTogVGhlIGBhbmNob3JFbGAgcHJvcCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGlzIGludmFsaWQuJywgJ1RoZSBhbmNob3IgZWxlbWVudCBzaG91bGQgYmUgcGFydCBvZiB0aGUgZG9jdW1lbnQgbGF5b3V0LicsIFwiTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHByZXNlbnQgaW4gdGhlIGRvY3VtZW50IG9yIHRoYXQgaXQncyBub3QgZGlzcGxheSBub25lLlwiXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoWydNYXRlcmlhbC1VSTogVGhlIGBhbmNob3JFbGAgcHJvcCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGlzIGludmFsaWQuJywgXCJJdCBzaG91bGQgYmUgYW4gRWxlbWVudCBpbnN0YW5jZSBidXQgaXQncyBgXCIuY29uY2F0KHJlc29sdmVkQW5jaG9yRWwsIFwiYCBpbnN0ZWFkLlwiKV0uam9pbignXFxuJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9KSxcblxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcG9pbnQgb24gdGhlIGFuY2hvciB3aGVyZSB0aGUgcG9wb3ZlcidzXG4gICAqIGBhbmNob3JFbGAgd2lsbCBhdHRhY2ggdG8uIFRoaXMgaXMgbm90IHVzZWQgd2hlbiB0aGVcbiAgICogYW5jaG9yUmVmZXJlbmNlIGlzICdhbmNob3JQb3NpdGlvbicuXG4gICAqXG4gICAqIE9wdGlvbnM6XG4gICAqIHZlcnRpY2FsOiBbdG9wLCBjZW50ZXIsIGJvdHRvbV07XG4gICAqIGhvcml6b250YWw6IFtsZWZ0LCBjZW50ZXIsIHJpZ2h0XS5cbiAgICovXG4gIGFuY2hvck9yaWdpbjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBob3Jpem9udGFsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydjZW50ZXInLCAnbGVmdCcsICdyaWdodCddKSwgUHJvcFR5cGVzLm51bWJlcl0pLmlzUmVxdWlyZWQsXG4gICAgdmVydGljYWw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ2JvdHRvbScsICdjZW50ZXInLCAndG9wJ10pLCBQcm9wVHlwZXMubnVtYmVyXSkuaXNSZXF1aXJlZFxuICB9KSxcblxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcG9zaXRpb24gdGhhdCBtYXkgYmUgdXNlZFxuICAgKiB0byBzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyLlxuICAgKiBUaGUgY29vcmRpbmF0ZXMgYXJlIHJlbGF0aXZlIHRvXG4gICAqIHRoZSBhcHBsaWNhdGlvbidzIGNsaWVudCBhcmVhLlxuICAgKi9cbiAgYW5jaG9yUG9zaXRpb246IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgbGVmdDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHRvcDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gIH0pLFxuXG4gIC8qKlxuICAgKiBUaGlzIGRldGVybWluZXMgd2hpY2ggYW5jaG9yIHByb3AgdG8gcmVmZXIgdG8gdG8gc2V0XG4gICAqIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wb3Zlci5cbiAgICovXG4gIGFuY2hvclJlZmVyZW5jZTogUHJvcFR5cGVzLm9uZU9mKFsnYW5jaG9yRWwnLCAnYW5jaG9yUG9zaXRpb24nLCAnbm9uZSddKSxcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEEgSFRNTCBlbGVtZW50LCBjb21wb25lbnQgaW5zdGFuY2UsIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlaXRoZXIuXG4gICAqIFRoZSBgY29udGFpbmVyYCB3aWxsIHBhc3NlZCB0byB0aGUgTW9kYWwgY29tcG9uZW50LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpdCB1c2VzIHRoZSBib2R5IG9mIHRoZSBhbmNob3JFbCdzIHRvcC1sZXZlbCBkb2N1bWVudCBvYmplY3QsXG4gICAqIHNvIGl0J3Mgc2ltcGx5IGBkb2N1bWVudC5ib2R5YCBtb3N0IG9mIHRoZSB0aW1lLlxuICAgKi9cbiAgY29udGFpbmVyOiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAub25lT2ZUeXBlKFtIVE1MRWxlbWVudFR5cGUsIFByb3BUeXBlcy5pbnN0YW5jZU9mKFJlYWN0LkNvbXBvbmVudCksIFByb3BUeXBlcy5mdW5jXSksXG5cbiAgLyoqXG4gICAqIFRoZSBlbGV2YXRpb24gb2YgdGhlIHBvcG92ZXIuXG4gICAqL1xuICBlbGV2YXRpb246IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGluIG9yZGVyIHRvIHJldHJpZXZlIHRoZSBjb250ZW50IGFuY2hvciBlbGVtZW50LlxuICAgKiBJdCdzIHRoZSBvcHBvc2l0ZSBvZiB0aGUgYGFuY2hvckVsYCBwcm9wLlxuICAgKiBUaGUgY29udGVudCBhbmNob3IgZWxlbWVudCBzaG91bGQgYmUgYW4gZWxlbWVudCBpbnNpZGUgdGhlIHBvcG92ZXIuXG4gICAqIEl0J3MgdXNlZCB0byBjb3JyZWN0bHkgc2Nyb2xsIGFuZCBzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyLlxuICAgKiBUaGUgcG9zaXRpb25pbmcgc3RyYXRlZ3kgdHJpZXMgdG8gbWFrZSB0aGUgY29udGVudCBhbmNob3IgZWxlbWVudCBqdXN0IGFib3ZlIHRoZVxuICAgKiBhbmNob3IgZWxlbWVudC5cbiAgICovXG4gIGdldENvbnRlbnRBbmNob3JFbDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyBob3cgY2xvc2UgdG8gdGhlIGVkZ2Ugb2YgdGhlIHdpbmRvdyB0aGUgcG9wb3ZlciBjYW4gYXBwZWFyLlxuICAgKi9cbiAgbWFyZ2luVGhyZXNob2xkOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgcmVxdWVzdHMgdG8gYmUgY2xvc2VkLlxuICAgKi9cbiAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIGVudGVyaW5nLlxuICAgKi9cbiAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgZW50ZXJlZC5cbiAgICovXG4gIG9uRW50ZXJlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBlbnRlcmluZy5cbiAgICovXG4gIG9uRW50ZXJpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBleGl0aW5nLlxuICAgKi9cbiAgb25FeGl0OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBleGl0ZWQuXG4gICAqL1xuICBvbkV4aXRlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBleGl0aW5nLlxuICAgKi9cbiAgb25FeGl0aW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcG9wb3ZlciBpcyB2aXNpYmxlLlxuICAgKi9cbiAgb3BlbjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgW2BQYXBlcmBdKC9hcGkvcGFwZXIvKSBlbGVtZW50LlxuICAgKi9cbiAgUGFwZXJQcm9wczogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLnNoYXBlKHtcbiAgICBjb21wb25lbnQ6IGVsZW1lbnRUeXBlQWNjZXB0aW5nUmVmXG4gIH0pLFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwb2ludCBvbiB0aGUgcG9wb3ZlciB3aGljaFxuICAgKiB3aWxsIGF0dGFjaCB0byB0aGUgYW5jaG9yJ3Mgb3JpZ2luLlxuICAgKlxuICAgKiBPcHRpb25zOlxuICAgKiB2ZXJ0aWNhbDogW3RvcCwgY2VudGVyLCBib3R0b20sIHgocHgpXTtcbiAgICogaG9yaXpvbnRhbDogW2xlZnQsIGNlbnRlciwgcmlnaHQsIHgocHgpXS5cbiAgICovXG4gIHRyYW5zZm9ybU9yaWdpbjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBob3Jpem9udGFsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydjZW50ZXInLCAnbGVmdCcsICdyaWdodCddKSwgUHJvcFR5cGVzLm51bWJlcl0pLmlzUmVxdWlyZWQsXG4gICAgdmVydGljYWw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ2JvdHRvbScsICdjZW50ZXInLCAndG9wJ10pLCBQcm9wVHlwZXMubnVtYmVyXSkuaXNSZXF1aXJlZFxuICB9KSxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgdHJhbnNpdGlvbi5cbiAgICogW0ZvbGxvdyB0aGlzIGd1aWRlXSgvY29tcG9uZW50cy90cmFuc2l0aW9ucy8jdHJhbnNpdGlvbmNvbXBvbmVudC1wcm9wKSB0byBsZWFybiBtb3JlIGFib3V0IHRoZSByZXF1aXJlbWVudHMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgVHJhbnNpdGlvbkNvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gJ2F1dG8nIHRvIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlIHRyYW5zaXRpb24gdGltZSBiYXNlZCBvbiBoZWlnaHQuXG4gICAqL1xuICB0cmFuc2l0aW9uRHVyYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ2F1dG8nXSksIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgYXBwZWFyOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGVudGVyOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGV4aXQ6IFByb3BUeXBlcy5udW1iZXJcbiAgfSldKSxcblxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgW2BUcmFuc2l0aW9uYF0oaHR0cDovL3JlYWN0Y29tbXVuaXR5Lm9yZy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL3RyYW5zaXRpb24jVHJhbnNpdGlvbi1wcm9wcykgZWxlbWVudC5cbiAgICovXG4gIFRyYW5zaXRpb25Qcm9wczogUHJvcFR5cGVzLm9iamVjdFxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlQb3BvdmVyJ1xufSkoUG9wb3Zlcik7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNGcmFnbWVudCB9IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IG93bmVyRG9jdW1lbnQgZnJvbSAnLi4vdXRpbHMvb3duZXJEb2N1bWVudCc7XG5pbXBvcnQgTGlzdCBmcm9tICcuLi9MaXN0JztcbmltcG9ydCBnZXRTY3JvbGxiYXJTaXplIGZyb20gJy4uL3V0aWxzL2dldFNjcm9sbGJhclNpemUnO1xuaW1wb3J0IHVzZUZvcmtSZWYgZnJvbSAnLi4vdXRpbHMvdXNlRm9ya1JlZic7XG5cbmZ1bmN0aW9uIG5leHRJdGVtKGxpc3QsIGl0ZW0sIGRpc2FibGVMaXN0V3JhcCkge1xuICBpZiAobGlzdCA9PT0gaXRlbSkge1xuICAgIHJldHVybiBsaXN0LmZpcnN0Q2hpbGQ7XG4gIH1cblxuICBpZiAoaXRlbSAmJiBpdGVtLm5leHRFbGVtZW50U2libGluZykge1xuICAgIHJldHVybiBpdGVtLm5leHRFbGVtZW50U2libGluZztcbiAgfVxuXG4gIHJldHVybiBkaXNhYmxlTGlzdFdyYXAgPyBudWxsIDogbGlzdC5maXJzdENoaWxkO1xufVxuXG5mdW5jdGlvbiBwcmV2aW91c0l0ZW0obGlzdCwgaXRlbSwgZGlzYWJsZUxpc3RXcmFwKSB7XG4gIGlmIChsaXN0ID09PSBpdGVtKSB7XG4gICAgcmV0dXJuIGRpc2FibGVMaXN0V3JhcCA/IGxpc3QuZmlyc3RDaGlsZCA6IGxpc3QubGFzdENoaWxkO1xuICB9XG5cbiAgaWYgKGl0ZW0gJiYgaXRlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgcmV0dXJuIGl0ZW0ucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgfVxuXG4gIHJldHVybiBkaXNhYmxlTGlzdFdyYXAgPyBudWxsIDogbGlzdC5sYXN0Q2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHRleHRDcml0ZXJpYU1hdGNoZXMobmV4dEZvY3VzLCB0ZXh0Q3JpdGVyaWEpIHtcbiAgaWYgKHRleHRDcml0ZXJpYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgdGV4dCA9IG5leHRGb2N1cy5pbm5lclRleHQ7XG5cbiAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGpzZG9tIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lclRleHRcbiAgICB0ZXh0ID0gbmV4dEZvY3VzLnRleHRDb250ZW50O1xuICB9XG5cbiAgdGV4dCA9IHRleHQudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRleHRDcml0ZXJpYS5yZXBlYXRpbmcpIHtcbiAgICByZXR1cm4gdGV4dFswXSA9PT0gdGV4dENyaXRlcmlhLmtleXNbMF07XG4gIH1cblxuICByZXR1cm4gdGV4dC5pbmRleE9mKHRleHRDcml0ZXJpYS5rZXlzLmpvaW4oJycpKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gbW92ZUZvY3VzKGxpc3QsIGN1cnJlbnRGb2N1cywgZGlzYWJsZUxpc3RXcmFwLCBkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlLCB0cmF2ZXJzYWxGdW5jdGlvbiwgdGV4dENyaXRlcmlhKSB7XG4gIHZhciB3cmFwcGVkT25jZSA9IGZhbHNlO1xuICB2YXIgbmV4dEZvY3VzID0gdHJhdmVyc2FsRnVuY3Rpb24obGlzdCwgY3VycmVudEZvY3VzLCBjdXJyZW50Rm9jdXMgPyBkaXNhYmxlTGlzdFdyYXAgOiBmYWxzZSk7XG5cbiAgd2hpbGUgKG5leHRGb2N1cykge1xuICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcC5cbiAgICBpZiAobmV4dEZvY3VzID09PSBsaXN0LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGlmICh3cmFwcGVkT25jZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdyYXBwZWRPbmNlID0gdHJ1ZTtcbiAgICB9IC8vIFNhbWUgbG9naWMgYXMgdXNlQXV0b2NvbXBsZXRlLmpzXG5cblxuICAgIHZhciBuZXh0Rm9jdXNEaXNhYmxlZCA9IGRpc2FibGVkSXRlbXNGb2N1c2FibGUgPyBmYWxzZSA6IG5leHRGb2N1cy5kaXNhYmxlZCB8fCBuZXh0Rm9jdXMuZ2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJykgPT09ICd0cnVlJztcblxuICAgIGlmICghbmV4dEZvY3VzLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCAhdGV4dENyaXRlcmlhTWF0Y2hlcyhuZXh0Rm9jdXMsIHRleHRDcml0ZXJpYSkgfHwgbmV4dEZvY3VzRGlzYWJsZWQpIHtcbiAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgZWxlbWVudC5cbiAgICAgIG5leHRGb2N1cyA9IHRyYXZlcnNhbEZ1bmN0aW9uKGxpc3QsIG5leHRGb2N1cywgZGlzYWJsZUxpc3RXcmFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEZvY3VzLmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VFbmhhbmNlZEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlRWZmZWN0IDogUmVhY3QudXNlTGF5b3V0RWZmZWN0O1xuLyoqXG4gKiBBIHBlcm1hbmVudGx5IGRpc3BsYXllZCBtZW51IGZvbGxvd2luZyBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtcHJhY3RpY2VzLyNtZW51YnV0dG9uLlxuICogSXQncyBleHBvc2VkIHRvIGhlbHAgY3VzdG9taXphdGlvbiBvZiB0aGUgW2BNZW51YF0oL2FwaS9tZW51LykgY29tcG9uZW50LiBJZiB5b3VcbiAqIHVzZSBpdCBzZXBhcmF0ZWx5IHlvdSBuZWVkIHRvIG1vdmUgZm9jdXMgaW50byB0aGUgY29tcG9uZW50IG1hbnVhbGx5LiBPbmNlXG4gKiB0aGUgZm9jdXMgaXMgcGxhY2VkIGluc2lkZSB0aGUgY29tcG9uZW50IGl0IGlzIGZ1bGx5IGtleWJvYXJkIGFjY2Vzc2libGUuXG4gKi9cblxudmFyIE1lbnVMaXN0ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTWVudUxpc3QocHJvcHMsIHJlZikge1xuICB2YXIgYWN0aW9ucyA9IHByb3BzLmFjdGlvbnMsXG4gICAgICBfcHJvcHMkYXV0b0ZvY3VzID0gcHJvcHMuYXV0b0ZvY3VzLFxuICAgICAgYXV0b0ZvY3VzID0gX3Byb3BzJGF1dG9Gb2N1cyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkYXV0b0ZvY3VzLFxuICAgICAgX3Byb3BzJGF1dG9Gb2N1c0l0ZW0gPSBwcm9wcy5hdXRvRm9jdXNJdGVtLFxuICAgICAgYXV0b0ZvY3VzSXRlbSA9IF9wcm9wcyRhdXRvRm9jdXNJdGVtID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRhdXRvRm9jdXNJdGVtLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlZEl0ZW1zRiA9IHByb3BzLmRpc2FibGVkSXRlbXNGb2N1c2FibGUsXG4gICAgICBkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlID0gX3Byb3BzJGRpc2FibGVkSXRlbXNGID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlZEl0ZW1zRixcbiAgICAgIF9wcm9wcyRkaXNhYmxlTGlzdFdyYSA9IHByb3BzLmRpc2FibGVMaXN0V3JhcCxcbiAgICAgIGRpc2FibGVMaXN0V3JhcCA9IF9wcm9wcyRkaXNhYmxlTGlzdFdyYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUxpc3RXcmEsXG4gICAgICBvbktleURvd24gPSBwcm9wcy5vbktleURvd24sXG4gICAgICBfcHJvcHMkdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICB2YXJpYW50ID0gX3Byb3BzJHZhcmlhbnQgPT09IHZvaWQgMCA/ICdzZWxlY3RlZE1lbnUnIDogX3Byb3BzJHZhcmlhbnQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYWN0aW9uc1wiLCBcImF1dG9Gb2N1c1wiLCBcImF1dG9Gb2N1c0l0ZW1cIiwgXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcImRpc2FibGVkSXRlbXNGb2N1c2FibGVcIiwgXCJkaXNhYmxlTGlzdFdyYXBcIiwgXCJvbktleURvd25cIiwgXCJ2YXJpYW50XCJdKTtcblxuICB2YXIgbGlzdFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIHRleHRDcml0ZXJpYVJlZiA9IFJlYWN0LnVzZVJlZih7XG4gICAga2V5czogW10sXG4gICAgcmVwZWF0aW5nOiB0cnVlLFxuICAgIHByZXZpb3VzS2V5TWF0Y2hlZDogdHJ1ZSxcbiAgICBsYXN0VGltZTogbnVsbFxuICB9KTtcbiAgdXNlRW5oYW5jZWRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChhdXRvRm9jdXMpIHtcbiAgICAgIGxpc3RSZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cbiAgfSwgW2F1dG9Gb2N1c10pO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGFjdGlvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRqdXN0U3R5bGVGb3JTY3JvbGxiYXI6IGZ1bmN0aW9uIGFkanVzdFN0eWxlRm9yU2Nyb2xsYmFyKGNvbnRhaW5lckVsZW1lbnQsIHRoZW1lKSB7XG4gICAgICAgIC8vIExldCdzIGlnbm9yZSB0aGF0IHBpZWNlIG9mIGxvZ2ljIGlmIHVzZXJzIGFyZSBhbHJlYWR5IG92ZXJyaWRpbmcgdGhlIHdpZHRoXG4gICAgICAgIC8vIG9mIHRoZSBtZW51LlxuICAgICAgICB2YXIgbm9FeHBsaWNpdFdpZHRoID0gIWxpc3RSZWYuY3VycmVudC5zdHlsZS53aWR0aDtcblxuICAgICAgICBpZiAoY29udGFpbmVyRWxlbWVudC5jbGllbnRIZWlnaHQgPCBsaXN0UmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0ICYmIG5vRXhwbGljaXRXaWR0aCkge1xuICAgICAgICAgIHZhciBzY3JvbGxiYXJTaXplID0gXCJcIi5jb25jYXQoZ2V0U2Nyb2xsYmFyU2l6ZSh0cnVlKSwgXCJweFwiKTtcbiAgICAgICAgICBsaXN0UmVmLmN1cnJlbnQuc3R5bGVbdGhlbWUuZGlyZWN0aW9uID09PSAncnRsJyA/ICdwYWRkaW5nTGVmdCcgOiAncGFkZGluZ1JpZ2h0J10gPSBzY3JvbGxiYXJTaXplO1xuICAgICAgICAgIGxpc3RSZWYuY3VycmVudC5zdHlsZS53aWR0aCA9IFwiY2FsYygxMDAlICsgXCIuY29uY2F0KHNjcm9sbGJhclNpemUsIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0UmVmLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHZhciBoYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIHZhciBsaXN0ID0gbGlzdFJlZi5jdXJyZW50O1xuICAgIHZhciBrZXkgPSBldmVudC5rZXk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0VsZW1lbnR9IC0gd2lsbCBhbHdheXMgYmUgZGVmaW5lZCBzaW5jZSB3ZSBhcmUgaW4gYSBrZXlkb3duIGhhbmRsZXJcbiAgICAgKiBhdHRhY2hlZCB0byBhbiBlbGVtZW50LiBBIGtleWRvd24gZXZlbnQgaXMgZWl0aGVyIGRpc3BhdGNoZWQgdG8gdGhlIGFjdGl2ZUVsZW1lbnRcbiAgICAgKiBvciBkb2N1bWVudC5ib2R5IG9yIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC4gT25seSB0aGUgZmlyc3QgY2FzZSB3aWxsXG4gICAgICogdHJpZ2dlciB0aGlzIHNwZWNpZmljIGhhbmRsZXIuXG4gICAgICovXG5cbiAgICB2YXIgY3VycmVudEZvY3VzID0gb3duZXJEb2N1bWVudChsaXN0KS5hY3RpdmVFbGVtZW50O1xuXG4gICAgaWYgKGtleSA9PT0gJ0Fycm93RG93bicpIHtcbiAgICAgIC8vIFByZXZlbnQgc2Nyb2xsIG9mIHRoZSBwYWdlXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbW92ZUZvY3VzKGxpc3QsIGN1cnJlbnRGb2N1cywgZGlzYWJsZUxpc3RXcmFwLCBkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlLCBuZXh0SXRlbSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdBcnJvd1VwJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG1vdmVGb2N1cyhsaXN0LCBjdXJyZW50Rm9jdXMsIGRpc2FibGVMaXN0V3JhcCwgZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSwgcHJldmlvdXNJdGVtKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ0hvbWUnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbW92ZUZvY3VzKGxpc3QsIG51bGwsIGRpc2FibGVMaXN0V3JhcCwgZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSwgbmV4dEl0ZW0pO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnRW5kJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG1vdmVGb2N1cyhsaXN0LCBudWxsLCBkaXNhYmxlTGlzdFdyYXAsIGRpc2FibGVkSXRlbXNGb2N1c2FibGUsIHByZXZpb3VzSXRlbSk7XG4gICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY3JpdGVyaWEgPSB0ZXh0Q3JpdGVyaWFSZWYuY3VycmVudDtcbiAgICAgIHZhciBsb3dlcktleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGN1cnJUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIGlmIChjcml0ZXJpYS5rZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gUmVzZXRcbiAgICAgICAgaWYgKGN1cnJUaW1lIC0gY3JpdGVyaWEubGFzdFRpbWUgPiA1MDApIHtcbiAgICAgICAgICBjcml0ZXJpYS5rZXlzID0gW107XG4gICAgICAgICAgY3JpdGVyaWEucmVwZWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBjcml0ZXJpYS5wcmV2aW91c0tleU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNyaXRlcmlhLnJlcGVhdGluZyAmJiBsb3dlcktleSAhPT0gY3JpdGVyaWEua2V5c1swXSkge1xuICAgICAgICAgIGNyaXRlcmlhLnJlcGVhdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNyaXRlcmlhLmxhc3RUaW1lID0gY3VyclRpbWU7XG4gICAgICBjcml0ZXJpYS5rZXlzLnB1c2gobG93ZXJLZXkpO1xuICAgICAgdmFyIGtlZXBGb2N1c09uQ3VycmVudCA9IGN1cnJlbnRGb2N1cyAmJiAhY3JpdGVyaWEucmVwZWF0aW5nICYmIHRleHRDcml0ZXJpYU1hdGNoZXMoY3VycmVudEZvY3VzLCBjcml0ZXJpYSk7XG5cbiAgICAgIGlmIChjcml0ZXJpYS5wcmV2aW91c0tleU1hdGNoZWQgJiYgKGtlZXBGb2N1c09uQ3VycmVudCB8fCBtb3ZlRm9jdXMobGlzdCwgY3VycmVudEZvY3VzLCBmYWxzZSwgZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSwgbmV4dEl0ZW0sIGNyaXRlcmlhKSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyaXRlcmlhLnByZXZpb3VzS2V5TWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbktleURvd24pIHtcbiAgICAgIG9uS2V5RG93bihldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVPd25SZWYgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAvLyAjU3RyaWN0TW9kZSByZWFkeVxuICAgIGxpc3RSZWYuY3VycmVudCA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKGluc3RhbmNlKTtcbiAgfSwgW10pO1xuICB2YXIgaGFuZGxlUmVmID0gdXNlRm9ya1JlZihoYW5kbGVPd25SZWYsIHJlZik7XG4gIC8qKlxuICAgKiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gc2hvdWxkIHJlY2VpdmUgZm9jdXNcbiAgICogaW4gYSBgdmFyaWFudD1cInNlbGVjdGVkTWVudVwiYCBpdCdzIHRoZSBmaXJzdCBgc2VsZWN0ZWRgIGl0ZW1cbiAgICogb3RoZXJ3aXNlIGl0J3MgdGhlIHZlcnkgZmlyc3QgaXRlbS5cbiAgICovXG5cbiAgdmFyIGFjdGl2ZUl0ZW1JbmRleCA9IC0xOyAvLyBzaW5jZSB3ZSBpbmplY3QgZm9jdXMgcmVsYXRlZCBwcm9wcyBpbnRvIGNoaWxkcmVuIHdlIGhhdmUgdG8gZG8gYSBsb29rYWhlYWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlcmUgaXMgYSBgc2VsZWN0ZWRgIGl0ZW0uIFdlJ3JlIGxvb2tpbmcgZm9yIHRoZSBsYXN0IGBzZWxlY3RlZGBcbiAgLy8gaXRlbSBhbmQgdXNlIHRoZSBmaXJzdCB2YWxpZCBpdGVtIGFzIGEgZmFsbGJhY2tcblxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKCEgLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaXNGcmFnbWVudChjaGlsZCkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIE1lbnUgY29tcG9uZW50IGRvZXNuJ3QgYWNjZXB0IGEgRnJhZ21lbnQgYXMgYSBjaGlsZC5cIiwgJ0NvbnNpZGVyIHByb3ZpZGluZyBhbiBhcnJheSBpbnN0ZWFkLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICBpZiAodmFyaWFudCA9PT0gJ3NlbGVjdGVkTWVudScgJiYgY2hpbGQucHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgICAgYWN0aXZlSXRlbUluZGV4ID0gaW5kZXg7XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2ZUl0ZW1JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgYWN0aXZlSXRlbUluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIGl0ZW1zID0gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSBhY3RpdmVJdGVtSW5kZXgpIHtcbiAgICAgIHZhciBuZXdDaGlsZFByb3BzID0ge307XG5cbiAgICAgIGlmIChhdXRvRm9jdXNJdGVtKSB7XG4gICAgICAgIG5ld0NoaWxkUHJvcHMuYXV0b0ZvY3VzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLnByb3BzLnRhYkluZGV4ID09PSB1bmRlZmluZWQgJiYgdmFyaWFudCA9PT0gJ3NlbGVjdGVkTWVudScpIHtcbiAgICAgICAgbmV3Q2hpbGRQcm9wcy50YWJJbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBuZXdDaGlsZFByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdCwgX2V4dGVuZHMoe1xuICAgIHJvbGU6IFwibWVudVwiLFxuICAgIHJlZjogaGFuZGxlUmVmLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICB0YWJJbmRleDogYXV0b0ZvY3VzID8gMCA6IC0xXG4gIH0sIG90aGVyKSwgaXRlbXMpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBNZW51TGlzdC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHdpbGwgZm9jdXMgdGhlIGBbcm9sZT1cIm1lbnVcIl1gIGNvbnRhaW5lciBhbmQgbW92ZSBpbnRvIHRhYiBvcmRlci5cbiAgICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgd2lsbCBmb2N1cyB0aGUgZmlyc3QgbWVudWl0ZW0gaWYgYHZhcmlhbnQ9XCJtZW51XCJgIG9yIHNlbGVjdGVkIGl0ZW1cbiAgICogaWYgYHZhcmlhbnQ9XCJzZWxlY3RlZE1lbnVcImAuXG4gICAqL1xuICBhdXRvRm9jdXNJdGVtOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTWVudUxpc3QgY29udGVudHMsIG5vcm1hbGx5IGBNZW51SXRlbWBzLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgd2lsbCBhbGxvdyBmb2N1cyBvbiBkaXNhYmxlZCBpdGVtcy5cbiAgICovXG4gIGRpc2FibGVkSXRlbXNGb2N1c2FibGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBtZW51IGl0ZW1zIHdpbGwgbm90IHdyYXAgZm9jdXMuXG4gICAqL1xuICBkaXNhYmxlTGlzdFdyYXA6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuIFVzZSBgbWVudWAgdG8gcHJldmVudCBzZWxlY3RlZCBpdGVtcyBmcm9tIGltcGFjdGluZyB0aGUgaW5pdGlhbCBmb2N1c1xuICAgKiBhbmQgdGhlIHZlcnRpY2FsIGFsaWdubWVudCByZWxhdGl2ZSB0byB0aGUgYW5jaG9yIGVsZW1lbnQuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydtZW51JywgJ3NlbGVjdGVkTWVudSddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IE1lbnVMaXN0OyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzRnJhZ21lbnQgfSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBIVE1MRWxlbWVudFR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IFBvcG92ZXIgZnJvbSAnLi4vUG9wb3Zlcic7XG5pbXBvcnQgTWVudUxpc3QgZnJvbSAnLi4vTWVudUxpc3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBzZXRSZWYgZnJvbSAnLi4vdXRpbHMvc2V0UmVmJztcbmltcG9ydCB1c2VUaGVtZSBmcm9tICcuLi9zdHlsZXMvdXNlVGhlbWUnO1xudmFyIFJUTF9PUklHSU4gPSB7XG4gIHZlcnRpY2FsOiAndG9wJyxcbiAgaG9yaXpvbnRhbDogJ3JpZ2h0J1xufTtcbnZhciBMVFJfT1JJR0lOID0ge1xuICB2ZXJ0aWNhbDogJ3RvcCcsXG4gIGhvcml6b250YWw6ICdsZWZ0J1xufTtcbmV4cG9ydCB2YXIgc3R5bGVzID0ge1xuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYFBhcGVyYCBjb21wb25lbnQuICovXG4gIHBhcGVyOiB7XG4gICAgLy8gc3BlY1o6IFRoZSBtYXhpbXVtIGhlaWdodCBvZiBhIHNpbXBsZSBtZW51IHNob3VsZCBiZSBvbmUgb3IgbW9yZSByb3dzIGxlc3MgdGhhbiB0aGUgdmlld1xuICAgIC8vIGhlaWdodC4gVGhpcyBlbnN1cmVzIGEgdGFwYWJsZSBhcmVhIG91dHNpZGUgb2YgdGhlIHNpbXBsZSBtZW51IHdpdGggd2hpY2ggdG8gZGlzbWlzc1xuICAgIC8vIHRoZSBtZW51LlxuICAgIG1heEhlaWdodDogJ2NhbGMoMTAwJSAtIDk2cHgpJyxcbiAgICAvLyBBZGQgaU9TIG1vbWVudHVtIHNjcm9sbGluZy5cbiAgICBXZWJraXRPdmVyZmxvd1Njcm9sbGluZzogJ3RvdWNoJ1xuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgTGlzdGAgY29tcG9uZW50IHZpYSBgTWVudUxpc3RgLiAqL1xuICBsaXN0OiB7XG4gICAgLy8gV2UgZGlzYWJsZSB0aGUgZm9jdXMgcmluZyBmb3IgbW91c2UsIHRvdWNoIGFuZCBrZXlib2FyZCB1c2Vycy5cbiAgICBvdXRsaW5lOiAwXG4gIH1cbn07XG52YXIgTWVudSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE1lbnUocHJvcHMsIHJlZikge1xuICB2YXIgX3Byb3BzJGF1dG9Gb2N1cyA9IHByb3BzLmF1dG9Gb2N1cyxcbiAgICAgIGF1dG9Gb2N1cyA9IF9wcm9wcyRhdXRvRm9jdXMgPT09IHZvaWQgMCA/IHRydWUgOiBfcHJvcHMkYXV0b0ZvY3VzLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgX3Byb3BzJGRpc2FibGVBdXRvRm9jID0gcHJvcHMuZGlzYWJsZUF1dG9Gb2N1c0l0ZW0sXG4gICAgICBkaXNhYmxlQXV0b0ZvY3VzSXRlbSA9IF9wcm9wcyRkaXNhYmxlQXV0b0ZvYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUF1dG9Gb2MsXG4gICAgICBfcHJvcHMkTWVudUxpc3RQcm9wcyA9IHByb3BzLk1lbnVMaXN0UHJvcHMsXG4gICAgICBNZW51TGlzdFByb3BzID0gX3Byb3BzJE1lbnVMaXN0UHJvcHMgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJE1lbnVMaXN0UHJvcHMsXG4gICAgICBvbkNsb3NlID0gcHJvcHMub25DbG9zZSxcbiAgICAgIG9uRW50ZXJpbmcgPSBwcm9wcy5vbkVudGVyaW5nLFxuICAgICAgb3BlbiA9IHByb3BzLm9wZW4sXG4gICAgICBfcHJvcHMkUGFwZXJQcm9wcyA9IHByb3BzLlBhcGVyUHJvcHMsXG4gICAgICBQYXBlclByb3BzID0gX3Byb3BzJFBhcGVyUHJvcHMgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJFBhcGVyUHJvcHMsXG4gICAgICBQb3BvdmVyQ2xhc3NlcyA9IHByb3BzLlBvcG92ZXJDbGFzc2VzLFxuICAgICAgX3Byb3BzJHRyYW5zaXRpb25EdXJhID0gcHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gX3Byb3BzJHRyYW5zaXRpb25EdXJhID09PSB2b2lkIDAgPyAnYXV0bycgOiBfcHJvcHMkdHJhbnNpdGlvbkR1cmEsXG4gICAgICBfcHJvcHMkdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICB2YXJpYW50ID0gX3Byb3BzJHZhcmlhbnQgPT09IHZvaWQgMCA/ICdzZWxlY3RlZE1lbnUnIDogX3Byb3BzJHZhcmlhbnQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYXV0b0ZvY3VzXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiZGlzYWJsZUF1dG9Gb2N1c0l0ZW1cIiwgXCJNZW51TGlzdFByb3BzXCIsIFwib25DbG9zZVwiLCBcIm9uRW50ZXJpbmdcIiwgXCJvcGVuXCIsIFwiUGFwZXJQcm9wc1wiLCBcIlBvcG92ZXJDbGFzc2VzXCIsIFwidHJhbnNpdGlvbkR1cmF0aW9uXCIsIFwidmFyaWFudFwiXSk7XG5cbiAgdmFyIHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgdmFyIGF1dG9Gb2N1c0l0ZW0gPSBhdXRvRm9jdXMgJiYgIWRpc2FibGVBdXRvRm9jdXNJdGVtICYmIG9wZW47XG4gIHZhciBtZW51TGlzdEFjdGlvbnNSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBjb250ZW50QW5jaG9yUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuXG4gIHZhciBnZXRDb250ZW50QW5jaG9yRWwgPSBmdW5jdGlvbiBnZXRDb250ZW50QW5jaG9yRWwoKSB7XG4gICAgcmV0dXJuIGNvbnRlbnRBbmNob3JSZWYuY3VycmVudDtcbiAgfTtcblxuICB2YXIgaGFuZGxlRW50ZXJpbmcgPSBmdW5jdGlvbiBoYW5kbGVFbnRlcmluZyhlbGVtZW50LCBpc0FwcGVhcmluZykge1xuICAgIGlmIChtZW51TGlzdEFjdGlvbnNSZWYuY3VycmVudCkge1xuICAgICAgbWVudUxpc3RBY3Rpb25zUmVmLmN1cnJlbnQuYWRqdXN0U3R5bGVGb3JTY3JvbGxiYXIoZWxlbWVudCwgdGhlbWUpO1xuICAgIH1cblxuICAgIGlmIChvbkVudGVyaW5nKSB7XG4gICAgICBvbkVudGVyaW5nKGVsZW1lbnQsIGlzQXBwZWFyaW5nKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUxpc3RLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlTGlzdEtleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgb25DbG9zZShldmVudCwgJ3RhYktleURvd24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gc2hvdWxkIHJlY2VpdmUgZm9jdXNcbiAgICogaW4gYSBgdmFyaWFudD1cInNlbGVjdGVkTWVudVwiYCBpdCdzIHRoZSBmaXJzdCBgc2VsZWN0ZWRgIGl0ZW1cbiAgICogb3RoZXJ3aXNlIGl0J3MgdGhlIHZlcnkgZmlyc3QgaXRlbS5cbiAgICovXG5cblxuICB2YXIgYWN0aXZlSXRlbUluZGV4ID0gLTE7IC8vIHNpbmNlIHdlIGluamVjdCBmb2N1cyByZWxhdGVkIHByb3BzIGludG8gY2hpbGRyZW4gd2UgaGF2ZSB0byBkbyBhIGxvb2thaGVhZFxuICAvLyB0byBjaGVjayBpZiB0aGVyZSBpcyBhIGBzZWxlY3RlZGAgaXRlbS4gV2UncmUgbG9va2luZyBmb3IgdGhlIGxhc3QgYHNlbGVjdGVkYFxuICAvLyBpdGVtIGFuZCB1c2UgdGhlIGZpcnN0IHZhbGlkIGl0ZW0gYXMgYSBmYWxsYmFja1xuXG4gIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgIGlmICghIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzRnJhZ21lbnQoY2hpbGQpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IFRoZSBNZW51IGNvbXBvbmVudCBkb2Vzbid0IGFjY2VwdCBhIEZyYWdtZW50IGFzIGEgY2hpbGQuXCIsICdDb25zaWRlciBwcm92aWRpbmcgYW4gYXJyYXkgaW5zdGVhZC4nXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZC5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgaWYgKHZhcmlhbnQgIT09IFwibWVudVwiICYmIGNoaWxkLnByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAgIGFjdGl2ZUl0ZW1JbmRleCA9IGluZGV4O1xuICAgICAgfSBlbHNlIGlmIChhY3RpdmVJdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGFjdGl2ZUl0ZW1JbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBpdGVtcyA9IFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gYWN0aXZlSXRlbUluZGV4KSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihpbnN0YW5jZSkge1xuICAgICAgICAgIC8vICNTdHJpY3RNb2RlIHJlYWR5XG4gICAgICAgICAgY29udGVudEFuY2hvclJlZi5jdXJyZW50ID0gUmVhY3RET00uZmluZERPTU5vZGUoaW5zdGFuY2UpO1xuICAgICAgICAgIHNldFJlZihjaGlsZC5yZWYsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcG92ZXIsIF9leHRlbmRzKHtcbiAgICBnZXRDb250ZW50QW5jaG9yRWw6IGdldENvbnRlbnRBbmNob3JFbCxcbiAgICBjbGFzc2VzOiBQb3BvdmVyQ2xhc3NlcyxcbiAgICBvbkNsb3NlOiBvbkNsb3NlLFxuICAgIG9uRW50ZXJpbmc6IGhhbmRsZUVudGVyaW5nLFxuICAgIGFuY2hvck9yaWdpbjogdGhlbWUuZGlyZWN0aW9uID09PSAncnRsJyA/IFJUTF9PUklHSU4gOiBMVFJfT1JJR0lOLFxuICAgIHRyYW5zZm9ybU9yaWdpbjogdGhlbWUuZGlyZWN0aW9uID09PSAncnRsJyA/IFJUTF9PUklHSU4gOiBMVFJfT1JJR0lOLFxuICAgIFBhcGVyUHJvcHM6IF9leHRlbmRzKHt9LCBQYXBlclByb3BzLCB7XG4gICAgICBjbGFzc2VzOiBfZXh0ZW5kcyh7fSwgUGFwZXJQcm9wcy5jbGFzc2VzLCB7XG4gICAgICAgIHJvb3Q6IGNsYXNzZXMucGFwZXJcbiAgICAgIH0pXG4gICAgfSksXG4gICAgb3Blbjogb3BlbixcbiAgICByZWY6IHJlZixcbiAgICB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvblxuICB9LCBvdGhlciksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbnVMaXN0LCBfZXh0ZW5kcyh7XG4gICAgb25LZXlEb3duOiBoYW5kbGVMaXN0S2V5RG93bixcbiAgICBhY3Rpb25zOiBtZW51TGlzdEFjdGlvbnNSZWYsXG4gICAgYXV0b0ZvY3VzOiBhdXRvRm9jdXMgJiYgKGFjdGl2ZUl0ZW1JbmRleCA9PT0gLTEgfHwgZGlzYWJsZUF1dG9Gb2N1c0l0ZW0pLFxuICAgIGF1dG9Gb2N1c0l0ZW06IGF1dG9Gb2N1c0l0ZW0sXG4gICAgdmFyaWFudDogdmFyaWFudFxuICB9LCBNZW51TGlzdFByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMubGlzdCwgTWVudUxpc3RQcm9wcy5jbGFzc05hbWUpXG4gIH0pLCBpdGVtcykpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBNZW51LnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEEgSFRNTCBlbGVtZW50LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpdC5cbiAgICogSXQncyB1c2VkIHRvIHNldCB0aGUgcG9zaXRpb24gb2YgdGhlIG1lbnUuXG4gICAqL1xuICBhbmNob3JFbDogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLm9uZU9mVHlwZShbSFRNTEVsZW1lbnRUeXBlLCBQcm9wVHlwZXMuZnVuY10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAgKERlZmF1bHQpIHdpbGwgZm9jdXMgdGhlIGBbcm9sZT1cIm1lbnVcIl1gIGlmIG5vIGZvY3VzYWJsZSBjaGlsZCBpcyBmb3VuZC4gRGlzYWJsZWRcbiAgICogY2hpbGRyZW4gYXJlIG5vdCBmb2N1c2FibGUuIElmIHlvdSBzZXQgdGhpcyBwcm9wIHRvIGBmYWxzZWAgZm9jdXMgd2lsbCBiZSBwbGFjZWRcbiAgICogb24gdGhlIHBhcmVudCBtb2RhbCBjb250YWluZXIuIFRoaXMgaGFzIHNldmVyZSBhY2Nlc3NpYmlsaXR5IGltcGxpY2F0aW9uc1xuICAgKiBhbmQgc2hvdWxkIG9ubHkgYmUgY29uc2lkZXJlZCBpZiB5b3UgbWFuYWdlIGZvY3VzIG90aGVyd2lzZS5cbiAgICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE1lbnUgY29udGVudHMsIG5vcm1hbGx5IGBNZW51SXRlbWBzLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFdoZW4gb3BlbmluZyB0aGUgbWVudSB3aWxsIG5vdCBmb2N1cyB0aGUgYWN0aXZlIGl0ZW0gYnV0IHRoZSBgW3JvbGU9XCJtZW51XCJdYFxuICAgKiB1bmxlc3MgYGF1dG9Gb2N1c2AgaXMgYWxzbyBzZXQgdG8gYGZhbHNlYC4gTm90IHVzaW5nIHRoZSBkZWZhdWx0IG1lYW5zIG5vdFxuICAgKiBmb2xsb3dpbmcgV0FJLUFSSUEgYXV0aG9yaW5nIHByYWN0aWNlcy4gUGxlYXNlIGJlIGNvbnNpZGVyYXRlIGFib3V0IHBvc3NpYmxlXG4gICAqIGFjY2Vzc2liaWxpdHkgaW1wbGljYXRpb25zLlxuICAgKi9cbiAgZGlzYWJsZUF1dG9Gb2N1c0l0ZW06IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYE1lbnVMaXN0YF0oL2FwaS9tZW51LWxpc3QvKSBlbGVtZW50LlxuICAgKi9cbiAgTWVudUxpc3RQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IHJlcXVlc3RzIHRvIGJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIENhbiBiZTogYFwiZXNjYXBlS2V5RG93blwiYCwgYFwiYmFja2Ryb3BDbGlja1wiYCwgYFwidGFiS2V5RG93blwiYC5cbiAgICovXG4gIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgdGhlIE1lbnUgZW50ZXJzLlxuICAgKi9cbiAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIE1lbnUgaGFzIGVudGVyZWQuXG4gICAqL1xuICBvbkVudGVyZWQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBNZW51IGlzIGVudGVyaW5nLlxuICAgKi9cbiAgb25FbnRlcmluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgTWVudSBleGl0cy5cbiAgICovXG4gIG9uRXhpdDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIE1lbnUgaGFzIGV4aXRlZC5cbiAgICovXG4gIG9uRXhpdGVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgTWVudSBpcyBleGl0aW5nLlxuICAgKi9cbiAgb25FeGl0aW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbWVudSBpcyB2aXNpYmxlLlxuICAgKi9cbiAgb3BlbjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgUGFwZXJQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogYGNsYXNzZXNgIHByb3AgYXBwbGllZCB0byB0aGUgW2BQb3BvdmVyYF0oL2FwaS9wb3BvdmVyLykgZWxlbWVudC5cbiAgICovXG4gIFBvcG92ZXJDbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSB0cmFuc2l0aW9uIGluIGBtc2AsIG9yICdhdXRvJ1xuICAgKi9cbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydhdXRvJ10pLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGFwcGVhcjogUHJvcFR5cGVzLm51bWJlcixcbiAgICBlbnRlcjogUHJvcFR5cGVzLm51bWJlcixcbiAgICBleGl0OiBQcm9wVHlwZXMubnVtYmVyXG4gIH0pXSksXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS4gVXNlIGBtZW51YCB0byBwcmV2ZW50IHNlbGVjdGVkIGl0ZW1zIGZyb20gaW1wYWN0aW5nIHRoZSBpbml0aWFsIGZvY3VzXG4gICAqIGFuZCB0aGUgdmVydGljYWwgYWxpZ25tZW50IHJlbGF0aXZlIHRvIHRoZSBhbmNob3IgZWxlbWVudC5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ21lbnUnLCAnc2VsZWN0ZWRNZW51J10pXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aU1lbnUnXG59KShNZW51KTsiLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rcywgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VDb250cm9sbGVkKF9yZWYpIHtcbiAgdmFyIGNvbnRyb2xsZWQgPSBfcmVmLmNvbnRyb2xsZWQsXG4gICAgICBkZWZhdWx0UHJvcCA9IF9yZWYuZGVmYXVsdCxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBfcmVmJHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIHN0YXRlID0gX3JlZiRzdGF0ZSA9PT0gdm9pZCAwID8gJ3ZhbHVlJyA6IF9yZWYkc3RhdGU7XG5cbiAgdmFyIF9SZWFjdCR1c2VSZWYgPSBSZWFjdC51c2VSZWYoY29udHJvbGxlZCAhPT0gdW5kZWZpbmVkKSxcbiAgICAgIGlzQ29udHJvbGxlZCA9IF9SZWFjdCR1c2VSZWYuY3VycmVudDtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZGVmYXVsdFByb3ApLFxuICAgICAgdmFsdWVTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldFZhbHVlID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciB2YWx1ZSA9IGlzQ29udHJvbGxlZCA/IGNvbnRyb2xsZWQgOiB2YWx1ZVN0YXRlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0NvbnRyb2xsZWQgIT09IChjb250cm9sbGVkICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IEEgY29tcG9uZW50IGlzIGNoYW5naW5nIHRoZSBcIi5jb25jYXQoaXNDb250cm9sbGVkID8gJycgOiAndW4nLCBcImNvbnRyb2xsZWQgXCIpLmNvbmNhdChzdGF0ZSwgXCIgc3RhdGUgb2YgXCIpLmNvbmNhdChuYW1lLCBcIiB0byBiZSBcIikuY29uY2F0KGlzQ29udHJvbGxlZCA/ICd1bicgOiAnJywgXCJjb250cm9sbGVkLlwiKSwgJ0VsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLicsIFwiRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBcIi5jb25jYXQobmFtZSwgXCIgXCIpICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LicsIFwiVGhlIG5hdHVyZSBvZiB0aGUgc3RhdGUgaXMgZGV0ZXJtaW5lZCBkdXJpbmcgdGhlIGZpcnN0IHJlbmRlciwgaXQncyBjb25zaWRlcmVkIGNvbnRyb2xsZWQgaWYgdGhlIHZhbHVlIGlzIG5vdCBgdW5kZWZpbmVkYC5cIiwgJ01vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfSwgW2NvbnRyb2xsZWRdKTtcblxuICAgIHZhciBfUmVhY3QkdXNlUmVmMiA9IFJlYWN0LnVzZVJlZihkZWZhdWx0UHJvcCksXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IF9SZWFjdCR1c2VSZWYyLmN1cnJlbnQ7XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpc0NvbnRyb2xsZWQgJiYgZGVmYXVsdFZhbHVlICE9PSBkZWZhdWx0UHJvcCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFtcIk1hdGVyaWFsLVVJOiBBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyB0aGUgZGVmYXVsdCBcIi5jb25jYXQoc3RhdGUsIFwiIHN0YXRlIG9mIGFuIHVuY29udHJvbGxlZCBcIikuY29uY2F0KG5hbWUsIFwiIGFmdGVyIGJlaW5nIGluaXRpYWxpemVkLiBcIikgKyBcIlRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBvcHQgdG8gdXNlIGEgY29udHJvbGxlZCBcIi5jb25jYXQobmFtZSwgXCIuXCIpXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfSwgW0pTT04uc3RyaW5naWZ5KGRlZmF1bHRQcm9wKV0pO1xuICB9XG5cbiAgdmFyIHNldFZhbHVlSWZVbmNvbnRyb2xsZWQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICBpZiAoIWlzQ29udHJvbGxlZCkge1xuICAgICAgc2V0VmFsdWUobmV3VmFsdWUpO1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gW3ZhbHVlLCBzZXRWYWx1ZUlmVW5jb250cm9sbGVkXTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2ZcIjtcbmltcG9ydCB7IGZvcm1hdE11aUVycm9yTWVzc2FnZSBhcyBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkBtYXRlcmlhbC11aS91dGlsc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNGcmFnbWVudCB9IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCBvd25lckRvY3VtZW50IGZyb20gJy4uL3V0aWxzL293bmVyRG9jdW1lbnQnO1xuaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnLi4vdXRpbHMvY2FwaXRhbGl6ZSc7XG5pbXBvcnQgeyByZWZUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBNZW51IGZyb20gJy4uL01lbnUvTWVudSc7XG5pbXBvcnQgeyBpc0ZpbGxlZCB9IGZyb20gJy4uL0lucHV0QmFzZS91dGlscyc7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcbmltcG9ydCB1c2VDb250cm9sbGVkIGZyb20gJy4uL3V0aWxzL3VzZUNvbnRyb2xsZWQnO1xuXG5mdW5jdGlvbiBhcmVFcXVhbFZhbHVlcyhhLCBiKSB7XG4gIGlmIChfdHlwZW9mKGIpID09PSAnb2JqZWN0JyAmJiBiICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cblxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkoZGlzcGxheSkge1xuICByZXR1cm4gZGlzcGxheSA9PSBudWxsIHx8IHR5cGVvZiBkaXNwbGF5ID09PSAnc3RyaW5nJyAmJiAhZGlzcGxheS50cmltKCk7XG59XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxuXG52YXIgU2VsZWN0SW5wdXQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBTZWxlY3RJbnB1dChwcm9wcywgcmVmKSB7XG4gIHZhciBhcmlhTGFiZWwgPSBwcm9wc1snYXJpYS1sYWJlbCddLFxuICAgICAgYXV0b0ZvY3VzID0gcHJvcHMuYXV0b0ZvY3VzLFxuICAgICAgYXV0b1dpZHRoID0gcHJvcHMuYXV0b1dpZHRoLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGRpc3BsYXlFbXB0eSA9IHByb3BzLmRpc3BsYXlFbXB0eSxcbiAgICAgIEljb25Db21wb25lbnQgPSBwcm9wcy5JY29uQ29tcG9uZW50LFxuICAgICAgaW5wdXRSZWZQcm9wID0gcHJvcHMuaW5wdXRSZWYsXG4gICAgICBsYWJlbElkID0gcHJvcHMubGFiZWxJZCxcbiAgICAgIF9wcm9wcyRNZW51UHJvcHMgPSBwcm9wcy5NZW51UHJvcHMsXG4gICAgICBNZW51UHJvcHMgPSBfcHJvcHMkTWVudVByb3BzID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRNZW51UHJvcHMsXG4gICAgICBtdWx0aXBsZSA9IHByb3BzLm11bHRpcGxlLFxuICAgICAgbmFtZSA9IHByb3BzLm5hbWUsXG4gICAgICBvbkJsdXIgPSBwcm9wcy5vbkJsdXIsXG4gICAgICBvbkNoYW5nZSA9IHByb3BzLm9uQ2hhbmdlLFxuICAgICAgb25DbG9zZSA9IHByb3BzLm9uQ2xvc2UsXG4gICAgICBvbkZvY3VzID0gcHJvcHMub25Gb2N1cyxcbiAgICAgIG9uT3BlbiA9IHByb3BzLm9uT3BlbixcbiAgICAgIG9wZW5Qcm9wID0gcHJvcHMub3BlbixcbiAgICAgIHJlYWRPbmx5ID0gcHJvcHMucmVhZE9ubHksXG4gICAgICByZW5kZXJWYWx1ZSA9IHByb3BzLnJlbmRlclZhbHVlLFxuICAgICAgX3Byb3BzJFNlbGVjdERpc3BsYXlQID0gcHJvcHMuU2VsZWN0RGlzcGxheVByb3BzLFxuICAgICAgU2VsZWN0RGlzcGxheVByb3BzID0gX3Byb3BzJFNlbGVjdERpc3BsYXlQID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRTZWxlY3REaXNwbGF5UCxcbiAgICAgIHRhYkluZGV4UHJvcCA9IHByb3BzLnRhYkluZGV4LFxuICAgICAgdHlwZSA9IHByb3BzLnR5cGUsXG4gICAgICB2YWx1ZVByb3AgPSBwcm9wcy52YWx1ZSxcbiAgICAgIF9wcm9wcyR2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIHZhcmlhbnQgPSBfcHJvcHMkdmFyaWFudCA9PT0gdm9pZCAwID8gJ3N0YW5kYXJkJyA6IF9wcm9wcyR2YXJpYW50LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImFyaWEtbGFiZWxcIiwgXCJhdXRvRm9jdXNcIiwgXCJhdXRvV2lkdGhcIiwgXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJkaXNhYmxlZFwiLCBcImRpc3BsYXlFbXB0eVwiLCBcIkljb25Db21wb25lbnRcIiwgXCJpbnB1dFJlZlwiLCBcImxhYmVsSWRcIiwgXCJNZW51UHJvcHNcIiwgXCJtdWx0aXBsZVwiLCBcIm5hbWVcIiwgXCJvbkJsdXJcIiwgXCJvbkNoYW5nZVwiLCBcIm9uQ2xvc2VcIiwgXCJvbkZvY3VzXCIsIFwib25PcGVuXCIsIFwib3BlblwiLCBcInJlYWRPbmx5XCIsIFwicmVuZGVyVmFsdWVcIiwgXCJTZWxlY3REaXNwbGF5UHJvcHNcIiwgXCJ0YWJJbmRleFwiLCBcInR5cGVcIiwgXCJ2YWx1ZVwiLCBcInZhcmlhbnRcIl0pO1xuXG4gIHZhciBfdXNlQ29udHJvbGxlZCA9IHVzZUNvbnRyb2xsZWQoe1xuICAgIGNvbnRyb2xsZWQ6IHZhbHVlUHJvcCxcbiAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWUsXG4gICAgbmFtZTogJ1NlbGVjdCdcbiAgfSksXG4gICAgICBfdXNlQ29udHJvbGxlZDIgPSBfc2xpY2VkVG9BcnJheShfdXNlQ29udHJvbGxlZCwgMiksXG4gICAgICB2YWx1ZSA9IF91c2VDb250cm9sbGVkMlswXSxcbiAgICAgIHNldFZhbHVlID0gX3VzZUNvbnRyb2xsZWQyWzFdO1xuXG4gIHZhciBpbnB1dFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUobnVsbCksXG4gICAgICBkaXNwbGF5Tm9kZSA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldERpc3BsYXlOb2RlID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlUmVmID0gUmVhY3QudXNlUmVmKG9wZW5Qcm9wICE9IG51bGwpLFxuICAgICAgaXNPcGVuQ29udHJvbGxlZCA9IF9SZWFjdCR1c2VSZWYuY3VycmVudDtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMiA9IFJlYWN0LnVzZVN0YXRlKCksXG4gICAgICBtZW51TWluV2lkdGhTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRNZW51TWluV2lkdGhTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTMgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBvcGVuU3RhdGUgPSBfUmVhY3QkdXNlU3RhdGUzWzBdLFxuICAgICAgc2V0T3BlblN0YXRlID0gX1JlYWN0JHVzZVN0YXRlM1sxXTtcblxuICB2YXIgaGFuZGxlUmVmID0gdXNlRm9ya1JlZihyZWYsIGlucHV0UmVmUHJvcCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoaGFuZGxlUmVmLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgZGlzcGxheU5vZGUuZm9jdXMoKTtcbiAgICAgIH0sXG4gICAgICBub2RlOiBpbnB1dFJlZi5jdXJyZW50LFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfSwgW2Rpc3BsYXlOb2RlLCB2YWx1ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChhdXRvRm9jdXMgJiYgZGlzcGxheU5vZGUpIHtcbiAgICAgIGRpc3BsYXlOb2RlLmZvY3VzKCk7XG4gICAgfVxuICB9LCBbYXV0b0ZvY3VzLCBkaXNwbGF5Tm9kZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChkaXNwbGF5Tm9kZSkge1xuICAgICAgdmFyIGxhYmVsID0gb3duZXJEb2N1bWVudChkaXNwbGF5Tm9kZSkuZ2V0RWxlbWVudEJ5SWQobGFiZWxJZCk7XG5cbiAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKGdldFNlbGVjdGlvbigpLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICBkaXNwbGF5Tm9kZS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxhYmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSwgW2xhYmVsSWQsIGRpc3BsYXlOb2RlXSk7XG5cbiAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShvcGVuLCBldmVudCkge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBpZiAob25PcGVuKSB7XG4gICAgICAgIG9uT3BlbihldmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbkNsb3NlKSB7XG4gICAgICBvbkNsb3NlKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWlzT3BlbkNvbnRyb2xsZWQpIHtcbiAgICAgIHNldE1lbnVNaW5XaWR0aFN0YXRlKGF1dG9XaWR0aCA/IG51bGwgOiBkaXNwbGF5Tm9kZS5jbGllbnRXaWR0aCk7XG4gICAgICBzZXRPcGVuU3RhdGUob3Blbik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdC1jbGlja1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEhpamFjayB0aGUgZGVmYXVsdCBmb2N1cyBiZWhhdmlvci5cblxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwbGF5Tm9kZS5mb2N1cygpO1xuICAgIHVwZGF0ZSh0cnVlLCBldmVudCk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNsb3NlID0gZnVuY3Rpb24gaGFuZGxlQ2xvc2UoZXZlbnQpIHtcbiAgICB1cGRhdGUoZmFsc2UsIGV2ZW50KTtcbiAgfTtcblxuICB2YXIgY2hpbGRyZW5BcnJheSA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pOyAvLyBTdXBwb3J0IGF1dG9maWxsLlxuXG4gIHZhciBoYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgICB2YXIgaW5kZXggPSBjaGlsZHJlbkFycmF5Lm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5wcm9wcy52YWx1ZTtcbiAgICB9KS5pbmRleE9mKGV2ZW50LnRhcmdldC52YWx1ZSk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5BcnJheVtpbmRleF07XG4gICAgc2V0VmFsdWUoY2hpbGQucHJvcHMudmFsdWUpO1xuXG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICBvbkNoYW5nZShldmVudCwgY2hpbGQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlSXRlbUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlSXRlbUNsaWNrKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgICB1cGRhdGUoZmFsc2UsIGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1ZhbHVlO1xuXG4gICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiBbXTtcbiAgICAgICAgdmFyIGl0ZW1JbmRleCA9IHZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpO1xuXG4gICAgICAgIGlmIChpdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgbmV3VmFsdWUucHVzaChjaGlsZC5wcm9wcy52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3VmFsdWUuc3BsaWNlKGl0ZW1JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY2hpbGQucHJvcHMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZC5wcm9wcy5vbkNsaWNrKSB7XG4gICAgICAgIGNoaWxkLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2V0VmFsdWUobmV3VmFsdWUpO1xuXG4gICAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgICAgZXZlbnQucGVyc2lzdCgpOyAvLyBQcmVhY3Qgc3VwcG9ydCwgdGFyZ2V0IGlzIHJlYWQgb25seSBwcm9wZXJ0eSBvbiBhIG5hdGl2ZSBldmVudC5cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsICd0YXJnZXQnLCB7XG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvbkNoYW5nZShldmVudCwgY2hpbGQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKCFyZWFkT25seSkge1xuICAgICAgdmFyIHZhbGlkS2V5cyA9IFsnICcsICdBcnJvd1VwJywgJ0Fycm93RG93bicsIC8vIFRoZSBuYXRpdmUgc2VsZWN0IGRvZXNuJ3QgcmVzcG9uZCB0byBlbnRlciBvbiBNYWNPUywgYnV0IGl0J3MgcmVjb21tZW5kZWQgYnlcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMvZXhhbXBsZXMvbGlzdGJveC9saXN0Ym94LWNvbGxhcHNpYmxlLmh0bWxcbiAgICAgICdFbnRlciddO1xuXG4gICAgICBpZiAodmFsaWRLZXlzLmluZGV4T2YoZXZlbnQua2V5KSAhPT0gLTEpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdXBkYXRlKHRydWUsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIG9wZW4gPSBkaXNwbGF5Tm9kZSAhPT0gbnVsbCAmJiAoaXNPcGVuQ29udHJvbGxlZCA/IG9wZW5Qcm9wIDogb3BlblN0YXRlKTtcblxuICB2YXIgaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIGhhbmRsZUJsdXIoZXZlbnQpIHtcbiAgICAvLyBpZiBvcGVuIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblxuICAgIGlmICghb3BlbiAmJiBvbkJsdXIpIHtcbiAgICAgIGV2ZW50LnBlcnNpc3QoKTsgLy8gUHJlYWN0IHN1cHBvcnQsIHRhcmdldCBpcyByZWFkIG9ubHkgcHJvcGVydHkgb24gYSBuYXRpdmUgZXZlbnQuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgJ3RhcmdldCcsIHtcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbkJsdXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBkZWxldGUgb3RoZXJbJ2FyaWEtaW52YWxpZCddO1xuICB2YXIgZGlzcGxheTtcbiAgdmFyIGRpc3BsYXlTaW5nbGU7XG4gIHZhciBkaXNwbGF5TXVsdGlwbGUgPSBbXTtcbiAgdmFyIGNvbXB1dGVEaXNwbGF5ID0gZmFsc2U7XG4gIHZhciBmb3VuZE1hdGNoID0gZmFsc2U7IC8vIE5vIG5lZWQgdG8gZGlzcGxheSBhbnkgdmFsdWUgaWYgdGhlIGZpZWxkIGlzIGVtcHR5LlxuXG4gIGlmIChpc0ZpbGxlZCh7XG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pIHx8IGRpc3BsYXlFbXB0eSkge1xuICAgIGlmIChyZW5kZXJWYWx1ZSkge1xuICAgICAgZGlzcGxheSA9IHJlbmRlclZhbHVlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcHV0ZURpc3BsYXkgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpdGVtcyA9IGNoaWxkcmVuQXJyYXkubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmICghIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaXNGcmFnbWVudChjaGlsZCkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIFNlbGVjdCBjb21wb25lbnQgZG9lc24ndCBhY2NlcHQgYSBGcmFnbWVudCBhcyBhIGNoaWxkLlwiLCAnQ29uc2lkZXIgcHJvdmlkaW5nIGFuIGFycmF5IGluc3RlYWQuJ10uam9pbignXFxuJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzZWxlY3RlZDtcblxuICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJNYXRlcmlhbC1VSTogVGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGJlIGFuIGFycmF5IHdoZW4gdXNpbmcgdGhlIGBTZWxlY3RgIGNvbXBvbmVudCB3aXRoIGBtdWx0aXBsZWAuXCIgOiBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlKDIpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0ZWQgPSB2YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBhcmVFcXVhbFZhbHVlcyh2LCBjaGlsZC5wcm9wcy52YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNlbGVjdGVkICYmIGNvbXB1dGVEaXNwbGF5KSB7XG4gICAgICAgIGRpc3BsYXlNdWx0aXBsZS5wdXNoKGNoaWxkLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0ZWQgPSBhcmVFcXVhbFZhbHVlcyh2YWx1ZSwgY2hpbGQucHJvcHMudmFsdWUpO1xuXG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgY29tcHV0ZURpc3BsYXkpIHtcbiAgICAgICAgZGlzcGxheVNpbmdsZSA9IGNoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgZm91bmRNYXRjaCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICdhcmlhLXNlbGVjdGVkJzogc2VsZWN0ZWQgPyAndHJ1ZScgOiB1bmRlZmluZWQsXG4gICAgICBvbkNsaWNrOiBoYW5kbGVJdGVtQ2xpY2soY2hpbGQpLFxuICAgICAgb25LZXlVcDogZnVuY3Rpb24gb25LZXlVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICAvLyBvdGhlcndpc2Ugb3VyIE1lbnVJdGVtcyBkaXNwYXRjaGVzIGEgY2xpY2sgZXZlbnRcbiAgICAgICAgICAvLyBpdCdzIG5vdCBiZWhhdmlvciBvZiB0aGUgbmF0aXZlIDxvcHRpb24+IGFuZCBjYXVzZXNcbiAgICAgICAgICAvLyB0aGUgc2VsZWN0IHRvIGNsb3NlIGltbWVkaWF0ZWx5IHNpbmNlIHdlIG9wZW4gb24gc3BhY2Uga2V5ZG93blxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQucHJvcHMub25LZXlVcCkge1xuICAgICAgICAgIGNoaWxkLnByb3BzLm9uS2V5VXAoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcm9sZTogJ29wdGlvbicsXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgLy8gVGhlIHZhbHVlIGlzIG1vc3QgbGlrZWx5IG5vdCBhIHZhbGlkIEhUTUwgYXR0cmlidXRlLlxuICAgICAgJ2RhdGEtdmFsdWUnOiBjaGlsZC5wcm9wcy52YWx1ZSAvLyBJbnN0ZWFkLCB3ZSBwcm92aWRlIGl0IGFzIGEgZGF0YSBhdHRyaWJ1dGUuXG5cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFmb3VuZE1hdGNoICYmICFtdWx0aXBsZSAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGNoaWxkcmVuQXJyYXkubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZC5wcm9wcy52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUud2FybihbXCJNYXRlcmlhbC1VSTogWW91IGhhdmUgcHJvdmlkZWQgYW4gb3V0LW9mLXJhbmdlIHZhbHVlIGBcIi5jb25jYXQodmFsdWUsIFwiYCBmb3IgdGhlIHNlbGVjdCBcIikuY29uY2F0KG5hbWUgPyBcIihuYW1lPVxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiKSBcIikgOiAnJywgXCJjb21wb25lbnQuXCIpLCBcIkNvbnNpZGVyIHByb3ZpZGluZyBhIHZhbHVlIHRoYXQgbWF0Y2hlcyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBvcHRpb25zIG9yICcnLlwiLCBcIlRoZSBhdmFpbGFibGUgdmFsdWVzIGFyZSBcIi5jb25jYXQodmFsdWVzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4ICE9IG51bGw7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBcImBcIi5jb25jYXQoeCwgXCJgXCIpO1xuICAgICAgICB9KS5qb2luKCcsICcpIHx8ICdcIlwiJywgXCIuXCIpXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfSwgW2ZvdW5kTWF0Y2gsIGNoaWxkcmVuQXJyYXksIG11bHRpcGxlLCBuYW1lLCB2YWx1ZV0pO1xuICB9XG5cbiAgaWYgKGNvbXB1dGVEaXNwbGF5KSB7XG4gICAgZGlzcGxheSA9IG11bHRpcGxlID8gZGlzcGxheU11bHRpcGxlLmpvaW4oJywgJykgOiBkaXNwbGF5U2luZ2xlO1xuICB9IC8vIEF2b2lkIHBlcmZvcm1pbmcgYSBsYXlvdXQgY29tcHV0YXRpb24gaW4gdGhlIHJlbmRlciBtZXRob2QuXG5cblxuICB2YXIgbWVudU1pbldpZHRoID0gbWVudU1pbldpZHRoU3RhdGU7XG5cbiAgaWYgKCFhdXRvV2lkdGggJiYgaXNPcGVuQ29udHJvbGxlZCAmJiBkaXNwbGF5Tm9kZSkge1xuICAgIG1lbnVNaW5XaWR0aCA9IGRpc3BsYXlOb2RlLmNsaWVudFdpZHRoO1xuICB9XG5cbiAgdmFyIHRhYkluZGV4O1xuXG4gIGlmICh0eXBlb2YgdGFiSW5kZXhQcm9wICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRhYkluZGV4ID0gdGFiSW5kZXhQcm9wO1xuICB9IGVsc2Uge1xuICAgIHRhYkluZGV4ID0gZGlzYWJsZWQgPyBudWxsIDogMDtcbiAgfVxuXG4gIHZhciBidXR0b25JZCA9IFNlbGVjdERpc3BsYXlQcm9wcy5pZCB8fCAobmFtZSA/IFwibXVpLWNvbXBvbmVudC1zZWxlY3QtXCIuY29uY2F0KG5hbWUpIDogdW5kZWZpbmVkKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgLy8gVE9ETyB2NTogbWVyZ2Ugcm9vdCBhbmQgc2VsZWN0XG4gICAgY2xhc3Nlcy5zZWxlY3QsIGNsYXNzZXMuc2VsZWN0TWVudSwgY2xhc3Nlc1t2YXJpYW50XSwgY2xhc3NOYW1lLCBkaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkKSxcbiAgICByZWY6IHNldERpc3BsYXlOb2RlLFxuICAgIHRhYkluZGV4OiB0YWJJbmRleCxcbiAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCA/ICd0cnVlJyA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtZXhwYW5kZWRcIjogb3BlbiA/ICd0cnVlJyA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtaGFzcG9wdXBcIjogXCJsaXN0Ym94XCIsXG4gICAgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBbbGFiZWxJZCwgYnV0dG9uSWRdLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJykgfHwgdW5kZWZpbmVkLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBvbk1vdXNlRG93bjogZGlzYWJsZWQgfHwgcmVhZE9ubHkgPyBudWxsIDogaGFuZGxlTW91c2VEb3duLFxuICAgIG9uQmx1cjogaGFuZGxlQmx1cixcbiAgICBvbkZvY3VzOiBvbkZvY3VzXG4gIH0sIFNlbGVjdERpc3BsYXlQcm9wcywge1xuICAgIC8vIFRoZSBpZCBpcyByZXF1aXJlZCBmb3IgcHJvcGVyIGExMXlcbiAgICBpZDogYnV0dG9uSWRcbiAgfSksIGlzRW1wdHkoZGlzcGxheSkgP1xuICAvKiNfX1BVUkVfXyovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1kYW5nZXJcbiAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6ICcmIzgyMDM7J1xuICAgIH1cbiAgfSkgOiBkaXNwbGF5KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBfZXh0ZW5kcyh7XG4gICAgdmFsdWU6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCcpIDogdmFsdWUsXG4gICAgbmFtZTogbmFtZSxcbiAgICByZWY6IGlucHV0UmVmLFxuICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLFxuICAgIHRhYkluZGV4OiAtMSxcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMubmF0aXZlSW5wdXQsXG4gICAgYXV0b0ZvY3VzOiBhdXRvRm9jdXNcbiAgfSwgb3RoZXIpKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkNvbXBvbmVudCwge1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLmljb24sIGNsYXNzZXNbXCJpY29uXCIuY29uY2F0KGNhcGl0YWxpemUodmFyaWFudCkpXSwgb3BlbiAmJiBjbGFzc2VzLmljb25PcGVuLCBkaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkKVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVudSwgX2V4dGVuZHMoe1xuICAgIGlkOiBcIm1lbnUtXCIuY29uY2F0KG5hbWUgfHwgJycpLFxuICAgIGFuY2hvckVsOiBkaXNwbGF5Tm9kZSxcbiAgICBvcGVuOiBvcGVuLFxuICAgIG9uQ2xvc2U6IGhhbmRsZUNsb3NlXG4gIH0sIE1lbnVQcm9wcywge1xuICAgIE1lbnVMaXN0UHJvcHM6IF9leHRlbmRzKHtcbiAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsYWJlbElkLFxuICAgICAgcm9sZTogJ2xpc3Rib3gnLFxuICAgICAgZGlzYWJsZUxpc3RXcmFwOiB0cnVlXG4gICAgfSwgTWVudVByb3BzLk1lbnVMaXN0UHJvcHMpLFxuICAgIFBhcGVyUHJvcHM6IF9leHRlbmRzKHt9LCBNZW51UHJvcHMuUGFwZXJQcm9wcywge1xuICAgICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgICAgbWluV2lkdGg6IG1lbnVNaW5XaWR0aFxuICAgICAgfSwgTWVudVByb3BzLlBhcGVyUHJvcHMgIT0gbnVsbCA/IE1lbnVQcm9wcy5QYXBlclByb3BzLnN0eWxlIDogbnVsbClcbiAgICB9KVxuICB9KSwgaXRlbXMpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU2VsZWN0SW5wdXQucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgJ2FyaWEtbGFiZWwnOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB3aWR0aCBvZiB0aGUgcG9wb3ZlciB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgc2V0IGFjY29yZGluZyB0byB0aGUgaXRlbXMgaW5zaWRlIHRoZVxuICAgKiBtZW51LCBvdGhlcndpc2UgaXQgd2lsbCBiZSBhdCBsZWFzdCB0aGUgd2lkdGggb2YgdGhlIHNlbGVjdCBpbnB1dC5cbiAgICovXG4gIGF1dG9XaWR0aDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBvcHRpb24gZWxlbWVudHMgdG8gcG9wdWxhdGUgdGhlIHNlbGVjdCB3aXRoLlxuICAgKiBDYW4gYmUgc29tZSBgPE1lbnVJdGVtPmAgZWxlbWVudHMuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBUaGUgQ1NTIGNsYXNzIG5hbWUgb2YgdGhlIHNlbGVjdCBlbGVtZW50LlxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBlbGVtZW50IHZhbHVlLiBVc2Ugd2hlbiB0aGUgY29tcG9uZW50IGlzIG5vdCBjb250cm9sbGVkLlxuICAgKi9cbiAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBzZWxlY3Qgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgc2VsZWN0ZWQgaXRlbSBpcyBkaXNwbGF5ZWQgZXZlbiBpZiBpdHMgdmFsdWUgaXMgZW1wdHkuXG4gICAqL1xuICBkaXNwbGF5RW1wdHk6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiB0aGF0IGRpc3BsYXlzIHRoZSBhcnJvdy5cbiAgICovXG4gIEljb25Db21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBJbXBlcmF0aXZlIGhhbmRsZSBpbXBsZW1lbnRpbmcgYHsgdmFsdWU6IFQsIG5vZGU6IEhUTUxFbGVtZW50LCBmb2N1cygpOiB2b2lkIH1gXG4gICAqIEVxdWl2YWxlbnQgdG8gYHJlZmBcbiAgICovXG4gIGlucHV0UmVmOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgYW4gZWxlbWVudCB0aGF0IGFjdHMgYXMgYW4gYWRkaXRpb25hbCBsYWJlbC4gVGhlIFNlbGVjdCB3aWxsXG4gICAqIGJlIGxhYmVsbGVkIGJ5IHRoZSBhZGRpdGlvbmFsIGxhYmVsIGFuZCB0aGUgc2VsZWN0ZWQgdmFsdWUuXG4gICAqL1xuICBsYWJlbElkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYE1lbnVgXSgvYXBpL21lbnUvKSBlbGVtZW50LlxuICAgKi9cbiAgTWVudVByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGB2YWx1ZWAgbXVzdCBiZSBhbiBhcnJheSBhbmQgdGhlIG1lbnUgd2lsbCBzdXBwb3J0IG11bHRpcGxlIHNlbGVjdGlvbnMuXG4gICAqL1xuICBtdWx0aXBsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE5hbWUgYXR0cmlidXRlIG9mIHRoZSBgc2VsZWN0YCBvciBoaWRkZW4gYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gZmlyZWQgd2hlbiBhIG1lbnUgaXRlbSBpcyBzZWxlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgdmFsdWUgYnkgYWNjZXNzaW5nIGBldmVudC50YXJnZXQudmFsdWVgIChhbnkpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW2NoaWxkXSBUaGUgcmVhY3QgZWxlbWVudCB0aGF0IHdhcyBzZWxlY3RlZC5cbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IHJlcXVlc3RzIHRvIGJlIGNsb3NlZC5cbiAgICogVXNlIGluIGNvbnRyb2xsZWQgbW9kZSAoc2VlIG9wZW4pLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqL1xuICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCByZXF1ZXN0cyB0byBiZSBvcGVuZWQuXG4gICAqIFVzZSBpbiBjb250cm9sbGVkIG1vZGUgKHNlZSBvcGVuKS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgb25PcGVuOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ29udHJvbCBgc2VsZWN0YCBvcGVuIHN0YXRlLlxuICAgKi9cbiAgb3BlbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBzZWxlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSBgdmFsdWVgIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIEByZXR1cm5zIHtSZWFjdE5vZGV9XG4gICAqL1xuICByZW5kZXJWYWx1ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIGNsaWNrYWJsZSBkaXYgZWxlbWVudC5cbiAgICovXG4gIFNlbGVjdERpc3BsYXlQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdGFiSW5kZXg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdHlwZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogVGhlIGlucHV0IHZhbHVlLlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ3N0YW5kYXJkJywgJ291dGxpbmVkJywgJ2ZpbGxlZCddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IFNlbGVjdElucHV0OyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4uL3V0aWxzL2NhcGl0YWxpemUnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgIHdpZHRoOiAnMWVtJyxcbiAgICAgIGhlaWdodDogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgZmxleFNocmluazogMCxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjQpLFxuICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCdmaWxsJywge1xuICAgICAgICBkdXJhdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlclxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJwcmltYXJ5XCJgLiAqL1xuICAgIGNvbG9yUHJpbWFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwic2Vjb25kYXJ5XCJgLiAqL1xuICAgIGNvbG9yU2Vjb25kYXJ5OiB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpblxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBjb2xvcj1cImFjdGlvblwiYC4gKi9cbiAgICBjb2xvckFjdGlvbjoge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLmFjdGl2ZVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBjb2xvcj1cImVycm9yXCJgLiAqL1xuICAgIGNvbG9yRXJyb3I6IHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmVycm9yLm1haW5cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJkaXNhYmxlZFwiYC4gKi9cbiAgICBjb2xvckRpc2FibGVkOiB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZm9udFNpemU9XCJpbmhlcml0XCJgLiAqL1xuICAgIGZvbnRTaXplSW5oZXJpdDoge1xuICAgICAgZm9udFNpemU6ICdpbmhlcml0J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBmb250U2l6ZT1cInNtYWxsXCJgLiAqL1xuICAgIGZvbnRTaXplU21hbGw6IHtcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjApXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZvbnRTaXplPVwibGFyZ2VcImAuICovXG4gICAgZm9udFNpemVMYXJnZToge1xuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkucHhUb1JlbSgzNSlcbiAgICB9XG4gIH07XG59O1xudmFyIFN2Z0ljb24gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBTdmdJY29uKHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgY29sb3IgPSBfcHJvcHMkY29sb3IgPT09IHZvaWQgMCA/ICdpbmhlcml0JyA6IF9wcm9wcyRjb2xvcixcbiAgICAgIF9wcm9wcyRjb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBDb21wb25lbnQgPSBfcHJvcHMkY29tcG9uZW50ID09PSB2b2lkIDAgPyAnc3ZnJyA6IF9wcm9wcyRjb21wb25lbnQsXG4gICAgICBfcHJvcHMkZm9udFNpemUgPSBwcm9wcy5mb250U2l6ZSxcbiAgICAgIGZvbnRTaXplID0gX3Byb3BzJGZvbnRTaXplID09PSB2b2lkIDAgPyAnZGVmYXVsdCcgOiBfcHJvcHMkZm9udFNpemUsXG4gICAgICBodG1sQ29sb3IgPSBwcm9wcy5odG1sQ29sb3IsXG4gICAgICB0aXRsZUFjY2VzcyA9IHByb3BzLnRpdGxlQWNjZXNzLFxuICAgICAgX3Byb3BzJHZpZXdCb3ggPSBwcm9wcy52aWV3Qm94LFxuICAgICAgdmlld0JveCA9IF9wcm9wcyR2aWV3Qm94ID09PSB2b2lkIDAgPyAnMCAwIDI0IDI0JyA6IF9wcm9wcyR2aWV3Qm94LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNvbG9yXCIsIFwiY29tcG9uZW50XCIsIFwiZm9udFNpemVcIiwgXCJodG1sQ29sb3JcIiwgXCJ0aXRsZUFjY2Vzc1wiLCBcInZpZXdCb3hcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUsIGNvbG9yICE9PSAnaW5oZXJpdCcgJiYgY2xhc3Nlc1tcImNvbG9yXCIuY29uY2F0KGNhcGl0YWxpemUoY29sb3IpKV0sIGZvbnRTaXplICE9PSAnZGVmYXVsdCcgJiYgY2xhc3Nlc1tcImZvbnRTaXplXCIuY29uY2F0KGNhcGl0YWxpemUoZm9udFNpemUpKV0pLFxuICAgIGZvY3VzYWJsZTogXCJmYWxzZVwiLFxuICAgIHZpZXdCb3g6IHZpZXdCb3gsXG4gICAgY29sb3I6IGh0bWxDb2xvcixcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRpdGxlQWNjZXNzID8gdW5kZWZpbmVkIDogdHJ1ZSxcbiAgICByb2xlOiB0aXRsZUFjY2VzcyA/ICdpbWcnIDogdW5kZWZpbmVkLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSwgY2hpbGRyZW4sIHRpdGxlQWNjZXNzID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCB0aXRsZUFjY2VzcykgOiBudWxsKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU3ZnSWNvbi5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBOb2RlIHBhc3NlZCBpbnRvIHRoZSBTVkcgZWxlbWVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LiBJdCBzdXBwb3J0cyB0aG9zZSB0aGVtZSBjb2xvcnMgdGhhdCBtYWtlIHNlbnNlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICogWW91IGNhbiB1c2UgdGhlIGBodG1sQ29sb3JgIHByb3AgdG8gYXBwbHkgYSBjb2xvciBhdHRyaWJ1dGUgdG8gdGhlIFNWRyBlbGVtZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ2FjdGlvbicsICdkaXNhYmxlZCcsICdlcnJvcicsICdpbmhlcml0JywgJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogVGhlIGZvbnRTaXplIGFwcGxpZWQgdG8gdGhlIGljb24uIERlZmF1bHRzIHRvIDI0cHgsIGJ1dCBjYW4gYmUgY29uZmlndXJlIHRvIGluaGVyaXQgZm9udCBzaXplLlxuICAgKi9cbiAgZm9udFNpemU6IFByb3BUeXBlcy5vbmVPZihbJ2RlZmF1bHQnLCAnaW5oZXJpdCcsICdsYXJnZScsICdzbWFsbCddKSxcblxuICAvKipcbiAgICogQXBwbGllcyBhIGNvbG9yIGF0dHJpYnV0ZSB0byB0aGUgU1ZHIGVsZW1lbnQuXG4gICAqL1xuICBodG1sQ29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBzaGFwZS1yZW5kZXJpbmcgYXR0cmlidXRlLiBUaGUgYmVoYXZpb3Igb2YgdGhlIGRpZmZlcmVudCBvcHRpb25zIGlzIGRlc2NyaWJlZCBvbiB0aGVcbiAgICogW01ETiBXZWIgRG9jc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zaGFwZS1yZW5kZXJpbmcpLlxuICAgKiBJZiB5b3UgYXJlIGhhdmluZyBpc3N1ZXMgd2l0aCBibHVycnkgaWNvbnMgeW91IHNob3VsZCBpbnZlc3RpZ2F0ZSB0aGlzIHByb3BlcnR5LlxuICAgKi9cbiAgc2hhcGVSZW5kZXJpbmc6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgaHVtYW4tcmVhZGFibGUgdGl0bGUgZm9yIHRoZSBlbGVtZW50IHRoYXQgY29udGFpbnMgaXQuXG4gICAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkctYWNjZXNzLyNFcXVpdmFsZW50XG4gICAqL1xuICB0aXRsZUFjY2VzczogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQWxsb3dzIHlvdSB0byByZWRlZmluZSB3aGF0IHRoZSBjb29yZGluYXRlcyB3aXRob3V0IHVuaXRzIG1lYW4gaW5zaWRlIGFuIFNWRyBlbGVtZW50LlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIFNWRyBlbGVtZW50IGlzIDUwMCAod2lkdGgpIGJ5IDIwMCAoaGVpZ2h0KSxcbiAgICogYW5kIHlvdSBwYXNzIHZpZXdCb3g9XCIwIDAgNTAgMjBcIixcbiAgICogdGhpcyBtZWFucyB0aGF0IHRoZSBjb29yZGluYXRlcyBpbnNpZGUgdGhlIFNWRyB3aWxsIGdvIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciAoMCwwKVxuICAgKiB0byBib3R0b20gcmlnaHQgKDUwLDIwKSBhbmQgZWFjaCB1bml0IHdpbGwgYmUgd29ydGggMTBweC5cbiAgICovXG4gIHZpZXdCb3g6IFByb3BUeXBlcy5zdHJpbmdcbn0gOiB2b2lkIDA7XG5TdmdJY29uLm11aU5hbWUgPSAnU3ZnSWNvbic7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpU3ZnSWNvbidcbn0pKFN2Z0ljb24pOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBTdmdJY29uIGZyb20gJy4uL1N2Z0ljb24nO1xuLyoqXG4gKiBQcml2YXRlIG1vZHVsZSByZXNlcnZlZCBmb3IgQG1hdGVyaWFsLXVpL3ggcGFja2FnZXMuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU3ZnSWNvbihwYXRoLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3ZnSWNvbiwgX2V4dGVuZHMoe1xuICAgICAgcmVmOiByZWZcbiAgICB9LCBwcm9wcyksIHBhdGgpO1xuICB9O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gTmVlZCB0byBzZXQgYGRpc3BsYXlOYW1lYCBvbiB0aGUgaW5uZXIgY29tcG9uZW50IGZvciBSZWFjdC5tZW1vLlxuICAgIC8vIFJlYWN0IHByaW9yIHRvIDE2LjE0IGlnbm9yZXMgYGRpc3BsYXlOYW1lYCBvbiB0aGUgd3JhcHBlci5cbiAgICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSBcIlwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCJJY29uXCIpO1xuICB9XG5cbiAgQ29tcG9uZW50Lm11aU5hbWUgPSBTdmdJY29uLm11aU5hbWU7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyggLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoQ29tcG9uZW50KSk7XG59IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNyZWF0ZVN2Z0ljb24gZnJvbSAnLi4vLi4vdXRpbHMvY3JlYXRlU3ZnSWNvbic7XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU3ZnSWNvbiggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgZDogXCJNNyAxMGw1IDUgNS01elwiXG59KSwgJ0Fycm93RHJvcERvd24nKTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyByZWZUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4uL3V0aWxzL2NhcGl0YWxpemUnO1xuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5cbnZhciBOYXRpdmVTZWxlY3RJbnB1dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE5hdGl2ZVNlbGVjdElucHV0KHByb3BzLCByZWYpIHtcbiAgdmFyIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIEljb25Db21wb25lbnQgPSBwcm9wcy5JY29uQ29tcG9uZW50LFxuICAgICAgaW5wdXRSZWYgPSBwcm9wcy5pbnB1dFJlZixcbiAgICAgIF9wcm9wcyR2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIHZhcmlhbnQgPSBfcHJvcHMkdmFyaWFudCA9PT0gdm9pZCAwID8gJ3N0YW5kYXJkJyA6IF9wcm9wcyR2YXJpYW50LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJkaXNhYmxlZFwiLCBcIkljb25Db21wb25lbnRcIiwgXCJpbnB1dFJlZlwiLCBcInZhcmlhbnRcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIC8vIFRPRE8gdjU6IG1lcmdlIHJvb3QgYW5kIHNlbGVjdFxuICAgIGNsYXNzZXMuc2VsZWN0LCBjbGFzc2VzW3ZhcmlhbnRdLCBjbGFzc05hbWUsIGRpc2FibGVkICYmIGNsYXNzZXMuZGlzYWJsZWQpLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICByZWY6IGlucHV0UmVmIHx8IHJlZlxuICB9LCBvdGhlcikpLCBwcm9wcy5tdWx0aXBsZSA/IG51bGwgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQ29tcG9uZW50LCB7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMuaWNvbiwgY2xhc3Nlc1tcImljb25cIi5jb25jYXQoY2FwaXRhbGl6ZSh2YXJpYW50KSldLCBkaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkKVxuICB9KSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IE5hdGl2ZVNlbGVjdElucHV0LnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFRoZSBvcHRpb24gZWxlbWVudHMgdG8gcG9wdWxhdGUgdGhlIHNlbGVjdCB3aXRoLlxuICAgKiBDYW4gYmUgc29tZSBgPG9wdGlvbj5gIGVsZW1lbnRzLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogVGhlIENTUyBjbGFzcyBuYW1lIG9mIHRoZSBzZWxlY3QgZWxlbWVudC5cbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgc2VsZWN0IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBpY29uIHRoYXQgZGlzcGxheXMgdGhlIGFycm93LlxuICAgKi9cbiAgSWNvbkNvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFVzZSB0aGF0IHByb3AgdG8gcGFzcyBhIHJlZiB0byB0aGUgbmF0aXZlIHNlbGVjdCBlbGVtZW50LlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgaW5wdXRSZWY6IHJlZlR5cGUsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG11bHRpcGxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTmFtZSBhdHRyaWJ1dGUgb2YgdGhlIGBzZWxlY3RgIG9yIGhpZGRlbiBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBmaXJlZCB3aGVuIGEgbWVudSBpdGVtIGlzIHNlbGVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqIFlvdSBjYW4gcHVsbCBvdXQgdGhlIG5ldyB2YWx1ZSBieSBhY2Nlc3NpbmcgYGV2ZW50LnRhcmdldC52YWx1ZWAgKHN0cmluZykuXG4gICAqL1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCB2YWx1ZS5cbiAgICovXG4gIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydzdGFuZGFyZCcsICdvdXRsaW5lZCcsICdmaWxsZWQnXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCBOYXRpdmVTZWxlY3RJbnB1dDsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE5hdGl2ZVNlbGVjdElucHV0IGZyb20gJy4vTmF0aXZlU2VsZWN0SW5wdXQnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IGZvcm1Db250cm9sU3RhdGUgZnJvbSAnLi4vRm9ybUNvbnRyb2wvZm9ybUNvbnRyb2xTdGF0ZSc7XG5pbXBvcnQgdXNlRm9ybUNvbnRyb2wgZnJvbSAnLi4vRm9ybUNvbnRyb2wvdXNlRm9ybUNvbnRyb2wnO1xuaW1wb3J0IEFycm93RHJvcERvd25JY29uIGZyb20gJy4uL2ludGVybmFsL3N2Zy1pY29ucy9BcnJvd0Ryb3BEb3duJztcbmltcG9ydCBJbnB1dCBmcm9tICcuLi9JbnB1dCc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBzZWxlY3QgY29tcG9uZW50IGByb290YCBjbGFzcy4gKi9cbiAgICByb290OiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBzZWxlY3QgY29tcG9uZW50IGBzZWxlY3RgIGNsYXNzLiAqL1xuICAgIHNlbGVjdDoge1xuICAgICAgJy1tb3otYXBwZWFyYW5jZSc6ICdub25lJyxcbiAgICAgIC8vIFJlc2V0XG4gICAgICAnLXdlYmtpdC1hcHBlYXJhbmNlJzogJ25vbmUnLFxuICAgICAgLy8gUmVzZXRcbiAgICAgIC8vIFdoZW4gaW50ZXJhY3RpbmcgcXVpY2tseSwgdGhlIHRleHQgY2FuIGVuZCB1cCBzZWxlY3RlZC5cbiAgICAgIC8vIE5hdGl2ZSBzZWxlY3QgY2FuJ3QgYmUgc2VsZWN0ZWQgZWl0aGVyLlxuICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgLy8gUmVzZXRcbiAgICAgIG1pbldpZHRoOiAxNixcbiAgICAgIC8vIFNvIGl0IGRvZXNuJ3QgY29sbGFwc2UuXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICcmOmZvY3VzJzoge1xuICAgICAgICAvLyBTaG93IHRoYXQgaXQncyBub3QgYW4gdGV4dCBpbnB1dFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUudHlwZSA9PT0gJ2xpZ2h0JyA/ICdyZ2JhKDAsIDAsIDAsIDAuMDUpJyA6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDUpJyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAwIC8vIFJlc2V0IENocm9tZSBzdHlsZVxuXG4gICAgICB9LFxuICAgICAgLy8gUmVtb3ZlIElFIDExIGFycm93XG4gICAgICAnJjo6LW1zLWV4cGFuZCc6IHtcbiAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICB9LFxuICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnXG4gICAgICB9LFxuICAgICAgJyZbbXVsdGlwbGVdJzoge1xuICAgICAgICBoZWlnaHQ6ICdhdXRvJ1xuICAgICAgfSxcbiAgICAgICcmOm5vdChbbXVsdGlwbGVdKSBvcHRpb24sICY6bm90KFttdWx0aXBsZV0pIG9wdGdyb3VwJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUuYmFja2dyb3VuZC5wYXBlclxuICAgICAgfSxcbiAgICAgICcmJic6IHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiAyNFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgc2VsZWN0IGNvbXBvbmVudCBpZiBgdmFyaWFudD1cImZpbGxlZFwiYC4gKi9cbiAgICBmaWxsZWQ6IHtcbiAgICAgICcmJic6IHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiAzMlxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgc2VsZWN0IGNvbXBvbmVudCBpZiBgdmFyaWFudD1cIm91dGxpbmVkXCJgLiAqL1xuICAgIG91dGxpbmVkOiB7XG4gICAgICBib3JkZXJSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1cyxcbiAgICAgICcmJic6IHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiAzMlxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgc2VsZWN0IGNvbXBvbmVudCBgc2VsZWN0TWVudWAgY2xhc3MuICovXG4gICAgc2VsZWN0TWVudToge1xuICAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICAvLyBSZXNldHMgZm9yIG11bHRwaWxlIHNlbGVjdCB3aXRoIGNoaXBzXG4gICAgICBtaW5IZWlnaHQ6ICcxLjE4NzZlbScsXG4gICAgICAvLyBSZXF1aXJlZCBmb3Igc2VsZWN0XFx0ZXh0LWZpZWxkIGhlaWdodCBjb25zaXN0ZW5jeVxuICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICB9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHNlbGVjdCBjb21wb25lbnQgYGRpc2FibGVkYCBjbGFzcy4gKi9cbiAgICBkaXNhYmxlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaWNvbiBjb21wb25lbnQuICovXG4gICAgaWNvbjoge1xuICAgICAgLy8gV2UgdXNlIGEgcG9zaXRpb24gYWJzb2x1dGUgb3ZlciBhIGZsZXhib3ggaW4gb3JkZXIgdG8gZm9yd2FyZCB0aGUgcG9pbnRlciBldmVudHNcbiAgICAgIC8vIHRvIHRoZSBpbnB1dCBhbmQgdG8gc3VwcG9ydCB3cmFwcGluZyB0YWdzLi5cbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6ICdjYWxjKDUwJSAtIDEycHgpJyxcbiAgICAgIC8vIENlbnRlciB2ZXJ0aWNhbGx5XG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAvLyBEb24ndCBibG9jayBwb2ludGVyIGV2ZW50cyBvbiB0aGUgc2VsZWN0IHVuZGVyIHRoZSBpY29uLlxuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLmFjdGl2ZSxcbiAgICAgICcmJGRpc2FibGVkJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGljb24gY29tcG9uZW50IGlmIHRoZSBwb3B1cCBpcyBvcGVuLiAqL1xuICAgIGljb25PcGVuOiB7XG4gICAgICB0cmFuc2Zvcm06ICdyb3RhdGUoMTgwZGVnKSdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGljb24gY29tcG9uZW50IGlmIGB2YXJpYW50PVwiZmlsbGVkXCJgLiAqL1xuICAgIGljb25GaWxsZWQ6IHtcbiAgICAgIHJpZ2h0OiA3XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpY29uIGNvbXBvbmVudCBpZiBgdmFyaWFudD1cIm91dGxpbmVkXCJgLiAqL1xuICAgIGljb25PdXRsaW5lZDoge1xuICAgICAgcmlnaHQ6IDdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHVuZGVybHlpbmcgbmF0aXZlIGlucHV0IGNvbXBvbmVudC4gKi9cbiAgICBuYXRpdmVJbnB1dDoge1xuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICB9XG4gIH07XG59O1xudmFyIGRlZmF1bHRJbnB1dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KElucHV0LCBudWxsKTtcbi8qKlxuICogQW4gYWx0ZXJuYXRpdmUgdG8gYDxTZWxlY3QgbmF0aXZlIC8+YCB3aXRoIGEgbXVjaCBzbWFsbGVyIGJ1bmRsZSBzaXplIGZvb3RwcmludC5cbiAqL1xuXG52YXIgTmF0aXZlU2VsZWN0ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTmF0aXZlU2VsZWN0KHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIF9wcm9wcyRJY29uQ29tcG9uZW50ID0gcHJvcHMuSWNvbkNvbXBvbmVudCxcbiAgICAgIEljb25Db21wb25lbnQgPSBfcHJvcHMkSWNvbkNvbXBvbmVudCA9PT0gdm9pZCAwID8gQXJyb3dEcm9wRG93bkljb24gOiBfcHJvcHMkSWNvbkNvbXBvbmVudCxcbiAgICAgIF9wcm9wcyRpbnB1dCA9IHByb3BzLmlucHV0LFxuICAgICAgaW5wdXQgPSBfcHJvcHMkaW5wdXQgPT09IHZvaWQgMCA/IGRlZmF1bHRJbnB1dCA6IF9wcm9wcyRpbnB1dCxcbiAgICAgIGlucHV0UHJvcHMgPSBwcm9wcy5pbnB1dFByb3BzLFxuICAgICAgdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiSWNvbkNvbXBvbmVudFwiLCBcImlucHV0XCIsIFwiaW5wdXRQcm9wc1wiLCBcInZhcmlhbnRcIl0pO1xuXG4gIHZhciBtdWlGb3JtQ29udHJvbCA9IHVzZUZvcm1Db250cm9sKCk7XG4gIHZhciBmY3MgPSBmb3JtQ29udHJvbFN0YXRlKHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgbXVpRm9ybUNvbnRyb2w6IG11aUZvcm1Db250cm9sLFxuICAgIHN0YXRlczogWyd2YXJpYW50J11cbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGlucHV0LCBfZXh0ZW5kcyh7XG4gICAgLy8gTW9zdCBvZiB0aGUgbG9naWMgaXMgaW1wbGVtZW50ZWQgaW4gYE5hdGl2ZVNlbGVjdElucHV0YC5cbiAgICAvLyBUaGUgYFNlbGVjdGAgY29tcG9uZW50IGlzIGEgc2ltcGxlIEFQSSB3cmFwcGVyIHRvIGV4cG9zZSBzb21ldGhpbmcgYmV0dGVyIHRvIHBsYXkgd2l0aC5cbiAgICBpbnB1dENvbXBvbmVudDogTmF0aXZlU2VsZWN0SW5wdXQsXG4gICAgaW5wdXRQcm9wczogX2V4dGVuZHMoe1xuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgY2xhc3NlczogY2xhc3NlcyxcbiAgICAgIEljb25Db21wb25lbnQ6IEljb25Db21wb25lbnQsXG4gICAgICB2YXJpYW50OiBmY3MudmFyaWFudCxcbiAgICAgIHR5cGU6IHVuZGVmaW5lZFxuICAgIH0sIGlucHV0UHJvcHMsIGlucHV0ID8gaW5wdXQucHJvcHMuaW5wdXRQcm9wcyA6IHt9KSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlcikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBOYXRpdmVTZWxlY3QucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhlIG9wdGlvbiBlbGVtZW50cyB0byBwb3B1bGF0ZSB0aGUgc2VsZWN0IHdpdGguXG4gICAqIENhbiBiZSBzb21lIGA8b3B0aW9uPmAgZWxlbWVudHMuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogVGhlIGljb24gdGhhdCBkaXNwbGF5cyB0aGUgYXJyb3cuXG4gICAqL1xuICBJY29uQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG5cbiAgLyoqXG4gICAqIEFuIGBJbnB1dGAgZWxlbWVudDsgZG9lcyBub3QgaGF2ZSB0byBiZSBhIG1hdGVyaWFsLXVpIHNwZWNpZmljIGBJbnB1dGAuXG4gICAqL1xuICBpbnB1dDogUHJvcFR5cGVzLmVsZW1lbnQsXG5cbiAgLyoqXG4gICAqIEF0dHJpYnV0ZXMgYXBwbGllZCB0byB0aGUgYHNlbGVjdGAgZWxlbWVudC5cbiAgICovXG4gIGlucHV0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGZpcmVkIHdoZW4gYSBtZW51IGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICogWW91IGNhbiBwdWxsIG91dCB0aGUgbmV3IHZhbHVlIGJ5IGFjY2Vzc2luZyBgZXZlbnQudGFyZ2V0LnZhbHVlYCAoc3RyaW5nKS5cbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogVGhlIGlucHV0IHZhbHVlLiBUaGUgRE9NIEFQSSBjYXN0cyB0aGlzIHRvIGEgc3RyaW5nLlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ2ZpbGxlZCcsICdvdXRsaW5lZCcsICdzdGFuZGFyZCddKVxufSA6IHZvaWQgMDtcbk5hdGl2ZVNlbGVjdC5tdWlOYW1lID0gJ1NlbGVjdCc7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpTmF0aXZlU2VsZWN0J1xufSkoTmF0aXZlU2VsZWN0KTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3N0eWxlcyc7XG5pbXBvcnQgU2VsZWN0SW5wdXQgZnJvbSAnLi9TZWxlY3RJbnB1dCc7XG5pbXBvcnQgZm9ybUNvbnRyb2xTdGF0ZSBmcm9tICcuLi9Gb3JtQ29udHJvbC9mb3JtQ29udHJvbFN0YXRlJztcbmltcG9ydCB1c2VGb3JtQ29udHJvbCBmcm9tICcuLi9Gb3JtQ29udHJvbC91c2VGb3JtQ29udHJvbCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgQXJyb3dEcm9wRG93bkljb24gZnJvbSAnLi4vaW50ZXJuYWwvc3ZnLWljb25zL0Fycm93RHJvcERvd24nO1xuaW1wb3J0IElucHV0IGZyb20gJy4uL0lucHV0JztcbmltcG9ydCB7IHN0eWxlcyBhcyBuYXRpdmVTZWxlY3RTdHlsZXMgfSBmcm9tICcuLi9OYXRpdmVTZWxlY3QvTmF0aXZlU2VsZWN0JztcbmltcG9ydCBOYXRpdmVTZWxlY3RJbnB1dCBmcm9tICcuLi9OYXRpdmVTZWxlY3QvTmF0aXZlU2VsZWN0SW5wdXQnO1xuaW1wb3J0IEZpbGxlZElucHV0IGZyb20gJy4uL0ZpbGxlZElucHV0JztcbmltcG9ydCBPdXRsaW5lZElucHV0IGZyb20gJy4uL091dGxpbmVkSW5wdXQnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBuYXRpdmVTZWxlY3RTdHlsZXM7XG5cbnZhciBfcmVmID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXQsIG51bGwpO1xuXG52YXIgX3JlZjIgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGaWxsZWRJbnB1dCwgbnVsbCk7XG5cbnZhciBTZWxlY3QgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBTZWxlY3QocHJvcHMsIHJlZikge1xuICB2YXIgX3Byb3BzJGF1dG9XaWR0aCA9IHByb3BzLmF1dG9XaWR0aCxcbiAgICAgIGF1dG9XaWR0aCA9IF9wcm9wcyRhdXRvV2lkdGggPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGF1dG9XaWR0aCxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIF9wcm9wcyRkaXNwbGF5RW1wdHkgPSBwcm9wcy5kaXNwbGF5RW1wdHksXG4gICAgICBkaXNwbGF5RW1wdHkgPSBfcHJvcHMkZGlzcGxheUVtcHR5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNwbGF5RW1wdHksXG4gICAgICBfcHJvcHMkSWNvbkNvbXBvbmVudCA9IHByb3BzLkljb25Db21wb25lbnQsXG4gICAgICBJY29uQ29tcG9uZW50ID0gX3Byb3BzJEljb25Db21wb25lbnQgPT09IHZvaWQgMCA/IEFycm93RHJvcERvd25JY29uIDogX3Byb3BzJEljb25Db21wb25lbnQsXG4gICAgICBpZCA9IHByb3BzLmlkLFxuICAgICAgaW5wdXQgPSBwcm9wcy5pbnB1dCxcbiAgICAgIGlucHV0UHJvcHMgPSBwcm9wcy5pbnB1dFByb3BzLFxuICAgICAgbGFiZWwgPSBwcm9wcy5sYWJlbCxcbiAgICAgIGxhYmVsSWQgPSBwcm9wcy5sYWJlbElkLFxuICAgICAgX3Byb3BzJGxhYmVsV2lkdGggPSBwcm9wcy5sYWJlbFdpZHRoLFxuICAgICAgbGFiZWxXaWR0aCA9IF9wcm9wcyRsYWJlbFdpZHRoID09PSB2b2lkIDAgPyAwIDogX3Byb3BzJGxhYmVsV2lkdGgsXG4gICAgICBNZW51UHJvcHMgPSBwcm9wcy5NZW51UHJvcHMsXG4gICAgICBfcHJvcHMkbXVsdGlwbGUgPSBwcm9wcy5tdWx0aXBsZSxcbiAgICAgIG11bHRpcGxlID0gX3Byb3BzJG11bHRpcGxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRtdWx0aXBsZSxcbiAgICAgIF9wcm9wcyRuYXRpdmUgPSBwcm9wcy5uYXRpdmUsXG4gICAgICBuYXRpdmUgPSBfcHJvcHMkbmF0aXZlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRuYXRpdmUsXG4gICAgICBvbkNsb3NlID0gcHJvcHMub25DbG9zZSxcbiAgICAgIG9uT3BlbiA9IHByb3BzLm9uT3BlbixcbiAgICAgIG9wZW4gPSBwcm9wcy5vcGVuLFxuICAgICAgcmVuZGVyVmFsdWUgPSBwcm9wcy5yZW5kZXJWYWx1ZSxcbiAgICAgIFNlbGVjdERpc3BsYXlQcm9wcyA9IHByb3BzLlNlbGVjdERpc3BsYXlQcm9wcyxcbiAgICAgIF9wcm9wcyR2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIHZhcmlhbnRQcm9wcyA9IF9wcm9wcyR2YXJpYW50ID09PSB2b2lkIDAgPyAnc3RhbmRhcmQnIDogX3Byb3BzJHZhcmlhbnQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYXV0b1dpZHRoXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiZGlzcGxheUVtcHR5XCIsIFwiSWNvbkNvbXBvbmVudFwiLCBcImlkXCIsIFwiaW5wdXRcIiwgXCJpbnB1dFByb3BzXCIsIFwibGFiZWxcIiwgXCJsYWJlbElkXCIsIFwibGFiZWxXaWR0aFwiLCBcIk1lbnVQcm9wc1wiLCBcIm11bHRpcGxlXCIsIFwibmF0aXZlXCIsIFwib25DbG9zZVwiLCBcIm9uT3BlblwiLCBcIm9wZW5cIiwgXCJyZW5kZXJWYWx1ZVwiLCBcIlNlbGVjdERpc3BsYXlQcm9wc1wiLCBcInZhcmlhbnRcIl0pO1xuXG4gIHZhciBpbnB1dENvbXBvbmVudCA9IG5hdGl2ZSA/IE5hdGl2ZVNlbGVjdElucHV0IDogU2VsZWN0SW5wdXQ7XG4gIHZhciBtdWlGb3JtQ29udHJvbCA9IHVzZUZvcm1Db250cm9sKCk7XG4gIHZhciBmY3MgPSBmb3JtQ29udHJvbFN0YXRlKHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgbXVpRm9ybUNvbnRyb2w6IG11aUZvcm1Db250cm9sLFxuICAgIHN0YXRlczogWyd2YXJpYW50J11cbiAgfSk7XG4gIHZhciB2YXJpYW50ID0gZmNzLnZhcmlhbnQgfHwgdmFyaWFudFByb3BzO1xuICB2YXIgSW5wdXRDb21wb25lbnQgPSBpbnB1dCB8fCB7XG4gICAgc3RhbmRhcmQ6IF9yZWYsXG4gICAgb3V0bGluZWQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE91dGxpbmVkSW5wdXQsIHtcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIGxhYmVsV2lkdGg6IGxhYmVsV2lkdGhcbiAgICB9KSxcbiAgICBmaWxsZWQ6IF9yZWYyXG4gIH1bdmFyaWFudF07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KElucHV0Q29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgLy8gTW9zdCBvZiB0aGUgbG9naWMgaXMgaW1wbGVtZW50ZWQgaW4gYFNlbGVjdElucHV0YC5cbiAgICAvLyBUaGUgYFNlbGVjdGAgY29tcG9uZW50IGlzIGEgc2ltcGxlIEFQSSB3cmFwcGVyIHRvIGV4cG9zZSBzb21ldGhpbmcgYmV0dGVyIHRvIHBsYXkgd2l0aC5cbiAgICBpbnB1dENvbXBvbmVudDogaW5wdXRDb21wb25lbnQsXG4gICAgaW5wdXRQcm9wczogX2V4dGVuZHMoe1xuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgSWNvbkNvbXBvbmVudDogSWNvbkNvbXBvbmVudCxcbiAgICAgIHZhcmlhbnQ6IHZhcmlhbnQsXG4gICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICAvLyBXZSByZW5kZXIgYSBzZWxlY3QuIFdlIGNhbiBpZ25vcmUgdGhlIHR5cGUgcHJvdmlkZWQgYnkgdGhlIGBJbnB1dGAuXG4gICAgICBtdWx0aXBsZTogbXVsdGlwbGVcbiAgICB9LCBuYXRpdmUgPyB7XG4gICAgICBpZDogaWRcbiAgICB9IDoge1xuICAgICAgYXV0b1dpZHRoOiBhdXRvV2lkdGgsXG4gICAgICBkaXNwbGF5RW1wdHk6IGRpc3BsYXlFbXB0eSxcbiAgICAgIGxhYmVsSWQ6IGxhYmVsSWQsXG4gICAgICBNZW51UHJvcHM6IE1lbnVQcm9wcyxcbiAgICAgIG9uQ2xvc2U6IG9uQ2xvc2UsXG4gICAgICBvbk9wZW46IG9uT3BlbixcbiAgICAgIG9wZW46IG9wZW4sXG4gICAgICByZW5kZXJWYWx1ZTogcmVuZGVyVmFsdWUsXG4gICAgICBTZWxlY3REaXNwbGF5UHJvcHM6IF9leHRlbmRzKHtcbiAgICAgICAgaWQ6IGlkXG4gICAgICB9LCBTZWxlY3REaXNwbGF5UHJvcHMpXG4gICAgfSwgaW5wdXRQcm9wcywge1xuICAgICAgY2xhc3NlczogaW5wdXRQcm9wcyA/IG1lcmdlQ2xhc3Nlcyh7XG4gICAgICAgIGJhc2VDbGFzc2VzOiBjbGFzc2VzLFxuICAgICAgICBuZXdDbGFzc2VzOiBpbnB1dFByb3BzLmNsYXNzZXMsXG4gICAgICAgIENvbXBvbmVudDogU2VsZWN0XG4gICAgICB9KSA6IGNsYXNzZXNcbiAgICB9LCBpbnB1dCA/IGlucHV0LnByb3BzLmlucHV0UHJvcHMgOiB7fSksXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU2VsZWN0LnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHdpZHRoIG9mIHRoZSBwb3BvdmVyIHdpbGwgYXV0b21hdGljYWxseSBiZSBzZXQgYWNjb3JkaW5nIHRvIHRoZSBpdGVtcyBpbnNpZGUgdGhlXG4gICAqIG1lbnUsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGF0IGxlYXN0IHRoZSB3aWR0aCBvZiB0aGUgc2VsZWN0IGlucHV0LlxuICAgKi9cbiAgYXV0b1dpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIG9wdGlvbiBlbGVtZW50cyB0byBwb3B1bGF0ZSB0aGUgc2VsZWN0IHdpdGguXG4gICAqIENhbiBiZSBzb21lIGBNZW51SXRlbWAgd2hlbiBgbmF0aXZlYCBpcyBmYWxzZSBhbmQgYG9wdGlvbmAgd2hlbiBgbmF0aXZlYCBpcyB0cnVlLlxuICAgKlxuICAgKiDimqDvuI9UaGUgYE1lbnVJdGVtYCBlbGVtZW50cyAqKm11c3QqKiBiZSBkaXJlY3QgZGVzY2VuZGFudHMgd2hlbiBgbmF0aXZlYCBpcyBmYWxzZS5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBlbGVtZW50IHZhbHVlLiBVc2Ugd2hlbiB0aGUgY29tcG9uZW50IGlzIG5vdCBjb250cm9sbGVkLlxuICAgKi9cbiAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGEgdmFsdWUgaXMgZGlzcGxheWVkIGV2ZW4gaWYgbm8gaXRlbXMgYXJlIHNlbGVjdGVkLlxuICAgKlxuICAgKiBJbiBvcmRlciB0byBkaXNwbGF5IGEgbWVhbmluZ2Z1bCB2YWx1ZSwgYSBmdW5jdGlvbiBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBgcmVuZGVyVmFsdWVgIHByb3Agd2hpY2ggcmV0dXJucyB0aGUgdmFsdWUgdG8gYmUgZGlzcGxheWVkIHdoZW4gbm8gaXRlbXMgYXJlIHNlbGVjdGVkLlxuICAgKiBZb3UgY2FuIG9ubHkgdXNlIGl0IHdoZW4gdGhlIGBuYXRpdmVgIHByb3AgaXMgYGZhbHNlYCAoZGVmYXVsdCkuXG4gICAqL1xuICBkaXNwbGF5RW1wdHk6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiB0aGF0IGRpc3BsYXlzIHRoZSBhcnJvdy5cbiAgICovXG4gIEljb25Db21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogVGhlIGBpZGAgb2YgdGhlIHdyYXBwZXIgZWxlbWVudCBvciB0aGUgYHNlbGVjdGAgZWxlbWVudCB3aGVuIGBuYXRpdmVgLlxuICAgKi9cbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEFuIGBJbnB1dGAgZWxlbWVudDsgZG9lcyBub3QgaGF2ZSB0byBiZSBhIG1hdGVyaWFsLXVpIHNwZWNpZmljIGBJbnB1dGAuXG4gICAqL1xuICBpbnB1dDogUHJvcFR5cGVzLmVsZW1lbnQsXG5cbiAgLyoqXG4gICAqIFtBdHRyaWJ1dGVzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjQXR0cmlidXRlcykgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKiBXaGVuIGBuYXRpdmVgIGlzIGB0cnVlYCwgdGhlIGF0dHJpYnV0ZXMgYXJlIGFwcGxpZWQgb24gdGhlIGBzZWxlY3RgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBTZWUgW091dGxpbmVkSW5wdXQjbGFiZWxdKC9hcGkvb3V0bGluZWQtaW5wdXQvI3Byb3BzKVxuICAgKi9cbiAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgYW4gZWxlbWVudCB0aGF0IGFjdHMgYXMgYW4gYWRkaXRpb25hbCBsYWJlbC4gVGhlIFNlbGVjdCB3aWxsXG4gICAqIGJlIGxhYmVsbGVkIGJ5IHRoZSBhZGRpdGlvbmFsIGxhYmVsIGFuZCB0aGUgc2VsZWN0ZWQgdmFsdWUuXG4gICAqL1xuICBsYWJlbElkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBTZWUgW091dGxpbmVkSW5wdXQjbGFiZWxdKC9hcGkvb3V0bGluZWQtaW5wdXQvI3Byb3BzKVxuICAgKi9cbiAgbGFiZWxXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgW2BNZW51YF0oL2FwaS9tZW51LykgZWxlbWVudC5cbiAgICovXG4gIE1lbnVQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBgdmFsdWVgIG11c3QgYmUgYW4gYXJyYXkgYW5kIHRoZSBtZW51IHdpbGwgc3VwcG9ydCBtdWx0aXBsZSBzZWxlY3Rpb25zLlxuICAgKi9cbiAgbXVsdGlwbGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgd2lsbCBiZSB1c2luZyBhIG5hdGl2ZSBgc2VsZWN0YCBlbGVtZW50LlxuICAgKi9cbiAgbmF0aXZlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gZmlyZWQgd2hlbiBhIG1lbnUgaXRlbSBpcyBzZWxlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgdmFsdWUgYnkgYWNjZXNzaW5nIGBldmVudC50YXJnZXQudmFsdWVgIChhbnkpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW2NoaWxkXSBUaGUgcmVhY3QgZWxlbWVudCB0aGF0IHdhcyBzZWxlY3RlZCB3aGVuIGBuYXRpdmVgIGlzIGBmYWxzZWAgKGRlZmF1bHQpLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgcmVxdWVzdHMgdG8gYmUgY2xvc2VkLlxuICAgKiBVc2UgaW4gY29udHJvbGxlZCBtb2RlIChzZWUgb3BlbikuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICovXG4gIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgcmVxdWVzdHMgdG8gYmUgb3BlbmVkLlxuICAgKiBVc2UgaW4gY29udHJvbGxlZCBtb2RlIChzZWUgb3BlbikuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICovXG4gIG9uT3BlbjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENvbnRyb2wgYHNlbGVjdGAgb3BlbiBzdGF0ZS5cbiAgICogWW91IGNhbiBvbmx5IHVzZSBpdCB3aGVuIHRoZSBgbmF0aXZlYCBwcm9wIGlzIGBmYWxzZWAgKGRlZmF1bHQpLlxuICAgKi9cbiAgb3BlbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc2VsZWN0ZWQgdmFsdWUuXG4gICAqIFlvdSBjYW4gb25seSB1c2UgaXQgd2hlbiB0aGUgYG5hdGl2ZWAgcHJvcCBpcyBgZmFsc2VgIChkZWZhdWx0KS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSBgdmFsdWVgIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIEByZXR1cm5zIHtSZWFjdE5vZGV9XG4gICAqL1xuICByZW5kZXJWYWx1ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIGNsaWNrYWJsZSBkaXYgZWxlbWVudC5cbiAgICovXG4gIFNlbGVjdERpc3BsYXlQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogVGhlIGlucHV0IHZhbHVlLiBQcm92aWRpbmcgYW4gZW1wdHkgc3RyaW5nIHdpbGwgc2VsZWN0IG5vIG9wdGlvbnMuXG4gICAqIFRoaXMgcHJvcCBpcyByZXF1aXJlZCB3aGVuIHRoZSBgbmF0aXZlYCBwcm9wIGlzIGBmYWxzZWAgKGRlZmF1bHQpLlxuICAgKiBTZXQgdG8gYW4gZW1wdHkgc3RyaW5nIGAnJ2AgaWYgeW91IGRvbid0IHdhbnQgYW55IG9mIHRoZSBhdmFpbGFibGUgb3B0aW9ucyB0byBiZSBzZWxlY3RlZC5cbiAgICpcbiAgICogSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCBpdCBtdXN0IGhhdmUgcmVmZXJlbmNlIGVxdWFsaXR5IHdpdGggdGhlIG9wdGlvbiBpbiBvcmRlciB0byBiZSBzZWxlY3RlZC5cbiAgICogSWYgdGhlIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QsIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gbXVzdCBtYXRjaCB3aXRoIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9wdGlvbiBpbiBvcmRlciB0byBiZSBzZWxlY3RlZC5cbiAgICovXG4gIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydmaWxsZWQnLCAnb3V0bGluZWQnLCAnc3RhbmRhcmQnXSlcbn0gOiB2b2lkIDA7XG5TZWxlY3QubXVpTmFtZSA9ICdTZWxlY3QnO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aVNlbGVjdCdcbn0pKFNlbGVjdCk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgcmVmVHlwZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vSW5wdXQnO1xuaW1wb3J0IEZpbGxlZElucHV0IGZyb20gJy4uL0ZpbGxlZElucHV0JztcbmltcG9ydCBPdXRsaW5lZElucHV0IGZyb20gJy4uL091dGxpbmVkSW5wdXQnO1xuaW1wb3J0IElucHV0TGFiZWwgZnJvbSAnLi4vSW5wdXRMYWJlbCc7XG5pbXBvcnQgRm9ybUNvbnRyb2wgZnJvbSAnLi4vRm9ybUNvbnRyb2wnO1xuaW1wb3J0IEZvcm1IZWxwZXJUZXh0IGZyb20gJy4uL0Zvcm1IZWxwZXJUZXh0JztcbmltcG9ydCBTZWxlY3QgZnJvbSAnLi4vU2VsZWN0JztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbnZhciB2YXJpYW50Q29tcG9uZW50ID0ge1xuICBzdGFuZGFyZDogSW5wdXQsXG4gIGZpbGxlZDogRmlsbGVkSW5wdXQsXG4gIG91dGxpbmVkOiBPdXRsaW5lZElucHV0XG59O1xuZXhwb3J0IHZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gIHJvb3Q6IHt9XG59O1xuLyoqXG4gKiBUaGUgYFRleHRGaWVsZGAgaXMgYSBjb252ZW5pZW5jZSB3cmFwcGVyIGZvciB0aGUgbW9zdCBjb21tb24gY2FzZXMgKDgwJSkuXG4gKiBJdCBjYW5ub3QgYmUgYWxsIHRoaW5ncyB0byBhbGwgcGVvcGxlLCBvdGhlcndpc2UgdGhlIEFQSSB3b3VsZCBncm93IG91dCBvZiBjb250cm9sLlxuICpcbiAqICMjIEFkdmFuY2VkIENvbmZpZ3VyYXRpb25cbiAqXG4gKiBJdCdzIGltcG9ydGFudCB0byB1bmRlcnN0YW5kIHRoYXQgdGhlIHRleHQgZmllbGQgaXMgYSBzaW1wbGUgYWJzdHJhY3Rpb25cbiAqIG9uIHRvcCBvZiB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6XG4gKlxuICogLSBbRm9ybUNvbnRyb2xdKC9hcGkvZm9ybS1jb250cm9sLylcbiAqIC0gW0lucHV0TGFiZWxdKC9hcGkvaW5wdXQtbGFiZWwvKVxuICogLSBbRmlsbGVkSW5wdXRdKC9hcGkvZmlsbGVkLWlucHV0LylcbiAqIC0gW091dGxpbmVkSW5wdXRdKC9hcGkvb3V0bGluZWQtaW5wdXQvKVxuICogLSBbSW5wdXRdKC9hcGkvaW5wdXQvKVxuICogLSBbRm9ybUhlbHBlclRleHRdKC9hcGkvZm9ybS1oZWxwZXItdGV4dC8pXG4gKlxuICogSWYgeW91IHdpc2ggdG8gYWx0ZXIgdGhlIHByb3BzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCwgeW91IGNhbiBkbyBzbyBhcyBmb2xsb3dzOlxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgaW5wdXRQcm9wcyA9IHtcbiAqICAgc3RlcDogMzAwLFxuICogfTtcbiAqXG4gKiByZXR1cm4gPFRleHRGaWVsZCBpZD1cInRpbWVcIiB0eXBlPVwidGltZVwiIGlucHV0UHJvcHM9e2lucHV0UHJvcHN9IC8+O1xuICogYGBgXG4gKlxuICogRm9yIGFkdmFuY2VkIGNhc2VzLCBwbGVhc2UgbG9vayBhdCB0aGUgc291cmNlIG9mIFRleHRGaWVsZCBieSBjbGlja2luZyBvbiB0aGVcbiAqIFwiRWRpdCB0aGlzIHBhZ2VcIiBidXR0b24gYWJvdmUuIENvbnNpZGVyIGVpdGhlcjpcbiAqXG4gKiAtIHVzaW5nIHRoZSB1cHBlciBjYXNlIHByb3BzIGZvciBwYXNzaW5nIHZhbHVlcyBkaXJlY3RseSB0byB0aGUgY29tcG9uZW50c1xuICogLSB1c2luZyB0aGUgdW5kZXJseWluZyBjb21wb25lbnRzIGRpcmVjdGx5IGFzIHNob3duIGluIHRoZSBkZW1vc1xuICovXG5cbnZhciBUZXh0RmllbGQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBUZXh0RmllbGQocHJvcHMsIHJlZikge1xuICB2YXIgYXV0b0NvbXBsZXRlID0gcHJvcHMuYXV0b0NvbXBsZXRlLFxuICAgICAgX3Byb3BzJGF1dG9Gb2N1cyA9IHByb3BzLmF1dG9Gb2N1cyxcbiAgICAgIGF1dG9Gb2N1cyA9IF9wcm9wcyRhdXRvRm9jdXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGF1dG9Gb2N1cyxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgY29sb3IgPSBfcHJvcHMkY29sb3IgPT09IHZvaWQgMCA/ICdwcmltYXJ5JyA6IF9wcm9wcyRjb2xvcixcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkLFxuICAgICAgZGlzYWJsZWQgPSBfcHJvcHMkZGlzYWJsZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVkLFxuICAgICAgX3Byb3BzJGVycm9yID0gcHJvcHMuZXJyb3IsXG4gICAgICBlcnJvciA9IF9wcm9wcyRlcnJvciA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZXJyb3IsXG4gICAgICBGb3JtSGVscGVyVGV4dFByb3BzID0gcHJvcHMuRm9ybUhlbHBlclRleHRQcm9wcyxcbiAgICAgIF9wcm9wcyRmdWxsV2lkdGggPSBwcm9wcy5mdWxsV2lkdGgsXG4gICAgICBmdWxsV2lkdGggPSBfcHJvcHMkZnVsbFdpZHRoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmdWxsV2lkdGgsXG4gICAgICBoZWxwZXJUZXh0ID0gcHJvcHMuaGVscGVyVGV4dCxcbiAgICAgIGhpZGRlbkxhYmVsID0gcHJvcHMuaGlkZGVuTGFiZWwsXG4gICAgICBpZCA9IHByb3BzLmlkLFxuICAgICAgSW5wdXRMYWJlbFByb3BzID0gcHJvcHMuSW5wdXRMYWJlbFByb3BzLFxuICAgICAgaW5wdXRQcm9wcyA9IHByb3BzLmlucHV0UHJvcHMsXG4gICAgICBJbnB1dFByb3BzID0gcHJvcHMuSW5wdXRQcm9wcyxcbiAgICAgIGlucHV0UmVmID0gcHJvcHMuaW5wdXRSZWYsXG4gICAgICBsYWJlbCA9IHByb3BzLmxhYmVsLFxuICAgICAgX3Byb3BzJG11bHRpbGluZSA9IHByb3BzLm11bHRpbGluZSxcbiAgICAgIG11bHRpbGluZSA9IF9wcm9wcyRtdWx0aWxpbmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJG11bHRpbGluZSxcbiAgICAgIG5hbWUgPSBwcm9wcy5uYW1lLFxuICAgICAgb25CbHVyID0gcHJvcHMub25CbHVyLFxuICAgICAgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZSxcbiAgICAgIG9uRm9jdXMgPSBwcm9wcy5vbkZvY3VzLFxuICAgICAgcGxhY2Vob2xkZXIgPSBwcm9wcy5wbGFjZWhvbGRlcixcbiAgICAgIF9wcm9wcyRyZXF1aXJlZCA9IHByb3BzLnJlcXVpcmVkLFxuICAgICAgcmVxdWlyZWQgPSBfcHJvcHMkcmVxdWlyZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJHJlcXVpcmVkLFxuICAgICAgcm93cyA9IHByb3BzLnJvd3MsXG4gICAgICByb3dzTWF4ID0gcHJvcHMucm93c01heCxcbiAgICAgIF9wcm9wcyRzZWxlY3QgPSBwcm9wcy5zZWxlY3QsXG4gICAgICBzZWxlY3QgPSBfcHJvcHMkc2VsZWN0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRzZWxlY3QsXG4gICAgICBTZWxlY3RQcm9wcyA9IHByb3BzLlNlbGVjdFByb3BzLFxuICAgICAgdHlwZSA9IHByb3BzLnR5cGUsXG4gICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlLFxuICAgICAgX3Byb3BzJHZhcmlhbnQgPSBwcm9wcy52YXJpYW50LFxuICAgICAgdmFyaWFudCA9IF9wcm9wcyR2YXJpYW50ID09PSB2b2lkIDAgPyAnc3RhbmRhcmQnIDogX3Byb3BzJHZhcmlhbnQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYXV0b0NvbXBsZXRlXCIsIFwiYXV0b0ZvY3VzXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sb3JcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJkaXNhYmxlZFwiLCBcImVycm9yXCIsIFwiRm9ybUhlbHBlclRleHRQcm9wc1wiLCBcImZ1bGxXaWR0aFwiLCBcImhlbHBlclRleHRcIiwgXCJoaWRkZW5MYWJlbFwiLCBcImlkXCIsIFwiSW5wdXRMYWJlbFByb3BzXCIsIFwiaW5wdXRQcm9wc1wiLCBcIklucHV0UHJvcHNcIiwgXCJpbnB1dFJlZlwiLCBcImxhYmVsXCIsIFwibXVsdGlsaW5lXCIsIFwibmFtZVwiLCBcIm9uQmx1clwiLCBcIm9uQ2hhbmdlXCIsIFwib25Gb2N1c1wiLCBcInBsYWNlaG9sZGVyXCIsIFwicmVxdWlyZWRcIiwgXCJyb3dzXCIsIFwicm93c01heFwiLCBcInNlbGVjdFwiLCBcIlNlbGVjdFByb3BzXCIsIFwidHlwZVwiLCBcInZhbHVlXCIsIFwidmFyaWFudFwiXSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoc2VsZWN0ICYmICFjaGlsZHJlbikge1xuICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IGBjaGlsZHJlbmAgbXVzdCBiZSBwYXNzZWQgd2hlbiB1c2luZyB0aGUgYFRleHRGaWVsZGAgY29tcG9uZW50IHdpdGggYHNlbGVjdGAuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIElucHV0TW9yZSA9IHt9O1xuXG4gIGlmICh2YXJpYW50ID09PSAnb3V0bGluZWQnKSB7XG4gICAgaWYgKElucHV0TGFiZWxQcm9wcyAmJiB0eXBlb2YgSW5wdXRMYWJlbFByb3BzLnNocmluayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIElucHV0TW9yZS5ub3RjaGVkID0gSW5wdXRMYWJlbFByb3BzLnNocmluaztcbiAgICB9XG5cbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHZhciBfSW5wdXRMYWJlbFByb3BzJHJlcXU7XG5cbiAgICAgIHZhciBkaXNwbGF5UmVxdWlyZWQgPSAoX0lucHV0TGFiZWxQcm9wcyRyZXF1ID0gSW5wdXRMYWJlbFByb3BzID09PSBudWxsIHx8IElucHV0TGFiZWxQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogSW5wdXRMYWJlbFByb3BzLnJlcXVpcmVkKSAhPT0gbnVsbCAmJiBfSW5wdXRMYWJlbFByb3BzJHJlcXUgIT09IHZvaWQgMCA/IF9JbnB1dExhYmVsUHJvcHMkcmVxdSA6IHJlcXVpcmVkO1xuICAgICAgSW5wdXRNb3JlLmxhYmVsID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGxhYmVsLCBkaXNwbGF5UmVxdWlyZWQgJiYgXCJcXHhBMCpcIik7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGVjdCkge1xuICAgIC8vIHVuc2V0IGRlZmF1bHRzIGZyb20gdGV4dGJveCBpbnB1dHNcbiAgICBpZiAoIVNlbGVjdFByb3BzIHx8ICFTZWxlY3RQcm9wcy5uYXRpdmUpIHtcbiAgICAgIElucHV0TW9yZS5pZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBJbnB1dE1vcmVbJ2FyaWEtZGVzY3JpYmVkYnknXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBoZWxwZXJUZXh0SWQgPSBoZWxwZXJUZXh0ICYmIGlkID8gXCJcIi5jb25jYXQoaWQsIFwiLWhlbHBlci10ZXh0XCIpIDogdW5kZWZpbmVkO1xuICB2YXIgaW5wdXRMYWJlbElkID0gbGFiZWwgJiYgaWQgPyBcIlwiLmNvbmNhdChpZCwgXCItbGFiZWxcIikgOiB1bmRlZmluZWQ7XG4gIHZhciBJbnB1dENvbXBvbmVudCA9IHZhcmlhbnRDb21wb25lbnRbdmFyaWFudF07XG4gIHZhciBJbnB1dEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnB1dENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiBoZWxwZXJUZXh0SWQsXG4gICAgYXV0b0NvbXBsZXRlOiBhdXRvQ29tcGxldGUsXG4gICAgYXV0b0ZvY3VzOiBhdXRvRm9jdXMsXG4gICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgZnVsbFdpZHRoOiBmdWxsV2lkdGgsXG4gICAgbXVsdGlsaW5lOiBtdWx0aWxpbmUsXG4gICAgbmFtZTogbmFtZSxcbiAgICByb3dzOiByb3dzLFxuICAgIHJvd3NNYXg6IHJvd3NNYXgsXG4gICAgdHlwZTogdHlwZSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgaWQ6IGlkLFxuICAgIGlucHV0UmVmOiBpbnB1dFJlZixcbiAgICBvbkJsdXI6IG9uQmx1cixcbiAgICBvbkNoYW5nZTogb25DaGFuZ2UsXG4gICAgb25Gb2N1czogb25Gb2N1cyxcbiAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgaW5wdXRQcm9wczogaW5wdXRQcm9wc1xuICB9LCBJbnB1dE1vcmUsIElucHV0UHJvcHMpKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1Db250cm9sLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lKSxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgZXJyb3I6IGVycm9yLFxuICAgIGZ1bGxXaWR0aDogZnVsbFdpZHRoLFxuICAgIGhpZGRlbkxhYmVsOiBoaWRkZW5MYWJlbCxcbiAgICByZWY6IHJlZixcbiAgICByZXF1aXJlZDogcmVxdWlyZWQsXG4gICAgY29sb3I6IGNvbG9yLFxuICAgIHZhcmlhbnQ6IHZhcmlhbnRcbiAgfSwgb3RoZXIpLCBsYWJlbCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnB1dExhYmVsLCBfZXh0ZW5kcyh7XG4gICAgaHRtbEZvcjogaWQsXG4gICAgaWQ6IGlucHV0TGFiZWxJZFxuICB9LCBJbnB1dExhYmVsUHJvcHMpLCBsYWJlbCksIHNlbGVjdCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNlbGVjdCwgX2V4dGVuZHMoe1xuICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiBoZWxwZXJUZXh0SWQsXG4gICAgaWQ6IGlkLFxuICAgIGxhYmVsSWQ6IGlucHV0TGFiZWxJZCxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgaW5wdXQ6IElucHV0RWxlbWVudFxuICB9LCBTZWxlY3RQcm9wcyksIGNoaWxkcmVuKSA6IElucHV0RWxlbWVudCwgaGVscGVyVGV4dCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtSGVscGVyVGV4dCwgX2V4dGVuZHMoe1xuICAgIGlkOiBoZWxwZXJUZXh0SWRcbiAgfSwgRm9ybUhlbHBlclRleHRQcm9wcyksIGhlbHBlclRleHQpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVGV4dEZpZWxkLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoaXMgcHJvcCBoZWxwcyB1c2VycyB0byBmaWxsIGZvcm1zIGZhc3RlciwgZXNwZWNpYWxseSBvbiBtb2JpbGUgZGV2aWNlcy5cbiAgICogVGhlIG5hbWUgY2FuIGJlIGNvbmZ1c2luZywgYXMgaXQncyBtb3JlIGxpa2UgYW4gYXV0b2ZpbGwuXG4gICAqIFlvdSBjYW4gbGVhcm4gbW9yZSBhYm91dCBpdCBbZm9sbG93aW5nIHRoZSBzcGVjaWZpY2F0aW9uXShodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNhdXRvZmlsbCkuXG4gICAqL1xuICBhdXRvQ29tcGxldGU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGZvY3VzZWQgZHVyaW5nIHRoZSBmaXJzdCBtb3VudC5cbiAgICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LiBJdCBzdXBwb3J0cyB0aG9zZSB0aGVtZSBjb2xvcnMgdGhhdCBtYWtlIHNlbnNlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydwcmltYXJ5JywgJ3NlY29uZGFyeSddKSxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIHdpbGwgYmUgZGlzcGxheWVkIGluIGFuIGVycm9yIHN0YXRlLlxuICAgKi9cbiAgZXJyb3I6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYEZvcm1IZWxwZXJUZXh0YF0oL2FwaS9mb3JtLWhlbHBlci10ZXh0LykgZWxlbWVudC5cbiAgICovXG4gIEZvcm1IZWxwZXJUZXh0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiBpdHMgY29udGFpbmVyLlxuICAgKi9cbiAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGhlbHBlciB0ZXh0IGNvbnRlbnQuXG4gICAqL1xuICBoZWxwZXJUZXh0OiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgaGlkZGVuTGFiZWw6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICogVXNlIHRoaXMgcHJvcCB0byBtYWtlIGBsYWJlbGAgYW5kIGBoZWxwZXJUZXh0YCBhY2Nlc3NpYmxlIGZvciBzY3JlZW4gcmVhZGVycy5cbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYElucHV0TGFiZWxgXSgvYXBpL2lucHV0LWxhYmVsLykgZWxlbWVudC5cbiAgICovXG4gIElucHV0TGFiZWxQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogW0F0dHJpYnV0ZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNBdHRyaWJ1dGVzKSBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBJbnB1dCBlbGVtZW50LlxuICAgKiBJdCB3aWxsIGJlIGEgW2BGaWxsZWRJbnB1dGBdKC9hcGkvZmlsbGVkLWlucHV0LyksXG4gICAqIFtgT3V0bGluZWRJbnB1dGBdKC9hcGkvb3V0bGluZWQtaW5wdXQvKSBvciBbYElucHV0YF0oL2FwaS9pbnB1dC8pXG4gICAqIGNvbXBvbmVudCBkZXBlbmRpbmcgb24gdGhlIGB2YXJpYW50YCBwcm9wIHZhbHVlLlxuICAgKi9cbiAgSW5wdXRQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogUGFzcyBhIHJlZiB0byB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaW5wdXRSZWY6IHJlZlR5cGUsXG5cbiAgLyoqXG4gICAqIFRoZSBsYWJlbCBjb250ZW50LlxuICAgKi9cbiAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVuc2VgIG9yIGBub3JtYWxgLCB3aWxsIGFkanVzdCB2ZXJ0aWNhbCBzcGFjaW5nIG9mIHRoaXMgYW5kIGNvbnRhaW5lZCBjb21wb25lbnRzLlxuICAgKi9cbiAgbWFyZ2luOiBQcm9wVHlwZXMub25lT2YoWydkZW5zZScsICdub25lJywgJ25vcm1hbCddKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBhIHRleHRhcmVhIGVsZW1lbnQgd2lsbCBiZSByZW5kZXJlZCBpbnN0ZWFkIG9mIGFuIGlucHV0LlxuICAgKi9cbiAgbXVsdGlsaW5lOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTmFtZSBhdHRyaWJ1dGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICogWW91IGNhbiBwdWxsIG91dCB0aGUgbmV3IHZhbHVlIGJ5IGFjY2Vzc2luZyBgZXZlbnQudGFyZ2V0LnZhbHVlYCAoc3RyaW5nKS5cbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFRoZSBzaG9ydCBoaW50IGRpc3BsYXllZCBpbiB0aGUgaW5wdXQgYmVmb3JlIHRoZSB1c2VyIGVudGVycyBhIHZhbHVlLlxuICAgKi9cbiAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIGlzIGRpc3BsYXllZCBhcyByZXF1aXJlZCBhbmQgdGhlIGBpbnB1dGAgZWxlbWVudGAgd2lsbCBiZSByZXF1aXJlZC5cbiAgICovXG4gIHJlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSB3aGVuIG11bHRpbGluZSBvcHRpb24gaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICByb3dzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSB3aGVuIG11bHRpbGluZSBvcHRpb24gaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICByb3dzTWF4OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIFtgU2VsZWN0YF0oL2FwaS9zZWxlY3QvKSBlbGVtZW50IHdoaWxlIHBhc3NpbmcgdGhlIElucHV0IGVsZW1lbnQgdG8gYFNlbGVjdGAgYXMgYGlucHV0YCBwYXJhbWV0ZXIuXG4gICAqIElmIHRoaXMgb3B0aW9uIGlzIHNldCB5b3UgbXVzdCBwYXNzIHRoZSBvcHRpb25zIG9mIHRoZSBzZWxlY3QgYXMgY2hpbGRyZW4uXG4gICAqL1xuICBzZWxlY3Q6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYFNlbGVjdGBdKC9hcGkvc2VsZWN0LykgZWxlbWVudC5cbiAgICovXG4gIFNlbGVjdFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgdGV4dCBmaWVsZC5cbiAgICovXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ21lZGl1bScsICdzbWFsbCddKSxcblxuICAvKipcbiAgICogVHlwZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LiBJdCBzaG91bGQgYmUgW2EgdmFsaWQgSFRNTDUgaW5wdXQgdHlwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I0Zvcm1fJTNDaW5wdXQlM0VfdHlwZXMpLlxuICAgKi9cbiAgdHlwZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQsIHJlcXVpcmVkIGZvciBhIGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ2ZpbGxlZCcsICdvdXRsaW5lZCcsICdzdGFuZGFyZCddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlUZXh0RmllbGQnXG59KShUZXh0RmllbGQpOyIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCB7IGZhZGUgfSBmcm9tICcuLi9zdHlsZXMvY29sb3JNYW5pcHVsYXRvcic7XG5pbXBvcnQgQnV0dG9uQmFzZSBmcm9tICcuLi9CdXR0b25CYXNlJztcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4uL3V0aWxzL2NhcGl0YWxpemUnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IF9leHRlbmRzKHt9LCB0aGVtZS50eXBvZ3JhcGh5LmJ1dHRvbiwge1xuICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICBtaW5XaWR0aDogNjQsXG4gICAgICBwYWRkaW5nOiAnNnB4IDE2cHgnLFxuICAgICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5zaGFwZS5ib3JkZXJSYWRpdXMsXG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50ZXh0LnByaW1hcnksXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoWydiYWNrZ3JvdW5kLWNvbG9yJywgJ2JveC1zaGFkb3cnLCAnYm9yZGVyJ10sIHtcbiAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0XG4gICAgICB9KSxcbiAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGZhZGUodGhlbWUucGFsZXR0ZS50ZXh0LnByaW1hcnksIHRoZW1lLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksXG4gICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSxcbiAgICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkXG4gICAgICB9XG4gICAgfSksXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgc3BhbiBlbGVtZW50IHRoYXQgd3JhcHMgdGhlIGNoaWxkcmVuLiAqL1xuICAgIGxhYmVsOiB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgLy8gRW5zdXJlIHRoZSBjb3JyZWN0IHdpZHRoIGZvciBpT1MgU2FmYXJpXG4gICAgICBkaXNwbGF5OiAnaW5oZXJpdCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnaW5oZXJpdCcsXG4gICAgICBqdXN0aWZ5Q29udGVudDogJ2luaGVyaXQnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJ0ZXh0XCJgLiAqL1xuICAgIHRleHQ6IHtcbiAgICAgIHBhZGRpbmc6ICc2cHggOHB4J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGB2YXJpYW50PVwidGV4dFwiYCBhbmQgYGNvbG9yPVwicHJpbWFyeVwiYC4gKi9cbiAgICB0ZXh0UHJpbWFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluLFxuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogZmFkZSh0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpbiwgdGhlbWUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KSxcbiAgICAgICAgLy8gUmVzZXQgb24gdG91Y2ggZGV2aWNlcywgaXQgZG9lc24ndCBhZGQgc3BlY2lmaWNpdHlcbiAgICAgICAgJ0BtZWRpYSAoaG92ZXI6IG5vbmUpJzoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJ0ZXh0XCJgIGFuZCBgY29sb3I9XCJzZWNvbmRhcnlcImAuICovXG4gICAgdGV4dFNlY29uZGFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBmYWRlKHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sIHRoZW1lLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksXG4gICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGB2YXJpYW50PVwib3V0bGluZWRcImAuICovXG4gICAgb3V0bGluZWQ6IHtcbiAgICAgIHBhZGRpbmc6ICc1cHggMTVweCcsXG4gICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIFwiLmNvbmNhdCh0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyAncmdiYSgwLCAwLCAwLCAwLjIzKScgOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIzKScpLFxuICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgXCIuY29uY2F0KHRoZW1lLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkQmFja2dyb3VuZClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cIm91dGxpbmVkXCJgIGFuZCBgY29sb3I9XCJwcmltYXJ5XCJgLiAqL1xuICAgIG91dGxpbmVkUHJpbWFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluLFxuICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBcIi5jb25jYXQoZmFkZSh0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpbiwgMC41KSksXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBcIi5jb25jYXQodGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4pLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGZhZGUodGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sIHRoZW1lLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksXG4gICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGB2YXJpYW50PVwib3V0bGluZWRcImAgYW5kIGBjb2xvcj1cInNlY29uZGFyeVwiYC4gKi9cbiAgICBvdXRsaW5lZFNlY29uZGFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sXG4gICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIFwiLmNvbmNhdChmYWRlKHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sIDAuNSkpLFxuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgXCIuY29uY2F0KHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4pLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGZhZGUodGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbiwgdGhlbWUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KSxcbiAgICAgICAgLy8gUmVzZXQgb24gdG91Y2ggZGV2aWNlcywgaXQgZG9lc24ndCBhZGQgc3BlY2lmaWNpdHlcbiAgICAgICAgJ0BtZWRpYSAoaG92ZXI6IG5vbmUpJzoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgXCIuY29uY2F0KHRoZW1lLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGB2YXJpYW50PVwiY29udGFpbmVkXCJgLiAqL1xuICAgIGNvbnRhaW5lZDoge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuZ2V0Q29udHJhc3RUZXh0KHRoZW1lLnBhbGV0dGUuZ3JleVszMDBdKSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5ncmV5WzMwMF0sXG4gICAgICBib3hTaGFkb3c6IHRoZW1lLnNoYWRvd3NbMl0sXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLmdyZXkuQTEwMCxcbiAgICAgICAgYm94U2hhZG93OiB0aGVtZS5zaGFkb3dzWzRdLFxuICAgICAgICAvLyBSZXNldCBvbiB0b3VjaCBkZXZpY2VzLCBpdCBkb2Vzbid0IGFkZCBzcGVjaWZpY2l0eVxuICAgICAgICAnQG1lZGlhIChob3Zlcjogbm9uZSknOiB7XG4gICAgICAgICAgYm94U2hhZG93OiB0aGVtZS5zaGFkb3dzWzJdLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5ncmV5WzMwMF1cbiAgICAgICAgfSxcbiAgICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZEJhY2tncm91bmRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICcmJGZvY3VzVmlzaWJsZSc6IHtcbiAgICAgICAgYm94U2hhZG93OiB0aGVtZS5zaGFkb3dzWzZdXG4gICAgICB9LFxuICAgICAgJyY6YWN0aXZlJzoge1xuICAgICAgICBib3hTaGFkb3c6IHRoZW1lLnNoYWRvd3NbOF1cbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkLFxuICAgICAgICBib3hTaGFkb3c6IHRoZW1lLnNoYWRvd3NbMF0sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRCYWNrZ3JvdW5kXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJjb250YWluZWRcImAgYW5kIGBjb2xvcj1cInByaW1hcnlcImAuICovXG4gICAgY29udGFpbmVkUHJpbWFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5jb250cmFzdFRleHQsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluLFxuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5wcmltYXJ5LmRhcmssXG4gICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImNvbnRhaW5lZFwiYCBhbmQgYGNvbG9yPVwic2Vjb25kYXJ5XCJgLiAqL1xuICAgIGNvbnRhaW5lZFNlY29uZGFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5LmNvbnRyYXN0VGV4dCxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbixcbiAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5LmRhcmssXG4gICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlRWxldmF0aW9uPXt0cnVlfWAuICovXG4gICAgZGlzYWJsZUVsZXZhdGlvbjoge1xuICAgICAgYm94U2hhZG93OiAnbm9uZScsXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgYm94U2hhZG93OiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICAnJiRmb2N1c1Zpc2libGUnOiB7XG4gICAgICAgIGJveFNoYWRvdzogJ25vbmUnXG4gICAgICB9LFxuICAgICAgJyY6YWN0aXZlJzoge1xuICAgICAgICBib3hTaGFkb3c6ICdub25lJ1xuICAgICAgfSxcbiAgICAgICcmJGRpc2FibGVkJzoge1xuICAgICAgICBib3hTaGFkb3c6ICdub25lJ1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgQnV0dG9uQmFzZSByb290IGVsZW1lbnQgaWYgdGhlIGJ1dHRvbiBpcyBrZXlib2FyZCBmb2N1c2VkLiAqL1xuICAgIGZvY3VzVmlzaWJsZToge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlZD17dHJ1ZX1gLiAqL1xuICAgIGRpc2FibGVkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwiaW5oZXJpdFwiYC4gKi9cbiAgICBjb2xvckluaGVyaXQ6IHtcbiAgICAgIGNvbG9yOiAnaW5oZXJpdCcsXG4gICAgICBib3JkZXJDb2xvcjogJ2N1cnJlbnRDb2xvcidcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgc2l6ZT1cInNtYWxsXCJgIGFuZCBgdmFyaWFudD1cInRleHRcImAuICovXG4gICAgdGV4dFNpemVTbWFsbDoge1xuICAgICAgcGFkZGluZzogJzRweCA1cHgnLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkucHhUb1JlbSgxMylcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgc2l6ZT1cImxhcmdlXCJgIGFuZCBgdmFyaWFudD1cInRleHRcImAuICovXG4gICAgdGV4dFNpemVMYXJnZToge1xuICAgICAgcGFkZGluZzogJzhweCAxMXB4JyxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTUpXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHNpemU9XCJzbWFsbFwiYCBhbmQgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYC4gKi9cbiAgICBvdXRsaW5lZFNpemVTbWFsbDoge1xuICAgICAgcGFkZGluZzogJzNweCA5cHgnLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkucHhUb1JlbSgxMylcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgc2l6ZT1cImxhcmdlXCJgIGFuZCBgdmFyaWFudD1cIm91dGxpbmVkXCJgLiAqL1xuICAgIG91dGxpbmVkU2l6ZUxhcmdlOiB7XG4gICAgICBwYWRkaW5nOiAnN3B4IDIxcHgnLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkucHhUb1JlbSgxNSlcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgc2l6ZT1cInNtYWxsXCJgIGFuZCBgdmFyaWFudD1cImNvbnRhaW5lZFwiYC4gKi9cbiAgICBjb250YWluZWRTaXplU21hbGw6IHtcbiAgICAgIHBhZGRpbmc6ICc0cHggMTBweCcsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5weFRvUmVtKDEzKVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBzaXplPVwibGFyZ2VcImAgYW5kIGB2YXJpYW50PVwiY29udGFpbmVkXCJgLiAqL1xuICAgIGNvbnRhaW5lZFNpemVMYXJnZToge1xuICAgICAgcGFkZGluZzogJzhweCAyMnB4JyxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTUpXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHNpemU9XCJzbWFsbFwiYC4gKi9cbiAgICBzaXplU21hbGw6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgc2l6ZT1cImxhcmdlXCJgLiAqL1xuICAgIHNpemVMYXJnZToge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBmdWxsV2lkdGg9e3RydWV9YC4gKi9cbiAgICBmdWxsV2lkdGg6IHtcbiAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHN0YXJ0SWNvbiBlbGVtZW50IGlmIHN1cHBsaWVkLiAqL1xuICAgIHN0YXJ0SWNvbjoge1xuICAgICAgZGlzcGxheTogJ2luaGVyaXQnLFxuICAgICAgbWFyZ2luUmlnaHQ6IDgsXG4gICAgICBtYXJnaW5MZWZ0OiAtNCxcbiAgICAgICcmJGljb25TaXplU21hbGwnOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IC0yXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBlbmRJY29uIGVsZW1lbnQgaWYgc3VwcGxpZWQuICovXG4gICAgZW5kSWNvbjoge1xuICAgICAgZGlzcGxheTogJ2luaGVyaXQnLFxuICAgICAgbWFyZ2luUmlnaHQ6IC00LFxuICAgICAgbWFyZ2luTGVmdDogOCxcbiAgICAgICcmJGljb25TaXplU21hbGwnOiB7XG4gICAgICAgIG1hcmdpblJpZ2h0OiAtMlxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaWNvbiBlbGVtZW50IGlmIHN1cHBsaWVkIGFuZCBgc2l6ZT1cInNtYWxsXCJgLiAqL1xuICAgIGljb25TaXplU21hbGw6IHtcbiAgICAgICcmID4gKjpmaXJzdC1jaGlsZCc6IHtcbiAgICAgICAgZm9udFNpemU6IDE4XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpY29uIGVsZW1lbnQgaWYgc3VwcGxpZWQgYW5kIGBzaXplPVwibWVkaXVtXCJgLiAqL1xuICAgIGljb25TaXplTWVkaXVtOiB7XG4gICAgICAnJiA+ICo6Zmlyc3QtY2hpbGQnOiB7XG4gICAgICAgIGZvbnRTaXplOiAyMFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaWNvbiBlbGVtZW50IGlmIHN1cHBsaWVkIGFuZCBgc2l6ZT1cImxhcmdlXCJgLiAqL1xuICAgIGljb25TaXplTGFyZ2U6IHtcbiAgICAgICcmID4gKjpmaXJzdC1jaGlsZCc6IHtcbiAgICAgICAgZm9udFNpemU6IDIyXG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbnZhciBCdXR0b24gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBCdXR0b24ocHJvcHMsIHJlZikge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJGNvbG9yID0gcHJvcHMuY29sb3IsXG4gICAgICBjb2xvciA9IF9wcm9wcyRjb2xvciA9PT0gdm9pZCAwID8gJ2RlZmF1bHQnIDogX3Byb3BzJGNvbG9yLFxuICAgICAgX3Byb3BzJGNvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgIGNvbXBvbmVudCA9IF9wcm9wcyRjb21wb25lbnQgPT09IHZvaWQgMCA/ICdidXR0b24nIDogX3Byb3BzJGNvbXBvbmVudCxcbiAgICAgIF9wcm9wcyRkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkLFxuICAgICAgZGlzYWJsZWQgPSBfcHJvcHMkZGlzYWJsZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVkLFxuICAgICAgX3Byb3BzJGRpc2FibGVFbGV2YXRpID0gcHJvcHMuZGlzYWJsZUVsZXZhdGlvbixcbiAgICAgIGRpc2FibGVFbGV2YXRpb24gPSBfcHJvcHMkZGlzYWJsZUVsZXZhdGkgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVFbGV2YXRpLFxuICAgICAgX3Byb3BzJGRpc2FibGVGb2N1c1JpID0gcHJvcHMuZGlzYWJsZUZvY3VzUmlwcGxlLFxuICAgICAgZGlzYWJsZUZvY3VzUmlwcGxlID0gX3Byb3BzJGRpc2FibGVGb2N1c1JpID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlRm9jdXNSaSxcbiAgICAgIGVuZEljb25Qcm9wID0gcHJvcHMuZW5kSWNvbixcbiAgICAgIGZvY3VzVmlzaWJsZUNsYXNzTmFtZSA9IHByb3BzLmZvY3VzVmlzaWJsZUNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRmdWxsV2lkdGggPSBwcm9wcy5mdWxsV2lkdGgsXG4gICAgICBmdWxsV2lkdGggPSBfcHJvcHMkZnVsbFdpZHRoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmdWxsV2lkdGgsXG4gICAgICBfcHJvcHMkc2l6ZSA9IHByb3BzLnNpemUsXG4gICAgICBzaXplID0gX3Byb3BzJHNpemUgPT09IHZvaWQgMCA/ICdtZWRpdW0nIDogX3Byb3BzJHNpemUsXG4gICAgICBzdGFydEljb25Qcm9wID0gcHJvcHMuc3RhcnRJY29uLFxuICAgICAgX3Byb3BzJHR5cGUgPSBwcm9wcy50eXBlLFxuICAgICAgdHlwZSA9IF9wcm9wcyR0eXBlID09PSB2b2lkIDAgPyAnYnV0dG9uJyA6IF9wcm9wcyR0eXBlLFxuICAgICAgX3Byb3BzJHZhcmlhbnQgPSBwcm9wcy52YXJpYW50LFxuICAgICAgdmFyaWFudCA9IF9wcm9wcyR2YXJpYW50ID09PSB2b2lkIDAgPyAndGV4dCcgOiBfcHJvcHMkdmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb2xvclwiLCBcImNvbXBvbmVudFwiLCBcImRpc2FibGVkXCIsIFwiZGlzYWJsZUVsZXZhdGlvblwiLCBcImRpc2FibGVGb2N1c1JpcHBsZVwiLCBcImVuZEljb25cIiwgXCJmb2N1c1Zpc2libGVDbGFzc05hbWVcIiwgXCJmdWxsV2lkdGhcIiwgXCJzaXplXCIsIFwic3RhcnRJY29uXCIsIFwidHlwZVwiLCBcInZhcmlhbnRcIl0pO1xuXG4gIHZhciBzdGFydEljb24gPSBzdGFydEljb25Qcm9wICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMuc3RhcnRJY29uLCBjbGFzc2VzW1wiaWNvblNpemVcIi5jb25jYXQoY2FwaXRhbGl6ZShzaXplKSldKVxuICB9LCBzdGFydEljb25Qcm9wKTtcbiAgdmFyIGVuZEljb24gPSBlbmRJY29uUHJvcCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLmVuZEljb24sIGNsYXNzZXNbXCJpY29uU2l6ZVwiLmNvbmNhdChjYXBpdGFsaXplKHNpemUpKV0pXG4gIH0sIGVuZEljb25Qcm9wKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbkJhc2UsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc2VzW3ZhcmlhbnRdLCBjbGFzc05hbWUsIGNvbG9yID09PSAnaW5oZXJpdCcgPyBjbGFzc2VzLmNvbG9ySW5oZXJpdCA6IGNvbG9yICE9PSAnZGVmYXVsdCcgJiYgY2xhc3Nlc1tcIlwiLmNvbmNhdCh2YXJpYW50KS5jb25jYXQoY2FwaXRhbGl6ZShjb2xvcikpXSwgc2l6ZSAhPT0gJ21lZGl1bScgJiYgW2NsYXNzZXNbXCJcIi5jb25jYXQodmFyaWFudCwgXCJTaXplXCIpLmNvbmNhdChjYXBpdGFsaXplKHNpemUpKV0sIGNsYXNzZXNbXCJzaXplXCIuY29uY2F0KGNhcGl0YWxpemUoc2l6ZSkpXV0sIGRpc2FibGVFbGV2YXRpb24gJiYgY2xhc3Nlcy5kaXNhYmxlRWxldmF0aW9uLCBkaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkLCBmdWxsV2lkdGggJiYgY2xhc3Nlcy5mdWxsV2lkdGgpLFxuICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICBmb2N1c1JpcHBsZTogIWRpc2FibGVGb2N1c1JpcHBsZSxcbiAgICBmb2N1c1Zpc2libGVDbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5mb2N1c1Zpc2libGUsIGZvY3VzVmlzaWJsZUNsYXNzTmFtZSksXG4gICAgcmVmOiByZWYsXG4gICAgdHlwZTogdHlwZVxuICB9LCBvdGhlciksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLmxhYmVsXG4gIH0sIHN0YXJ0SWNvbiwgY2hpbGRyZW4sIGVuZEljb24pKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gQnV0dG9uLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBidXR0b24uXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC4gSXQgc3VwcG9ydHMgdGhvc2UgdGhlbWUgY29sb3JzIHRoYXQgbWFrZSBzZW5zZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnZGVmYXVsdCcsICdpbmhlcml0JywgJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYnV0dG9uIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgbm8gZWxldmF0aW9uIGlzIHVzZWQuXG4gICAqL1xuICBkaXNhYmxlRWxldmF0aW9uOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgIGtleWJvYXJkIGZvY3VzIHJpcHBsZSB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZUZvY3VzUmlwcGxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcmlwcGxlIGVmZmVjdCB3aWxsIGJlIGRpc2FibGVkLlxuICAgKlxuICAgKiDimqDvuI8gV2l0aG91dCBhIHJpcHBsZSB0aGVyZSBpcyBubyBzdHlsaW5nIGZvciA6Zm9jdXMtdmlzaWJsZSBieSBkZWZhdWx0LiBCZSBzdXJlXG4gICAqIHRvIGhpZ2hsaWdodCB0aGUgZWxlbWVudCBieSBhcHBseWluZyBzZXBhcmF0ZSBzdHlsZXMgd2l0aCB0aGUgYGZvY3VzVmlzaWJsZUNsYXNzTmFtZWAuXG4gICAqL1xuICBkaXNhYmxlUmlwcGxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRWxlbWVudCBwbGFjZWQgYWZ0ZXIgdGhlIGNoaWxkcmVuLlxuICAgKi9cbiAgZW5kSWNvbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZvY3VzVmlzaWJsZUNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYnV0dG9uIHdpbGwgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiBpdHMgY29udGFpbmVyLlxuICAgKi9cbiAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIFVSTCB0byBsaW5rIHRvIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkLlxuICAgKiBJZiBkZWZpbmVkLCBhbiBgYWAgZWxlbWVudCB3aWxsIGJlIHVzZWQgYXMgdGhlIHJvb3Qgbm9kZS5cbiAgICovXG4gIGhyZWY6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBidXR0b24uXG4gICAqIGBzbWFsbGAgaXMgZXF1aXZhbGVudCB0byB0aGUgZGVuc2UgYnV0dG9uIHN0eWxpbmcuXG4gICAqL1xuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydsYXJnZScsICdtZWRpdW0nLCAnc21hbGwnXSksXG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgcGxhY2VkIGJlZm9yZSB0aGUgY2hpbGRyZW4uXG4gICAqL1xuICBzdGFydEljb246IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICB0eXBlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydidXR0b24nLCAncmVzZXQnLCAnc3VibWl0J10pLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ2NvbnRhaW5lZCcsICdvdXRsaW5lZCcsICd0ZXh0J10pXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUJ1dHRvbidcbn0pKEJ1dHRvbik7IiwiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgTGlzdCBmcm9tIFwiQG1hdGVyaWFsLXVpL2NvcmUvTGlzdFwiO1xuaW1wb3J0IExpc3RJdGVtIGZyb20gXCJAbWF0ZXJpYWwtdWkvY29yZS9MaXN0SXRlbVwiO1xuaW1wb3J0IExpc3RJdGVtVGV4dCBmcm9tIFwiQG1hdGVyaWFsLXVpL2NvcmUvTGlzdEl0ZW1UZXh0XCI7XG5pbXBvcnQgRGl2aWRlciBmcm9tIFwiQG1hdGVyaWFsLXVpL2NvcmUvRGl2aWRlclwiO1xuaW1wb3J0IENoZWNrYm94IGZyb20gXCJAbWF0ZXJpYWwtdWkvY29yZS9DaGVja2JveFwiO1xuaW1wb3J0IExpc3RJdGVtSWNvbiBmcm9tIFwiQG1hdGVyaWFsLXVpL2NvcmUvTGlzdEl0ZW1JY29uXCI7XG5pbXBvcnQgVGV4dEZpZWxkIGZyb20gXCJAbWF0ZXJpYWwtdWkvY29yZS9UZXh0RmllbGRcIjtcbmltcG9ydCBCdXR0b24gZnJvbSBcIkBtYXRlcmlhbC11aS9jb3JlL0J1dHRvblwiO1xuaW1wb3J0IHsgdXNlUXVlcnksIHVzZU11dGF0aW9uIH0gZnJvbSBcIkBhcG9sbG8vcmVhY3QtaG9va3NcIjtcbmltcG9ydCB7IFJFQURfVE9ET1MgfSBmcm9tIFwiLi4vY29tcG9uZW50cy9NYWluLmpzeFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZUl0ZW1MaXN0KHByb3BzKSB7XG4gIC8vVE9ETzogcmV0cmlldmluZyB0b2RvaXRlbXMgZnJvbSBkYlxuICBjb25zdCB7IGRhdGEsIGNyZWF0ZVRvZG8sIHJlbW92ZVRvZG8sIHJlZmV0Y2ggfSA9IHByb3BzO1xuICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShbMF0pO1xuICBjb25zdCBbdGV4dCwgc2V0VGV4dF0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgY29uc3QgaGFuZGxlVG9nZ2xlID0gKHZhbHVlKSA9PiAoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudEluZGV4ID0gY2hlY2tlZC5pbmRleE9mKHZhbHVlKTtcbiAgICBjb25zdCBuZXdDaGVja2VkID0gWy4uLmNoZWNrZWRdO1xuXG4gICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gLTEpIHtcbiAgICAgIG5ld0NoZWNrZWQucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NoZWNrZWQuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSk7XG4gICAgfVxuICAgIHNldENoZWNrZWQobmV3Q2hlY2tlZCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlVmFsdWUgPSAoZXZlbnQpID0+IHtcbiAgICBzZXRUZXh0KGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gIH07XG5cbiAgY29uc3QgYWRkVG9kb0l0ZW0gPSAobmV3SXRlbSkgPT4ge1xuICAgIGNyZWF0ZVRvZG8oe1xuICAgICAgdmFyaWFibGVzOiB7IG5hbWU6IG5ld0l0ZW0gfSxcbiAgICAgIG9wdGltaXN0aWNSZXNwb25zZToge1xuICAgICAgICBfX3R5cGVuYW1lOiBcIk11dGF0aW9uXCIsXG4gICAgICAgIGNyZWF0ZVRvZG86IHtcbiAgICAgICAgICBfX3R5cGVuYW1lOiBcIlRvZG9cIixcbiAgICAgICAgICBpZDogTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogLTEwMDAwMDApLFxuICAgICAgICAgIG5hbWU6IFwiTEFMQUxBXCIsXG4gICAgICAgICAgY29tcGxldGVkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB1cGRhdGUoY2FjaGUsIHsgZGF0YTogeyBjcmVhdGVUb2RvIH0gfSkge1xuICAgICAgICBjb25zdCB7IHRvZG9zIH0gPSBjYWNoZS5yZWFkUXVlcnkoeyBxdWVyeTogUkVBRF9UT0RPUyB9KTtcbiAgICAgICAgY2FjaGUud3JpdGVRdWVyeSh7XG4gICAgICAgICAgcXVlcnk6IFJFQURfVE9ET1MsXG4gICAgICAgICAgZGF0YTogeyB0b2RvczogdG9kb3MuY29uY2F0KFtjcmVhdGVUb2RvXSkgfSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgIH0pO1xuICAgIC8vIGxldCBsaXN0ID0gdG9kb0l0ZW1zLnNsaWNlKCk7XG4gICAgLy8gbGlzdC5wdXNoKHsgbmFtZTogbmV3SXRlbSwgZG9uZTogZmFsc2UgfSk7XG4gICAgLy8gc2V0VG9Eb0l0ZW1zKGxpc3QpO1xuICAgIC8vIGNyZWF0ZVRvZG8oeyB2YXJpYWJsZXM6IHsgbmFtZTogbmV3SXRlbSB9IH0pO1xuICAgIC8vIHJlZmV0Y2goKTtcbiAgICBzZXRUZXh0KFwiXCIpO1xuICB9O1xuICByZXR1cm4gKFxuICAgIDxMaXN0PlxuICAgICAge2RhdGEgJiZcbiAgICAgICAgZGF0YS50b2RvcyAmJlxuICAgICAgICBkYXRhLnRvZG9zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBsYWJlbElkID0gYGNoZWNrYm94LWxpc3QtbGFiZWwtJHtpbmRleH1gO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICA8RGl2aWRlciAvPlxuICAgICAgICAgICAgICA8TGlzdEl0ZW1cbiAgICAgICAgICAgICAgICBrZXk9e2BpdGVtLSR7aXRlbS5uYW1lfS0ke2luZGV4fWB9XG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlVG9nZ2xlKGluZGV4KX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxMaXN0SXRlbUljb24+PC9MaXN0SXRlbUljb24+XG4gICAgICAgICAgICAgICAgPExpc3RJdGVtVGV4dCBwcmltYXJ5PXtgJHtpdGVtLm5hbWV9YH0gLz5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVRvZG8oeyB2YXJpYWJsZXM6IHsgaWQ6IGl0ZW0uaWQgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXRjaCgpO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBYXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgIDwvTGlzdEl0ZW0+XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDxUZXh0RmllbGRcbiAgICAgICAgaWQ9XCJzdGFuZGFyZC1uYW1lXCJcbiAgICAgICAgbGFiZWw9XCJBZGQgVG8gRG9cIlxuICAgICAgICB2YWx1ZT17dGV4dH1cbiAgICAgICAgb25DaGFuZ2U9e2hhbmRsZVZhbHVlfVxuICAgICAgLz5cbiAgICAgIDxCdXR0b24gb25DbGljaz17KCkgPT4gYWRkVG9kb0l0ZW0odGV4dCl9PlNhdmUgVG8gRG88L0J1dHRvbj5cbiAgICA8L0xpc3Q+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBtYWtlU3R5bGVzIH0gZnJvbSBcIkBtYXRlcmlhbC11aS9jb3JlL3N0eWxlc1wiO1xuaW1wb3J0IENhcmQgZnJvbSBcIkBtYXRlcmlhbC11aS9jb3JlL0NhcmRcIjtcbmltcG9ydCBDYXJkQ29udGVudCBmcm9tIFwiQG1hdGVyaWFsLXVpL2NvcmUvQ2FyZENvbnRlbnRcIjtcbmltcG9ydCBDYXJkSGVhZGVyIGZyb20gXCJAbWF0ZXJpYWwtdWkvY29yZS9DYXJkSGVhZGVyXCI7XG5pbXBvcnQgSXRlbUxpc3QgZnJvbSBcIi4uL2NvbnRhaW5lcnMvTGlzdC5qc3hcIjtcblxuLy8gaW1wb3J0IFR5cG9ncmFwaHkgZnJvbSBcIkBtYXRlcmlhbC11aS9jb3JlL1R5cG9ncmFwaHlcIjtcblxuY29uc3QgdXNlU3R5bGVzID0gbWFrZVN0eWxlcygodGhlbWUpID0+ICh7XG4gIHJvb3Q6IHtcbiAgICBtYXhXaWR0aDogMzQ1LFxuICB9LFxufSkpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUb0RvTGlzdChwcm9wcykge1xuICBjb25zdCB7IGRhdGEsIGNyZWF0ZVRvZG8sIHJlbW92ZVRvZG8sIHJlZmV0Y2ggfSA9IHByb3BzO1xuICBjb25zb2xlLmxvZyhcImRhdGFcIiwgZGF0YSk7XG4gIGNvbnN0IGNsYXNzZXMgPSB1c2VTdHlsZXMoKTtcbiAgcmV0dXJuIChcbiAgICA8Q2FyZCBjbGFzc05hbWU9e2NsYXNzZXMucm9vdH0+XG4gICAgICA8Q2FyZEhlYWRlciB0aXRsZT1cIlRvIERvIExpc3RcIiBzdWJoZWFkZXI9XCJTZXB0ZW1iZXIgMTQsIDIwMTZcIiAvPlxuICAgICAgPENhcmRDb250ZW50PlxuICAgICAgICA8SXRlbUxpc3RcbiAgICAgICAgICBkYXRhPXtkYXRhfVxuICAgICAgICAgIHJlZmV0Y2g9e3JlZmV0Y2h9XG4gICAgICAgICAgY3JlYXRlVG9kbz17Y3JlYXRlVG9kb31cbiAgICAgICAgICByZW1vdmVUb2RvPXtyZW1vdmVUb2RvfVxuICAgICAgICAvPlxuICAgICAgPC9DYXJkQ29udGVudD5cbiAgICA8L0NhcmQ+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAndHMtaW52YXJpYW50JztcblxudmFyIGFwb2xsb0NvbnRleHQ7XG5mdW5jdGlvbiBnZXRBcG9sbG9Db250ZXh0KCkge1xuICAgIGlmICghYXBvbGxvQ29udGV4dCkge1xuICAgICAgICBhcG9sbG9Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG4gICAgfVxuICAgIHJldHVybiBhcG9sbG9Db250ZXh0O1xufVxuZnVuY3Rpb24gcmVzZXRBcG9sbG9Db250ZXh0KCkge1xuICAgIGFwb2xsb0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcbn1cblxudmFyIEFwb2xsb1Byb3ZpZGVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNsaWVudCA9IF9hLmNsaWVudCwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICB2YXIgQXBvbGxvQ29udGV4dCA9IGdldEFwb2xsb0NvbnRleHQoKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBcG9sbG9Db250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSB7fTsgfVxuICAgICAgICBpZiAoY2xpZW50ICYmIGNvbnRleHQuY2xpZW50ICE9PSBjbGllbnQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LCB7IGNsaWVudDogY2xpZW50IH0pO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChjb250ZXh0LmNsaWVudCwgNSkgOiBpbnZhcmlhbnQoY29udGV4dC5jbGllbnQsICdBcG9sbG9Qcm92aWRlciB3YXMgbm90IHBhc3NlZCBhIGNsaWVudCBpbnN0YW5jZS4gTWFrZSAnICtcbiAgICAgICAgICAgICdzdXJlIHlvdSBwYXNzIGluIHlvdXIgY2xpZW50IHZpYSB0aGUgXCJjbGllbnRcIiBwcm9wLicpO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXBvbGxvQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCBjaGlsZHJlbikpO1xuICAgIH0pO1xufTtcblxudmFyIEFwb2xsb0NvbnN1bWVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIEFwb2xsb0NvbnRleHQgPSBnZXRBcG9sbG9Db250ZXh0KCk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXBvbGxvQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGNvbnRleHQgJiYgY29udGV4dC5jbGllbnQsIDYpIDogaW52YXJpYW50KGNvbnRleHQgJiYgY29udGV4dC5jbGllbnQsICdDb3VsZCBub3QgZmluZCBcImNsaWVudFwiIGluIHRoZSBjb250ZXh0IG9mIEFwb2xsb0NvbnN1bWVyLiAnICtcbiAgICAgICAgICAgICdXcmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhbiA8QXBvbGxvUHJvdmlkZXI+LicpO1xuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oY29udGV4dC5jbGllbnQpO1xuICAgIH0pO1xufTtcblxudmFyIERvY3VtZW50VHlwZTtcbihmdW5jdGlvbiAoRG9jdW1lbnRUeXBlKSB7XG4gICAgRG9jdW1lbnRUeXBlW0RvY3VtZW50VHlwZVtcIlF1ZXJ5XCJdID0gMF0gPSBcIlF1ZXJ5XCI7XG4gICAgRG9jdW1lbnRUeXBlW0RvY3VtZW50VHlwZVtcIk11dGF0aW9uXCJdID0gMV0gPSBcIk11dGF0aW9uXCI7XG4gICAgRG9jdW1lbnRUeXBlW0RvY3VtZW50VHlwZVtcIlN1YnNjcmlwdGlvblwiXSA9IDJdID0gXCJTdWJzY3JpcHRpb25cIjtcbn0pKERvY3VtZW50VHlwZSB8fCAoRG9jdW1lbnRUeXBlID0ge30pKTtcbnZhciBjYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIG9wZXJhdGlvbk5hbWUodHlwZSkge1xuICAgIHZhciBuYW1lO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIERvY3VtZW50VHlwZS5RdWVyeTpcbiAgICAgICAgICAgIG5hbWUgPSAnUXVlcnknO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRG9jdW1lbnRUeXBlLk11dGF0aW9uOlxuICAgICAgICAgICAgbmFtZSA9ICdNdXRhdGlvbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBEb2N1bWVudFR5cGUuU3Vic2NyaXB0aW9uOlxuICAgICAgICAgICAgbmFtZSA9ICdTdWJzY3JpcHRpb24nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gcGFyc2VyKGRvY3VtZW50KSB7XG4gICAgdmFyIGNhY2hlZCA9IGNhY2hlLmdldChkb2N1bWVudCk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB2YXIgdmFyaWFibGVzLCB0eXBlLCBuYW1lO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCghIWRvY3VtZW50ICYmICEhZG9jdW1lbnQua2luZCwgMSkgOiBpbnZhcmlhbnQoISFkb2N1bWVudCAmJiAhIWRvY3VtZW50LmtpbmQsIFwiQXJndW1lbnQgb2YgXCIgKyBkb2N1bWVudCArIFwiIHBhc3NlZCB0byBwYXJzZXIgd2FzIG5vdCBhIHZhbGlkIEdyYXBoUUwgXCIgK1xuICAgICAgICBcIkRvY3VtZW50Tm9kZS4gWW91IG1heSBuZWVkIHRvIHVzZSAnZ3JhcGhxbC10YWcnIG9yIGFub3RoZXIgbWV0aG9kIFwiICtcbiAgICAgICAgXCJ0byBjb252ZXJ0IHlvdXIgb3BlcmF0aW9uIGludG8gYSBkb2N1bWVudFwiKTtcbiAgICB2YXIgZnJhZ21lbnRzID0gZG9jdW1lbnQuZGVmaW5pdGlvbnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmtpbmQgPT09ICdGcmFnbWVudERlZmluaXRpb24nOyB9KTtcbiAgICB2YXIgcXVlcmllcyA9IGRvY3VtZW50LmRlZmluaXRpb25zLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5raW5kID09PSAnT3BlcmF0aW9uRGVmaW5pdGlvbicgJiYgeC5vcGVyYXRpb24gPT09ICdxdWVyeSc7XG4gICAgfSk7XG4gICAgdmFyIG11dGF0aW9ucyA9IGRvY3VtZW50LmRlZmluaXRpb25zLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5raW5kID09PSAnT3BlcmF0aW9uRGVmaW5pdGlvbicgJiYgeC5vcGVyYXRpb24gPT09ICdtdXRhdGlvbic7XG4gICAgfSk7XG4gICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBkb2N1bWVudC5kZWZpbml0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nICYmIHgub3BlcmF0aW9uID09PSAnc3Vic2NyaXB0aW9uJztcbiAgICB9KTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoIWZyYWdtZW50cy5sZW5ndGggfHxcbiAgICAgICAgKHF1ZXJpZXMubGVuZ3RoIHx8IG11dGF0aW9ucy5sZW5ndGggfHwgc3Vic2NyaXB0aW9ucy5sZW5ndGgpLCAyKSA6IGludmFyaWFudCghZnJhZ21lbnRzLmxlbmd0aCB8fFxuICAgICAgICAocXVlcmllcy5sZW5ndGggfHwgbXV0YXRpb25zLmxlbmd0aCB8fCBzdWJzY3JpcHRpb25zLmxlbmd0aCksIFwiUGFzc2luZyBvbmx5IGEgZnJhZ21lbnQgdG8gJ2dyYXBocWwnIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBcIiArXG4gICAgICAgIFwiWW91IG11c3QgaW5jbHVkZSBhIHF1ZXJ5LCBzdWJzY3JpcHRpb24gb3IgbXV0YXRpb24gYXMgd2VsbFwiKTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQocXVlcmllcy5sZW5ndGggKyBtdXRhdGlvbnMubGVuZ3RoICsgc3Vic2NyaXB0aW9ucy5sZW5ndGggPD0gMSwgMykgOiBpbnZhcmlhbnQocXVlcmllcy5sZW5ndGggKyBtdXRhdGlvbnMubGVuZ3RoICsgc3Vic2NyaXB0aW9ucy5sZW5ndGggPD0gMSwgXCJyZWFjdC1hcG9sbG8gb25seSBzdXBwb3J0cyBhIHF1ZXJ5LCBzdWJzY3JpcHRpb24sIG9yIGEgbXV0YXRpb24gcGVyIEhPQy4gXCIgK1xuICAgICAgICAoZG9jdW1lbnQgKyBcIiBoYWQgXCIgKyBxdWVyaWVzLmxlbmd0aCArIFwiIHF1ZXJpZXMsIFwiICsgc3Vic2NyaXB0aW9ucy5sZW5ndGggKyBcIiBcIikgK1xuICAgICAgICAoXCJzdWJzY3JpcHRpb25zIGFuZCBcIiArIG11dGF0aW9ucy5sZW5ndGggKyBcIiBtdXRhdGlvbnMuIFwiKSArXG4gICAgICAgIFwiWW91IGNhbiB1c2UgJ2NvbXBvc2UnIHRvIGpvaW4gbXVsdGlwbGUgb3BlcmF0aW9uIHR5cGVzIHRvIGEgY29tcG9uZW50XCIpO1xuICAgIHR5cGUgPSBxdWVyaWVzLmxlbmd0aCA/IERvY3VtZW50VHlwZS5RdWVyeSA6IERvY3VtZW50VHlwZS5NdXRhdGlvbjtcbiAgICBpZiAoIXF1ZXJpZXMubGVuZ3RoICYmICFtdXRhdGlvbnMubGVuZ3RoKVxuICAgICAgICB0eXBlID0gRG9jdW1lbnRUeXBlLlN1YnNjcmlwdGlvbjtcbiAgICB2YXIgZGVmaW5pdGlvbnMgPSBxdWVyaWVzLmxlbmd0aFxuICAgICAgICA/IHF1ZXJpZXNcbiAgICAgICAgOiBtdXRhdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICA/IG11dGF0aW9uc1xuICAgICAgICAgICAgOiBzdWJzY3JpcHRpb25zO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChkZWZpbml0aW9ucy5sZW5ndGggPT09IDEsIDQpIDogaW52YXJpYW50KGRlZmluaXRpb25zLmxlbmd0aCA9PT0gMSwgXCJyZWFjdC1hcG9sbG8gb25seSBzdXBwb3J0cyBvbmUgZGVmaW5pdGlvbiBwZXIgSE9DLiBcIiArIGRvY3VtZW50ICsgXCIgaGFkIFwiICtcbiAgICAgICAgKGRlZmluaXRpb25zLmxlbmd0aCArIFwiIGRlZmluaXRpb25zLiBcIikgK1xuICAgICAgICBcIllvdSBjYW4gdXNlICdjb21wb3NlJyB0byBqb2luIG11bHRpcGxlIG9wZXJhdGlvbiB0eXBlcyB0byBhIGNvbXBvbmVudFwiKTtcbiAgICB2YXIgZGVmaW5pdGlvbiA9IGRlZmluaXRpb25zWzBdO1xuICAgIHZhcmlhYmxlcyA9IGRlZmluaXRpb24udmFyaWFibGVEZWZpbml0aW9ucyB8fCBbXTtcbiAgICBpZiAoZGVmaW5pdGlvbi5uYW1lICYmIGRlZmluaXRpb24ubmFtZS5raW5kID09PSAnTmFtZScpIHtcbiAgICAgICAgbmFtZSA9IGRlZmluaXRpb24ubmFtZS52YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5hbWUgPSAnZGF0YSc7XG4gICAgfVxuICAgIHZhciBwYXlsb2FkID0geyBuYW1lOiBuYW1lLCB0eXBlOiB0eXBlLCB2YXJpYWJsZXM6IHZhcmlhYmxlcyB9O1xuICAgIGNhY2hlLnNldChkb2N1bWVudCwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59XG5cbmV4cG9ydCB7IEFwb2xsb0NvbnN1bWVyLCBBcG9sbG9Qcm92aWRlciwgRG9jdW1lbnRUeXBlLCBnZXRBcG9sbG9Db250ZXh0LCBvcGVyYXRpb25OYW1lLCBwYXJzZXIsIHJlc2V0QXBvbGxvQ29udGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtY29tbW9uLmVzbS5qcy5tYXBcbiIsImltcG9ydCB6ZW5PYnNlcnZhYmxlIGZyb20gJ3plbi1vYnNlcnZhYmxlJztcblxudmFyIE9ic2VydmFibGUgPSB6ZW5PYnNlcnZhYmxlO1xuXG5leHBvcnQgZGVmYXVsdCBPYnNlcnZhYmxlO1xuZXhwb3J0IHsgT2JzZXJ2YWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVuZGxlLmVzbS5qcy5tYXBcbiIsImltcG9ydCBPYnNlcnZhYmxlIGZyb20gJ3plbi1vYnNlcnZhYmxlLXRzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgT2JzZXJ2YWJsZSB9IGZyb20gJ3plbi1vYnNlcnZhYmxlLXRzJztcbmltcG9ydCB7IGludmFyaWFudCwgSW52YXJpYW50RXJyb3IgfSBmcm9tICd0cy1pbnZhcmlhbnQnO1xuaW1wb3J0IHsgX19leHRlbmRzLCBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGdldE9wZXJhdGlvbk5hbWUgfSBmcm9tICdhcG9sbG8tdXRpbGl0aWVzJztcbmV4cG9ydCB7IGdldE9wZXJhdGlvbk5hbWUgfSBmcm9tICdhcG9sbG8tdXRpbGl0aWVzJztcblxuZnVuY3Rpb24gdmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uKSB7XG4gICAgdmFyIE9QRVJBVElPTl9GSUVMRFMgPSBbXG4gICAgICAgICdxdWVyeScsXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICAgICAgJ3ZhcmlhYmxlcycsXG4gICAgICAgICdleHRlbnNpb25zJyxcbiAgICAgICAgJ2NvbnRleHQnLFxuICAgIF07XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKG9wZXJhdGlvbik7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgIGlmIChPUEVSQVRJT05fRklFTERTLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG5ldyBJbnZhcmlhbnRFcnJvcigyKSA6IG5ldyBJbnZhcmlhbnRFcnJvcihcImlsbGVnYWwgYXJndW1lbnQ6IFwiICsga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9uO1xufVxudmFyIExpbmtFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmtFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rRXJyb3IobWVzc2FnZSwgbGluaykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5saW5rID0gbGluaztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGlua0Vycm9yO1xufShFcnJvcikpO1xuZnVuY3Rpb24gaXNUZXJtaW5hdGluZyhsaW5rKSB7XG4gICAgcmV0dXJuIGxpbmsucmVxdWVzdC5sZW5ndGggPD0gMTtcbn1cbmZ1bmN0aW9uIHRvUHJvbWlzZShvYnNlcnZhYmxlKSB7XG4gICAgdmFyIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIG9ic2VydmFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgaW52YXJpYW50Lndhcm4oXCJQcm9taXNlIFdyYXBwZXIgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aXBsZSByZXN1bHRzIGZyb20gT2JzZXJ2YWJsZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxudmFyIG1ha2VQcm9taXNlID0gdG9Qcm9taXNlO1xuZnVuY3Rpb24gZnJvbVByb21pc2UocHJvbWlzZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2gob2JzZXJ2ZXIuZXJyb3IuYmluZChvYnNlcnZlcikpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZnJvbUVycm9yKGVycm9yVmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yVmFsdWUpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgIHZhciB0cmFuc2Zvcm1lZE9wZXJhdGlvbiA9IHtcbiAgICAgICAgdmFyaWFibGVzOiBvcGVyYXRpb24udmFyaWFibGVzIHx8IHt9LFxuICAgICAgICBleHRlbnNpb25zOiBvcGVyYXRpb24uZXh0ZW5zaW9ucyB8fCB7fSxcbiAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm9wZXJhdGlvbk5hbWUsXG4gICAgICAgIHF1ZXJ5OiBvcGVyYXRpb24ucXVlcnksXG4gICAgfTtcbiAgICBpZiAoIXRyYW5zZm9ybWVkT3BlcmF0aW9uLm9wZXJhdGlvbk5hbWUpIHtcbiAgICAgICAgdHJhbnNmb3JtZWRPcGVyYXRpb24ub3BlcmF0aW9uTmFtZSA9XG4gICAgICAgICAgICB0eXBlb2YgdHJhbnNmb3JtZWRPcGVyYXRpb24ucXVlcnkgIT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBnZXRPcGVyYXRpb25OYW1lKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnF1ZXJ5KVxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1lZE9wZXJhdGlvbjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9wZXJhdGlvbihzdGFydGluZywgb3BlcmF0aW9uKSB7XG4gICAgdmFyIGNvbnRleHQgPSBfX2Fzc2lnbih7fSwgc3RhcnRpbmcpO1xuICAgIHZhciBzZXRDb250ZXh0ID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gX19hc3NpZ24oe30sIGNvbnRleHQsIG5leHQoY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dCA9IF9fYXNzaWduKHt9LCBjb250ZXh0LCBuZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoX19hc3NpZ24oe30sIGNvbnRleHQpKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3BlcmF0aW9uLCAnc2V0Q29udGV4dCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZXRDb250ZXh0LFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcGVyYXRpb24sICdnZXRDb250ZXh0Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGdldENvbnRleHQsXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wZXJhdGlvbiwgJ3RvS2V5Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldEtleShvcGVyYXRpb24pOyB9LFxuICAgIH0pO1xuICAgIHJldHVybiBvcGVyYXRpb247XG59XG5mdW5jdGlvbiBnZXRLZXkob3BlcmF0aW9uKSB7XG4gICAgdmFyIHF1ZXJ5ID0gb3BlcmF0aW9uLnF1ZXJ5LCB2YXJpYWJsZXMgPSBvcGVyYXRpb24udmFyaWFibGVzLCBvcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uLm9wZXJhdGlvbk5hbWU7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFtvcGVyYXRpb25OYW1lLCBxdWVyeSwgdmFyaWFibGVzXSk7XG59XG5cbmZ1bmN0aW9uIHBhc3N0aHJvdWdoKG9wLCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGZvcndhcmQgPyBmb3J3YXJkKG9wKSA6IE9ic2VydmFibGUub2YoKTtcbn1cbmZ1bmN0aW9uIHRvTGluayhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nID8gbmV3IEFwb2xsb0xpbmsoaGFuZGxlcikgOiBoYW5kbGVyO1xufVxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9ic2VydmFibGUub2YoKTsgfSk7XG59XG5mdW5jdGlvbiBmcm9tKGxpbmtzKSB7XG4gICAgaWYgKGxpbmtzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGVtcHR5KCk7XG4gICAgcmV0dXJuIGxpbmtzLm1hcCh0b0xpbmspLnJlZHVjZShmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geC5jb25jYXQoeSk7IH0pO1xufVxuZnVuY3Rpb24gc3BsaXQodGVzdCwgbGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgbGVmdExpbmsgPSB0b0xpbmsobGVmdCk7XG4gICAgdmFyIHJpZ2h0TGluayA9IHRvTGluayhyaWdodCB8fCBuZXcgQXBvbGxvTGluayhwYXNzdGhyb3VnaCkpO1xuICAgIGlmIChpc1Rlcm1pbmF0aW5nKGxlZnRMaW5rKSAmJiBpc1Rlcm1pbmF0aW5nKHJpZ2h0TGluaykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0KG9wZXJhdGlvbilcbiAgICAgICAgICAgICAgICA/IGxlZnRMaW5rLnJlcXVlc3Qob3BlcmF0aW9uKSB8fCBPYnNlcnZhYmxlLm9mKClcbiAgICAgICAgICAgICAgICA6IHJpZ2h0TGluay5yZXF1ZXN0KG9wZXJhdGlvbikgfHwgT2JzZXJ2YWJsZS5vZigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQXBvbGxvTGluayhmdW5jdGlvbiAob3BlcmF0aW9uLCBmb3J3YXJkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdChvcGVyYXRpb24pXG4gICAgICAgICAgICAgICAgPyBsZWZ0TGluay5yZXF1ZXN0KG9wZXJhdGlvbiwgZm9yd2FyZCkgfHwgT2JzZXJ2YWJsZS5vZigpXG4gICAgICAgICAgICAgICAgOiByaWdodExpbmsucmVxdWVzdChvcGVyYXRpb24sIGZvcndhcmQpIHx8IE9ic2VydmFibGUub2YoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxudmFyIGNvbmNhdCA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgdmFyIGZpcnN0TGluayA9IHRvTGluayhmaXJzdCk7XG4gICAgaWYgKGlzVGVybWluYXRpbmcoZmlyc3RMaW5rKSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgaW52YXJpYW50Lndhcm4obmV3IExpbmtFcnJvcihcIllvdSBhcmUgY2FsbGluZyBjb25jYXQgb24gYSB0ZXJtaW5hdGluZyBsaW5rLCB3aGljaCB3aWxsIGhhdmUgbm8gZWZmZWN0XCIsIGZpcnN0TGluaykpO1xuICAgICAgICByZXR1cm4gZmlyc3RMaW5rO1xuICAgIH1cbiAgICB2YXIgbmV4dExpbmsgPSB0b0xpbmsoc2Vjb25kKTtcbiAgICBpZiAoaXNUZXJtaW5hdGluZyhuZXh0TGluaykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdExpbmsucmVxdWVzdChvcGVyYXRpb24sIGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gbmV4dExpbmsucmVxdWVzdChvcCkgfHwgT2JzZXJ2YWJsZS5vZigpOyB9KSB8fCBPYnNlcnZhYmxlLm9mKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24sIGZvcndhcmQpIHtcbiAgICAgICAgICAgIHJldHVybiAoZmlyc3RMaW5rLnJlcXVlc3Qob3BlcmF0aW9uLCBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dExpbmsucmVxdWVzdChvcCwgZm9yd2FyZCkgfHwgT2JzZXJ2YWJsZS5vZigpO1xuICAgICAgICAgICAgfSkgfHwgT2JzZXJ2YWJsZS5vZigpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbnZhciBBcG9sbG9MaW5rID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcG9sbG9MaW5rKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QpXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIH1cbiAgICBBcG9sbG9MaW5rLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICh0ZXN0LCBsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25jYXQoc3BsaXQodGVzdCwgbGVmdCwgcmlnaHQgfHwgbmV3IEFwb2xsb0xpbmsocGFzc3Rocm91Z2gpKSk7XG4gICAgfTtcbiAgICBBcG9sbG9MaW5rLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KHRoaXMsIG5leHQpO1xuICAgIH07XG4gICAgQXBvbGxvTGluay5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIGZvcndhcmQpIHtcbiAgICAgICAgdGhyb3cgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbmV3IEludmFyaWFudEVycm9yKDEpIDogbmV3IEludmFyaWFudEVycm9yKCdyZXF1ZXN0IGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgQXBvbGxvTGluay5lbXB0eSA9IGVtcHR5O1xuICAgIEFwb2xsb0xpbmsuZnJvbSA9IGZyb207XG4gICAgQXBvbGxvTGluay5zcGxpdCA9IHNwbGl0O1xuICAgIEFwb2xsb0xpbmsuZXhlY3V0ZSA9IGV4ZWN1dGU7XG4gICAgcmV0dXJuIEFwb2xsb0xpbms7XG59KCkpO1xuZnVuY3Rpb24gZXhlY3V0ZShsaW5rLCBvcGVyYXRpb24pIHtcbiAgICByZXR1cm4gKGxpbmsucmVxdWVzdChjcmVhdGVPcGVyYXRpb24ob3BlcmF0aW9uLmNvbnRleHQsIHRyYW5zZm9ybU9wZXJhdGlvbih2YWxpZGF0ZU9wZXJhdGlvbihvcGVyYXRpb24pKSkpIHx8IE9ic2VydmFibGUub2YoKSk7XG59XG5cbmV4cG9ydCB7IEFwb2xsb0xpbmssIGNvbmNhdCwgY3JlYXRlT3BlcmF0aW9uLCBlbXB0eSwgZXhlY3V0ZSwgZnJvbSwgZnJvbUVycm9yLCBmcm9tUHJvbWlzZSwgbWFrZVByb21pc2UsIHNwbGl0LCB0b1Byb21pc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBfX2V4dGVuZHMsIF9fYXNzaWduLCBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbiwgaXNFcXVhbCwgdHJ5RnVuY3Rpb25PckxvZ0Vycm9yLCBjbG9uZURlZXAsIG1lcmdlRGVlcCwgaGFzRGlyZWN0aXZlcywgcmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudCwgYnVpbGRRdWVyeUZyb21TZWxlY3Rpb25TZXQsIGdldE1haW5EZWZpbml0aW9uLCBnZXRGcmFnbWVudERlZmluaXRpb25zLCBjcmVhdGVGcmFnbWVudE1hcCwgbWVyZ2VEZWVwQXJyYXksIHJlc3VsdEtleU5hbWVGcm9tRmllbGQsIGFyZ3VtZW50c09iamVjdEZyb21GaWVsZCwgc2hvdWxkSW5jbHVkZSwgaXNGaWVsZCwgaXNJbmxpbmVGcmFnbWVudCwgY2FuVXNlV2Vha01hcCwgZ3JhcGhRTFJlc3VsdEhhc0Vycm9yLCByZW1vdmVDb25uZWN0aW9uRGlyZWN0aXZlRnJvbURvY3VtZW50LCBoYXNDbGllbnRFeHBvcnRzLCBnZXREZWZhdWx0VmFsdWVzLCBnZXRPcGVyYXRpb25OYW1lIH0gZnJvbSAnYXBvbGxvLXV0aWxpdGllcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIGFzIE9ic2VydmFibGUkMSwgZXhlY3V0ZSwgQXBvbGxvTGluayB9IGZyb20gJ2Fwb2xsby1saW5rJztcbmltcG9ydCAkJG9ic2VydmFibGUgZnJvbSAnc3ltYm9sLW9ic2VydmFibGUnO1xuaW1wb3J0IHsgSW52YXJpYW50RXJyb3IsIGludmFyaWFudCB9IGZyb20gJ3RzLWludmFyaWFudCc7XG5pbXBvcnQgeyB2aXNpdCwgQlJFQUsgfSBmcm9tICdncmFwaHFsL2xhbmd1YWdlL3Zpc2l0b3InO1xuXG52YXIgTmV0d29ya1N0YXR1cztcbihmdW5jdGlvbiAoTmV0d29ya1N0YXR1cykge1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcImxvYWRpbmdcIl0gPSAxXSA9IFwibG9hZGluZ1wiO1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcInNldFZhcmlhYmxlc1wiXSA9IDJdID0gXCJzZXRWYXJpYWJsZXNcIjtcbiAgICBOZXR3b3JrU3RhdHVzW05ldHdvcmtTdGF0dXNbXCJmZXRjaE1vcmVcIl0gPSAzXSA9IFwiZmV0Y2hNb3JlXCI7XG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wicmVmZXRjaFwiXSA9IDRdID0gXCJyZWZldGNoXCI7XG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wicG9sbFwiXSA9IDZdID0gXCJwb2xsXCI7XG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wicmVhZHlcIl0gPSA3XSA9IFwicmVhZHlcIjtcbiAgICBOZXR3b3JrU3RhdHVzW05ldHdvcmtTdGF0dXNbXCJlcnJvclwiXSA9IDhdID0gXCJlcnJvclwiO1xufSkoTmV0d29ya1N0YXR1cyB8fCAoTmV0d29ya1N0YXR1cyA9IHt9KSk7XG5mdW5jdGlvbiBpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQobmV0d29ya1N0YXR1cykge1xuICAgIHJldHVybiBuZXR3b3JrU3RhdHVzIDwgNztcbn1cblxudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVsnQEBvYnNlcnZhYmxlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KE9ic2VydmFibGUkMSkpO1xuXG5mdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cblxuZnVuY3Rpb24gaXNBcG9sbG9FcnJvcihlcnIpIHtcbiAgICByZXR1cm4gZXJyLmhhc093blByb3BlcnR5KCdncmFwaFFMRXJyb3JzJyk7XG59XG52YXIgZ2VuZXJhdGVFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnJztcbiAgICBpZiAoaXNOb25FbXB0eUFycmF5KGVyci5ncmFwaFFMRXJyb3JzKSkge1xuICAgICAgICBlcnIuZ3JhcGhRTEVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChncmFwaFFMRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBncmFwaFFMRXJyb3JcbiAgICAgICAgICAgICAgICA/IGdyYXBoUUxFcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgOiAnRXJyb3IgbWVzc2FnZSBub3QgZm91bmQuJztcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCJHcmFwaFFMIGVycm9yOiBcIiArIGVycm9yTWVzc2FnZSArIFwiXFxuXCI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyLm5ldHdvcmtFcnJvcikge1xuICAgICAgICBtZXNzYWdlICs9ICdOZXR3b3JrIGVycm9yOiAnICsgZXJyLm5ldHdvcmtFcnJvci5tZXNzYWdlICsgJ1xcbic7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoL1xcbiQvLCAnJyk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59O1xudmFyIEFwb2xsb0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXBvbGxvRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXBvbGxvRXJyb3IoX2EpIHtcbiAgICAgICAgdmFyIGdyYXBoUUxFcnJvcnMgPSBfYS5ncmFwaFFMRXJyb3JzLCBuZXR3b3JrRXJyb3IgPSBfYS5uZXR3b3JrRXJyb3IsIGVycm9yTWVzc2FnZSA9IF9hLmVycm9yTWVzc2FnZSwgZXh0cmFJbmZvID0gX2EuZXh0cmFJbmZvO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlcnJvck1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmdyYXBoUUxFcnJvcnMgPSBncmFwaFFMRXJyb3JzIHx8IFtdO1xuICAgICAgICBfdGhpcy5uZXR3b3JrRXJyb3IgPSBuZXR3b3JrRXJyb3IgfHwgbnVsbDtcbiAgICAgICAgaWYgKCFlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIF90aGlzLm1lc3NhZ2UgPSBnZW5lcmF0ZUVycm9yTWVzc2FnZShfdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5tZXNzYWdlID0gZXJyb3JNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmV4dHJhSW5mbyA9IGV4dHJhSW5mbztcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gQXBvbGxvRXJyb3IucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBcG9sbG9FcnJvcjtcbn0oRXJyb3IpKTtcblxudmFyIEZldGNoVHlwZTtcbihmdW5jdGlvbiAoRmV0Y2hUeXBlKSB7XG4gICAgRmV0Y2hUeXBlW0ZldGNoVHlwZVtcIm5vcm1hbFwiXSA9IDFdID0gXCJub3JtYWxcIjtcbiAgICBGZXRjaFR5cGVbRmV0Y2hUeXBlW1wicmVmZXRjaFwiXSA9IDJdID0gXCJyZWZldGNoXCI7XG4gICAgRmV0Y2hUeXBlW0ZldGNoVHlwZVtcInBvbGxcIl0gPSAzXSA9IFwicG9sbFwiO1xufSkoRmV0Y2hUeXBlIHx8IChGZXRjaFR5cGUgPSB7fSkpO1xuXG52YXIgaGFzRXJyb3IgPSBmdW5jdGlvbiAoc3RvcmVWYWx1ZSwgcG9saWN5KSB7XG4gICAgaWYgKHBvbGljeSA9PT0gdm9pZCAwKSB7IHBvbGljeSA9ICdub25lJzsgfVxuICAgIHJldHVybiBzdG9yZVZhbHVlICYmIChzdG9yZVZhbHVlLm5ldHdvcmtFcnJvciB8fFxuICAgICAgICAocG9saWN5ID09PSAnbm9uZScgJiYgaXNOb25FbXB0eUFycmF5KHN0b3JlVmFsdWUuZ3JhcGhRTEVycm9ycykpKTtcbn07XG52YXIgT2JzZXJ2YWJsZVF1ZXJ5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JzZXJ2YWJsZVF1ZXJ5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVRdWVyeShfYSkge1xuICAgICAgICB2YXIgcXVlcnlNYW5hZ2VyID0gX2EucXVlcnlNYW5hZ2VyLCBvcHRpb25zID0gX2Eub3B0aW9ucywgX2IgPSBfYS5zaG91bGRTdWJzY3JpYmUsIHNob3VsZFN1YnNjcmliZSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9uU3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub2JzZXJ2ZXJzID0gbmV3IFNldCgpO1xuICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICBfdGhpcy5pc1Rvcm5Eb3duID0gZmFsc2U7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBfdGhpcy52YXJpYWJsZXMgPSBvcHRpb25zLnZhcmlhYmxlcyB8fCB7fTtcbiAgICAgICAgX3RoaXMucXVlcnlJZCA9IHF1ZXJ5TWFuYWdlci5nZW5lcmF0ZVF1ZXJ5SWQoKTtcbiAgICAgICAgX3RoaXMuc2hvdWxkU3Vic2NyaWJlID0gc2hvdWxkU3Vic2NyaWJlO1xuICAgICAgICB2YXIgb3BEZWYgPSBnZXRPcGVyYXRpb25EZWZpbml0aW9uKG9wdGlvbnMucXVlcnkpO1xuICAgICAgICBfdGhpcy5xdWVyeU5hbWUgPSBvcERlZiAmJiBvcERlZi5uYW1lICYmIG9wRGVmLm5hbWUudmFsdWU7XG4gICAgICAgIF90aGlzLnF1ZXJ5TWFuYWdlciA9IHF1ZXJ5TWFuYWdlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMub2JzZXJ2ZXJzLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnF1ZXJ5TWFuYWdlci5yZW1vdmVRdWVyeShfdGhpcy5xdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5jdXJyZW50UmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRDdXJyZW50UmVzdWx0KCk7XG4gICAgICAgIGlmIChyZXN1bHQuZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmdldEN1cnJlbnRSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVG9ybkRvd24pIHtcbiAgICAgICAgICAgIHZhciBsYXN0UmVzdWx0ID0gdGhpcy5sYXN0UmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiAhdGhpcy5sYXN0RXJyb3IgJiYgbGFzdFJlc3VsdCAmJiBsYXN0UmVzdWx0LmRhdGEgfHwgdm9pZCAwLFxuICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmxhc3RFcnJvcixcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBOZXR3b3JrU3RhdHVzLmVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLnF1ZXJ5TWFuYWdlci5nZXRDdXJyZW50UXVlcnlSZXN1bHQodGhpcyksIGRhdGEgPSBfYS5kYXRhLCBwYXJ0aWFsID0gX2EucGFydGlhbDtcbiAgICAgICAgdmFyIHF1ZXJ5U3RvcmVWYWx1ZSA9IHRoaXMucXVlcnlNYW5hZ2VyLnF1ZXJ5U3RvcmUuZ2V0KHRoaXMucXVlcnlJZCk7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBmZXRjaFBvbGljeSA9IHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICAgICAgdmFyIGlzTmV0d29ya0ZldGNoUG9saWN5ID0gZmV0Y2hQb2xpY3kgPT09ICduZXR3b3JrLW9ubHknIHx8XG4gICAgICAgICAgICBmZXRjaFBvbGljeSA9PT0gJ25vLWNhY2hlJztcbiAgICAgICAgaWYgKHF1ZXJ5U3RvcmVWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIG5ldHdvcmtTdGF0dXMgPSBxdWVyeVN0b3JlVmFsdWUubmV0d29ya1N0YXR1cztcbiAgICAgICAgICAgIGlmIChoYXNFcnJvcihxdWVyeVN0b3JlVmFsdWUsIHRoaXMub3B0aW9ucy5lcnJvclBvbGljeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBuZXR3b3JrU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEFwb2xsb0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoUUxFcnJvcnM6IHF1ZXJ5U3RvcmVWYWx1ZS5ncmFwaFFMRXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya0Vycm9yOiBxdWVyeVN0b3JlVmFsdWUubmV0d29ya0Vycm9yLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHF1ZXJ5U3RvcmVWYWx1ZS52YXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudmFyaWFibGVzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucy52YXJpYWJsZXMpLCBxdWVyeVN0b3JlVmFsdWUudmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHRoaXMub3B0aW9ucy52YXJpYWJsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQobmV0d29ya1N0YXR1cyksXG4gICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogbmV0d29ya1N0YXR1cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocXVlcnlTdG9yZVZhbHVlLmdyYXBoUUxFcnJvcnMgJiYgdGhpcy5vcHRpb25zLmVycm9yUG9saWN5ID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBxdWVyeVN0b3JlVmFsdWUuZ3JhcGhRTEVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsb2FkaW5nID0gaXNOZXR3b3JrRmV0Y2hQb2xpY3kgfHxcbiAgICAgICAgICAgICAgICAocGFydGlhbCAmJiBmZXRjaFBvbGljeSAhPT0gJ2NhY2hlLW9ubHknKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGxvYWRpbmc6IGxvYWRpbmcsXG4gICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogbG9hZGluZyA/IE5ldHdvcmtTdGF0dXMubG9hZGluZyA6IE5ldHdvcmtTdGF0dXMucmVhZHksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFydGlhbCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0UmVzdWx0KF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCB7IHN0YWxlOiBmYWxzZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCB7IHBhcnRpYWw6IHBhcnRpYWwgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmlzRGlmZmVyZW50RnJvbUxhc3RSZXN1bHQgPSBmdW5jdGlvbiAobmV3UmVzdWx0KSB7XG4gICAgICAgIHZhciBzbmFwc2hvdCA9IHRoaXMubGFzdFJlc3VsdFNuYXBzaG90O1xuICAgICAgICByZXR1cm4gIShzbmFwc2hvdCAmJlxuICAgICAgICAgICAgbmV3UmVzdWx0ICYmXG4gICAgICAgICAgICBzbmFwc2hvdC5uZXR3b3JrU3RhdHVzID09PSBuZXdSZXN1bHQubmV0d29ya1N0YXR1cyAmJlxuICAgICAgICAgICAgc25hcHNob3Quc3RhbGUgPT09IG5ld1Jlc3VsdC5zdGFsZSAmJlxuICAgICAgICAgICAgaXNFcXVhbChzbmFwc2hvdC5kYXRhLCBuZXdSZXN1bHQuZGF0YSkpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRMYXN0UmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0UmVzdWx0O1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRMYXN0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RFcnJvcjtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUucmVzZXRMYXN0UmVzdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubGFzdFJlc3VsdDtcbiAgICAgICAgZGVsZXRlIHRoaXMubGFzdFJlc3VsdFNuYXBzaG90O1xuICAgICAgICBkZWxldGUgdGhpcy5sYXN0RXJyb3I7XG4gICAgICAgIHRoaXMuaXNUb3JuRG93biA9IGZhbHNlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5yZXNldFF1ZXJ5U3RvcmVFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxdWVyeVN0b3JlID0gdGhpcy5xdWVyeU1hbmFnZXIucXVlcnlTdG9yZS5nZXQodGhpcy5xdWVyeUlkKTtcbiAgICAgICAgaWYgKHF1ZXJ5U3RvcmUpIHtcbiAgICAgICAgICAgIHF1ZXJ5U3RvcmUubmV0d29ya0Vycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHF1ZXJ5U3RvcmUuZ3JhcGhRTEVycm9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlZmV0Y2ggPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBmZXRjaFBvbGljeSA9IHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICAgICAgaWYgKGZldGNoUG9saWN5ID09PSAnY2FjaGUtb25seScpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoMSkgOiBuZXcgSW52YXJpYW50RXJyb3IoJ2NhY2hlLW9ubHkgZmV0Y2hQb2xpY3kgb3B0aW9uIHNob3VsZCBub3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIHF1ZXJ5IHJlZmV0Y2guJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZXRjaFBvbGljeSAhPT0gJ25vLWNhY2hlJyAmJlxuICAgICAgICAgICAgZmV0Y2hQb2xpY3kgIT09ICdjYWNoZS1hbmQtbmV0d29yaycpIHtcbiAgICAgICAgICAgIGZldGNoUG9saWN5ID0gJ25ldHdvcmstb25seSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsKHRoaXMudmFyaWFibGVzLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLnZhcmlhYmxlcyksIHZhcmlhYmxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsKHRoaXMub3B0aW9ucy52YXJpYWJsZXMsIHRoaXMudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnZhcmlhYmxlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMudmFyaWFibGVzKSwgdGhpcy52YXJpYWJsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5mZXRjaFF1ZXJ5KHRoaXMucXVlcnlJZCwgX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIHsgZmV0Y2hQb2xpY3k6IGZldGNoUG9saWN5IH0pLCBGZXRjaFR5cGUucmVmZXRjaCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmZldGNoTW9yZSA9IGZ1bmN0aW9uIChmZXRjaE1vcmVPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmZXRjaE1vcmVPcHRpb25zLnVwZGF0ZVF1ZXJ5LCAyKSA6IGludmFyaWFudChmZXRjaE1vcmVPcHRpb25zLnVwZGF0ZVF1ZXJ5LCAndXBkYXRlUXVlcnkgb3B0aW9uIGlzIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uIGRlZmluZXMgaG93IHRvIHVwZGF0ZSB0aGUgcXVlcnkgZGF0YSB3aXRoIHRoZSBuZXcgcmVzdWx0cy4nKTtcbiAgICAgICAgdmFyIGNvbWJpbmVkT3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCAoZmV0Y2hNb3JlT3B0aW9ucy5xdWVyeSA/IGZldGNoTW9yZU9wdGlvbnMgOiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgZmV0Y2hNb3JlT3B0aW9ucyksIHsgdmFyaWFibGVzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy52YXJpYWJsZXMpLCBmZXRjaE1vcmVPcHRpb25zLnZhcmlhYmxlcykgfSkpKSwgeyBmZXRjaFBvbGljeTogJ25ldHdvcmstb25seScgfSk7XG4gICAgICAgIHZhciBxaWQgPSB0aGlzLnF1ZXJ5TWFuYWdlci5nZW5lcmF0ZVF1ZXJ5SWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyXG4gICAgICAgICAgICAuZmV0Y2hRdWVyeShxaWQsIGNvbWJpbmVkT3B0aW9ucywgRmV0Y2hUeXBlLm5vcm1hbCwgdGhpcy5xdWVyeUlkKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZldGNoTW9yZVJlc3VsdCkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlUXVlcnkoZnVuY3Rpb24gKHByZXZpb3VzUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoTW9yZU9wdGlvbnMudXBkYXRlUXVlcnkocHJldmlvdXNSZXN1bHQsIHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hNb3JlUmVzdWx0OiBmZXRjaE1vcmVSZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBjb21iaW5lZE9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5xdWVyeU1hbmFnZXIuc3RvcFF1ZXJ5KHFpZCk7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hNb3JlUmVzdWx0O1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLnF1ZXJ5TWFuYWdlci5zdG9wUXVlcnkocWlkKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc3Vic2NyaWJlVG9Nb3JlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMucXVlcnlNYW5hZ2VyXG4gICAgICAgICAgICAuc3RhcnRHcmFwaFFMU3Vic2NyaXB0aW9uKHtcbiAgICAgICAgICAgIHF1ZXJ5OiBvcHRpb25zLmRvY3VtZW50LFxuICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHN1YnNjcmlwdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlUXVlcnkgPSBvcHRpb25zLnVwZGF0ZVF1ZXJ5O1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVRdWVyeShmdW5jdGlvbiAocHJldmlvdXMsIF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVzID0gX2EudmFyaWFibGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVF1ZXJ5KHByZXZpb3VzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uRGF0YTogc3Vic2NyaXB0aW9uRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQuZXJyb3IoJ1VuaGFuZGxlZCBHcmFwaFFMIHN1YnNjcmlwdGlvbiBlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIHZhciBvbGRGZXRjaFBvbGljeSA9IHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdHMpO1xuICAgICAgICBpZiAob3B0cy5wb2xsSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb2xsaW5nKG9wdHMucG9sbEludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLnBvbGxJbnRlcnZhbCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmZXRjaFBvbGljeSA9IG9wdHMuZmV0Y2hQb2xpY3k7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFZhcmlhYmxlcyh0aGlzLm9wdGlvbnMudmFyaWFibGVzLCBvbGRGZXRjaFBvbGljeSAhPT0gZmV0Y2hQb2xpY3kgJiYgKG9sZEZldGNoUG9saWN5ID09PSAnY2FjaGUtb25seScgfHxcbiAgICAgICAgICAgIG9sZEZldGNoUG9saWN5ID09PSAnc3RhbmRieScgfHxcbiAgICAgICAgICAgIGZldGNoUG9saWN5ID09PSAnbmV0d29yay1vbmx5JyksIG9wdHMuZmV0Y2hSZXN1bHRzKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc2V0VmFyaWFibGVzID0gZnVuY3Rpb24gKHZhcmlhYmxlcywgdHJ5RmV0Y2gsIGZldGNoUmVzdWx0cykge1xuICAgICAgICBpZiAodHJ5RmV0Y2ggPT09IHZvaWQgMCkgeyB0cnlGZXRjaCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChmZXRjaFJlc3VsdHMgPT09IHZvaWQgMCkgeyBmZXRjaFJlc3VsdHMgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMuaXNUb3JuRG93biA9IGZhbHNlO1xuICAgICAgICB2YXJpYWJsZXMgPSB2YXJpYWJsZXMgfHwgdGhpcy52YXJpYWJsZXM7XG4gICAgICAgIGlmICghdHJ5RmV0Y2ggJiYgaXNFcXVhbCh2YXJpYWJsZXMsIHRoaXMudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLnNpemUgJiYgZmV0Y2hSZXN1bHRzXG4gICAgICAgICAgICAgICAgPyB0aGlzLnJlc3VsdCgpXG4gICAgICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHRoaXMub3B0aW9ucy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgIGlmICghdGhpcy5vYnNlcnZlcnMuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5mZXRjaFF1ZXJ5KHRoaXMucXVlcnlJZCwgdGhpcy5vcHRpb25zKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUudXBkYXRlUXVlcnkgPSBmdW5jdGlvbiAobWFwRm4pIHtcbiAgICAgICAgdmFyIHF1ZXJ5TWFuYWdlciA9IHRoaXMucXVlcnlNYW5hZ2VyO1xuICAgICAgICB2YXIgX2EgPSBxdWVyeU1hbmFnZXIuZ2V0UXVlcnlXaXRoUHJldmlvdXNSZXN1bHQodGhpcy5xdWVyeUlkKSwgcHJldmlvdXNSZXN1bHQgPSBfYS5wcmV2aW91c1Jlc3VsdCwgdmFyaWFibGVzID0gX2EudmFyaWFibGVzLCBkb2N1bWVudCA9IF9hLmRvY3VtZW50O1xuICAgICAgICB2YXIgbmV3UmVzdWx0ID0gdHJ5RnVuY3Rpb25PckxvZ0Vycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBGbihwcmV2aW91c1Jlc3VsdCwgeyB2YXJpYWJsZXM6IHZhcmlhYmxlcyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdSZXN1bHQpIHtcbiAgICAgICAgICAgIHF1ZXJ5TWFuYWdlci5kYXRhU3RvcmUubWFya1VwZGF0ZVF1ZXJ5UmVzdWx0KGRvY3VtZW50LCB2YXJpYWJsZXMsIG5ld1Jlc3VsdCk7XG4gICAgICAgICAgICBxdWVyeU1hbmFnZXIuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnN0b3BQb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5zdG9wUG9sbGluZ1F1ZXJ5KHRoaXMucXVlcnlJZCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wb2xsSW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnN0YXJ0UG9sbGluZyA9IGZ1bmN0aW9uIChwb2xsSW50ZXJ2YWwpIHtcbiAgICAgICAgYXNzZXJ0Tm90Q2FjaGVGaXJzdE9yT25seSh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvbGxJbnRlcnZhbCA9IHBvbGxJbnRlcnZhbDtcbiAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIuc3RhcnRQb2xsaW5nUXVlcnkodGhpcy5vcHRpb25zLCB0aGlzLnF1ZXJ5SWQpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS51cGRhdGVMYXN0UmVzdWx0ID0gZnVuY3Rpb24gKG5ld1Jlc3VsdCkge1xuICAgICAgICB2YXIgcHJldmlvdXNSZXN1bHQgPSB0aGlzLmxhc3RSZXN1bHQ7XG4gICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IG5ld1Jlc3VsdDtcbiAgICAgICAgdGhpcy5sYXN0UmVzdWx0U25hcHNob3QgPSB0aGlzLnF1ZXJ5TWFuYWdlci5hc3N1bWVJbW11dGFibGVSZXN1bHRzXG4gICAgICAgICAgICA/IG5ld1Jlc3VsdFxuICAgICAgICAgICAgOiBjbG9uZURlZXAobmV3UmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzUmVzdWx0O1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5vblN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHN1Yk9ic2VydmVyID0gb2JzZXJ2ZXIuX3N1YnNjcmlwdGlvbi5fb2JzZXJ2ZXI7XG4gICAgICAgICAgICBpZiAoc3ViT2JzZXJ2ZXIgJiYgIXN1Yk9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgc3ViT2JzZXJ2ZXIuZXJyb3IgPSBkZWZhdWx0U3Vic2NyaXB0aW9uT2JzZXJ2ZXJFcnJvckNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgIHZhciBmaXJzdCA9ICF0aGlzLm9ic2VydmVycy5zaXplO1xuICAgICAgICB0aGlzLm9ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCAmJiB0aGlzLmxhc3RSZXN1bHQpXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHRoaXMubGFzdFJlc3VsdCk7XG4gICAgICAgIGlmIChvYnNlcnZlci5lcnJvciAmJiB0aGlzLmxhc3RFcnJvcilcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHRoaXMubGFzdEVycm9yKTtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFVwUXVlcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIpICYmICFfdGhpcy5vYnNlcnZlcnMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRlYXJEb3duUXVlcnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc2V0VXBRdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcXVlcnlNYW5hZ2VyID0gX2EucXVlcnlNYW5hZ2VyLCBxdWVyeUlkID0gX2EucXVlcnlJZDtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkU3Vic2NyaWJlKSB7XG4gICAgICAgICAgICBxdWVyeU1hbmFnZXIuYWRkT2JzZXJ2YWJsZVF1ZXJ5KHF1ZXJ5SWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucG9sbEludGVydmFsKSB7XG4gICAgICAgICAgICBhc3NlcnROb3RDYWNoZUZpcnN0T3JPbmx5KHRoaXMpO1xuICAgICAgICAgICAgcXVlcnlNYW5hZ2VyLnN0YXJ0UG9sbGluZ1F1ZXJ5KHRoaXMub3B0aW9ucywgcXVlcnlJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUxhc3RSZXN1bHQoX19hc3NpZ24oX19hc3NpZ24oe30sIF90aGlzLmxhc3RSZXN1bHQpLCB7IGVycm9yczogZXJyb3IuZ3JhcGhRTEVycm9ycywgbmV0d29ya1N0YXR1czogTmV0d29ya1N0YXR1cy5lcnJvciwgbG9hZGluZzogZmFsc2UgfSkpO1xuICAgICAgICAgICAgaXRlcmF0ZU9ic2VydmVyc1NhZmVseShfdGhpcy5vYnNlcnZlcnMsICdlcnJvcicsIF90aGlzLmxhc3RFcnJvciA9IGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcXVlcnlNYW5hZ2VyLm9ic2VydmVRdWVyeShxdWVyeUlkLCB0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGFzdEVycm9yIHx8IF90aGlzLmlzRGlmZmVyZW50RnJvbUxhc3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNSZXN1bHRfMSA9IF90aGlzLnVwZGF0ZUxhc3RSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMub3B0aW9ucywgcXVlcnlfMSA9IF9hLnF1ZXJ5LCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIGZldGNoUG9saWN5XzEgPSBfYS5mZXRjaFBvbGljeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5TWFuYWdlci50cmFuc2Zvcm0ocXVlcnlfMSkuaGFzQ2xpZW50RXhwb3J0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlNYW5hZ2VyLmdldExvY2FsU3RhdGUoKS5hZGRFeHBvcnRlZFZhcmlhYmxlcyhxdWVyeV8xLCB2YXJpYWJsZXMpLnRoZW4oZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1ZhcmlhYmxlcyA9IF90aGlzLnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52YXJpYWJsZXMgPSBfdGhpcy5vcHRpb25zLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5sb2FkaW5nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUmVzdWx0XzEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3lfMSAhPT0gJ2NhY2hlLW9ubHknICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5TWFuYWdlci50cmFuc2Zvcm0ocXVlcnlfMSkuc2VydmVyUXVlcnkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzRXF1YWwocHJldmlvdXNWYXJpYWJsZXMsIHZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmZXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZU9ic2VydmVyc1NhZmVseShfdGhpcy5vYnNlcnZlcnMsICduZXh0JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkoX3RoaXMub2JzZXJ2ZXJzLCAnbmV4dCcsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IG9uRXJyb3IsXG4gICAgICAgIH0pLmNhdGNoKG9uRXJyb3IpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS50ZWFyRG93blF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcXVlcnlNYW5hZ2VyID0gdGhpcy5xdWVyeU1hbmFnZXI7XG4gICAgICAgIHRoaXMuaXNUb3JuRG93biA9IHRydWU7XG4gICAgICAgIHF1ZXJ5TWFuYWdlci5zdG9wUG9sbGluZ1F1ZXJ5KHRoaXMucXVlcnlJZCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi51bnN1YnNjcmliZSgpOyB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgIHF1ZXJ5TWFuYWdlci5yZW1vdmVPYnNlcnZhYmxlUXVlcnkodGhpcy5xdWVyeUlkKTtcbiAgICAgICAgcXVlcnlNYW5hZ2VyLnN0b3BRdWVyeSh0aGlzLnF1ZXJ5SWQpO1xuICAgICAgICB0aGlzLm9ic2VydmVycy5jbGVhcigpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGVRdWVyeTtcbn0oT2JzZXJ2YWJsZSkpO1xuZnVuY3Rpb24gZGVmYXVsdFN1YnNjcmlwdGlvbk9ic2VydmVyRXJyb3JDYWxsYmFjayhlcnJvcikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQuZXJyb3IoJ1VuaGFuZGxlZCBlcnJvcicsIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrKTtcbn1cbmZ1bmN0aW9uIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkob2JzZXJ2ZXJzLCBtZXRob2QsIGFyZ3VtZW50KSB7XG4gICAgdmFyIG9ic2VydmVyc1dpdGhNZXRob2QgPSBbXTtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnNbbWV0aG9kXSAmJiBvYnNlcnZlcnNXaXRoTWV0aG9kLnB1c2gob2JzKTsgfSk7XG4gICAgb2JzZXJ2ZXJzV2l0aE1ldGhvZC5mb3JFYWNoKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9ic1ttZXRob2RdKGFyZ3VtZW50KTsgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnROb3RDYWNoZUZpcnN0T3JPbmx5KG9ic1F1ZXJ5KSB7XG4gICAgdmFyIGZldGNoUG9saWN5ID0gb2JzUXVlcnkub3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmV0Y2hQb2xpY3kgIT09ICdjYWNoZS1maXJzdCcgJiYgZmV0Y2hQb2xpY3kgIT09ICdjYWNoZS1vbmx5JywgMykgOiBpbnZhcmlhbnQoZmV0Y2hQb2xpY3kgIT09ICdjYWNoZS1maXJzdCcgJiYgZmV0Y2hQb2xpY3kgIT09ICdjYWNoZS1vbmx5JywgJ1F1ZXJpZXMgdGhhdCBzcGVjaWZ5IHRoZSBjYWNoZS1maXJzdCBhbmQgY2FjaGUtb25seSBmZXRjaFBvbGljaWVzIGNhbm5vdCBhbHNvIGJlIHBvbGxpbmcgcXVlcmllcy4nKTtcbn1cblxudmFyIE11dGF0aW9uU3RvcmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE11dGF0aW9uU3RvcmUoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSB7fTtcbiAgICB9XG4gICAgTXV0YXRpb25TdG9yZS5wcm90b3R5cGUuZ2V0U3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlO1xuICAgIH07XG4gICAgTXV0YXRpb25TdG9yZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG11dGF0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmVbbXV0YXRpb25JZF07XG4gICAgfTtcbiAgICBNdXRhdGlvblN0b3JlLnByb3RvdHlwZS5pbml0TXV0YXRpb24gPSBmdW5jdGlvbiAobXV0YXRpb25JZCwgbXV0YXRpb24sIHZhcmlhYmxlcykge1xuICAgICAgICB0aGlzLnN0b3JlW211dGF0aW9uSWRdID0ge1xuICAgICAgICAgICAgbXV0YXRpb246IG11dGF0aW9uLFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMgfHwge30sXG4gICAgICAgICAgICBsb2FkaW5nOiB0cnVlLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNdXRhdGlvblN0b3JlLnByb3RvdHlwZS5tYXJrTXV0YXRpb25FcnJvciA9IGZ1bmN0aW9uIChtdXRhdGlvbklkLCBlcnJvcikge1xuICAgICAgICB2YXIgbXV0YXRpb24gPSB0aGlzLnN0b3JlW211dGF0aW9uSWRdO1xuICAgICAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgIG11dGF0aW9uLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIG11dGF0aW9uLmVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE11dGF0aW9uU3RvcmUucHJvdG90eXBlLm1hcmtNdXRhdGlvblJlc3VsdCA9IGZ1bmN0aW9uIChtdXRhdGlvbklkKSB7XG4gICAgICAgIHZhciBtdXRhdGlvbiA9IHRoaXMuc3RvcmVbbXV0YXRpb25JZF07XG4gICAgICAgIGlmIChtdXRhdGlvbikge1xuICAgICAgICAgICAgbXV0YXRpb24ubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbXV0YXRpb24uZXJyb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNdXRhdGlvblN0b3JlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHt9O1xuICAgIH07XG4gICAgcmV0dXJuIE11dGF0aW9uU3RvcmU7XG59KCkpO1xuXG52YXIgUXVlcnlTdG9yZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVlcnlTdG9yZSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHt9O1xuICAgIH1cbiAgICBRdWVyeVN0b3JlLnByb3RvdHlwZS5nZXRTdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmU7XG4gICAgfTtcbiAgICBRdWVyeVN0b3JlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZVtxdWVyeUlkXTtcbiAgICB9O1xuICAgIFF1ZXJ5U3RvcmUucHJvdG90eXBlLmluaXRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICB2YXIgcHJldmlvdXNRdWVyeSA9IHRoaXMuc3RvcmVbcXVlcnkucXVlcnlJZF07XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCghcHJldmlvdXNRdWVyeSB8fFxuICAgICAgICAgICAgcHJldmlvdXNRdWVyeS5kb2N1bWVudCA9PT0gcXVlcnkuZG9jdW1lbnQgfHxcbiAgICAgICAgICAgIGlzRXF1YWwocHJldmlvdXNRdWVyeS5kb2N1bWVudCwgcXVlcnkuZG9jdW1lbnQpLCAxOSkgOiBpbnZhcmlhbnQoIXByZXZpb3VzUXVlcnkgfHxcbiAgICAgICAgICAgIHByZXZpb3VzUXVlcnkuZG9jdW1lbnQgPT09IHF1ZXJ5LmRvY3VtZW50IHx8XG4gICAgICAgICAgICBpc0VxdWFsKHByZXZpb3VzUXVlcnkuZG9jdW1lbnQsIHF1ZXJ5LmRvY3VtZW50KSwgJ0ludGVybmFsIEVycm9yOiBtYXkgbm90IHVwZGF0ZSBleGlzdGluZyBxdWVyeSBzdHJpbmcgaW4gc3RvcmUnKTtcbiAgICAgICAgdmFyIGlzU2V0VmFyaWFibGVzID0gZmFsc2U7XG4gICAgICAgIHZhciBwcmV2aW91c1ZhcmlhYmxlcyA9IG51bGw7XG4gICAgICAgIGlmIChxdWVyeS5zdG9yZVByZXZpb3VzVmFyaWFibGVzICYmXG4gICAgICAgICAgICBwcmV2aW91c1F1ZXJ5ICYmXG4gICAgICAgICAgICBwcmV2aW91c1F1ZXJ5Lm5ldHdvcmtTdGF0dXMgIT09IE5ldHdvcmtTdGF0dXMubG9hZGluZykge1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKHByZXZpb3VzUXVlcnkudmFyaWFibGVzLCBxdWVyeS52YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgaXNTZXRWYXJpYWJsZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFyaWFibGVzID0gcHJldmlvdXNRdWVyeS52YXJpYWJsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ldHdvcmtTdGF0dXM7XG4gICAgICAgIGlmIChpc1NldFZhcmlhYmxlcykge1xuICAgICAgICAgICAgbmV0d29ya1N0YXR1cyA9IE5ldHdvcmtTdGF0dXMuc2V0VmFyaWFibGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHF1ZXJ5LmlzUG9sbCkge1xuICAgICAgICAgICAgbmV0d29ya1N0YXR1cyA9IE5ldHdvcmtTdGF0dXMucG9sbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChxdWVyeS5pc1JlZmV0Y2gpIHtcbiAgICAgICAgICAgIG5ldHdvcmtTdGF0dXMgPSBOZXR3b3JrU3RhdHVzLnJlZmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXR3b3JrU3RhdHVzID0gTmV0d29ya1N0YXR1cy5sb2FkaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncmFwaFFMRXJyb3JzID0gW107XG4gICAgICAgIGlmIChwcmV2aW91c1F1ZXJ5ICYmIHByZXZpb3VzUXVlcnkuZ3JhcGhRTEVycm9ycykge1xuICAgICAgICAgICAgZ3JhcGhRTEVycm9ycyA9IHByZXZpb3VzUXVlcnkuZ3JhcGhRTEVycm9ycztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JlW3F1ZXJ5LnF1ZXJ5SWRdID0ge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IHF1ZXJ5LmRvY3VtZW50LFxuICAgICAgICAgICAgdmFyaWFibGVzOiBxdWVyeS52YXJpYWJsZXMsXG4gICAgICAgICAgICBwcmV2aW91c1ZhcmlhYmxlczogcHJldmlvdXNWYXJpYWJsZXMsXG4gICAgICAgICAgICBuZXR3b3JrRXJyb3I6IG51bGwsXG4gICAgICAgICAgICBncmFwaFFMRXJyb3JzOiBncmFwaFFMRXJyb3JzLFxuICAgICAgICAgICAgbmV0d29ya1N0YXR1czogbmV0d29ya1N0YXR1cyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBxdWVyeS5tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeS5mZXRjaE1vcmVGb3JRdWVyeUlkID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgdGhpcy5zdG9yZVtxdWVyeS5mZXRjaE1vcmVGb3JRdWVyeUlkXSkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZVtxdWVyeS5mZXRjaE1vcmVGb3JRdWVyeUlkXS5uZXR3b3JrU3RhdHVzID1cbiAgICAgICAgICAgICAgICBOZXR3b3JrU3RhdHVzLmZldGNoTW9yZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlTdG9yZS5wcm90b3R5cGUubWFya1F1ZXJ5UmVzdWx0ID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIHJlc3VsdCwgZmV0Y2hNb3JlRm9yUXVlcnlJZCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RvcmUgfHwgIXRoaXMuc3RvcmVbcXVlcnlJZF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc3RvcmVbcXVlcnlJZF0ubmV0d29ya0Vycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9yZVtxdWVyeUlkXS5ncmFwaFFMRXJyb3JzID0gaXNOb25FbXB0eUFycmF5KHJlc3VsdC5lcnJvcnMpID8gcmVzdWx0LmVycm9ycyA6IFtdO1xuICAgICAgICB0aGlzLnN0b3JlW3F1ZXJ5SWRdLnByZXZpb3VzVmFyaWFibGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9yZVtxdWVyeUlkXS5uZXR3b3JrU3RhdHVzID0gTmV0d29ya1N0YXR1cy5yZWFkeTtcbiAgICAgICAgaWYgKHR5cGVvZiBmZXRjaE1vcmVGb3JRdWVyeUlkID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgdGhpcy5zdG9yZVtmZXRjaE1vcmVGb3JRdWVyeUlkXSkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZVtmZXRjaE1vcmVGb3JRdWVyeUlkXS5uZXR3b3JrU3RhdHVzID0gTmV0d29ya1N0YXR1cy5yZWFkeTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlTdG9yZS5wcm90b3R5cGUubWFya1F1ZXJ5RXJyb3IgPSBmdW5jdGlvbiAocXVlcnlJZCwgZXJyb3IsIGZldGNoTW9yZUZvclF1ZXJ5SWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0b3JlIHx8ICF0aGlzLnN0b3JlW3F1ZXJ5SWRdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0b3JlW3F1ZXJ5SWRdLm5ldHdvcmtFcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnN0b3JlW3F1ZXJ5SWRdLm5ldHdvcmtTdGF0dXMgPSBOZXR3b3JrU3RhdHVzLmVycm9yO1xuICAgICAgICBpZiAodHlwZW9mIGZldGNoTW9yZUZvclF1ZXJ5SWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtRdWVyeVJlc3VsdENsaWVudChmZXRjaE1vcmVGb3JRdWVyeUlkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlTdG9yZS5wcm90b3R5cGUubWFya1F1ZXJ5UmVzdWx0Q2xpZW50ID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBzdG9yZVZhbHVlID0gdGhpcy5zdG9yZSAmJiB0aGlzLnN0b3JlW3F1ZXJ5SWRdO1xuICAgICAgICBpZiAoc3RvcmVWYWx1ZSkge1xuICAgICAgICAgICAgc3RvcmVWYWx1ZS5uZXR3b3JrRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgc3RvcmVWYWx1ZS5wcmV2aW91c1ZhcmlhYmxlcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBzdG9yZVZhbHVlLm5ldHdvcmtTdGF0dXMgPSBOZXR3b3JrU3RhdHVzLnJlYWR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeVN0b3JlLnByb3RvdHlwZS5zdG9wUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5zdG9yZVtxdWVyeUlkXTtcbiAgICB9O1xuICAgIFF1ZXJ5U3RvcmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKG9ic2VydmFibGVRdWVyeUlkcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnN0b3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2YWJsZVF1ZXJ5SWRzLmluZGV4T2YocXVlcnlJZCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RvcFF1ZXJ5KHF1ZXJ5SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RvcmVbcXVlcnlJZF0ubmV0d29ya1N0YXR1cyA9IE5ldHdvcmtTdGF0dXMubG9hZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVlcnlTdG9yZTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemVGaXJzdExldHRlcihzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuXG52YXIgTG9jYWxTdGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9jYWxTdGF0ZShfYSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBfYS5jYWNoZSwgY2xpZW50ID0gX2EuY2xpZW50LCByZXNvbHZlcnMgPSBfYS5yZXNvbHZlcnMsIGZyYWdtZW50TWF0Y2hlciA9IF9hLmZyYWdtZW50TWF0Y2hlcjtcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFJlc29sdmVycyhyZXNvbHZlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnbWVudE1hdGNoZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RnJhZ21lbnRNYXRjaGVyKGZyYWdtZW50TWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuYWRkUmVzb2x2ZXJzID0gZnVuY3Rpb24gKHJlc29sdmVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlc29sdmVycyA9IHRoaXMucmVzb2x2ZXJzIHx8IHt9O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNvbHZlcnMpKSB7XG4gICAgICAgICAgICByZXNvbHZlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZXJHcm91cCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc29sdmVycyA9IG1lcmdlRGVlcChfdGhpcy5yZXNvbHZlcnMsIHJlc29sdmVyR3JvdXApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVycyA9IG1lcmdlRGVlcCh0aGlzLnJlc29sdmVycywgcmVzb2x2ZXJzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuc2V0UmVzb2x2ZXJzID0gZnVuY3Rpb24gKHJlc29sdmVycykge1xuICAgICAgICB0aGlzLnJlc29sdmVycyA9IHt9O1xuICAgICAgICB0aGlzLmFkZFJlc29sdmVycyhyZXNvbHZlcnMpO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuZ2V0UmVzb2x2ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlcnMgfHwge307XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5ydW5SZXNvbHZlcnMgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gX2EuZG9jdW1lbnQsIHJlbW90ZVJlc3VsdCA9IF9hLnJlbW90ZVJlc3VsdCwgY29udGV4dCA9IF9hLmNvbnRleHQsIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgX2IgPSBfYS5vbmx5UnVuRm9yY2VkUmVzb2x2ZXJzLCBvbmx5UnVuRm9yY2VkUmVzb2x2ZXJzID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLnJlc29sdmVEb2N1bWVudChkb2N1bWVudCwgcmVtb3RlUmVzdWx0LmRhdGEsIGNvbnRleHQsIHZhcmlhYmxlcywgdGhpcy5mcmFnbWVudE1hdGNoZXIsIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMpLnRoZW4oZnVuY3Rpb24gKGxvY2FsUmVzdWx0KSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHJlbW90ZVJlc3VsdCksIHsgZGF0YTogbG9jYWxSZXN1bHQucmVzdWx0IH0pKTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlbW90ZVJlc3VsdF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5zZXRGcmFnbWVudE1hdGNoZXIgPSBmdW5jdGlvbiAoZnJhZ21lbnRNYXRjaGVyKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRNYXRjaGVyID0gZnJhZ21lbnRNYXRjaGVyO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuZ2V0RnJhZ21lbnRNYXRjaGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudE1hdGNoZXI7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5jbGllbnRRdWVyeSA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICBpZiAoaGFzRGlyZWN0aXZlcyhbJ2NsaWVudCddLCBkb2N1bWVudCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQud2FybignRm91bmQgQGNsaWVudCBkaXJlY3RpdmVzIGluIGEgcXVlcnkgYnV0IG5vIEFwb2xsb0NsaWVudCByZXNvbHZlcnMgJyArXG4gICAgICAgICAgICAgICAgJ3dlcmUgc3BlY2lmaWVkLiBUaGlzIG1lYW5zIEFwb2xsb0NsaWVudCBsb2NhbCByZXNvbHZlciBoYW5kbGluZyAnICtcbiAgICAgICAgICAgICAgICAnaGFzIGJlZW4gZGlzYWJsZWQsIGFuZCBAY2xpZW50IGRpcmVjdGl2ZXMgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCAnICtcbiAgICAgICAgICAgICAgICAndG8geW91ciBsaW5rIGNoYWluLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuc2VydmVyUXVlcnkgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJzID8gcmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudChkb2N1bWVudCkgOiBkb2N1bWVudDtcbiAgICB9O1xuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLnByZXBhcmVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICAgICAgdmFyIG5ld0NvbnRleHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dCksIHsgY2FjaGU6IGNhY2hlLCBnZXRDYWNoZUtleTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZS5jb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmNvbmZpZy5kYXRhSWRGcm9tT2JqZWN0KG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIDYpIDogaW52YXJpYW50KGZhbHNlLCAnVG8gdXNlIGNvbnRleHQuZ2V0Q2FjaGVLZXksIHlvdSBuZWVkIHRvIHVzZSBhIGNhY2hlIHRoYXQgaGFzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2EgY29uZmlndXJhYmxlIGRhdGFJZEZyb21PYmplY3QsIGxpa2UgYXBvbGxvLWNhY2hlLWlubWVtb3J5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gfSk7XG4gICAgICAgIHJldHVybiBuZXdDb250ZXh0O1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuYWRkRXhwb3J0ZWRWYXJpYWJsZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHZhcmlhYmxlcywgY29udGV4dCkge1xuICAgICAgICBpZiAodmFyaWFibGVzID09PSB2b2lkIDApIHsgdmFyaWFibGVzID0ge307IH1cbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVzb2x2ZURvY3VtZW50KGRvY3VtZW50LCB0aGlzLmJ1aWxkUm9vdFZhbHVlRnJvbUNhY2hlKGRvY3VtZW50LCB2YXJpYWJsZXMpIHx8IHt9LCB0aGlzLnByZXBhcmVDb250ZXh0KGNvbnRleHQpLCB2YXJpYWJsZXMpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdmFyaWFibGVzKSwgZGF0YS5leHBvcnRlZFZhcmlhYmxlcykpOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgX19hc3NpZ24oe30sIHZhcmlhYmxlcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuc2hvdWxkRm9yY2VSZXNvbHZlcnMgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGZvcmNlUmVzb2x2ZXJzID0gZmFsc2U7XG4gICAgICAgIHZpc2l0KGRvY3VtZW50LCB7XG4gICAgICAgICAgICBEaXJlY3RpdmU6IHtcbiAgICAgICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZS52YWx1ZSA9PT0gJ2NsaWVudCcgJiYgbm9kZS5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlUmVzb2x2ZXJzID0gbm9kZS5hcmd1bWVudHMuc29tZShmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5uYW1lLnZhbHVlID09PSAnYWx3YXlzJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcudmFsdWUua2luZCA9PT0gJ0Jvb2xlYW5WYWx1ZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnLnZhbHVlLnZhbHVlID09PSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2VSZXNvbHZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3JjZVJlc29sdmVycztcbiAgICB9O1xuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLmJ1aWxkUm9vdFZhbHVlRnJvbUNhY2hlID0gZnVuY3Rpb24gKGRvY3VtZW50LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZGlmZih7XG4gICAgICAgICAgICBxdWVyeTogYnVpbGRRdWVyeUZyb21TZWxlY3Rpb25TZXQoZG9jdW1lbnQpLFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICByZXR1cm5QYXJ0aWFsRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgIG9wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgICB9KS5yZXN1bHQ7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5yZXNvbHZlRG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHJvb3RWYWx1ZSwgY29udGV4dCwgdmFyaWFibGVzLCBmcmFnbWVudE1hdGNoZXIsIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgaWYgKHZhcmlhYmxlcyA9PT0gdm9pZCAwKSB7IHZhcmlhYmxlcyA9IHt9OyB9XG4gICAgICAgIGlmIChmcmFnbWVudE1hdGNoZXIgPT09IHZvaWQgMCkgeyBmcmFnbWVudE1hdGNoZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9OyB9XG4gICAgICAgIGlmIChvbmx5UnVuRm9yY2VkUmVzb2x2ZXJzID09PSB2b2lkIDApIHsgb25seVJ1bkZvcmNlZFJlc29sdmVycyA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYWluRGVmaW5pdGlvbiwgZnJhZ21lbnRzLCBmcmFnbWVudE1hcCwgZGVmaW5pdGlvbk9wZXJhdGlvbiwgZGVmYXVsdE9wZXJhdGlvblR5cGUsIF9hLCBjYWNoZSwgY2xpZW50LCBleGVjQ29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBtYWluRGVmaW5pdGlvbiA9IGdldE1haW5EZWZpbml0aW9uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudHMgPSBnZXRGcmFnbWVudERlZmluaXRpb25zKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudE1hcCA9IGNyZWF0ZUZyYWdtZW50TWFwKGZyYWdtZW50cyk7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbk9wZXJhdGlvbiA9IG1haW5EZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5vcGVyYXRpb247XG4gICAgICAgICAgICAgICAgZGVmYXVsdE9wZXJhdGlvblR5cGUgPSBkZWZpbml0aW9uT3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGRlZmluaXRpb25PcGVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIDogJ1F1ZXJ5JztcbiAgICAgICAgICAgICAgICBfYSA9IHRoaXMsIGNhY2hlID0gX2EuY2FjaGUsIGNsaWVudCA9IF9hLmNsaWVudDtcbiAgICAgICAgICAgICAgICBleGVjQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRNYXA6IGZyYWdtZW50TWFwLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dCksIHsgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50OiBjbGllbnQgfSksXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudE1hdGNoZXI6IGZyYWdtZW50TWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wZXJhdGlvblR5cGU6IGRlZmF1bHRPcGVyYXRpb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFZhcmlhYmxlczoge30sXG4gICAgICAgICAgICAgICAgICAgIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnM6IG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVzb2x2ZVNlbGVjdGlvblNldChtYWluRGVmaW5pdGlvbi5zZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRWYXJpYWJsZXM6IGV4ZWNDb250ZXh0LmV4cG9ydGVkVmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICB9KTsgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucmVzb2x2ZVNlbGVjdGlvblNldCA9IGZ1bmN0aW9uIChzZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50TWFwLCBjb250ZXh0LCB2YXJpYWJsZXMsIHJlc3VsdHNUb01lcmdlLCBleGVjdXRlO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudE1hcCA9IGV4ZWNDb250ZXh0LmZyYWdtZW50TWFwLCBjb250ZXh0ID0gZXhlY0NvbnRleHQuY29udGV4dCwgdmFyaWFibGVzID0gZXhlY0NvbnRleHQudmFyaWFibGVzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNUb01lcmdlID0gW3Jvb3RWYWx1ZV07XG4gICAgICAgICAgICAgICAgZXhlY3V0ZSA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50LCB0eXBlQ29uZGl0aW9uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZEluY2x1ZGUoc2VsZWN0aW9uLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpZWxkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVzb2x2ZUZpZWxkKHNlbGVjdGlvbiwgcm9vdFZhbHVlLCBleGVjQ29udGV4dCkudGhlbihmdW5jdGlvbiAoZmllbGRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGRSZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1RvTWVyZ2UucHVzaCgoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FbcmVzdWx0S2V5TmFtZUZyb21GaWVsZChzZWxlY3Rpb24pXSA9IGZpZWxkUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbmxpbmVGcmFnbWVudChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50TWFwW3NlbGVjdGlvbi5uYW1lLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZnJhZ21lbnQsIDcpIDogaW52YXJpYW50KGZyYWdtZW50LCBcIk5vIGZyYWdtZW50IG5hbWVkIFwiICsgc2VsZWN0aW9uLm5hbWUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50ICYmIGZyYWdtZW50LnR5cGVDb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlQ29uZGl0aW9uID0gZnJhZ21lbnQudHlwZUNvbmRpdGlvbi5uYW1lLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGVjQ29udGV4dC5mcmFnbWVudE1hdGNoZXIocm9vdFZhbHVlLCB0eXBlQ29uZGl0aW9uLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVzb2x2ZVNlbGVjdGlvblNldChmcmFnbWVudC5zZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGZyYWdtZW50UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1RvTWVyZ2UucHVzaChmcmFnbWVudFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7IH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBQcm9taXNlLmFsbChzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5tYXAoZXhlY3V0ZSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGVlcEFycmF5KHJlc3VsdHNUb01lcmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucmVzb2x2ZUZpZWxkID0gZnVuY3Rpb24gKGZpZWxkLCByb290VmFsdWUsIGV4ZWNDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YXJpYWJsZXMsIGZpZWxkTmFtZSwgYWxpYXNlZEZpZWxkTmFtZSwgYWxpYXNVc2VkLCBkZWZhdWx0UmVzdWx0LCByZXN1bHRQcm9taXNlLCByZXNvbHZlclR5cGUsIHJlc29sdmVyTWFwLCByZXNvbHZlO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMgPSBleGVjQ29udGV4dC52YXJpYWJsZXM7XG4gICAgICAgICAgICAgICAgZmllbGROYW1lID0gZmllbGQubmFtZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBhbGlhc2VkRmllbGROYW1lID0gcmVzdWx0S2V5TmFtZUZyb21GaWVsZChmaWVsZCk7XG4gICAgICAgICAgICAgICAgYWxpYXNVc2VkID0gZmllbGROYW1lICE9PSBhbGlhc2VkRmllbGROYW1lO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRSZXN1bHQgPSByb290VmFsdWVbYWxpYXNlZEZpZWxkTmFtZV0gfHwgcm9vdFZhbHVlW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShkZWZhdWx0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4ZWNDb250ZXh0Lm9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG91bGRGb3JjZVJlc29sdmVycyhmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXJUeXBlID0gcm9vdFZhbHVlLl9fdHlwZW5hbWUgfHwgZXhlY0NvbnRleHQuZGVmYXVsdE9wZXJhdGlvblR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyTWFwID0gdGhpcy5yZXNvbHZlcnMgJiYgdGhpcy5yZXNvbHZlcnNbcmVzb2x2ZXJUeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gcmVzb2x2ZXJNYXBbYWxpYXNVc2VkID8gZmllbGROYW1lIDogYWxpYXNlZEZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocmVzb2x2ZShyb290VmFsdWUsIGFyZ3VtZW50c09iamVjdEZyb21GaWVsZChmaWVsZCwgdmFyaWFibGVzKSwgZXhlY0NvbnRleHQuY29udGV4dCwgeyBmaWVsZDogZmllbGQsIGZyYWdtZW50TWFwOiBleGVjQ29udGV4dC5mcmFnbWVudE1hcCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXN1bHRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7IHJlc3VsdCA9IGRlZmF1bHRSZXN1bHQ7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5uYW1lLnZhbHVlID09PSAnZXhwb3J0JyAmJiBkaXJlY3RpdmUuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmUuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcubmFtZS52YWx1ZSA9PT0gJ2FzJyAmJiBhcmcudmFsdWUua2luZCA9PT0gJ1N0cmluZ1ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjQ29udGV4dC5leHBvcnRlZFZhcmlhYmxlc1thcmcudmFsdWUudmFsdWVdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNvbHZlU3ViU2VsZWN0ZWRBcnJheShmaWVsZCwgcmVzdWx0LCBleGVjQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc29sdmVTZWxlY3Rpb25TZXQoZmllbGQuc2VsZWN0aW9uU2V0LCByZXN1bHQsIGV4ZWNDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucmVzb2x2ZVN1YlNlbGVjdGVkQXJyYXkgPSBmdW5jdGlvbiAoZmllbGQsIHJlc3VsdCwgZXhlY0NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3VsdC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNvbHZlU3ViU2VsZWN0ZWRBcnJheShmaWVsZCwgaXRlbSwgZXhlY0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZWxkLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNvbHZlU2VsZWN0aW9uU2V0KGZpZWxkLnNlbGVjdGlvblNldCwgaXRlbSwgZXhlY0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxTdGF0ZTtcbn0oKSk7XG5cbmZ1bmN0aW9uIG11bHRpcGxleChpbm5lcikge1xuICAgIHZhciBvYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHN1YiA9IG51bGw7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBvYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgICAgc3ViID0gc3ViIHx8IGlubmVyLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMubmV4dCAmJiBvYnMubmV4dCh2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMuZXJyb3IgJiYgb2JzLmVycm9yKGVycm9yKTsgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMuY29tcGxldGUgJiYgb2JzLmNvbXBsZXRlKCk7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcikgJiYgIW9ic2VydmVycy5zaXplICYmIHN1Yikge1xuICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHN1YiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhc3luY01hcChvYnNlcnZhYmxlLCBtYXBGbikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIG5leHQgPSBvYnNlcnZlci5uZXh0LCBlcnJvciA9IG9ic2VydmVyLmVycm9yLCBjb21wbGV0ZSA9IG9ic2VydmVyLmNvbXBsZXRlO1xuICAgICAgICB2YXIgYWN0aXZlTmV4dENvdW50ID0gMDtcbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaGFuZGxlciA9IHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICsrYWN0aXZlTmV4dENvdW50O1xuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWFwRm4odmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1hY3RpdmVOZXh0Q291bnQ7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgJiYgbmV4dC5jYWxsKG9ic2VydmVyLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgJiYgaGFuZGxlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC0tYWN0aXZlTmV4dENvdW50O1xuICAgICAgICAgICAgICAgICAgICBlcnJvciAmJiBlcnJvci5jYWxsKG9ic2VydmVyLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvciAmJiBlcnJvci5jYWxsKG9ic2VydmVyLCBlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3RpdmVOZXh0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgJiYgY29tcGxldGUuY2FsbChvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN1YiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgfSk7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUXVlcnlNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWVyeU1hbmFnZXIoX2EpIHtcbiAgICAgICAgdmFyIGxpbmsgPSBfYS5saW5rLCBfYiA9IF9hLnF1ZXJ5RGVkdXBsaWNhdGlvbiwgcXVlcnlEZWR1cGxpY2F0aW9uID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIHN0b3JlID0gX2Euc3RvcmUsIF9jID0gX2Eub25Ccm9hZGNhc3QsIG9uQnJvYWRjYXN0ID0gX2MgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSA6IF9jLCBfZCA9IF9hLnNzck1vZGUsIHNzck1vZGUgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBfYS5jbGllbnRBd2FyZW5lc3MsIGNsaWVudEF3YXJlbmVzcyA9IF9lID09PSB2b2lkIDAgPyB7fSA6IF9lLCBsb2NhbFN0YXRlID0gX2EubG9jYWxTdGF0ZSwgYXNzdW1lSW1tdXRhYmxlUmVzdWx0cyA9IF9hLmFzc3VtZUltbXV0YWJsZVJlc3VsdHM7XG4gICAgICAgIHRoaXMubXV0YXRpb25TdG9yZSA9IG5ldyBNdXRhdGlvblN0b3JlKCk7XG4gICAgICAgIHRoaXMucXVlcnlTdG9yZSA9IG5ldyBRdWVyeVN0b3JlKCk7XG4gICAgICAgIHRoaXMuY2xpZW50QXdhcmVuZXNzID0ge307XG4gICAgICAgIHRoaXMuaWRDb3VudGVyID0gMTtcbiAgICAgICAgdGhpcy5xdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmZldGNoUXVlcnlSZWplY3RGbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FjaGUgPSBuZXcgKGNhblVzZVdlYWtNYXAgPyBXZWFrTWFwIDogTWFwKSgpO1xuICAgICAgICB0aGlzLmluRmxpZ2h0TGlua09ic2VydmFibGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBvbGxpbmdJbmZvQnlRdWVyeUlkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpbmsgPSBsaW5rO1xuICAgICAgICB0aGlzLnF1ZXJ5RGVkdXBsaWNhdGlvbiA9IHF1ZXJ5RGVkdXBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5kYXRhU3RvcmUgPSBzdG9yZTtcbiAgICAgICAgdGhpcy5vbkJyb2FkY2FzdCA9IG9uQnJvYWRjYXN0O1xuICAgICAgICB0aGlzLmNsaWVudEF3YXJlbmVzcyA9IGNsaWVudEF3YXJlbmVzcztcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbG9jYWxTdGF0ZSB8fCBuZXcgTG9jYWxTdGF0ZSh7IGNhY2hlOiBzdG9yZS5nZXRDYWNoZSgpIH0pO1xuICAgICAgICB0aGlzLnNzck1vZGUgPSBzc3JNb2RlO1xuICAgICAgICB0aGlzLmFzc3VtZUltbXV0YWJsZVJlc3VsdHMgPSAhIWFzc3VtZUltbXV0YWJsZVJlc3VsdHM7XG4gICAgfVxuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKF9pbmZvLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICBfdGhpcy5zdG9wUXVlcnlOb0Jyb2FkY2FzdChxdWVyeUlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmV0Y2hRdWVyeVJlamVjdEZucy5mb3JFYWNoKGZ1bmN0aW9uIChyZWplY3QpIHtcbiAgICAgICAgICAgIHJlamVjdChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoOCkgOiBuZXcgSW52YXJpYW50RXJyb3IoJ1F1ZXJ5TWFuYWdlciBzdG9wcGVkIHdoaWxlIHF1ZXJ5IHdhcyBpbiBmbGlnaHQnKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5tdXRhdGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG11dGF0aW9uID0gX2EubXV0YXRpb24sIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgb3B0aW1pc3RpY1Jlc3BvbnNlID0gX2Eub3B0aW1pc3RpY1Jlc3BvbnNlLCB1cGRhdGVRdWVyaWVzQnlOYW1lID0gX2EudXBkYXRlUXVlcmllcywgX2IgPSBfYS5yZWZldGNoUXVlcmllcywgcmVmZXRjaFF1ZXJpZXMgPSBfYiA9PT0gdm9pZCAwID8gW10gOiBfYiwgX2MgPSBfYS5hd2FpdFJlZmV0Y2hRdWVyaWVzLCBhd2FpdFJlZmV0Y2hRdWVyaWVzID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIHVwZGF0ZVdpdGhQcm94eUZuID0gX2EudXBkYXRlLCBfZCA9IF9hLmVycm9yUG9saWN5LCBlcnJvclBvbGljeSA9IF9kID09PSB2b2lkIDAgPyAnbm9uZScgOiBfZCwgZmV0Y2hQb2xpY3kgPSBfYS5mZXRjaFBvbGljeSwgX2UgPSBfYS5jb250ZXh0LCBjb250ZXh0ID0gX2UgPT09IHZvaWQgMCA/IHt9IDogX2U7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtdXRhdGlvbklkLCBnZW5lcmF0ZVVwZGF0ZVF1ZXJpZXNJbmZvLCBzZWxmO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChtdXRhdGlvbiwgOSkgOiBpbnZhcmlhbnQobXV0YXRpb24sICdtdXRhdGlvbiBvcHRpb24gaXMgcmVxdWlyZWQuIFlvdSBtdXN0IHNwZWNpZnkgeW91ciBHcmFwaFFMIGRvY3VtZW50IGluIHRoZSBtdXRhdGlvbiBvcHRpb24uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoIWZldGNoUG9saWN5IHx8IGZldGNoUG9saWN5ID09PSAnbm8tY2FjaGUnLCAxMCkgOiBpbnZhcmlhbnQoIWZldGNoUG9saWN5IHx8IGZldGNoUG9saWN5ID09PSAnbm8tY2FjaGUnLCBcIk11dGF0aW9ucyBvbmx5IHN1cHBvcnQgYSAnbm8tY2FjaGUnIGZldGNoUG9saWN5LiBJZiB5b3UgZG9uJ3Qgd2FudCB0byBkaXNhYmxlIHRoZSBjYWNoZSwgcmVtb3ZlIHlvdXIgZmV0Y2hQb2xpY3kgc2V0dGluZyB0byBwcm9jZWVkIHdpdGggdGhlIGRlZmF1bHQgbXV0YXRpb24gYmVoYXZpb3IuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25JZCA9IHRoaXMuZ2VuZXJhdGVRdWVyeUlkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IHRoaXMudHJhbnNmb3JtKG11dGF0aW9uKS5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UXVlcnkobXV0YXRpb25JZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgZG9jdW1lbnQ6IG11dGF0aW9uIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IHRoaXMuZ2V0VmFyaWFibGVzKG11dGF0aW9uLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybShtdXRhdGlvbikuaGFzQ2xpZW50RXhwb3J0cykgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5sb2NhbFN0YXRlLmFkZEV4cG9ydGVkVmFyaWFibGVzKG11dGF0aW9uLCB2YXJpYWJsZXMsIGNvbnRleHQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2YubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZVVwZGF0ZVF1ZXJpZXNJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlUXVlcmllc0J5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZVF1ZXJ5ID0gX2Eub2JzZXJ2YWJsZVF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ic2VydmFibGVRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeU5hbWUgPSBvYnNlcnZhYmxlUXVlcnkucXVlcnlOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWVyeU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbCh1cGRhdGVRdWVyaWVzQnlOYW1lLCBxdWVyeU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldFtxdWVyeUlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXI6IHVwZGF0ZVF1ZXJpZXNCeU5hbWVbcXVlcnlOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBfdGhpcy5xdWVyeVN0b3JlLmdldChxdWVyeUlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRpb25TdG9yZS5pbml0TXV0YXRpb24obXV0YXRpb25JZCwgbXV0YXRpb24sIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFTdG9yZS5tYXJrTXV0YXRpb25Jbml0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbklkOiBtdXRhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBtdXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVRdWVyaWVzOiBnZW5lcmF0ZVVwZGF0ZVF1ZXJpZXNJbmZvKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiB1cGRhdGVXaXRoUHJveHlGbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljUmVzcG9uc2U6IG9wdGltaXN0aWNSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXRPYnNlcnZhYmxlRnJvbUxpbmsobXV0YXRpb24sIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb250ZXh0KSwgeyBvcHRpbWlzdGljUmVzcG9uc2U6IG9wdGltaXN0aWNSZXNwb25zZSB9KSwgdmFyaWFibGVzLCBmYWxzZSkuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JhcGhRTFJlc3VsdEhhc0Vycm9yKHJlc3VsdCkgJiYgZXJyb3JQb2xpY3kgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBBcG9sbG9FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaFFMRXJyb3JzOiByZXN1bHQuZXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm11dGF0aW9uU3RvcmUubWFya011dGF0aW9uUmVzdWx0KG11dGF0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZXRjaFBvbGljeSAhPT0gJ25vLWNhY2hlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRhdGFTdG9yZS5tYXJrTXV0YXRpb25SZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25JZDogbXV0YXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IG11dGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVRdWVyaWVzOiBnZW5lcmF0ZVVwZGF0ZVF1ZXJpZXNJbmZvKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZVdpdGhQcm94eUZuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm11dGF0aW9uU3RvcmUubWFya011dGF0aW9uRXJyb3IobXV0YXRpb25JZCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRhdGFTdG9yZS5tYXJrTXV0YXRpb25Db21wbGV0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSWQ6IG11dGF0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNSZXNwb25zZTogb3B0aW1pc3RpY1Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0UXVlcnkobXV0YXRpb25JZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgZG9jdW1lbnQ6IG51bGwgfSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQXBvbGxvRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrRXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5tdXRhdGlvblN0b3JlLm1hcmtNdXRhdGlvbkVycm9yKG11dGF0aW9uSWQsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXRhU3RvcmUubWFya011dGF0aW9uQ29tcGxldGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbklkOiBtdXRhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljUmVzcG9uc2U6IG9wdGltaXN0aWNSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlZmV0Y2hRdWVyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmV0Y2hRdWVyaWVzID0gcmVmZXRjaFF1ZXJpZXMoc3RvcmVSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmZXRjaFF1ZXJ5UHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb25FbXB0eUFycmF5KHJlZmV0Y2hRdWVyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZldGNoUXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZldGNoUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmZXRjaFF1ZXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZVF1ZXJ5ID0gX2Eub2JzZXJ2YWJsZVF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JzZXJ2YWJsZVF1ZXJ5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlUXVlcnkucXVlcnlOYW1lID09PSByZWZldGNoUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmV0Y2hRdWVyeVByb21pc2VzLnB1c2gob2JzZXJ2YWJsZVF1ZXJ5LnJlZmV0Y2goKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiByZWZldGNoUXVlcnkucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogcmVmZXRjaFF1ZXJ5LnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3k6ICduZXR3b3JrLW9ubHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZmV0Y2hRdWVyeS5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5T3B0aW9ucy5jb250ZXh0ID0gcmVmZXRjaFF1ZXJ5LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmV0Y2hRdWVyeVByb21pc2VzLnB1c2goc2VsZi5xdWVyeShxdWVyeU9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKGF3YWl0UmVmZXRjaFF1ZXJpZXMgPyByZWZldGNoUXVlcnlQcm9taXNlcyA6IFtdKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRRdWVyeShtdXRhdGlvbklkLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBkb2N1bWVudDogbnVsbCB9KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvclBvbGljeSA9PT0gJ2lnbm9yZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlUmVzdWx0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaFFMUmVzdWx0SGFzRXJyb3Ioc3RvcmVSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmVSZXN1bHQuZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3RvcmVSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZmV0Y2hRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeUlkLCBvcHRpb25zLCBmZXRjaFR5cGUsIGZldGNoTW9yZUZvclF1ZXJ5SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBtZXRhZGF0YSwgX2IsIGZldGNoUG9saWN5LCBfYywgY29udGV4dCwgcXVlcnksIHZhcmlhYmxlcywgc3RvcmVSZXN1bHQsIGlzTmV0d29ya09ubHksIG5lZWRUb0ZldGNoLCBfZCwgY29tcGxldGUsIHJlc3VsdCwgc2hvdWxkRmV0Y2gsIHJlcXVlc3RJZCwgY2FuY2VsLCBuZXR3b3JrUmVzdWx0O1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gb3B0aW9ucy5tZXRhZGF0YSwgbWV0YWRhdGEgPSBfYSA9PT0gdm9pZCAwID8gbnVsbCA6IF9hLCBfYiA9IG9wdGlvbnMuZmV0Y2hQb2xpY3ksIGZldGNoUG9saWN5ID0gX2IgPT09IHZvaWQgMCA/ICdjYWNoZS1maXJzdCcgOiBfYiwgX2MgPSBvcHRpb25zLmNvbnRleHQsIGNvbnRleHQgPSBfYyA9PT0gdm9pZCAwID8ge30gOiBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm0ob3B0aW9ucy5xdWVyeSkuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMgPSB0aGlzLmdldFZhcmlhYmxlcyhxdWVyeSwgb3B0aW9ucy52YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybShxdWVyeSkuaGFzQ2xpZW50RXhwb3J0cykgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5sb2NhbFN0YXRlLmFkZEV4cG9ydGVkVmFyaWFibGVzKHF1ZXJ5LCB2YXJpYWJsZXMsIGNvbnRleHQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHZhcmlhYmxlczogdmFyaWFibGVzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNOZXR3b3JrT25seSA9IGZldGNoUG9saWN5ID09PSAnbmV0d29yay1vbmx5JyB8fCBmZXRjaFBvbGljeSA9PT0gJ25vLWNhY2hlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRUb0ZldGNoID0gaXNOZXR3b3JrT25seTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOZXR3b3JrT25seSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gdGhpcy5kYXRhU3RvcmUuZ2V0Q2FjaGUoKS5kaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBjb21wbGV0ZSA9IF9kLmNvbXBsZXRlLCByZXN1bHQgPSBfZC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZFRvRmV0Y2ggPSAhY29tcGxldGUgfHwgZmV0Y2hQb2xpY3kgPT09ICdjYWNoZS1hbmQtbmV0d29yayc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRGZXRjaCA9IG5lZWRUb0ZldGNoICYmIGZldGNoUG9saWN5ICE9PSAnY2FjaGUtb25seScgJiYgZmV0Y2hQb2xpY3kgIT09ICdzdGFuZGJ5JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNEaXJlY3RpdmVzKFsnbGl2ZSddLCBxdWVyeSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkRmV0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkID0gdGhpcy5pZENvdW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCA9IGZldGNoUG9saWN5ICE9PSAnbm8tY2FjaGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnVwZGF0ZVF1ZXJ5V2F0Y2gocXVlcnlJZCwgcXVlcnksIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KHF1ZXJ5SWQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGNhbmNlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZShmZXRjaE1vcmVGb3JRdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnlTdG9yZS5pbml0UXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5SWQ6IHF1ZXJ5SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlUHJldmlvdXNWYXJpYWJsZXM6IHNob3VsZEZldGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUG9sbDogZmV0Y2hUeXBlID09PSBGZXRjaFR5cGUucG9sbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JlZmV0Y2g6IGZldGNoVHlwZSA9PT0gRmV0Y2hUeXBlLnJlZmV0Y2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoTW9yZUZvclF1ZXJ5SWQ6IGZldGNoTW9yZUZvclF1ZXJ5SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya1Jlc3VsdCA9IHRoaXMuZmV0Y2hSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5SWQ6IHF1ZXJ5SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hNb3JlRm9yUXVlcnlJZDogZmV0Y2hNb3JlRm9yUXVlcnlJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXBvbGxvRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0SWQgPj0gX3RoaXMuZ2V0UXVlcnkocXVlcnlJZCkubGFzdFJlcXVlc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnF1ZXJ5U3RvcmUubWFya1F1ZXJ5RXJyb3IocXVlcnlJZCwgZXJyb3IsIGZldGNoTW9yZUZvclF1ZXJ5SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmludmFsaWRhdGUocXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW52YWxpZGF0ZShmZXRjaE1vcmVGb3JRdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBvbGxvRXJyb3IoeyBuZXR3b3JrRXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZldGNoUG9saWN5ICE9PSAnY2FjaGUtYW5kLW5ldHdvcmsnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbmV0d29ya1Jlc3VsdF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtSZXN1bHQuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnlTdG9yZS5tYXJrUXVlcnlSZXN1bHRDbGllbnQocXVlcnlJZCwgIXNob3VsZEZldGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZShxdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZShmZXRjaE1vcmVGb3JRdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybShxdWVyeSkuaGFzRm9yY2VkUmVzb2x2ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmxvY2FsU3RhdGUucnVuUmVzb2x2ZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZVJlc3VsdDogeyBkYXRhOiBzdG9yZVJlc3VsdCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25seVJ1bkZvcmNlZFJlc29sdmVyczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXJrUXVlcnlSZXN1bHQocXVlcnlJZCwgcmVzdWx0LCBvcHRpb25zLCBmZXRjaE1vcmVGb3JRdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IGRhdGE6IHN0b3JlUmVzdWx0IH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUubWFya1F1ZXJ5UmVzdWx0ID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIHJlc3VsdCwgX2EsIGZldGNoTW9yZUZvclF1ZXJ5SWQpIHtcbiAgICAgICAgdmFyIGZldGNoUG9saWN5ID0gX2EuZmV0Y2hQb2xpY3ksIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgZXJyb3JQb2xpY3kgPSBfYS5lcnJvclBvbGljeTtcbiAgICAgICAgaWYgKGZldGNoUG9saWN5ID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KHF1ZXJ5SWQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgbmV3RGF0YTogeyByZXN1bHQ6IHJlc3VsdC5kYXRhLCBjb21wbGV0ZTogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhU3RvcmUubWFya1F1ZXJ5UmVzdWx0KHJlc3VsdCwgdGhpcy5nZXRRdWVyeShxdWVyeUlkKS5kb2N1bWVudCwgdmFyaWFibGVzLCBmZXRjaE1vcmVGb3JRdWVyeUlkLCBlcnJvclBvbGljeSA9PT0gJ2lnbm9yZScgfHwgZXJyb3JQb2xpY3kgPT09ICdhbGwnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5xdWVyeUxpc3RlbmVyRm9yT2JzZXJ2ZXIgPSBmdW5jdGlvbiAocXVlcnlJZCwgb3B0aW9ucywgb2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJndW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlclttZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXJbbWV0aG9kXShhcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IGludmFyaWFudC5lcnJvcihhcmd1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChxdWVyeVN0b3JlVmFsdWUsIG5ld0RhdGEpIHtcbiAgICAgICAgICAgIF90aGlzLmludmFsaWRhdGUocXVlcnlJZCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCFxdWVyeVN0b3JlVmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuZ2V0UXVlcnkocXVlcnlJZCksIG9ic2VydmFibGVRdWVyeSA9IF9hLm9ic2VydmFibGVRdWVyeSwgZG9jdW1lbnQgPSBfYS5kb2N1bWVudDtcbiAgICAgICAgICAgIHZhciBmZXRjaFBvbGljeSA9IG9ic2VydmFibGVRdWVyeVxuICAgICAgICAgICAgICAgID8gb2JzZXJ2YWJsZVF1ZXJ5Lm9wdGlvbnMuZmV0Y2hQb2xpY3lcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuZmV0Y2hQb2xpY3k7XG4gICAgICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgPT09ICdzdGFuZGJ5JylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbG9hZGluZyA9IGlzTmV0d29ya1JlcXVlc3RJbkZsaWdodChxdWVyeVN0b3JlVmFsdWUubmV0d29ya1N0YXR1cyk7XG4gICAgICAgICAgICB2YXIgbGFzdFJlc3VsdCA9IG9ic2VydmFibGVRdWVyeSAmJiBvYnNlcnZhYmxlUXVlcnkuZ2V0TGFzdFJlc3VsdCgpO1xuICAgICAgICAgICAgdmFyIG5ldHdvcmtTdGF0dXNDaGFuZ2VkID0gISEobGFzdFJlc3VsdCAmJlxuICAgICAgICAgICAgICAgIGxhc3RSZXN1bHQubmV0d29ya1N0YXR1cyAhPT0gcXVlcnlTdG9yZVZhbHVlLm5ldHdvcmtTdGF0dXMpO1xuICAgICAgICAgICAgdmFyIHNob3VsZE5vdGlmeUlmTG9hZGluZyA9IG9wdGlvbnMucmV0dXJuUGFydGlhbERhdGEgfHxcbiAgICAgICAgICAgICAgICAoIW5ld0RhdGEgJiYgcXVlcnlTdG9yZVZhbHVlLnByZXZpb3VzVmFyaWFibGVzKSB8fFxuICAgICAgICAgICAgICAgIChuZXR3b3JrU3RhdHVzQ2hhbmdlZCAmJiBvcHRpb25zLm5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSkgfHxcbiAgICAgICAgICAgICAgICBmZXRjaFBvbGljeSA9PT0gJ2NhY2hlLW9ubHknIHx8XG4gICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3kgPT09ICdjYWNoZS1hbmQtbmV0d29yayc7XG4gICAgICAgICAgICBpZiAobG9hZGluZyAmJiAhc2hvdWxkTm90aWZ5SWZMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhc0dyYXBoUUxFcnJvcnMgPSBpc05vbkVtcHR5QXJyYXkocXVlcnlTdG9yZVZhbHVlLmdyYXBoUUxFcnJvcnMpO1xuICAgICAgICAgICAgdmFyIGVycm9yUG9saWN5ID0gb2JzZXJ2YWJsZVF1ZXJ5XG4gICAgICAgICAgICAgICAgJiYgb2JzZXJ2YWJsZVF1ZXJ5Lm9wdGlvbnMuZXJyb3JQb2xpY3lcbiAgICAgICAgICAgICAgICB8fCBvcHRpb25zLmVycm9yUG9saWN5XG4gICAgICAgICAgICAgICAgfHwgJ25vbmUnO1xuICAgICAgICAgICAgaWYgKGVycm9yUG9saWN5ID09PSAnbm9uZScgJiYgaGFzR3JhcGhRTEVycm9ycyB8fCBxdWVyeVN0b3JlVmFsdWUubmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludm9rZSgnZXJyb3InLCBuZXcgQXBvbGxvRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBncmFwaFFMRXJyb3JzOiBxdWVyeVN0b3JlVmFsdWUuZ3JhcGhRTEVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0Vycm9yOiBxdWVyeVN0b3JlVmFsdWUubmV0d29ya0Vycm9yLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGlzTWlzc2luZyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgIT09ICduby1jYWNoZScgJiYgZmV0Y2hQb2xpY3kgIT09ICduZXR3b3JrLW9ubHknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRRdWVyeShxdWVyeUlkLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBuZXdEYXRhOiBudWxsIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3RGF0YS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlzTWlzc2luZyA9ICFuZXdEYXRhLmNvbXBsZXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RFcnJvciA9IG9ic2VydmFibGVRdWVyeSAmJiBvYnNlcnZhYmxlUXVlcnkuZ2V0TGFzdEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvclN0YXR1c0NoYW5nZWQgPSBlcnJvclBvbGljeSAhPT0gJ25vbmUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAobGFzdEVycm9yICYmIGxhc3RFcnJvci5ncmFwaFFMRXJyb3JzKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVN0b3JlVmFsdWUuZ3JhcGhRTEVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RSZXN1bHQgJiYgbGFzdFJlc3VsdC5kYXRhICYmICFlcnJvclN0YXR1c0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBsYXN0UmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc01pc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmUmVzdWx0ID0gX3RoaXMuZGF0YVN0b3JlLmdldENhY2hlKCkuZGlmZih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogcXVlcnlTdG9yZVZhbHVlLnByZXZpb3VzVmFyaWFibGVzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RvcmVWYWx1ZS52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRpZmZSZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNNaXNzaW5nID0gIWRpZmZSZXN1bHQuY29tcGxldGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0YWxlID0gaXNNaXNzaW5nICYmICEob3B0aW9ucy5yZXR1cm5QYXJ0aWFsRGF0YSB8fFxuICAgICAgICAgICAgICAgICAgICBmZXRjaFBvbGljeSA9PT0gJ2NhY2hlLW9ubHknKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0RnJvbVN0b3JlID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBzdGFsZSA/IGxhc3RSZXN1bHQgJiYgbGFzdFJlc3VsdC5kYXRhIDogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogbG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogcXVlcnlTdG9yZVZhbHVlLm5ldHdvcmtTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIHN0YWxlOiBzdGFsZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvclBvbGljeSA9PT0gJ2FsbCcgJiYgaGFzR3JhcGhRTEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRGcm9tU3RvcmUuZXJyb3JzID0gcXVlcnlTdG9yZVZhbHVlLmdyYXBoUUxFcnJvcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGludm9rZSgnbmV4dCcsIHJlc3VsdEZyb21TdG9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAobmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlKCdlcnJvcicsIG5ldyBBcG9sbG9FcnJvcih7IG5ldHdvcmtFcnJvcjogbmV0d29ya0Vycm9yIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1DYWNoZSA9IHRoaXMudHJhbnNmb3JtQ2FjaGU7XG4gICAgICAgIGlmICghdHJhbnNmb3JtQ2FjaGUuaGFzKGRvY3VtZW50KSkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5kYXRhU3RvcmUuZ2V0Q2FjaGUoKTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IGNhY2hlLnRyYW5zZm9ybURvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgIHZhciBmb3JMaW5rID0gcmVtb3ZlQ29ubmVjdGlvbkRpcmVjdGl2ZUZyb21Eb2N1bWVudChjYWNoZS50cmFuc2Zvcm1Gb3JMaW5rKHRyYW5zZm9ybWVkKSk7XG4gICAgICAgICAgICB2YXIgY2xpZW50UXVlcnkgPSB0aGlzLmxvY2FsU3RhdGUuY2xpZW50UXVlcnkodHJhbnNmb3JtZWQpO1xuICAgICAgICAgICAgdmFyIHNlcnZlclF1ZXJ5ID0gdGhpcy5sb2NhbFN0YXRlLnNlcnZlclF1ZXJ5KGZvckxpbmspO1xuICAgICAgICAgICAgdmFyIGNhY2hlRW50cnlfMSA9IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudDogdHJhbnNmb3JtZWQsXG4gICAgICAgICAgICAgICAgaGFzQ2xpZW50RXhwb3J0czogaGFzQ2xpZW50RXhwb3J0cyh0cmFuc2Zvcm1lZCksXG4gICAgICAgICAgICAgICAgaGFzRm9yY2VkUmVzb2x2ZXJzOiB0aGlzLmxvY2FsU3RhdGUuc2hvdWxkRm9yY2VSZXNvbHZlcnModHJhbnNmb3JtZWQpLFxuICAgICAgICAgICAgICAgIGNsaWVudFF1ZXJ5OiBjbGllbnRRdWVyeSxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJRdWVyeTogc2VydmVyUXVlcnksXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhcnM6IGdldERlZmF1bHRWYWx1ZXMoZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbih0cmFuc2Zvcm1lZCkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBhZGQgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvYyAmJiAhdHJhbnNmb3JtQ2FjaGUuaGFzKGRvYykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQ2FjaGUuc2V0KGRvYywgY2FjaGVFbnRyeV8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWRkKGRvY3VtZW50KTtcbiAgICAgICAgICAgIGFkZCh0cmFuc2Zvcm1lZCk7XG4gICAgICAgICAgICBhZGQoY2xpZW50UXVlcnkpO1xuICAgICAgICAgICAgYWRkKHNlcnZlclF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtQ2FjaGUuZ2V0KGRvY3VtZW50KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2V0VmFyaWFibGVzID0gZnVuY3Rpb24gKGRvY3VtZW50LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLnRyYW5zZm9ybShkb2N1bWVudCkuZGVmYXVsdFZhcnMpLCB2YXJpYWJsZXMpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS53YXRjaFF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNob3VsZFN1YnNjcmliZSkge1xuICAgICAgICBpZiAoc2hvdWxkU3Vic2NyaWJlID09PSB2b2lkIDApIHsgc2hvdWxkU3Vic2NyaWJlID0gdHJ1ZTsgfVxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQob3B0aW9ucy5mZXRjaFBvbGljeSAhPT0gJ3N0YW5kYnknLCAxMSkgOiBpbnZhcmlhbnQob3B0aW9ucy5mZXRjaFBvbGljeSAhPT0gJ3N0YW5kYnknLCAnY2xpZW50LndhdGNoUXVlcnkgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGZldGNoUG9saWN5IHNldCB0byBcInN0YW5kYnlcIicpO1xuICAgICAgICBvcHRpb25zLnZhcmlhYmxlcyA9IHRoaXMuZ2V0VmFyaWFibGVzKG9wdGlvbnMucXVlcnksIG9wdGlvbnMudmFyaWFibGVzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkT3B0aW9ucyA9IF9fYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUXVlcnkoe1xuICAgICAgICAgICAgcXVlcnlNYW5hZ2VyOiB0aGlzLFxuICAgICAgICAgICAgb3B0aW9uczogdHJhbnNmb3JtZWRPcHRpb25zLFxuICAgICAgICAgICAgc2hvdWxkU3Vic2NyaWJlOiBzaG91bGRTdWJzY3JpYmUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChvcHRpb25zLnF1ZXJ5LCAxMikgOiBpbnZhcmlhbnQob3B0aW9ucy5xdWVyeSwgJ3F1ZXJ5IG9wdGlvbiBpcyByZXF1aXJlZC4gWW91IG11c3Qgc3BlY2lmeSB5b3VyIEdyYXBoUUwgZG9jdW1lbnQgJyArXG4gICAgICAgICAgICAnaW4gdGhlIHF1ZXJ5IG9wdGlvbi4nKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KG9wdGlvbnMucXVlcnkua2luZCA9PT0gJ0RvY3VtZW50JywgMTMpIDogaW52YXJpYW50KG9wdGlvbnMucXVlcnkua2luZCA9PT0gJ0RvY3VtZW50JywgJ1lvdSBtdXN0IHdyYXAgdGhlIHF1ZXJ5IHN0cmluZyBpbiBhIFwiZ3FsXCIgdGFnLicpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoIW9wdGlvbnMucmV0dXJuUGFydGlhbERhdGEsIDE0KSA6IGludmFyaWFudCghb3B0aW9ucy5yZXR1cm5QYXJ0aWFsRGF0YSwgJ3JldHVyblBhcnRpYWxEYXRhIG9wdGlvbiBvbmx5IHN1cHBvcnRlZCBvbiB3YXRjaFF1ZXJ5LicpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoIW9wdGlvbnMucG9sbEludGVydmFsLCAxNSkgOiBpbnZhcmlhbnQoIW9wdGlvbnMucG9sbEludGVydmFsLCAncG9sbEludGVydmFsIG9wdGlvbiBvbmx5IHN1cHBvcnRlZCBvbiB3YXRjaFF1ZXJ5LicpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHdhdGNoZWRRdWVyeSA9IF90aGlzLndhdGNoUXVlcnkob3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgICAgX3RoaXMuZmV0Y2hRdWVyeVJlamVjdEZucy5zZXQoXCJxdWVyeTpcIiArIHdhdGNoZWRRdWVyeS5xdWVyeUlkLCByZWplY3QpO1xuICAgICAgICAgICAgd2F0Y2hlZFF1ZXJ5XG4gICAgICAgICAgICAgICAgLnJlc3VsdCgpXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZmV0Y2hRdWVyeVJlamVjdEZucy5kZWxldGUoXCJxdWVyeTpcIiArIHdhdGNoZWRRdWVyeS5xdWVyeUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2VuZXJhdGVRdWVyeUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMuaWRDb3VudGVyKyspO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUXVlcnlJblN0b3JlID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5zdG9wUXVlcnlJblN0b3JlTm9Ccm9hZGNhc3QocXVlcnlJZCk7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUXVlcnlJblN0b3JlTm9Ccm9hZGNhc3QgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nUXVlcnkocXVlcnlJZCk7XG4gICAgICAgIHRoaXMucXVlcnlTdG9yZS5zdG9wUXVlcnkocXVlcnlJZCk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZShxdWVyeUlkKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuYWRkUXVlcnlMaXN0ZW5lciA9IGZ1bmN0aW9uIChxdWVyeUlkLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNldFF1ZXJ5KHF1ZXJ5SWQsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IF9hLmxpc3RlbmVycztcbiAgICAgICAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgaW52YWxpZGF0ZWQ6IGZhbHNlIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVRdWVyeVdhdGNoID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjYW5jZWwgPSB0aGlzLmdldFF1ZXJ5KHF1ZXJ5SWQpLmNhbmNlbDtcbiAgICAgICAgaWYgKGNhbmNlbClcbiAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB2YXIgcHJldmlvdXNSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGVRdWVyeSA9IF90aGlzLmdldFF1ZXJ5KHF1ZXJ5SWQpLm9ic2VydmFibGVRdWVyeTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZhYmxlUXVlcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFJlc3VsdCA9IG9ic2VydmFibGVRdWVyeS5nZXRMYXN0UmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNSZXN1bHQgPSBsYXN0UmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzUmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU3RvcmUuZ2V0Q2FjaGUoKS53YXRjaCh7XG4gICAgICAgICAgICBxdWVyeTogZG9jdW1lbnQsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgb3B0aW1pc3RpYzogdHJ1ZSxcbiAgICAgICAgICAgIHByZXZpb3VzUmVzdWx0OiBwcmV2aW91c1Jlc3VsdCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFF1ZXJ5KHF1ZXJ5SWQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7IGludmFsaWRhdGVkOiB0cnVlLCBuZXdEYXRhOiBuZXdEYXRhIH0pOyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5hZGRPYnNlcnZhYmxlUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCwgb2JzZXJ2YWJsZVF1ZXJ5KSB7XG4gICAgICAgIHRoaXMuc2V0UXVlcnkocXVlcnlJZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgb2JzZXJ2YWJsZVF1ZXJ5OiBvYnNlcnZhYmxlUXVlcnkgfSk7IH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVPYnNlcnZhYmxlUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICB2YXIgY2FuY2VsID0gdGhpcy5nZXRRdWVyeShxdWVyeUlkKS5jYW5jZWw7XG4gICAgICAgIHRoaXMuc2V0UXVlcnkocXVlcnlJZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgb2JzZXJ2YWJsZVF1ZXJ5OiBudWxsIH0pOyB9KTtcbiAgICAgICAgaWYgKGNhbmNlbClcbiAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5jbGVhclN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZldGNoUXVlcnlSZWplY3RGbnMuZm9yRWFjaChmdW5jdGlvbiAocmVqZWN0KSB7XG4gICAgICAgICAgICByZWplY3QocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbmV3IEludmFyaWFudEVycm9yKDE2KSA6IG5ldyBJbnZhcmlhbnRFcnJvcignU3RvcmUgcmVzZXQgd2hpbGUgcXVlcnkgd2FzIGluIGZsaWdodCAobm90IGNvbXBsZXRlZCBpbiBsaW5rIGNoYWluKScpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZXNldElkcyA9IFtdO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIHF1ZXJ5SWQpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlUXVlcnkgPSBfYS5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgICAgICBpZiAob2JzZXJ2YWJsZVF1ZXJ5KVxuICAgICAgICAgICAgICAgIHJlc2V0SWRzLnB1c2gocXVlcnlJZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnF1ZXJ5U3RvcmUucmVzZXQocmVzZXRJZHMpO1xuICAgICAgICB0aGlzLm11dGF0aW9uU3RvcmUucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVN0b3JlLnJlc2V0KCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnJlc2V0U3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmNsZWFyU3RvcmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcyA9IGZ1bmN0aW9uIChpbmNsdWRlU3RhbmRieSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaW5jbHVkZVN0YW5kYnkgPT09IHZvaWQgMCkgeyBpbmNsdWRlU3RhbmRieSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBvYnNlcnZhYmxlUXVlcnlQcm9taXNlcyA9IFtdO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIHF1ZXJ5SWQpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlUXVlcnkgPSBfYS5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgICAgICBpZiAob2JzZXJ2YWJsZVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZldGNoUG9saWN5ID0gb2JzZXJ2YWJsZVF1ZXJ5Lm9wdGlvbnMuZmV0Y2hQb2xpY3k7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZVF1ZXJ5LnJlc2V0TGFzdFJlc3VsdHMoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgIT09ICdjYWNoZS1vbmx5JyAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5jbHVkZVN0YW5kYnkgfHwgZmV0Y2hQb2xpY3kgIT09ICdzdGFuZGJ5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2YWJsZVF1ZXJ5UHJvbWlzZXMucHVzaChvYnNlcnZhYmxlUXVlcnkucmVmZXRjaCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0UXVlcnkocXVlcnlJZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgbmV3RGF0YTogbnVsbCB9KTsgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW52YWxpZGF0ZShxdWVyeUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob2JzZXJ2YWJsZVF1ZXJ5UHJvbWlzZXMpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5vYnNlcnZlUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCwgb3B0aW9ucywgb2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5hZGRRdWVyeUxpc3RlbmVyKHF1ZXJ5SWQsIHRoaXMucXVlcnlMaXN0ZW5lckZvck9ic2VydmVyKHF1ZXJ5SWQsIG9wdGlvbnMsIG9ic2VydmVyKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoUXVlcnkocXVlcnlJZCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnN0YXJ0UXVlcnkgPSBmdW5jdGlvbiAocXVlcnlJZCwgb3B0aW9ucywgbGlzdGVuZXIpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IGludmFyaWFudC53YXJuKFwiVGhlIFF1ZXJ5TWFuYWdlci5zdGFydFF1ZXJ5IG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkXCIpO1xuICAgICAgICB0aGlzLmFkZFF1ZXJ5TGlzdGVuZXIocXVlcnlJZCwgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmZldGNoUXVlcnkocXVlcnlJZCwgb3B0aW9ucylcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0pO1xuICAgICAgICByZXR1cm4gcXVlcnlJZDtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuc3RhcnRHcmFwaFFMU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBxdWVyeSA9IF9hLnF1ZXJ5LCBmZXRjaFBvbGljeSA9IF9hLmZldGNoUG9saWN5LCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXM7XG4gICAgICAgIHF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm0ocXVlcnkpLmRvY3VtZW50O1xuICAgICAgICB2YXJpYWJsZXMgPSB0aGlzLmdldFZhcmlhYmxlcyhxdWVyeSwgdmFyaWFibGVzKTtcbiAgICAgICAgdmFyIG1ha2VPYnNlcnZhYmxlID0gZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldE9ic2VydmFibGVGcm9tTGluayhxdWVyeSwge30sIHZhcmlhYmxlcywgZmFsc2UpLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmZXRjaFBvbGljeSB8fCBmZXRjaFBvbGljeSAhPT0gJ25vLWNhY2hlJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kYXRhU3RvcmUubWFya1N1YnNjcmlwdGlvblJlc3VsdChyZXN1bHQsIHF1ZXJ5LCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChncmFwaFFMUmVzdWx0SGFzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBvbGxvRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhRTEVycm9yczogcmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtKHF1ZXJ5KS5oYXNDbGllbnRFeHBvcnRzKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZVByb21pc2VfMSA9IHRoaXMubG9jYWxTdGF0ZS5hZGRFeHBvcnRlZFZhcmlhYmxlcyhxdWVyeSwgdmFyaWFibGVzKS50aGVuKG1ha2VPYnNlcnZhYmxlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlUHJvbWlzZV8xLnRoZW4oZnVuY3Rpb24gKG9ic2VydmFibGUpIHsgcmV0dXJuIHN1YiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTsgfSwgb2JzZXJ2ZXIuZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWIgJiYgc3ViLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZU9ic2VydmFibGUodmFyaWFibGVzKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuc3RvcFF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5zdG9wUXVlcnlOb0Jyb2FkY2FzdChxdWVyeUlkKTtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnN0b3BRdWVyeU5vQnJvYWRjYXN0ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5zdG9wUXVlcnlJblN0b3JlTm9Ccm9hZGNhc3QocXVlcnlJZCk7XG4gICAgICAgIHRoaXMucmVtb3ZlUXVlcnkocXVlcnlJZCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnJlbW92ZVF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5mZXRjaFF1ZXJ5UmVqZWN0Rm5zLmRlbGV0ZShcInF1ZXJ5OlwiICsgcXVlcnlJZCk7XG4gICAgICAgIHRoaXMuZmV0Y2hRdWVyeVJlamVjdEZucy5kZWxldGUoXCJmZXRjaFJlcXVlc3Q6XCIgKyBxdWVyeUlkKTtcbiAgICAgICAgdGhpcy5nZXRRdWVyeShxdWVyeUlkKS5zdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgICAgIHRoaXMucXVlcmllcy5kZWxldGUocXVlcnlJZCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdldEN1cnJlbnRRdWVyeVJlc3VsdCA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlUXVlcnksIG9wdGltaXN0aWMpIHtcbiAgICAgICAgaWYgKG9wdGltaXN0aWMgPT09IHZvaWQgMCkgeyBvcHRpbWlzdGljID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgX2EgPSBvYnNlcnZhYmxlUXVlcnkub3B0aW9ucywgdmFyaWFibGVzID0gX2EudmFyaWFibGVzLCBxdWVyeSA9IF9hLnF1ZXJ5LCBmZXRjaFBvbGljeSA9IF9hLmZldGNoUG9saWN5LCByZXR1cm5QYXJ0aWFsRGF0YSA9IF9hLnJldHVyblBhcnRpYWxEYXRhO1xuICAgICAgICB2YXIgbGFzdFJlc3VsdCA9IG9ic2VydmFibGVRdWVyeS5nZXRMYXN0UmVzdWx0KCk7XG4gICAgICAgIHZhciBuZXdEYXRhID0gdGhpcy5nZXRRdWVyeShvYnNlcnZhYmxlUXVlcnkucXVlcnlJZCkubmV3RGF0YTtcbiAgICAgICAgaWYgKG5ld0RhdGEgJiYgbmV3RGF0YS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbmV3RGF0YS5yZXN1bHQsIHBhcnRpYWw6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZldGNoUG9saWN5ID09PSAnbm8tY2FjaGUnIHx8IGZldGNoUG9saWN5ID09PSAnbmV0d29yay1vbmx5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogdW5kZWZpbmVkLCBwYXJ0aWFsOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYiA9IHRoaXMuZGF0YVN0b3JlLmdldENhY2hlKCkuZGlmZih7XG4gICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgIHByZXZpb3VzUmVzdWx0OiBsYXN0UmVzdWx0ID8gbGFzdFJlc3VsdC5kYXRhIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICBvcHRpbWlzdGljOiBvcHRpbWlzdGljLFxuICAgICAgICB9KSwgcmVzdWx0ID0gX2IucmVzdWx0LCBjb21wbGV0ZSA9IF9iLmNvbXBsZXRlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogKGNvbXBsZXRlIHx8IHJldHVyblBhcnRpYWxEYXRhKSA/IHJlc3VsdCA6IHZvaWQgMCxcbiAgICAgICAgICAgIHBhcnRpYWw6ICFjb21wbGV0ZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2V0UXVlcnlXaXRoUHJldmlvdXNSZXN1bHQgPSBmdW5jdGlvbiAocXVlcnlJZE9yT2JzZXJ2YWJsZSkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZVF1ZXJ5O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5SWRPck9ic2VydmFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgZm91bmRPYnNlcnZlYWJsZVF1ZXJ5ID0gdGhpcy5nZXRRdWVyeShxdWVyeUlkT3JPYnNlcnZhYmxlKS5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZm91bmRPYnNlcnZlYWJsZVF1ZXJ5LCAxNykgOiBpbnZhcmlhbnQoZm91bmRPYnNlcnZlYWJsZVF1ZXJ5LCBcIk9ic2VydmFibGVRdWVyeSB3aXRoIHRoaXMgaWQgZG9lc24ndCBleGlzdDogXCIgKyBxdWVyeUlkT3JPYnNlcnZhYmxlKTtcbiAgICAgICAgICAgIG9ic2VydmFibGVRdWVyeSA9IGZvdW5kT2JzZXJ2ZWFibGVRdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmFibGVRdWVyeSA9IHF1ZXJ5SWRPck9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gb2JzZXJ2YWJsZVF1ZXJ5Lm9wdGlvbnMsIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgcXVlcnkgPSBfYS5xdWVyeTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZXZpb3VzUmVzdWx0OiB0aGlzLmdldEN1cnJlbnRRdWVyeVJlc3VsdChvYnNlcnZhYmxlUXVlcnksIGZhbHNlKS5kYXRhLFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICBkb2N1bWVudDogcXVlcnksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmJyb2FkY2FzdFF1ZXJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMub25Ccm9hZGNhc3QoKTtcbiAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKGluZm8sIGlkKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgICAgIGluZm8ubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIoX3RoaXMucXVlcnlTdG9yZS5nZXQoaWQpLCBpbmZvLm5ld0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRMb2NhbFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRPYnNlcnZhYmxlRnJvbUxpbmsgPSBmdW5jdGlvbiAocXVlcnksIGNvbnRleHQsIHZhcmlhYmxlcywgZGVkdXBsaWNhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGVkdXBsaWNhdGlvbiA9PT0gdm9pZCAwKSB7IGRlZHVwbGljYXRpb24gPSB0aGlzLnF1ZXJ5RGVkdXBsaWNhdGlvbjsgfVxuICAgICAgICB2YXIgb2JzZXJ2YWJsZTtcbiAgICAgICAgdmFyIHNlcnZlclF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm0ocXVlcnkpLnNlcnZlclF1ZXJ5O1xuICAgICAgICBpZiAoc2VydmVyUXVlcnkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGluRmxpZ2h0TGlua09ic2VydmFibGVzXzEgPSBfYS5pbkZsaWdodExpbmtPYnNlcnZhYmxlcywgbGluayA9IF9hLmxpbms7XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBzZXJ2ZXJRdWVyeSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBnZXRPcGVyYXRpb25OYW1lKHNlcnZlclF1ZXJ5KSB8fCB2b2lkIDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5wcmVwYXJlQ29udGV4dChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dCksIHsgZm9yY2VGZXRjaDogIWRlZHVwbGljYXRpb24gfSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBvcGVyYXRpb24uY29udGV4dDtcbiAgICAgICAgICAgIGlmIChkZWR1cGxpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5VmFyaWFibGVzXzEgPSBpbkZsaWdodExpbmtPYnNlcnZhYmxlc18xLmdldChzZXJ2ZXJRdWVyeSkgfHwgbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIGluRmxpZ2h0TGlua09ic2VydmFibGVzXzEuc2V0KHNlcnZlclF1ZXJ5LCBieVZhcmlhYmxlc18xKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFySnNvbl8xID0gSlNPTi5zdHJpbmdpZnkodmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlID0gYnlWYXJpYWJsZXNfMS5nZXQodmFySnNvbl8xKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnlWYXJpYWJsZXNfMS5zZXQodmFySnNvbl8xLCBvYnNlcnZhYmxlID0gbXVsdGlwbGV4KGV4ZWN1dGUobGluaywgb3BlcmF0aW9uKSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5VmFyaWFibGVzXzEuZGVsZXRlKHZhckpzb25fMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ5VmFyaWFibGVzXzEuc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbkZsaWdodExpbmtPYnNlcnZhYmxlc18xLmRlbGV0ZShzZXJ2ZXJRdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3ViXzEudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsZWFudXBTdWJfMSA9IG9ic2VydmFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IGNsZWFudXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogY2xlYW51cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjbGVhbnVwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlID0gbXVsdGlwbGV4KGV4ZWN1dGUobGluaywgb3BlcmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlID0gT2JzZXJ2YWJsZS5vZih7IGRhdGE6IHt9IH0pO1xuICAgICAgICAgICAgY29udGV4dCA9IHRoaXMucHJlcGFyZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsaWVudFF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm0ocXVlcnkpLmNsaWVudFF1ZXJ5O1xuICAgICAgICBpZiAoY2xpZW50UXVlcnkpIHtcbiAgICAgICAgICAgIG9ic2VydmFibGUgPSBhc3luY01hcChvYnNlcnZhYmxlLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmxvY2FsU3RhdGUucnVuUmVzb2x2ZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IGNsaWVudFF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVSZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZmV0Y2hSZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXF1ZXN0SWQgPSBfYS5yZXF1ZXN0SWQsIHF1ZXJ5SWQgPSBfYS5xdWVyeUlkLCBkb2N1bWVudCA9IF9hLmRvY3VtZW50LCBvcHRpb25zID0gX2Eub3B0aW9ucywgZmV0Y2hNb3JlRm9yUXVlcnlJZCA9IF9hLmZldGNoTW9yZUZvclF1ZXJ5SWQ7XG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSBvcHRpb25zLnZhcmlhYmxlcywgX2IgPSBvcHRpb25zLmVycm9yUG9saWN5LCBlcnJvclBvbGljeSA9IF9iID09PSB2b2lkIDAgPyAnbm9uZScgOiBfYiwgZmV0Y2hQb2xpY3kgPSBvcHRpb25zLmZldGNoUG9saWN5O1xuICAgICAgICB2YXIgcmVzdWx0RnJvbVN0b3JlO1xuICAgICAgICB2YXIgZXJyb3JzRnJvbVN0b3JlO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBfdGhpcy5nZXRPYnNlcnZhYmxlRnJvbUxpbmsoZG9jdW1lbnQsIG9wdGlvbnMuY29udGV4dCwgdmFyaWFibGVzKTtcbiAgICAgICAgICAgIHZhciBmcXJmSWQgPSBcImZldGNoUmVxdWVzdDpcIiArIHF1ZXJ5SWQ7XG4gICAgICAgICAgICBfdGhpcy5mZXRjaFF1ZXJ5UmVqZWN0Rm5zLnNldChmcXJmSWQsIHJlamVjdCk7XG4gICAgICAgICAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5mZXRjaFF1ZXJ5UmVqZWN0Rm5zLmRlbGV0ZShmcXJmSWQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFF1ZXJ5KHF1ZXJ5SWQsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IF9hLnN1YnNjcmlwdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdElkID49IF90aGlzLmdldFF1ZXJ5KHF1ZXJ5SWQpLmxhc3RSZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFya1F1ZXJ5UmVzdWx0KHF1ZXJ5SWQsIHJlc3VsdCwgb3B0aW9ucywgZmV0Y2hNb3JlRm9yUXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnF1ZXJ5U3RvcmUubWFya1F1ZXJ5UmVzdWx0KHF1ZXJ5SWQsIHJlc3VsdCwgZmV0Y2hNb3JlRm9yUXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmludmFsaWRhdGUocXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmludmFsaWRhdGUoZmV0Y2hNb3JlRm9yUXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yUG9saWN5ID09PSAnbm9uZScgJiYgaXNOb25FbXB0eUFycmF5KHJlc3VsdC5lcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEFwb2xsb0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoUUxFcnJvcnM6IHJlc3VsdC5lcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yUG9saWN5ID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnNGcm9tU3RvcmUgPSByZXN1bHQuZXJyb3JzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmV0Y2hNb3JlRm9yUXVlcnlJZCB8fCBmZXRjaFBvbGljeSA9PT0gJ25vLWNhY2hlJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRGcm9tU3RvcmUgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmRhdGFTdG9yZS5nZXRDYWNoZSgpLmRpZmYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblBhcnRpYWxEYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KSwgcmVzdWx0XzEgPSBfYS5yZXN1bHQsIGNvbXBsZXRlID0gX2EuY29tcGxldGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSB8fCBvcHRpb25zLnJldHVyblBhcnRpYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRGcm9tU3RvcmUgPSByZXN1bHRfMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0RnJvbVN0b3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnNGcm9tU3RvcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtTdGF0dXM6IE5ldHdvcmtTdGF0dXMucmVhZHksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLnNldFF1ZXJ5KHF1ZXJ5SWQsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gX2Euc3Vic2NyaXB0aW9ucztcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLmFkZChzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5xdWVyaWVzLmdldChxdWVyeUlkKSB8fCB7XG4gICAgICAgICAgICBsaXN0ZW5lcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIGludmFsaWRhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGRvY3VtZW50OiBudWxsLFxuICAgICAgICAgICAgbmV3RGF0YTogbnVsbCxcbiAgICAgICAgICAgIGxhc3RSZXF1ZXN0SWQ6IDEsXG4gICAgICAgICAgICBvYnNlcnZhYmxlUXVlcnk6IG51bGwsXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zOiBuZXcgU2V0KCksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zZXRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeUlkLCB1cGRhdGVyKSB7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5nZXRRdWVyeShxdWVyeUlkKTtcbiAgICAgICAgdmFyIG5ld0luZm8gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldiksIHVwZGF0ZXIocHJldikpO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuc2V0KHF1ZXJ5SWQsIG5ld0luZm8pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIGludmFsaWRhdGVkKSB7XG4gICAgICAgIGlmIChpbnZhbGlkYXRlZCA9PT0gdm9pZCAwKSB7IGludmFsaWRhdGVkID0gdHJ1ZTsgfVxuICAgICAgICBpZiAocXVlcnlJZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRRdWVyeShxdWVyeUlkLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBpbnZhbGlkYXRlZDogaW52YWxpZGF0ZWQgfSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnByZXBhcmVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgdmFyIG5ld0NvbnRleHQgPSB0aGlzLmxvY2FsU3RhdGUucHJlcGFyZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbmV3Q29udGV4dCksIHsgY2xpZW50QXdhcmVuZXNzOiB0aGlzLmNsaWVudEF3YXJlbmVzcyB9KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuY2hlY2tJbkZsaWdodCA9IGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnlTdG9yZS5nZXQocXVlcnlJZCk7XG4gICAgICAgIHJldHVybiAocXVlcnkgJiZcbiAgICAgICAgICAgIHF1ZXJ5Lm5ldHdvcmtTdGF0dXMgIT09IE5ldHdvcmtTdGF0dXMucmVhZHkgJiZcbiAgICAgICAgICAgIHF1ZXJ5Lm5ldHdvcmtTdGF0dXMgIT09IE5ldHdvcmtTdGF0dXMuZXJyb3IpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdGFydFBvbGxpbmdRdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zLCBxdWVyeUlkLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcG9sbEludGVydmFsID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWw7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChwb2xsSW50ZXJ2YWwsIDE4KSA6IGludmFyaWFudChwb2xsSW50ZXJ2YWwsICdBdHRlbXB0ZWQgdG8gc3RhcnQgYSBwb2xsaW5nIHF1ZXJ5IHdpdGhvdXQgYSBwb2xsaW5nIGludGVydmFsLicpO1xuICAgICAgICBpZiAoIXRoaXMuc3NyTW9kZSkge1xuICAgICAgICAgICAgdmFyIGluZm8gPSB0aGlzLnBvbGxpbmdJbmZvQnlRdWVyeUlkLmdldChxdWVyeUlkKTtcbiAgICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9sbGluZ0luZm9CeVF1ZXJ5SWQuc2V0KHF1ZXJ5SWQsIChpbmZvID0ge30pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZm8uaW50ZXJ2YWwgPSBwb2xsSW50ZXJ2YWw7XG4gICAgICAgICAgICBpbmZvLm9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZmV0Y2hQb2xpY3k6ICduZXR3b3JrLW9ubHknIH0pO1xuICAgICAgICAgICAgdmFyIG1heWJlRmV0Y2hfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IF90aGlzLnBvbGxpbmdJbmZvQnlRdWVyeUlkLmdldChxdWVyeUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2hlY2tJbkZsaWdodChxdWVyeUlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9sbF8xKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5mZXRjaFF1ZXJ5KHF1ZXJ5SWQsIGluZm8ub3B0aW9ucywgRmV0Y2hUeXBlLnBvbGwpLnRoZW4ocG9sbF8xLCBwb2xsXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBwb2xsXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBfdGhpcy5wb2xsaW5nSW5mb0J5UXVlcnlJZC5nZXQocXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGluZm8udGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIGluZm8udGltZW91dCA9IHNldFRpbWVvdXQobWF5YmVGZXRjaF8xLCBpbmZvLmludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRRdWVyeUxpc3RlbmVyKHF1ZXJ5SWQsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvbGxfMSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeUlkO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUG9sbGluZ1F1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgdGhpcy5wb2xsaW5nSW5mb0J5UXVlcnlJZC5kZWxldGUocXVlcnlJZCk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVlcnlNYW5hZ2VyO1xufSgpKTtcblxudmFyIERhdGFTdG9yZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YVN0b3JlKGluaXRpYWxDYWNoZSkge1xuICAgICAgICB0aGlzLmNhY2hlID0gaW5pdGlhbENhY2hlO1xuICAgIH1cbiAgICBEYXRhU3RvcmUucHJvdG90eXBlLmdldENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZTtcbiAgICB9O1xuICAgIERhdGFTdG9yZS5wcm90b3R5cGUubWFya1F1ZXJ5UmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCwgZG9jdW1lbnQsIHZhcmlhYmxlcywgZmV0Y2hNb3JlRm9yUXVlcnlJZCwgaWdub3JlRXJyb3JzKSB7XG4gICAgICAgIGlmIChpZ25vcmVFcnJvcnMgPT09IHZvaWQgMCkgeyBpZ25vcmVFcnJvcnMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgd3JpdGVXaXRoRXJyb3JzID0gIWdyYXBoUUxSZXN1bHRIYXNFcnJvcihyZXN1bHQpO1xuICAgICAgICBpZiAoaWdub3JlRXJyb3JzICYmIGdyYXBoUUxSZXN1bHRIYXNFcnJvcihyZXN1bHQpICYmIHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICB3cml0ZVdpdGhFcnJvcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmV0Y2hNb3JlRm9yUXVlcnlJZCAmJiB3cml0ZVdpdGhFcnJvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUud3JpdGUoe1xuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgZGF0YUlkOiAnUk9PVF9RVUVSWScsXG4gICAgICAgICAgICAgICAgcXVlcnk6IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFTdG9yZS5wcm90b3R5cGUubWFya1N1YnNjcmlwdGlvblJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGRvY3VtZW50LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKCFncmFwaFFMUmVzdWx0SGFzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS53cml0ZSh7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICBkYXRhSWQ6ICdST09UX1NVQlNDUklQVElPTicsXG4gICAgICAgICAgICAgICAgcXVlcnk6IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFTdG9yZS5wcm90b3R5cGUubWFya011dGF0aW9uSW5pdCA9IGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobXV0YXRpb24ub3B0aW1pc3RpY1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW1pc3RpY18xO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtdXRhdGlvbi5vcHRpbWlzdGljUmVzcG9uc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljXzEgPSBtdXRhdGlvbi5vcHRpbWlzdGljUmVzcG9uc2UobXV0YXRpb24udmFyaWFibGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGltaXN0aWNfMSA9IG11dGF0aW9uLm9wdGltaXN0aWNSZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FjaGUucmVjb3JkT3B0aW1pc3RpY1RyYW5zYWN0aW9uKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWcgPSBfdGhpcy5jYWNoZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jYWNoZSA9IGM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFya011dGF0aW9uUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSWQ6IG11dGF0aW9uLm11dGF0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHsgZGF0YTogb3B0aW1pc3RpY18xIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogbXV0YXRpb24uZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG11dGF0aW9uLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVF1ZXJpZXM6IG11dGF0aW9uLnVwZGF0ZVF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IG11dGF0aW9uLnVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYWNoZSA9IG9yaWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbXV0YXRpb24ubXV0YXRpb25JZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFTdG9yZS5wcm90b3R5cGUubWFya011dGF0aW9uUmVzdWx0ID0gZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghZ3JhcGhRTFJlc3VsdEhhc0Vycm9yKG11dGF0aW9uLnJlc3VsdCkpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZVdyaXRlc18xID0gW3tcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBtdXRhdGlvbi5yZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUlkOiAnUk9PVF9NVVRBVElPTicsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBtdXRhdGlvbi5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBtdXRhdGlvbi52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB2YXIgdXBkYXRlUXVlcmllc18xID0gbXV0YXRpb24udXBkYXRlUXVlcmllcztcbiAgICAgICAgICAgIGlmICh1cGRhdGVRdWVyaWVzXzEpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh1cGRhdGVRdWVyaWVzXzEpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHVwZGF0ZVF1ZXJpZXNfMVtpZF0sIHF1ZXJ5ID0gX2EucXVlcnksIHVwZGF0ZXIgPSBfYS51cGRhdGVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5jYWNoZS5kaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeS5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogcXVlcnkudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSksIGN1cnJlbnRRdWVyeVJlc3VsdCA9IF9iLnJlc3VsdCwgY29tcGxldGUgPSBfYi5jb21wbGV0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFF1ZXJ5UmVzdWx0ID0gdHJ5RnVuY3Rpb25PckxvZ0Vycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlcihjdXJyZW50UXVlcnlSZXN1bHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25SZXN1bHQ6IG11dGF0aW9uLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlOYW1lOiBnZXRPcGVyYXRpb25OYW1lKHF1ZXJ5LmRvY3VtZW50KSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5VmFyaWFibGVzOiBxdWVyeS52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0UXVlcnlSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVdyaXRlc18xLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IG5leHRRdWVyeVJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUlkOiAnUk9PVF9RVUVSWScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeS5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBxdWVyeS52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FjaGUucGVyZm9ybVRyYW5zYWN0aW9uKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVXcml0ZXNfMS5mb3JFYWNoKGZ1bmN0aW9uICh3cml0ZSkgeyByZXR1cm4gYy53cml0ZSh3cml0ZSk7IH0pO1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGUgPSBtdXRhdGlvbi51cGRhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnlGdW5jdGlvbk9yTG9nRXJyb3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlKGMsIG11dGF0aW9uLnJlc3VsdCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhU3RvcmUucHJvdG90eXBlLm1hcmtNdXRhdGlvbkNvbXBsZXRlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBtdXRhdGlvbklkID0gX2EubXV0YXRpb25JZCwgb3B0aW1pc3RpY1Jlc3BvbnNlID0gX2Eub3B0aW1pc3RpY1Jlc3BvbnNlO1xuICAgICAgICBpZiAob3B0aW1pc3RpY1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnJlbW92ZU9wdGltaXN0aWMobXV0YXRpb25JZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFTdG9yZS5wcm90b3R5cGUubWFya1VwZGF0ZVF1ZXJ5UmVzdWx0ID0gZnVuY3Rpb24gKGRvY3VtZW50LCB2YXJpYWJsZXMsIG5ld1Jlc3VsdCkge1xuICAgICAgICB0aGlzLmNhY2hlLndyaXRlKHtcbiAgICAgICAgICAgIHJlc3VsdDogbmV3UmVzdWx0LFxuICAgICAgICAgICAgZGF0YUlkOiAnUk9PVF9RVUVSWScsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgIHF1ZXJ5OiBkb2N1bWVudCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEYXRhU3RvcmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5yZXNldCgpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFTdG9yZTtcbn0oKSk7XG5cbnZhciB2ZXJzaW9uID0gXCIyLjYuMTBcIjtcblxudmFyIGhhc1N1Z2dlc3RlZERldnRvb2xzID0gZmFsc2U7XG52YXIgQXBvbGxvQ2xpZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcG9sbG9DbGllbnQob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge307XG4gICAgICAgIHRoaXMucmVzZXRTdG9yZUNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmNsZWFyU3RvcmVDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdmFyIGNhY2hlID0gb3B0aW9ucy5jYWNoZSwgX2EgPSBvcHRpb25zLnNzck1vZGUsIHNzck1vZGUgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBvcHRpb25zLnNzckZvcmNlRmV0Y2hEZWxheSwgc3NyRm9yY2VGZXRjaERlbGF5ID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYiwgY29ubmVjdFRvRGV2VG9vbHMgPSBvcHRpb25zLmNvbm5lY3RUb0RldlRvb2xzLCBfYyA9IG9wdGlvbnMucXVlcnlEZWR1cGxpY2F0aW9uLCBxdWVyeURlZHVwbGljYXRpb24gPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBkZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsIF9kID0gb3B0aW9ucy5hc3N1bWVJbW11dGFibGVSZXN1bHRzLCBhc3N1bWVJbW11dGFibGVSZXN1bHRzID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIHJlc29sdmVycyA9IG9wdGlvbnMucmVzb2x2ZXJzLCB0eXBlRGVmcyA9IG9wdGlvbnMudHlwZURlZnMsIGZyYWdtZW50TWF0Y2hlciA9IG9wdGlvbnMuZnJhZ21lbnRNYXRjaGVyLCBjbGllbnRBd2FyZW5lc3NOYW1lID0gb3B0aW9ucy5uYW1lLCBjbGllbnRBd2FyZW5lc3NWZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uO1xuICAgICAgICB2YXIgbGluayA9IG9wdGlvbnMubGluaztcbiAgICAgICAgaWYgKCFsaW5rICYmIHJlc29sdmVycykge1xuICAgICAgICAgICAgbGluayA9IEFwb2xsb0xpbmsuZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpbmsgfHwgIWNhY2hlKSB7XG4gICAgICAgICAgICB0aHJvdyBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoNCkgOiBuZXcgSW52YXJpYW50RXJyb3IoXCJJbiBvcmRlciB0byBpbml0aWFsaXplIEFwb2xsbyBDbGllbnQsIHlvdSBtdXN0IHNwZWNpZnkgJ2xpbmsnIGFuZCAnY2FjaGUnIHByb3BlcnRpZXMgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlRoZXNlIG9wdGlvbnMgYXJlIHBhcnQgb2YgdGhlIHVwZ3JhZGUgcmVxdWlyZW1lbnRzIHdoZW4gbWlncmF0aW5nIGZyb20gQXBvbGxvIENsaWVudCAxLnggdG8gQXBvbGxvIENsaWVudCAyLnguXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiRm9yIG1vcmUgaW5mb3JtYXRpb24sIHBsZWFzZSB2aXNpdDogaHR0cHM6Ly93d3cuYXBvbGxvZ3JhcGhxbC5jb20vZG9jcy90dXRvcmlhbC9jbGllbnQuaHRtbCNhcG9sbG8tY2xpZW50LXNldHVwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGluayA9IGxpbms7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG5ldyBEYXRhU3RvcmUoY2FjaGUpO1xuICAgICAgICB0aGlzLmRpc2FibGVOZXR3b3JrRmV0Y2hlcyA9IHNzck1vZGUgfHwgc3NyRm9yY2VGZXRjaERlbGF5ID4gMDtcbiAgICAgICAgdGhpcy5xdWVyeURlZHVwbGljYXRpb24gPSBxdWVyeURlZHVwbGljYXRpb247XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy50eXBlRGVmcyA9IHR5cGVEZWZzO1xuICAgICAgICBpZiAoc3NyRm9yY2VGZXRjaERlbGF5KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfdGhpcy5kaXNhYmxlTmV0d29ya0ZldGNoZXMgPSBmYWxzZSk7IH0sIHNzckZvcmNlRmV0Y2hEZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXRjaFF1ZXJ5ID0gdGhpcy53YXRjaFF1ZXJ5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubXV0YXRlID0gdGhpcy5tdXRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZXNldFN0b3JlID0gdGhpcy5yZXNldFN0b3JlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVGZXRjaE9ic2VydmFibGVRdWVyaWVzID0gdGhpcy5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIGRlZmF1bHRDb25uZWN0VG9EZXZUb29scyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAhd2luZG93Ll9fQVBPTExPX0NMSUVOVF9fO1xuICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3RUb0RldlRvb2xzID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkZWZhdWx0Q29ubmVjdFRvRGV2VG9vbHNcbiAgICAgICAgICAgIDogY29ubmVjdFRvRGV2VG9vbHMgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5fX0FQT0xMT19DTElFTlRfXyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNTdWdnZXN0ZWREZXZ0b29scyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBoYXNTdWdnZXN0ZWREZXZ0b29scyA9IHRydWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQgJiZcbiAgICAgICAgICAgICAgICB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Ll9fQVBPTExPX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnRG93bmxvYWQgdGhlIEFwb2xsbyBEZXZUb29scyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2Nocm9tZS5nb29nbGUuY29tL3dlYnN0b3JlL2RldGFpbC9hcG9sbG8tY2xpZW50LWRldmVsb3Blci10L2pka2tua2tiZWJiYXBpbGdvZWNjY2lnbGtmYm1ibmZtJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbmV3IExvY2FsU3RhdGUoe1xuICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLFxuICAgICAgICAgICAgcmVzb2x2ZXJzOiByZXNvbHZlcnMsXG4gICAgICAgICAgICBmcmFnbWVudE1hdGNoZXI6IGZyYWdtZW50TWF0Y2hlcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVlcnlNYW5hZ2VyID0gbmV3IFF1ZXJ5TWFuYWdlcih7XG4gICAgICAgICAgICBsaW5rOiB0aGlzLmxpbmssXG4gICAgICAgICAgICBzdG9yZTogdGhpcy5zdG9yZSxcbiAgICAgICAgICAgIHF1ZXJ5RGVkdXBsaWNhdGlvbjogcXVlcnlEZWR1cGxpY2F0aW9uLFxuICAgICAgICAgICAgc3NyTW9kZTogc3NyTW9kZSxcbiAgICAgICAgICAgIGNsaWVudEF3YXJlbmVzczoge1xuICAgICAgICAgICAgICAgIG5hbWU6IGNsaWVudEF3YXJlbmVzc05hbWUsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogY2xpZW50QXdhcmVuZXNzVmVyc2lvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2NhbFN0YXRlOiB0aGlzLmxvY2FsU3RhdGUsXG4gICAgICAgICAgICBhc3N1bWVJbW11dGFibGVSZXN1bHRzOiBhc3N1bWVJbW11dGFibGVSZXN1bHRzLFxuICAgICAgICAgICAgb25Ccm9hZGNhc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZGV2VG9vbHNIb29rQ2IpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGV2VG9vbHNIb29rQ2Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcmllczogX3RoaXMucXVlcnlNYW5hZ2VyLnF1ZXJ5U3RvcmUuZ2V0U3RvcmUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbnM6IF90aGlzLnF1ZXJ5TWFuYWdlci5tdXRhdGlvblN0b3JlLmdldFN0b3JlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVdpdGhPcHRpbWlzdGljUmVzdWx0czogX3RoaXMuY2FjaGUuZXh0cmFjdCh0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIuc3RvcCgpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS53YXRjaFF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdE9wdGlvbnMud2F0Y2hRdWVyeSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zLndhdGNoUXVlcnkpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlTmV0d29ya0ZldGNoZXMgJiZcbiAgICAgICAgICAgIChvcHRpb25zLmZldGNoUG9saWN5ID09PSAnbmV0d29yay1vbmx5JyB8fFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09ICdjYWNoZS1hbmQtbmV0d29yaycpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZldGNoUG9saWN5OiAnY2FjaGUtZmlyc3QnIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci53YXRjaFF1ZXJ5KG9wdGlvbnMpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRPcHRpb25zLnF1ZXJ5KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMucXVlcnkpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQob3B0aW9ucy5mZXRjaFBvbGljeSAhPT0gJ2NhY2hlLWFuZC1uZXR3b3JrJywgNSkgOiBpbnZhcmlhbnQob3B0aW9ucy5mZXRjaFBvbGljeSAhPT0gJ2NhY2hlLWFuZC1uZXR3b3JrJywgJ1RoZSBjYWNoZS1hbmQtbmV0d29yayBmZXRjaFBvbGljeSBkb2VzIG5vdCB3b3JrIHdpdGggY2xpZW50LnF1ZXJ5LCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgJ2NsaWVudC5xdWVyeSBjYW4gb25seSByZXR1cm4gYSBzaW5nbGUgcmVzdWx0LiBQbGVhc2UgdXNlIGNsaWVudC53YXRjaFF1ZXJ5ICcgK1xuICAgICAgICAgICAgJ3RvIHJlY2VpdmUgbXVsdGlwbGUgcmVzdWx0cyBmcm9tIHRoZSBjYWNoZSBhbmQgdGhlIG5ldHdvcmssIG9yIGNvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3VzaW5nIGEgZGlmZmVyZW50IGZldGNoUG9saWN5LCBzdWNoIGFzIGNhY2hlLWZpcnN0IG9yIG5ldHdvcmstb25seS4nKTtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZU5ldHdvcmtGZXRjaGVzICYmIG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09ICduZXR3b3JrLW9ubHknKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZldGNoUG9saWN5OiAnY2FjaGUtZmlyc3QnIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5xdWVyeShvcHRpb25zKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUubXV0YXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdE9wdGlvbnMubXV0YXRlKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMubXV0YXRlKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLm11dGF0ZShvcHRpb25zKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLnN0YXJ0R3JhcGhRTFN1YnNjcmlwdGlvbihvcHRpb25zKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUucmVhZFF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGltaXN0aWMpIHtcbiAgICAgICAgaWYgKG9wdGltaXN0aWMgPT09IHZvaWQgMCkgeyBvcHRpbWlzdGljID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUucmVhZFF1ZXJ5KG9wdGlvbnMsIG9wdGltaXN0aWMpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5yZWFkRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucywgb3B0aW1pc3RpYykge1xuICAgICAgICBpZiAob3B0aW1pc3RpYyA9PT0gdm9pZCAwKSB7IG9wdGltaXN0aWMgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5yZWFkRnJhZ21lbnQob3B0aW9ucywgb3B0aW1pc3RpYyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLndyaXRlUXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYWNoZS53cml0ZVF1ZXJ5KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLndyaXRlRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYWNoZS53cml0ZUZyYWdtZW50KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLndyaXRlRGF0YSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNhY2hlLndyaXRlRGF0YShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5fX2FjdGlvbkhvb2tGb3JEZXZUb29scyA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB0aGlzLmRldlRvb2xzSG9va0NiID0gY2I7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLl9fcmVxdWVzdFJhdyA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBleGVjdXRlKHRoaXMubGluaywgcGF5bG9hZCk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLmluaXRRdWVyeU1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQud2FybignQ2FsbGluZyB0aGUgaW5pdFF1ZXJ5TWFuYWdlciBtZXRob2QgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSwgJyArXG4gICAgICAgICAgICAnYW5kIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIEFwb2xsb0NsaWVudCBpbiB2ZXJzaW9uIDMuMC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5yZXNldFN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnF1ZXJ5TWFuYWdlci5jbGVhclN0b3JlKCk7IH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLmFsbChfdGhpcy5yZXNldFN0b3JlQ2FsbGJhY2tzLm1hcChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pKTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcygpOyB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuY2xlYXJTdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5xdWVyeU1hbmFnZXIuY2xlYXJTdG9yZSgpOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5hbGwoX3RoaXMuY2xlYXJTdG9yZUNhbGxiYWNrcy5tYXAoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KSk7IH0pO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5vblJlc2V0U3RvcmUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNldFN0b3JlQ2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucmVzZXRTdG9yZUNhbGxiYWNrcyA9IF90aGlzLnJlc2V0U3RvcmVDYWxsYmFja3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICE9PSBjYjsgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLm9uQ2xlYXJTdG9yZSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNsZWFyU3RvcmVDYWxsYmFja3MucHVzaChjYik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhclN0b3JlQ2FsbGJhY2tzID0gX3RoaXMuY2xlYXJTdG9yZUNhbGxiYWNrcy5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgIT09IGNiOyB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUucmVGZXRjaE9ic2VydmFibGVRdWVyaWVzID0gZnVuY3Rpb24gKGluY2x1ZGVTdGFuZGJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMoaW5jbHVkZVN0YW5kYnkpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKG9wdGltaXN0aWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZXh0cmFjdChvcHRpbWlzdGljKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVkU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUucmVzdG9yZShzZXJpYWxpemVkU3RhdGUpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5hZGRSZXNvbHZlcnMgPSBmdW5jdGlvbiAocmVzb2x2ZXJzKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdGF0ZS5hZGRSZXNvbHZlcnMocmVzb2x2ZXJzKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc2V0UmVzb2x2ZXJzID0gZnVuY3Rpb24gKHJlc29sdmVycykge1xuICAgICAgICB0aGlzLmxvY2FsU3RhdGUuc2V0UmVzb2x2ZXJzKHJlc29sdmVycyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLmdldFJlc29sdmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdGF0ZS5nZXRSZXNvbHZlcnMoKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc2V0TG9jYWxTdGF0ZUZyYWdtZW50TWF0Y2hlciA9IGZ1bmN0aW9uIChmcmFnbWVudE1hdGNoZXIpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlLnNldEZyYWdtZW50TWF0Y2hlcihmcmFnbWVudE1hdGNoZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIEFwb2xsb0NsaWVudDtcbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IEFwb2xsb0NsaWVudDtcbmV4cG9ydCB7IEFwb2xsb0NsaWVudCwgQXBvbGxvRXJyb3IsIEZldGNoVHlwZSwgTmV0d29ya1N0YXR1cywgT2JzZXJ2YWJsZVF1ZXJ5LCBpc0Fwb2xsb0Vycm9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUuZXNtLmpzLm1hcFxuIiwiaW1wb3J0IHsgcGFyc2VyLCBvcGVyYXRpb25OYW1lLCBEb2N1bWVudFR5cGUsIGdldEFwb2xsb0NvbnRleHQgfSBmcm9tICdAYXBvbGxvL3JlYWN0LWNvbW1vbic7XG5leHBvcnQgeyBBcG9sbG9Db25zdW1lciwgQXBvbGxvUHJvdmlkZXIsIGdldEFwb2xsb0NvbnRleHQsIHJlc2V0QXBvbGxvQ29udGV4dCB9IGZyb20gJ0BhcG9sbG8vcmVhY3QtY29tbW9uJztcbmltcG9ydCB7IF9fZXh0ZW5kcywgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VDb250ZXh0LCB1c2VSZWR1Y2VyLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTmV0d29ya1N0YXR1cywgQXBvbGxvRXJyb3IgfSBmcm9tICdhcG9sbG8tY2xpZW50JztcbmltcG9ydCB7IGVxdWFsIH0gZnJvbSAnQHdyeS9lcXVhbGl0eSc7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICd0cy1pbnZhcmlhbnQnO1xuXG52YXIgT3BlcmF0aW9uRGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uRGF0YShvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJldmlvdXNPcHRpb25zID0ge307XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dCB8fCB7fTtcbiAgICB9XG4gICAgT3BlcmF0aW9uRGF0YS5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICB9O1xuICAgIE9wZXJhdGlvbkRhdGEucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAobmV3T3B0aW9ucywgc3RvcmVQcmV2aW91cykge1xuICAgICAgICBpZiAoc3RvcmVQcmV2aW91cyA9PT0gdm9pZCAwKSB7IHN0b3JlUHJldmlvdXMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoc3RvcmVQcmV2aW91cyAmJiAhZXF1YWwodGhpcy5vcHRpb25zLCBuZXdPcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c09wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICB9O1xuICAgIE9wZXJhdGlvbkRhdGEucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICBPcGVyYXRpb25EYXRhLnByb3RvdHlwZS5yZWZyZXNoQ2xpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xpZW50ID0gKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuY2xpZW50KSB8fFxuICAgICAgICAgICAgKHRoaXMuY29udGV4dCAmJiB0aGlzLmNvbnRleHQuY2xpZW50KTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCEhY2xpZW50LCAyKSA6IGludmFyaWFudCghIWNsaWVudCwgJ0NvdWxkIG5vdCBmaW5kIFwiY2xpZW50XCIgaW4gdGhlIGNvbnRleHQgb3IgcGFzc2VkIGluIGFzIGFuIG9wdGlvbi4gJyArXG4gICAgICAgICAgICAnV3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYW4gPEFwb2xsb1Byb3ZpZGVyPiwgb3IgcGFzcyBhbiAnICtcbiAgICAgICAgICAgICdBcG9sbG9DbGllbnQgaW5zdGFuY2UgaW4gdmlhIG9wdGlvbnMuJyk7XG4gICAgICAgIHZhciBpc05ldyA9IGZhbHNlO1xuICAgICAgICBpZiAoY2xpZW50ICE9PSB0aGlzLmNsaWVudCkge1xuICAgICAgICAgICAgaXNOZXcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgIGlzTmV3OiBpc05ld1xuICAgICAgICB9O1xuICAgIH07XG4gICAgT3BlcmF0aW9uRGF0YS5wcm90b3R5cGUudmVyaWZ5RG9jdW1lbnRUeXBlID0gZnVuY3Rpb24gKGRvY3VtZW50LCB0eXBlKSB7XG4gICAgICAgIHZhciBvcGVyYXRpb24gPSBwYXJzZXIoZG9jdW1lbnQpO1xuICAgICAgICB2YXIgcmVxdWlyZWRPcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uTmFtZSh0eXBlKTtcbiAgICAgICAgdmFyIHVzZWRPcGVyYXRpb25OYW1lID0gb3BlcmF0aW9uTmFtZShvcGVyYXRpb24udHlwZSk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChvcGVyYXRpb24udHlwZSA9PT0gdHlwZSwgMykgOiBpbnZhcmlhbnQob3BlcmF0aW9uLnR5cGUgPT09IHR5cGUsIFwiUnVubmluZyBhIFwiICsgcmVxdWlyZWRPcGVyYXRpb25OYW1lICsgXCIgcmVxdWlyZXMgYSBncmFwaHFsIFwiICtcbiAgICAgICAgICAgIChyZXF1aXJlZE9wZXJhdGlvbk5hbWUgKyBcIiwgYnV0IGEgXCIgKyB1c2VkT3BlcmF0aW9uTmFtZSArIFwiIHdhcyB1c2VkIGluc3RlYWQuXCIpKTtcbiAgICB9O1xuICAgIHJldHVybiBPcGVyYXRpb25EYXRhO1xufSgpKTtcblxudmFyIFF1ZXJ5RGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1ZXJ5RGF0YSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBRdWVyeURhdGEoX2EpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfYS5vcHRpb25zLCBjb250ZXh0ID0gX2EuY29udGV4dCwgb25OZXdEYXRhID0gX2Eub25OZXdEYXRhO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcmV2aW91c0RhdGEgPSB7fTtcbiAgICAgICAgX3RoaXMuY3VycmVudE9ic2VydmFibGUgPSB7fTtcbiAgICAgICAgX3RoaXMucnVuTGF6eSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5ydW5MYXp5UXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgX3RoaXMuY2xlYW51cCgpO1xuICAgICAgICAgICAgX3RoaXMucnVuTGF6eSA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5sYXp5T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICBfdGhpcy5vbk5ld0RhdGEoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0RXhlY3V0ZVJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5nZXRRdWVyeVJlc3VsdCgpO1xuICAgICAgICAgICAgX3RoaXMuc3RhcnRRdWVyeVN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub2JzUmVmZXRjaCA9IGZ1bmN0aW9uICh2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5xdWVyeS5yZWZldGNoKHZhcmlhYmxlcyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9ic0ZldGNoTW9yZSA9IGZ1bmN0aW9uIChmZXRjaE1vcmVPcHRpb25zKSB7IHJldHVybiBfdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5xdWVyeS5mZXRjaE1vcmUoZmV0Y2hNb3JlT3B0aW9ucyk7IH07XG4gICAgICAgIF90aGlzLm9ic1VwZGF0ZVF1ZXJ5ID0gZnVuY3Rpb24gKG1hcEZuKSB7IHJldHVybiBfdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5xdWVyeS51cGRhdGVRdWVyeShtYXBGbik7IH07XG4gICAgICAgIF90aGlzLm9ic1N0YXJ0UG9sbGluZyA9IGZ1bmN0aW9uIChwb2xsSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnRPYnNlcnZhYmxlICYmXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudE9ic2VydmFibGUucXVlcnkgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5xdWVyeS5zdGFydFBvbGxpbmcocG9sbEludGVydmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub2JzU3RvcFBvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50T2JzZXJ2YWJsZSAmJlxuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnRPYnNlcnZhYmxlLnF1ZXJ5ICYmXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudE9ic2VydmFibGUucXVlcnkuc3RvcFBvbGxpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub2JzU3Vic2NyaWJlVG9Nb3JlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIF90aGlzLmN1cnJlbnRPYnNlcnZhYmxlLnF1ZXJ5LnN1YnNjcmliZVRvTW9yZShvcHRpb25zKTsgfTtcbiAgICAgICAgX3RoaXMub25OZXdEYXRhID0gb25OZXdEYXRhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFF1ZXJ5RGF0YS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoQ2xpZW50KCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0T3B0aW9ucygpLCBza2lwID0gX2Euc2tpcCwgcXVlcnkgPSBfYS5xdWVyeTtcbiAgICAgICAgaWYgKHNraXAgfHwgcXVlcnkgIT09IHRoaXMucHJldmlvdXNEYXRhLnF1ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVF1ZXJ5U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzRGF0YS5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlT2JzZXJ2YWJsZVF1ZXJ5KCk7XG4gICAgICAgIGlmICh0aGlzLmlzTW91bnRlZClcbiAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeVN1YnNjcmlwdGlvbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFeGVjdXRlU3NyUmVzdWx0KCkgfHwgdGhpcy5nZXRFeGVjdXRlUmVzdWx0KCk7XG4gICAgfTtcbiAgICBRdWVyeURhdGEucHJvdG90eXBlLmV4ZWN1dGVMYXp5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucnVuTGF6eVxuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5MYXp5UXVlcnksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogTmV0d29ya1N0YXR1cy5yZWFkeSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFt0aGlzLnJ1bkxhenlRdWVyeSwgdGhpcy5leGVjdXRlKCldO1xuICAgIH07XG4gICAgUXVlcnlEYXRhLnByb3RvdHlwZS5mZXRjaERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnNraXAgfHwgb3B0aW9ucy5zc3IgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgb2JzID0gdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5xdWVyeTtcbiAgICAgICAgdmFyIGN1cnJlbnRSZXN1bHQgPSBvYnMuZ2V0Q3VycmVudFJlc3VsdCgpO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlc3VsdC5sb2FkaW5nID8gb2JzLnJlc3VsdCgpIDogZmFsc2U7XG4gICAgfTtcbiAgICBRdWVyeURhdGEucHJvdG90eXBlLmFmdGVyRXhlY3V0ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLmxhenksIGxhenkgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcbiAgICAgICAgdGhpcy5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWxhenkgfHwgdGhpcy5ydW5MYXp5KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yT3JDb21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZpb3VzT3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgICByZXR1cm4gdGhpcy51bm1vdW50LmJpbmQodGhpcyk7XG4gICAgfTtcbiAgICBRdWVyeURhdGEucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUXVlcnlTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY3VycmVudE9ic2VydmFibGUucXVlcnk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByZXZpb3VzRGF0YS5yZXN1bHQ7XG4gICAgfTtcbiAgICBRdWVyeURhdGEucHJvdG90eXBlLmdldE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX3N1cGVyLnByb3RvdHlwZS5nZXRPcHRpb25zLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmxhenlPcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zLnZhcmlhYmxlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zLnZhcmlhYmxlcyksIHRoaXMubGF6eU9wdGlvbnMudmFyaWFibGVzKTtcbiAgICAgICAgICAgIG9wdGlvbnMuY29udGV4dCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zLmNvbnRleHQpLCB0aGlzLmxhenlPcHRpb25zLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bkxhenkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfTtcbiAgICBRdWVyeURhdGEucHJvdG90eXBlLnNzckluaXRpYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dCAmJiB0aGlzLmNvbnRleHQucmVuZGVyUHJvbWlzZXM7XG4gICAgfTtcbiAgICBRdWVyeURhdGEucHJvdG90eXBlLmdldEV4ZWN1dGVTc3JSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzc3JEaXNhYmxlZCA9IHRoaXMuZ2V0T3B0aW9ucygpLnNzciA9PT0gZmFsc2U7XG4gICAgICAgIHZhciBmZXRjaERpc2FibGVkID0gdGhpcy5yZWZyZXNoQ2xpZW50KCkuY2xpZW50LmRpc2FibGVOZXR3b3JrRmV0Y2hlcztcbiAgICAgICAgdmFyIHNzckxvYWRpbmcgPSBfX2Fzc2lnbih7IGxvYWRpbmc6IHRydWUsIG5ldHdvcmtTdGF0dXM6IE5ldHdvcmtTdGF0dXMubG9hZGluZywgY2FsbGVkOiB0cnVlLCBkYXRhOiB1bmRlZmluZWQsIHN0YWxlOiBmYWxzZSwgY2xpZW50OiB0aGlzLmNsaWVudCB9LCB0aGlzLm9ic2VydmFibGVRdWVyeUZpZWxkcygpKTtcbiAgICAgICAgaWYgKHNzckRpc2FibGVkICYmICh0aGlzLnNzckluaXRpYXRlZCgpIHx8IGZldGNoRGlzYWJsZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzRGF0YS5yZXN1bHQgPSBzc3JMb2FkaW5nO1xuICAgICAgICAgICAgcmV0dXJuIHNzckxvYWRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHRoaXMuc3NySW5pdGlhdGVkKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlbmRlclByb21pc2VzLmFkZFF1ZXJ5UHJvbWlzZSh0aGlzLCB0aGlzLmdldEV4ZWN1dGVSZXN1bHQpIHx8IHNzckxvYWRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFF1ZXJ5RGF0YS5wcm90b3R5cGUucHJlcGFyZU9ic2VydmFibGVRdWVyeU9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudmVyaWZ5RG9jdW1lbnRUeXBlKG9wdGlvbnMucXVlcnksIERvY3VtZW50VHlwZS5RdWVyeSk7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IG9wdGlvbnMuZGlzcGxheU5hbWUgfHwgJ1F1ZXJ5JztcbiAgICAgICAgaWYgKHRoaXMuc3NySW5pdGlhdGVkKCkgJiZcbiAgICAgICAgICAgIChvcHRpb25zLmZldGNoUG9saWN5ID09PSAnbmV0d29yay1vbmx5JyB8fFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09ICdjYWNoZS1hbmQtbmV0d29yaycpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmZldGNoUG9saWN5ID0gJ2NhY2hlLWZpcnN0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSwgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LCBtZXRhZGF0YTogeyByZWFjdENvbXBvbmVudDogeyBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUgfSB9IH0pO1xuICAgIH07XG4gICAgUXVlcnlEYXRhLnByb3RvdHlwZS5pbml0aWFsaXplT2JzZXJ2YWJsZVF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5zc3JJbml0aWF0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5xdWVyeSA9IHRoaXMuY29udGV4dC5yZW5kZXJQcm9taXNlcy5nZXRTU1JPYnNlcnZhYmxlKHRoaXMuZ2V0T3B0aW9ucygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudE9ic2VydmFibGUucXVlcnkpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlUXVlcnlPcHRpb25zID0gdGhpcy5wcmVwYXJlT2JzZXJ2YWJsZVF1ZXJ5T3B0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0RhdGEub2JzZXJ2YWJsZVF1ZXJ5T3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBvYnNlcnZhYmxlUXVlcnlPcHRpb25zKSwgeyBjaGlsZHJlbjogbnVsbCB9KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE9ic2VydmFibGUucXVlcnkgPSB0aGlzLnJlZnJlc2hDbGllbnQoKS5jbGllbnQud2F0Y2hRdWVyeShfX2Fzc2lnbih7fSwgb2JzZXJ2YWJsZVF1ZXJ5T3B0aW9ucykpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3NySW5pdGlhdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNvbnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW5kZXJQcm9taXNlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZ2lzdGVyU1NST2JzZXJ2YWJsZSh0aGlzLmN1cnJlbnRPYnNlcnZhYmxlLnF1ZXJ5LCBvYnNlcnZhYmxlUXVlcnlPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlEYXRhLnByb3RvdHlwZS51cGRhdGVPYnNlcnZhYmxlUXVlcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5xdWVyeSkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplT2JzZXJ2YWJsZVF1ZXJ5KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld09ic2VydmFibGVRdWVyeU9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5wcmVwYXJlT2JzZXJ2YWJsZVF1ZXJ5T3B0aW9ucygpKSwgeyBjaGlsZHJlbjogbnVsbCB9KTtcbiAgICAgICAgaWYgKCFlcXVhbChuZXdPYnNlcnZhYmxlUXVlcnlPcHRpb25zLCB0aGlzLnByZXZpb3VzRGF0YS5vYnNlcnZhYmxlUXVlcnlPcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0RhdGEub2JzZXJ2YWJsZVF1ZXJ5T3B0aW9ucyA9IG5ld09ic2VydmFibGVRdWVyeU9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRPYnNlcnZhYmxlXG4gICAgICAgICAgICAgICAgLnF1ZXJ5LnNldE9wdGlvbnMobmV3T2JzZXJ2YWJsZVF1ZXJ5T3B0aW9ucylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUXVlcnlEYXRhLnByb3RvdHlwZS5zdGFydFF1ZXJ5U3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5zdWJzY3JpcHRpb24gfHwgdGhpcy5nZXRPcHRpb25zKCkuc2tpcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG9ic1F1ZXJ5ID0gdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5xdWVyeTtcbiAgICAgICAgdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5zdWJzY3JpcHRpb24gPSBvYnNRdWVyeS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvYWRpbmcgPSBfYS5sb2FkaW5nLCBuZXR3b3JrU3RhdHVzID0gX2EubmV0d29ya1N0YXR1cywgZGF0YSA9IF9hLmRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUmVzdWx0ID0gX3RoaXMucHJldmlvdXNEYXRhLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNSZXN1bHQgJiZcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNSZXN1bHQubG9hZGluZyA9PT0gbG9hZGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1Jlc3VsdC5uZXR3b3JrU3RhdHVzID09PSBuZXR3b3JrU3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgIGVxdWFsKHByZXZpb3VzUmVzdWx0LmRhdGEsIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMub25OZXdEYXRhKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc3Vic2NyaWJlVG9RdWVyeSgpO1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IuaGFzT3duUHJvcGVydHkoJ2dyYXBoUUxFcnJvcnMnKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUmVzdWx0ID0gX3RoaXMucHJldmlvdXNEYXRhLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoKHByZXZpb3VzUmVzdWx0ICYmIHByZXZpb3VzUmVzdWx0LmxvYWRpbmcpIHx8XG4gICAgICAgICAgICAgICAgICAgICFlcXVhbChlcnJvciwgX3RoaXMucHJldmlvdXNEYXRhLmVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcmV2aW91c0RhdGEuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25OZXdEYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBRdWVyeURhdGEucHJvdG90eXBlLnJlc3Vic2NyaWJlVG9RdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVRdWVyeVN1YnNjcmlwdGlvbigpO1xuICAgICAgICB2YXIgbGFzdEVycm9yID0gdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5xdWVyeS5nZXRMYXN0RXJyb3IoKTtcbiAgICAgICAgdmFyIGxhc3RSZXN1bHQgPSB0aGlzLmN1cnJlbnRPYnNlcnZhYmxlLnF1ZXJ5LmdldExhc3RSZXN1bHQoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5xdWVyeS5yZXNldExhc3RSZXN1bHRzKCk7XG4gICAgICAgIHRoaXMuc3RhcnRRdWVyeVN1YnNjcmlwdGlvbigpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY3VycmVudE9ic2VydmFibGUucXVlcnksIHtcbiAgICAgICAgICAgIGxhc3RFcnJvcjogbGFzdEVycm9yLFxuICAgICAgICAgICAgbGFzdFJlc3VsdDogbGFzdFJlc3VsdCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBRdWVyeURhdGEucHJvdG90eXBlLmdldFF1ZXJ5UmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5vYnNlcnZhYmxlUXVlcnlGaWVsZHMoKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3VsdCksIHsgZGF0YTogdW5kZWZpbmVkLCBlcnJvcjogdW5kZWZpbmVkLCBsb2FkaW5nOiBmYWxzZSwgY2FsbGVkOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRSZXN1bHQgPSB0aGlzLmN1cnJlbnRPYnNlcnZhYmxlLnF1ZXJ5LmdldEN1cnJlbnRSZXN1bHQoKTtcbiAgICAgICAgICAgIHZhciBsb2FkaW5nID0gY3VycmVudFJlc3VsdC5sb2FkaW5nLCBwYXJ0aWFsID0gY3VycmVudFJlc3VsdC5wYXJ0aWFsLCBuZXR3b3JrU3RhdHVzID0gY3VycmVudFJlc3VsdC5uZXR3b3JrU3RhdHVzLCBlcnJvcnMgPSBjdXJyZW50UmVzdWx0LmVycm9ycztcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGN1cnJlbnRSZXN1bHQuZXJyb3IsIGRhdGEgPSBjdXJyZW50UmVzdWx0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgQXBvbGxvRXJyb3IoeyBncmFwaFFMRXJyb3JzOiBlcnJvcnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzdWx0KSwgeyBsb2FkaW5nOiBsb2FkaW5nLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtTdGF0dXM6IG5ldHdvcmtTdGF0dXMsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLCBjYWxsZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICBpZiAobG9hZGluZykge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0RhdGEgPSB0aGlzLnByZXZpb3VzRGF0YS5yZXN1bHQgJiYgdGhpcy5wcmV2aW91c0RhdGEucmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRhdGEgPVxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0RhdGEgJiYgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldmlvdXNEYXRhKSwgZGF0YSkgOiBwcmV2aW91c0RhdGEgfHwgZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKHRoaXMuY3VycmVudE9ic2VydmFibGUucXVlcnkuZ2V0TGFzdFJlc3VsdCgpIHx8IHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZmV0Y2hQb2xpY3kgPSB0aGlzLmN1cnJlbnRPYnNlcnZhYmxlLnF1ZXJ5Lm9wdGlvbnMuZmV0Y2hQb2xpY3k7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxSZWZldGNoID0gb3B0aW9ucy5wYXJ0aWFsUmVmZXRjaDtcbiAgICAgICAgICAgICAgICBpZiAocGFydGlhbFJlZmV0Y2ggJiZcbiAgICAgICAgICAgICAgICAgICAgIWRhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbCAmJlxuICAgICAgICAgICAgICAgICAgICBmZXRjaFBvbGljeSAhPT0gJ2NhY2hlLW9ubHknKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogTmV0d29ya1N0YXR1cy5sb2FkaW5nLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlZmV0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5jbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICAgICAgdGhpcy5wcmV2aW91c0RhdGEubG9hZGluZyA9XG4gICAgICAgICAgICAodGhpcy5wcmV2aW91c0RhdGEucmVzdWx0ICYmIHRoaXMucHJldmlvdXNEYXRhLnJlc3VsdC5sb2FkaW5nKSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmV2aW91c0RhdGEucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLmN1cnJlbnRPYnNlcnZhYmxlLnF1ZXJ5ICYmXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRPYnNlcnZhYmxlLnF1ZXJ5LnJlc2V0UXVlcnlTdG9yZUVycm9ycygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUXVlcnlEYXRhLnByb3RvdHlwZS5oYW5kbGVFcnJvck9yQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JzUXVlcnkgPSB0aGlzLmN1cnJlbnRPYnNlcnZhYmxlLnF1ZXJ5O1xuICAgICAgICBpZiAoIW9ic1F1ZXJ5IHx8ICF0aGlzLnByZXZpb3VzRGF0YS5yZXN1bHQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJldmlvdXNEYXRhLnJlc3VsdCwgZGF0YSA9IF9hLmRhdGEsIGxvYWRpbmcgPSBfYS5sb2FkaW5nLCBlcnJvciA9IF9hLmVycm9yO1xuICAgICAgICBpZiAoIWxvYWRpbmcpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IHRoaXMuZ2V0T3B0aW9ucygpLCBxdWVyeSA9IF9iLnF1ZXJ5LCB2YXJpYWJsZXMgPSBfYi52YXJpYWJsZXMsIG9uQ29tcGxldGVkID0gX2Iub25Db21wbGV0ZWQsIG9uRXJyb3IgPSBfYi5vbkVycm9yO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNPcHRpb25zICYmXG4gICAgICAgICAgICAgICAgIXRoaXMucHJldmlvdXNEYXRhLmxvYWRpbmcgJiZcbiAgICAgICAgICAgICAgICBlcXVhbCh0aGlzLnByZXZpb3VzT3B0aW9ucy5xdWVyeSwgcXVlcnkpICYmXG4gICAgICAgICAgICAgICAgZXF1YWwodGhpcy5wcmV2aW91c09wdGlvbnMudmFyaWFibGVzLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uQ29tcGxldGVkICYmICFlcnJvcikge1xuICAgICAgICAgICAgICAgIG9uQ29tcGxldGVkKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob25FcnJvciAmJiBlcnJvcikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeURhdGEucHJvdG90eXBlLnJlbW92ZVF1ZXJ5U3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE9ic2VydmFibGUuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5zdWJzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFF1ZXJ5RGF0YS5wcm90b3R5cGUub2JzZXJ2YWJsZVF1ZXJ5RmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMuY3VycmVudE9ic2VydmFibGUucXVlcnk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YXJpYWJsZXM6IG9ic2VydmFibGUudmFyaWFibGVzLFxuICAgICAgICAgICAgcmVmZXRjaDogdGhpcy5vYnNSZWZldGNoLFxuICAgICAgICAgICAgZmV0Y2hNb3JlOiB0aGlzLm9ic0ZldGNoTW9yZSxcbiAgICAgICAgICAgIHVwZGF0ZVF1ZXJ5OiB0aGlzLm9ic1VwZGF0ZVF1ZXJ5LFxuICAgICAgICAgICAgc3RhcnRQb2xsaW5nOiB0aGlzLm9ic1N0YXJ0UG9sbGluZyxcbiAgICAgICAgICAgIHN0b3BQb2xsaW5nOiB0aGlzLm9ic1N0b3BQb2xsaW5nLFxuICAgICAgICAgICAgc3Vic2NyaWJlVG9Nb3JlOiB0aGlzLm9ic1N1YnNjcmliZVRvTW9yZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBRdWVyeURhdGE7XG59KE9wZXJhdGlvbkRhdGEpKTtcblxuZnVuY3Rpb24gdXNlRGVlcE1lbW8obWVtb0ZuLCBrZXkpIHtcbiAgICB2YXIgcmVmID0gdXNlUmVmKCk7XG4gICAgaWYgKCFyZWYuY3VycmVudCB8fCAhZXF1YWwoa2V5LCByZWYuY3VycmVudC5rZXkpKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0geyBrZXk6IGtleSwgdmFsdWU6IG1lbW9GbigpIH07XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudC52YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlQmFzZVF1ZXJ5KHF1ZXJ5LCBvcHRpb25zLCBsYXp5KSB7XG4gICAgaWYgKGxhenkgPT09IHZvaWQgMCkgeyBsYXp5ID0gZmFsc2U7IH1cbiAgICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoZ2V0QXBvbGxvQ29udGV4dCgpKTtcbiAgICB2YXIgX2EgPSB1c2VSZWR1Y2VyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICsgMTsgfSwgMCksIHRpY2sgPSBfYVswXSwgZm9yY2VVcGRhdGUgPSBfYVsxXTtcbiAgICB2YXIgdXBkYXRlZE9wdGlvbnMgPSBvcHRpb25zID8gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHF1ZXJ5OiBxdWVyeSB9KSA6IHsgcXVlcnk6IHF1ZXJ5IH07XG4gICAgdmFyIHF1ZXJ5RGF0YVJlZiA9IHVzZVJlZigpO1xuICAgIHZhciBxdWVyeURhdGEgPSBxdWVyeURhdGFSZWYuY3VycmVudCB8fFxuICAgICAgICBuZXcgUXVlcnlEYXRhKHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHVwZGF0ZWRPcHRpb25zLFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIG9uTmV3RGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghcXVlcnlEYXRhLnNzckluaXRpYXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm9yY2VVcGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICBxdWVyeURhdGEuc2V0T3B0aW9ucyh1cGRhdGVkT3B0aW9ucyk7XG4gICAgcXVlcnlEYXRhLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGlmIChxdWVyeURhdGEuc3NySW5pdGlhdGVkKCkgJiYgIXF1ZXJ5RGF0YVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHF1ZXJ5RGF0YVJlZi5jdXJyZW50ID0gcXVlcnlEYXRhO1xuICAgIH1cbiAgICB2YXIgbWVtbyA9IHtcbiAgICAgICAgb3B0aW9uczogX19hc3NpZ24oX19hc3NpZ24oe30sIHVwZGF0ZWRPcHRpb25zKSwgeyBvbkVycm9yOiB1bmRlZmluZWQsIG9uQ29tcGxldGVkOiB1bmRlZmluZWQgfSksXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHRpY2s6IHRpY2ssXG4gICAgfTtcbiAgICB2YXIgcmVzdWx0ID0gdXNlRGVlcE1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gKGxhenkgPyBxdWVyeURhdGEuZXhlY3V0ZUxhenkoKSA6IHF1ZXJ5RGF0YS5leGVjdXRlKCkpOyB9LCBtZW1vKTtcbiAgICB2YXIgcXVlcnlSZXN1bHQgPSBsYXp5XG4gICAgICAgID8gcmVzdWx0WzFdXG4gICAgICAgIDogcmVzdWx0O1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcXVlcnlEYXRhUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHF1ZXJ5RGF0YVJlZi5jdXJyZW50ID0gcXVlcnlEYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBxdWVyeURhdGEuY2xlYW51cCgpOyB9O1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gcXVlcnlEYXRhLmFmdGVyRXhlY3V0ZSh7IGxhenk6IGxhenkgfSk7IH0sIFtcbiAgICAgICAgcXVlcnlSZXN1bHQubG9hZGluZyxcbiAgICAgICAgcXVlcnlSZXN1bHQubmV0d29ya1N0YXR1cyxcbiAgICAgICAgcXVlcnlSZXN1bHQuZXJyb3IsXG4gICAgICAgIHF1ZXJ5UmVzdWx0LmRhdGEsXG4gICAgXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdXNlUXVlcnkocXVlcnksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdXNlQmFzZVF1ZXJ5KHF1ZXJ5LCBvcHRpb25zLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHVzZUxhenlRdWVyeShxdWVyeSwgb3B0aW9ucykge1xuICAgIHJldHVybiB1c2VCYXNlUXVlcnkocXVlcnksIG9wdGlvbnMsIHRydWUpO1xufVxuXG52YXIgTXV0YXRpb25EYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTXV0YXRpb25EYXRhLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE11dGF0aW9uRGF0YShfYSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIGNvbnRleHQgPSBfYS5jb250ZXh0LCByZXN1bHQgPSBfYS5yZXN1bHQsIHNldFJlc3VsdCA9IF9hLnNldFJlc3VsdDtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucnVuTXV0YXRpb24gPSBmdW5jdGlvbiAobXV0YXRpb25GdW5jdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbkZ1bmN0aW9uT3B0aW9ucyA9PT0gdm9pZCAwKSB7IG11dGF0aW9uRnVuY3Rpb25PcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIF90aGlzLm9uTXV0YXRpb25TdGFydCgpO1xuICAgICAgICAgICAgdmFyIG11dGF0aW9uSWQgPSBfdGhpcy5nZW5lcmF0ZU5ld011dGF0aW9uSWQoKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5tdXRhdGUobXV0YXRpb25GdW5jdGlvbk9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25NdXRhdGlvbkNvbXBsZXRlZChyZXNwb25zZSwgbXV0YXRpb25JZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25NdXRhdGlvbkVycm9yKGVycm9yLCBtdXRhdGlvbklkKTtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmdldE9wdGlvbnMoKS5vbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy52ZXJpZnlEb2N1bWVudFR5cGUob3B0aW9ucy5tdXRhdGlvbiwgRG9jdW1lbnRUeXBlLk11dGF0aW9uKTtcbiAgICAgICAgX3RoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICBfdGhpcy5zZXRSZXN1bHQgPSBzZXRSZXN1bHQ7XG4gICAgICAgIF90aGlzLm1vc3RSZWNlbnRNdXRhdGlvbklkID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNdXRhdGlvbkRhdGEucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHRoaXMuaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52ZXJpZnlEb2N1bWVudFR5cGUodGhpcy5nZXRPcHRpb25zKCkubXV0YXRpb24sIERvY3VtZW50VHlwZS5NdXRhdGlvbik7XG4gICAgICAgIHJlc3VsdC5jbGllbnQgPSB0aGlzLnJlZnJlc2hDbGllbnQoKS5jbGllbnQ7XG4gICAgICAgIHJldHVybiBbdGhpcy5ydW5NdXRhdGlvbiwgcmVzdWx0XTtcbiAgICB9O1xuICAgIE11dGF0aW9uRGF0YS5wcm90b3R5cGUuYWZ0ZXJFeGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnVubW91bnQuYmluZCh0aGlzKTtcbiAgICB9O1xuICAgIE11dGF0aW9uRGF0YS5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIE11dGF0aW9uRGF0YS5wcm90b3R5cGUubXV0YXRlID0gZnVuY3Rpb24gKG11dGF0aW9uRnVuY3Rpb25PcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0T3B0aW9ucygpLCBtdXRhdGlvbiA9IF9hLm11dGF0aW9uLCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIG9wdGltaXN0aWNSZXNwb25zZSA9IF9hLm9wdGltaXN0aWNSZXNwb25zZSwgdXBkYXRlID0gX2EudXBkYXRlLCBfYiA9IF9hLmNvbnRleHQsIG11dGF0aW9uQ29udGV4dCA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iLCBfYyA9IF9hLmF3YWl0UmVmZXRjaFF1ZXJpZXMsIGF3YWl0UmVmZXRjaFF1ZXJpZXMgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgZmV0Y2hQb2xpY3kgPSBfYS5mZXRjaFBvbGljeTtcbiAgICAgICAgdmFyIG11dGF0ZU9wdGlvbnMgPSBfX2Fzc2lnbih7fSwgbXV0YXRpb25GdW5jdGlvbk9wdGlvbnMpO1xuICAgICAgICB2YXIgbXV0YXRlVmFyaWFibGVzID0gT2JqZWN0LmFzc2lnbih7fSwgdmFyaWFibGVzLCBtdXRhdGVPcHRpb25zLnZhcmlhYmxlcyk7XG4gICAgICAgIGRlbGV0ZSBtdXRhdGVPcHRpb25zLnZhcmlhYmxlcztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaENsaWVudCgpLmNsaWVudC5tdXRhdGUoX19hc3NpZ24oeyBtdXRhdGlvbjogbXV0YXRpb24sXG4gICAgICAgICAgICBvcHRpbWlzdGljUmVzcG9uc2U6IG9wdGltaXN0aWNSZXNwb25zZSwgcmVmZXRjaFF1ZXJpZXM6IG11dGF0ZU9wdGlvbnMucmVmZXRjaFF1ZXJpZXMgfHwgdGhpcy5nZXRPcHRpb25zKCkucmVmZXRjaFF1ZXJpZXMsIGF3YWl0UmVmZXRjaFF1ZXJpZXM6IGF3YWl0UmVmZXRjaFF1ZXJpZXMsXG4gICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZSwgY29udGV4dDogbXV0YXRpb25Db250ZXh0LCBmZXRjaFBvbGljeTogZmV0Y2hQb2xpY3ksIHZhcmlhYmxlczogbXV0YXRlVmFyaWFibGVzIH0sIG11dGF0ZU9wdGlvbnMpKTtcbiAgICB9O1xuICAgIE11dGF0aW9uRGF0YS5wcm90b3R5cGUub25NdXRhdGlvblN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVzdWx0LmxvYWRpbmcgJiYgIXRoaXMuZ2V0T3B0aW9ucygpLmlnbm9yZVJlc3VsdHMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNhbGxlZDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE11dGF0aW9uRGF0YS5wcm90b3R5cGUub25NdXRhdGlvbkNvbXBsZXRlZCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgbXV0YXRpb25JZCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldE9wdGlvbnMoKSwgb25Db21wbGV0ZWQgPSBfYS5vbkNvbXBsZXRlZCwgaWdub3JlUmVzdWx0cyA9IF9hLmlnbm9yZVJlc3VsdHM7XG4gICAgICAgIHZhciBkYXRhID0gcmVzcG9uc2UuZGF0YSwgZXJyb3JzID0gcmVzcG9uc2UuZXJyb3JzO1xuICAgICAgICB2YXIgZXJyb3IgPSBlcnJvcnMgJiYgZXJyb3JzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gbmV3IEFwb2xsb0Vycm9yKHsgZ3JhcGhRTEVycm9yczogZXJyb3JzIH0pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGNhbGxPbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9uQ29tcGxldGVkID8gb25Db21wbGV0ZWQoZGF0YSkgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5pc01vc3RSZWNlbnRNdXRhdGlvbihtdXRhdGlvbklkKSAmJiAhaWdub3JlUmVzdWx0cykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgIGNhbGxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbE9uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIE11dGF0aW9uRGF0YS5wcm90b3R5cGUub25NdXRhdGlvbkVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBtdXRhdGlvbklkKSB7XG4gICAgICAgIHZhciBvbkVycm9yID0gdGhpcy5nZXRPcHRpb25zKCkub25FcnJvcjtcbiAgICAgICAgaWYgKHRoaXMuaXNNb3N0UmVjZW50TXV0YXRpb24obXV0YXRpb25JZCkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNhbGxlZDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNdXRhdGlvbkRhdGEucHJvdG90eXBlLmdlbmVyYXRlTmV3TXV0YXRpb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICsrdGhpcy5tb3N0UmVjZW50TXV0YXRpb25JZDtcbiAgICB9O1xuICAgIE11dGF0aW9uRGF0YS5wcm90b3R5cGUuaXNNb3N0UmVjZW50TXV0YXRpb24gPSBmdW5jdGlvbiAobXV0YXRpb25JZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3N0UmVjZW50TXV0YXRpb25JZCA9PT0gbXV0YXRpb25JZDtcbiAgICB9O1xuICAgIE11dGF0aW9uRGF0YS5wcm90b3R5cGUudXBkYXRlUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQgJiZcbiAgICAgICAgICAgICghdGhpcy5wcmV2aW91c1Jlc3VsdCB8fCAhZXF1YWwodGhpcy5wcmV2aW91c1Jlc3VsdCwgcmVzdWx0KSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTXV0YXRpb25EYXRhO1xufShPcGVyYXRpb25EYXRhKSk7XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uKG11dGF0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KGdldEFwb2xsb0NvbnRleHQoKSk7XG4gICAgdmFyIF9hID0gdXNlU3RhdGUoeyBjYWxsZWQ6IGZhbHNlLCBsb2FkaW5nOiBmYWxzZSB9KSwgcmVzdWx0ID0gX2FbMF0sIHNldFJlc3VsdCA9IF9hWzFdO1xuICAgIHZhciB1cGRhdGVkT3B0aW9ucyA9IG9wdGlvbnMgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgbXV0YXRpb246IG11dGF0aW9uIH0pIDogeyBtdXRhdGlvbjogbXV0YXRpb24gfTtcbiAgICB2YXIgbXV0YXRpb25EYXRhUmVmID0gdXNlUmVmKCk7XG4gICAgZnVuY3Rpb24gZ2V0TXV0YXRpb25EYXRhUmVmKCkge1xuICAgICAgICBpZiAoIW11dGF0aW9uRGF0YVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBtdXRhdGlvbkRhdGFSZWYuY3VycmVudCA9IG5ldyBNdXRhdGlvbkRhdGEoe1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHVwZGF0ZWRPcHRpb25zLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgc2V0UmVzdWx0OiBzZXRSZXN1bHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtdXRhdGlvbkRhdGFSZWYuY3VycmVudDtcbiAgICB9XG4gICAgdmFyIG11dGF0aW9uRGF0YSA9IGdldE11dGF0aW9uRGF0YVJlZigpO1xuICAgIG11dGF0aW9uRGF0YS5zZXRPcHRpb25zKHVwZGF0ZWRPcHRpb25zKTtcbiAgICBtdXRhdGlvbkRhdGEuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG11dGF0aW9uRGF0YS5hZnRlckV4ZWN1dGUoKTsgfSk7XG4gICAgcmV0dXJuIG11dGF0aW9uRGF0YS5leGVjdXRlKHJlc3VsdCk7XG59XG5cbnZhciBTdWJzY3JpcHRpb25EYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3Vic2NyaXB0aW9uRGF0YSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb25EYXRhKF9hKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucywgY29udGV4dCA9IF9hLmNvbnRleHQsIHNldFJlc3VsdCA9IF9hLnNldFJlc3VsdDtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY3VycmVudE9ic2VydmFibGUgPSB7fTtcbiAgICAgICAgX3RoaXMuc2V0UmVzdWx0ID0gc2V0UmVzdWx0O1xuICAgICAgICBfdGhpcy5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN1YnNjcmlwdGlvbkRhdGEucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoKS5za2lwID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzOiB0aGlzLmdldE9wdGlvbnMoKS52YXJpYWJsZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hDbGllbnQoKS5pc05ldykge1xuICAgICAgICAgICAgY3VycmVudFJlc3VsdCA9IHRoaXMuZ2V0TG9hZGluZ1Jlc3VsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRSZXN1YnNjcmliZSA9IHRoaXMuZ2V0T3B0aW9ucygpLnNob3VsZFJlc3Vic2NyaWJlO1xuICAgICAgICBpZiAodHlwZW9mIHNob3VsZFJlc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzaG91bGRSZXN1YnNjcmliZSA9ICEhc2hvdWxkUmVzdWJzY3JpYmUodGhpcy5nZXRPcHRpb25zKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSZXN1YnNjcmliZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNPcHRpb25zICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnByZXZpb3VzT3B0aW9ucykubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgKHRoaXMucHJldmlvdXNPcHRpb25zLnN1YnNjcmlwdGlvbiAhPT0gdGhpcy5nZXRPcHRpb25zKCkuc3Vic2NyaXB0aW9uIHx8XG4gICAgICAgICAgICAgICAgIWVxdWFsKHRoaXMucHJldmlvdXNPcHRpb25zLnZhcmlhYmxlcywgdGhpcy5nZXRPcHRpb25zKCkudmFyaWFibGVzKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNPcHRpb25zLnNraXAgIT09IHRoaXMuZ2V0T3B0aW9ucygpLnNraXApKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgICAgIGN1cnJlbnRSZXN1bHQgPSB0aGlzLmdldExvYWRpbmdSZXN1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemUodGhpcy5nZXRPcHRpb25zKCkpO1xuICAgICAgICB0aGlzLnN0YXJ0U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMucHJldmlvdXNPcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY3VycmVudFJlc3VsdCksIHsgdmFyaWFibGVzOiB0aGlzLmdldE9wdGlvbnMoKS52YXJpYWJsZXMgfSk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EYXRhLnByb3RvdHlwZS5hZnRlckV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNNb3VudGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRhdGEucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5kU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRPYnNlcnZhYmxlLnF1ZXJ5O1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uRGF0YS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRPYnNlcnZhYmxlLnF1ZXJ5IHx8IHRoaXMuZ2V0T3B0aW9ucygpLnNraXAgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY3VycmVudE9ic2VydmFibGUucXVlcnkgPSB0aGlzLnJlZnJlc2hDbGllbnQoKS5jbGllbnQuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIHF1ZXJ5OiBvcHRpb25zLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICBmZXRjaFBvbGljeTogb3B0aW9ucy5mZXRjaFBvbGljeVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRhdGEucHJvdG90eXBlLnN0YXJ0U3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5zdWJzY3JpcHRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY3VycmVudE9ic2VydmFibGUuc3Vic2NyaXB0aW9uID0gdGhpcy5jdXJyZW50T2JzZXJ2YWJsZS5xdWVyeS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogdGhpcy51cGRhdGVDdXJyZW50RGF0YS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZXJyb3I6IHRoaXMudXBkYXRlRXJyb3IuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiB0aGlzLmNvbXBsZXRlU3Vic2NyaXB0aW9uLmJpbmQodGhpcylcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EYXRhLnByb3RvdHlwZS5nZXRMb2FkaW5nUmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRhdGEucHJvdG90eXBlLnVwZGF0ZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFJlc3VsdChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EYXRhLnByb3RvdHlwZS51cGRhdGVDdXJyZW50RGF0YSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgdmFyIG9uU3Vic2NyaXB0aW9uRGF0YSA9IHRoaXMuZ2V0T3B0aW9ucygpLm9uU3Vic2NyaXB0aW9uRGF0YTtcbiAgICAgICAgdGhpcy51cGRhdGVSZXN1bHQoe1xuICAgICAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvblN1YnNjcmlwdGlvbkRhdGEpIHtcbiAgICAgICAgICAgIG9uU3Vic2NyaXB0aW9uRGF0YSh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLnJlZnJlc2hDbGllbnQoKS5jbGllbnQsXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uRGF0YTogcmVzdWx0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uRGF0YS5wcm90b3R5cGUudXBkYXRlRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy51cGRhdGVSZXN1bHQoe1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgbG9hZGluZzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EYXRhLnByb3RvdHlwZS5jb21wbGV0ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9uU3Vic2NyaXB0aW9uQ29tcGxldGUgPSB0aGlzLmdldE9wdGlvbnMoKS5vblN1YnNjcmlwdGlvbkNvbXBsZXRlO1xuICAgICAgICBpZiAob25TdWJzY3JpcHRpb25Db21wbGV0ZSlcbiAgICAgICAgICAgIG9uU3Vic2NyaXB0aW9uQ29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5lbmRTdWJzY3JpcHRpb24oKTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRhdGEucHJvdG90eXBlLmVuZFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE9ic2VydmFibGUuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRPYnNlcnZhYmxlLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY3VycmVudE9ic2VydmFibGUuc3Vic2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uRGF0YTtcbn0oT3BlcmF0aW9uRGF0YSkpO1xuXG5mdW5jdGlvbiB1c2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KGdldEFwb2xsb0NvbnRleHQoKSk7XG4gICAgdmFyIHVwZGF0ZWRPcHRpb25zID0gb3B0aW9uc1xuICAgICAgICA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbiB9KSA6IHsgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24gfTtcbiAgICB2YXIgX2EgPSB1c2VTdGF0ZSh7XG4gICAgICAgIGxvYWRpbmc6ICF1cGRhdGVkT3B0aW9ucy5za2lwLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBkYXRhOiB1bmRlZmluZWRcbiAgICB9KSwgcmVzdWx0ID0gX2FbMF0sIHNldFJlc3VsdCA9IF9hWzFdO1xuICAgIHZhciBzdWJzY3JpcHRpb25EYXRhUmVmID0gdXNlUmVmKCk7XG4gICAgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uRGF0YVJlZigpIHtcbiAgICAgICAgaWYgKCFzdWJzY3JpcHRpb25EYXRhUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbkRhdGFSZWYuY3VycmVudCA9IG5ldyBTdWJzY3JpcHRpb25EYXRhKHtcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB1cGRhdGVkT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHNldFJlc3VsdDogc2V0UmVzdWx0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uRGF0YVJlZi5jdXJyZW50O1xuICAgIH1cbiAgICB2YXIgc3Vic2NyaXB0aW9uRGF0YSA9IGdldFN1YnNjcmlwdGlvbkRhdGFSZWYoKTtcbiAgICBzdWJzY3JpcHRpb25EYXRhLnNldE9wdGlvbnModXBkYXRlZE9wdGlvbnMsIHRydWUpO1xuICAgIHN1YnNjcmlwdGlvbkRhdGEuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmlwdGlvbkRhdGEuYWZ0ZXJFeGVjdXRlKCk7IH0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpcHRpb25EYXRhLmNsZWFudXAuYmluZChzdWJzY3JpcHRpb25EYXRhKTsgfSwgW10pO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb25EYXRhLmV4ZWN1dGUocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gdXNlQXBvbGxvQ2xpZW50KCkge1xuICAgIHZhciBjbGllbnQgPSBSZWFjdC51c2VDb250ZXh0KGdldEFwb2xsb0NvbnRleHQoKSkuY2xpZW50O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChjbGllbnQsIDEpIDogaW52YXJpYW50KGNsaWVudCwgJ05vIEFwb2xsbyBDbGllbnQgaW5zdGFuY2UgY2FuIGJlIGZvdW5kLiBQbGVhc2UgZW5zdXJlIHRoYXQgeW91ICcgK1xuICAgICAgICAnaGF2ZSBjYWxsZWQgYEFwb2xsb1Byb3ZpZGVyYCBoaWdoZXIgdXAgaW4geW91ciB0cmVlLicpO1xuICAgIHJldHVybiBjbGllbnQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VEZWZhdWx0UXVlcnlJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlZW46IGZhbHNlLFxuICAgICAgICBvYnNlcnZhYmxlOiBudWxsXG4gICAgfTtcbn1cbnZhciBSZW5kZXJQcm9taXNlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyUHJvbWlzZXMoKSB7XG4gICAgICAgIHRoaXMucXVlcnlQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5xdWVyeUluZm9UcmllID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBSZW5kZXJQcm9taXNlcy5wcm90b3R5cGUucmVnaXN0ZXJTU1JPYnNlcnZhYmxlID0gZnVuY3Rpb24gKG9ic2VydmFibGUsIHByb3BzKSB7XG4gICAgICAgIHRoaXMubG9va3VwUXVlcnlJbmZvKHByb3BzKS5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIFJlbmRlclByb21pc2VzLnByb3RvdHlwZS5nZXRTU1JPYnNlcnZhYmxlID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvb2t1cFF1ZXJ5SW5mbyhwcm9wcykub2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIFJlbmRlclByb21pc2VzLnByb3RvdHlwZS5hZGRRdWVyeVByb21pc2UgPSBmdW5jdGlvbiAocXVlcnlJbnN0YW5jZSwgZmluaXNoKSB7XG4gICAgICAgIHZhciBpbmZvID0gdGhpcy5sb29rdXBRdWVyeUluZm8ocXVlcnlJbnN0YW5jZS5nZXRPcHRpb25zKCkpO1xuICAgICAgICBpZiAoIWluZm8uc2Vlbikge1xuICAgICAgICAgICAgdGhpcy5xdWVyeVByb21pc2VzLnNldChxdWVyeUluc3RhbmNlLmdldE9wdGlvbnMoKSwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHF1ZXJ5SW5zdGFuY2UuZmV0Y2hEYXRhKCkpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgIH07XG4gICAgUmVuZGVyUHJvbWlzZXMucHJvdG90eXBlLmhhc1Byb21pc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVByb21pc2VzLnNpemUgPiAwO1xuICAgIH07XG4gICAgUmVuZGVyUHJvbWlzZXMucHJvdG90eXBlLmNvbnN1bWVBbmRBd2FpdFByb21pc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5xdWVyeVByb21pc2VzLmZvckVhY2goZnVuY3Rpb24gKHByb21pc2UsIHF1ZXJ5SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIF90aGlzLmxvb2t1cFF1ZXJ5SW5mbyhxdWVyeUluc3RhbmNlKS5zZWVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnF1ZXJ5UHJvbWlzZXMuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9O1xuICAgIFJlbmRlclByb21pc2VzLnByb3RvdHlwZS5sb29rdXBRdWVyeUluZm8gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgdmFyIHF1ZXJ5SW5mb1RyaWUgPSB0aGlzLnF1ZXJ5SW5mb1RyaWU7XG4gICAgICAgIHZhciBxdWVyeSA9IHByb3BzLnF1ZXJ5LCB2YXJpYWJsZXMgPSBwcm9wcy52YXJpYWJsZXM7XG4gICAgICAgIHZhciB2YXJNYXAgPSBxdWVyeUluZm9UcmllLmdldChxdWVyeSkgfHwgbmV3IE1hcCgpO1xuICAgICAgICBpZiAoIXF1ZXJ5SW5mb1RyaWUuaGFzKHF1ZXJ5KSlcbiAgICAgICAgICAgIHF1ZXJ5SW5mb1RyaWUuc2V0KHF1ZXJ5LCB2YXJNYXApO1xuICAgICAgICB2YXIgdmFyaWFibGVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkodmFyaWFibGVzKTtcbiAgICAgICAgdmFyIGluZm8gPSB2YXJNYXAuZ2V0KHZhcmlhYmxlc1N0cmluZykgfHwgbWFrZURlZmF1bHRRdWVyeUluZm8oKTtcbiAgICAgICAgaWYgKCF2YXJNYXAuaGFzKHZhcmlhYmxlc1N0cmluZykpXG4gICAgICAgICAgICB2YXJNYXAuc2V0KHZhcmlhYmxlc1N0cmluZywgaW5mbyk7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbmRlclByb21pc2VzO1xufSgpKTtcblxuZXhwb3J0IHsgUmVuZGVyUHJvbWlzZXMsIHVzZUFwb2xsb0NsaWVudCwgdXNlTGF6eVF1ZXJ5LCB1c2VNdXRhdGlvbiwgdXNlUXVlcnksIHVzZVN1YnNjcmlwdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtaG9va3MuZXNtLmpzLm1hcFxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFRvRG9MaXN0IGZyb20gXCIuL1RvRG9MaXN0LmpzeFwiO1xuLy8gaW1wb3J0ICcuL0FwcC5jc3MnO1xuaW1wb3J0IHsgdXNlUXVlcnksIHVzZU11dGF0aW9uIH0gZnJvbSBcIkBhcG9sbG8vcmVhY3QtaG9va3NcIjtcbmltcG9ydCBncWwgZnJvbSBcImdyYXBocWwtdGFnXCI7XG5cbmV4cG9ydCBjb25zdCBSRUFEX1RPRE9TID0gZ3FsYFxuICBxdWVyeSB0b2RvcyB7XG4gICAgdG9kb3Mge1xuICAgICAgaWRcbiAgICAgIG5hbWVcbiAgICAgIGNvbXBsZXRlZFxuICAgIH1cbiAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IENSRUFURV9UT0RPID0gZ3FsYFxuICBtdXRhdGlvbiBDcmVhdGVUb2RvKCRuYW1lOiBTdHJpbmchKSB7XG4gICAgY3JlYXRlVG9kbyhuYW1lOiAkbmFtZSkge1xuICAgICAgaWRcbiAgICAgIF9fdHlwZW5hbWVcbiAgICAgIG5hbWVcbiAgICAgIGNvbXBsZXRlZFxuICAgIH1cbiAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IFJFTU9WRV9UT0RPID0gZ3FsYFxuICBtdXRhdGlvbiBSZW1vdmVUb2RvKCRpZDogU3RyaW5nISkge1xuICAgIHJlbW92ZVRvZG8oaWQ6ICRpZClcbiAgfVxuYDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFpbigpIHtcbiAgY29uc3QgeyBkYXRhLCBsb2FkaW5nLCBlcnJvciwgcmVmZXRjaCB9ID0gdXNlUXVlcnkoUkVBRF9UT0RPUywge1xuICAgIG5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZTogdHJ1ZSxcbiAgfSk7XG4gIGNvbnN0IFtjcmVhdGVUb2RvXSA9IHVzZU11dGF0aW9uKENSRUFURV9UT0RPKTtcbiAgY29uc3QgW3JlbW92ZVRvZG9dID0gdXNlTXV0YXRpb24oUkVNT1ZFX1RPRE8pO1xuXG4gIGlmIChsb2FkaW5nKSByZXR1cm4gPHA+bG9hZGluZy4uLjwvcD47XG4gIGlmIChlcnJvcikgcmV0dXJuIDxwPkVSUk9SPC9wPjtcbiAgaWYgKCFkYXRhKSByZXR1cm4gPHA+Tm90IGZvdW5kPC9wPjtcblxuICByZXR1cm4gKFxuICAgIDxUb0RvTGlzdFxuICAgICAgZGF0YT17ZGF0YX1cbiAgICAgIHJlZmV0Y2g9e3JlZmV0Y2h9XG4gICAgICBjcmVhdGVUb2RvPXtjcmVhdGVUb2RvfVxuICAgICAgcmVtb3ZlVG9kbz17cmVtb3ZlVG9kb31cbiAgICAvPlxuICApO1xufVxuXG4vLyBDaGVjayB0aGF0IHNlcnZpY2Ugd29ya2VycyBhcmUgc3VwcG9ydGVkXG5pZiAoXCJzZXJ2aWNlV29ya2VyXCIgaW4gbmF2aWdhdG9yKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXJcbiAgICAgIC5yZWdpc3RlcihcIi9zdy5qc1wiKVxuICAgICAgLnRoZW4oKHJlZ2lzdHJhdGlvbikgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNXIHJlZ2lzdGVyZWQ6IFwiLCByZWdpc3RyYXRpb24pO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgocmVnaXN0cmF0aW9uRXJyb3IpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJTVyByZWdpc3RyYXRpb24gZmFpbGVkOiBcIiwgcmVnaXN0cmF0aW9uRXJyb3IpO1xuICAgICAgfSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgdmlzaXQgfSBmcm9tICcuL3Zpc2l0b3InO1xuaW1wb3J0IHsgcHJpbnRCbG9ja1N0cmluZyB9IGZyb20gJy4vYmxvY2tTdHJpbmcnO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBBU1QgaW50byBhIHN0cmluZywgdXNpbmcgb25lIHNldCBvZiByZWFzb25hYmxlXG4gKiBmb3JtYXR0aW5nIHJ1bGVzLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludChhc3QpIHtcbiAgcmV0dXJuIHZpc2l0KGFzdCwge1xuICAgIGxlYXZlOiBwcmludERvY0FTVFJlZHVjZXJcbiAgfSk7XG59IC8vIFRPRE86IHByb3ZpZGUgYmV0dGVyIHR5cGUgY292ZXJhZ2UgaW4gZnV0dXJlXG5cbnZhciBwcmludERvY0FTVFJlZHVjZXIgPSB7XG4gIE5hbWU6IGZ1bmN0aW9uIE5hbWUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9LFxuICBWYXJpYWJsZTogZnVuY3Rpb24gVmFyaWFibGUobm9kZSkge1xuICAgIHJldHVybiAnJCcgKyBub2RlLm5hbWU7XG4gIH0sXG4gIC8vIERvY3VtZW50XG4gIERvY3VtZW50OiBmdW5jdGlvbiBEb2N1bWVudChub2RlKSB7XG4gICAgcmV0dXJuIGpvaW4obm9kZS5kZWZpbml0aW9ucywgJ1xcblxcbicpICsgJ1xcbic7XG4gIH0sXG4gIE9wZXJhdGlvbkRlZmluaXRpb246IGZ1bmN0aW9uIE9wZXJhdGlvbkRlZmluaXRpb24obm9kZSkge1xuICAgIHZhciBvcCA9IG5vZGUub3BlcmF0aW9uO1xuICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICAgIHZhciB2YXJEZWZzID0gd3JhcCgnKCcsIGpvaW4obm9kZS52YXJpYWJsZURlZmluaXRpb25zLCAnLCAnKSwgJyknKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IGpvaW4obm9kZS5kaXJlY3RpdmVzLCAnICcpO1xuICAgIHZhciBzZWxlY3Rpb25TZXQgPSBub2RlLnNlbGVjdGlvblNldDsgLy8gQW5vbnltb3VzIHF1ZXJpZXMgd2l0aCBubyBkaXJlY3RpdmVzIG9yIHZhcmlhYmxlIGRlZmluaXRpb25zIGNhbiB1c2VcbiAgICAvLyB0aGUgcXVlcnkgc2hvcnQgZm9ybS5cblxuICAgIHJldHVybiAhbmFtZSAmJiAhZGlyZWN0aXZlcyAmJiAhdmFyRGVmcyAmJiBvcCA9PT0gJ3F1ZXJ5JyA/IHNlbGVjdGlvblNldCA6IGpvaW4oW29wLCBqb2luKFtuYW1lLCB2YXJEZWZzXSksIGRpcmVjdGl2ZXMsIHNlbGVjdGlvblNldF0sICcgJyk7XG4gIH0sXG4gIFZhcmlhYmxlRGVmaW5pdGlvbjogZnVuY3Rpb24gVmFyaWFibGVEZWZpbml0aW9uKF9yZWYpIHtcbiAgICB2YXIgdmFyaWFibGUgPSBfcmVmLnZhcmlhYmxlLFxuICAgICAgICB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBfcmVmLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYuZGlyZWN0aXZlcztcbiAgICByZXR1cm4gdmFyaWFibGUgKyAnOiAnICsgdHlwZSArIHdyYXAoJyA9ICcsIGRlZmF1bHRWYWx1ZSkgKyB3cmFwKCcgJywgam9pbihkaXJlY3RpdmVzLCAnICcpKTtcbiAgfSxcbiAgU2VsZWN0aW9uU2V0OiBmdW5jdGlvbiBTZWxlY3Rpb25TZXQoX3JlZjIpIHtcbiAgICB2YXIgc2VsZWN0aW9ucyA9IF9yZWYyLnNlbGVjdGlvbnM7XG4gICAgcmV0dXJuIGJsb2NrKHNlbGVjdGlvbnMpO1xuICB9LFxuICBGaWVsZDogZnVuY3Rpb24gRmllbGQoX3JlZjMpIHtcbiAgICB2YXIgYWxpYXMgPSBfcmVmMy5hbGlhcyxcbiAgICAgICAgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgIGFyZ3MgPSBfcmVmMy5hcmd1bWVudHMsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMy5kaXJlY3RpdmVzLFxuICAgICAgICBzZWxlY3Rpb25TZXQgPSBfcmVmMy5zZWxlY3Rpb25TZXQ7XG4gICAgcmV0dXJuIGpvaW4oW3dyYXAoJycsIGFsaWFzLCAnOiAnKSArIG5hbWUgKyB3cmFwKCcoJywgam9pbihhcmdzLCAnLCAnKSwgJyknKSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBzZWxlY3Rpb25TZXRdLCAnICcpO1xuICB9LFxuICBBcmd1bWVudDogZnVuY3Rpb24gQXJndW1lbnQoX3JlZjQpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWY0Lm5hbWUsXG4gICAgICAgIHZhbHVlID0gX3JlZjQudmFsdWU7XG4gICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgdmFsdWU7XG4gIH0sXG4gIC8vIEZyYWdtZW50c1xuICBGcmFnbWVudFNwcmVhZDogZnVuY3Rpb24gRnJhZ21lbnRTcHJlYWQoX3JlZjUpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWY1Lm5hbWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmNS5kaXJlY3RpdmVzO1xuICAgIHJldHVybiAnLi4uJyArIG5hbWUgKyB3cmFwKCcgJywgam9pbihkaXJlY3RpdmVzLCAnICcpKTtcbiAgfSxcbiAgSW5saW5lRnJhZ21lbnQ6IGZ1bmN0aW9uIElubGluZUZyYWdtZW50KF9yZWY2KSB7XG4gICAgdmFyIHR5cGVDb25kaXRpb24gPSBfcmVmNi50eXBlQ29uZGl0aW9uLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjYuZGlyZWN0aXZlcyxcbiAgICAgICAgc2VsZWN0aW9uU2V0ID0gX3JlZjYuc2VsZWN0aW9uU2V0O1xuICAgIHJldHVybiBqb2luKFsnLi4uJywgd3JhcCgnb24gJywgdHlwZUNvbmRpdGlvbiksIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgc2VsZWN0aW9uU2V0XSwgJyAnKTtcbiAgfSxcbiAgRnJhZ21lbnREZWZpbml0aW9uOiBmdW5jdGlvbiBGcmFnbWVudERlZmluaXRpb24oX3JlZjcpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWY3Lm5hbWUsXG4gICAgICAgIHR5cGVDb25kaXRpb24gPSBfcmVmNy50eXBlQ29uZGl0aW9uLFxuICAgICAgICB2YXJpYWJsZURlZmluaXRpb25zID0gX3JlZjcudmFyaWFibGVEZWZpbml0aW9ucyxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWY3LmRpcmVjdGl2ZXMsXG4gICAgICAgIHNlbGVjdGlvblNldCA9IF9yZWY3LnNlbGVjdGlvblNldDtcbiAgICByZXR1cm4gKC8vIE5vdGU6IGZyYWdtZW50IHZhcmlhYmxlIGRlZmluaXRpb25zIGFyZSBleHBlcmltZW50YWwgYW5kIG1heSBiZSBjaGFuZ2VkXG4gICAgICAvLyBvciByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAgICBcImZyYWdtZW50IFwiLmNvbmNhdChuYW1lKS5jb25jYXQod3JhcCgnKCcsIGpvaW4odmFyaWFibGVEZWZpbml0aW9ucywgJywgJyksICcpJyksIFwiIFwiKSArIFwib24gXCIuY29uY2F0KHR5cGVDb25kaXRpb24sIFwiIFwiKS5jb25jYXQod3JhcCgnJywgam9pbihkaXJlY3RpdmVzLCAnICcpLCAnICcpKSArIHNlbGVjdGlvblNldFxuICAgICk7XG4gIH0sXG4gIC8vIFZhbHVlXG4gIEludFZhbHVlOiBmdW5jdGlvbiBJbnRWYWx1ZShfcmVmOCkge1xuICAgIHZhciB2YWx1ZSA9IF9yZWY4LnZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgRmxvYXRWYWx1ZTogZnVuY3Rpb24gRmxvYXRWYWx1ZShfcmVmOSkge1xuICAgIHZhciB2YWx1ZSA9IF9yZWY5LnZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgU3RyaW5nVmFsdWU6IGZ1bmN0aW9uIFN0cmluZ1ZhbHVlKF9yZWYxMCwga2V5KSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZjEwLnZhbHVlLFxuICAgICAgICBpc0Jsb2NrU3RyaW5nID0gX3JlZjEwLmJsb2NrO1xuICAgIHJldHVybiBpc0Jsb2NrU3RyaW5nID8gcHJpbnRCbG9ja1N0cmluZyh2YWx1ZSwga2V5ID09PSAnZGVzY3JpcHRpb24nID8gJycgOiAnICAnKSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfSxcbiAgQm9vbGVhblZhbHVlOiBmdW5jdGlvbiBCb29sZWFuVmFsdWUoX3JlZjExKSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZjExLnZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0sXG4gIE51bGxWYWx1ZTogZnVuY3Rpb24gTnVsbFZhbHVlKCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH0sXG4gIEVudW1WYWx1ZTogZnVuY3Rpb24gRW51bVZhbHVlKF9yZWYxMikge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYxMi52YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIExpc3RWYWx1ZTogZnVuY3Rpb24gTGlzdFZhbHVlKF9yZWYxMykge1xuICAgIHZhciB2YWx1ZXMgPSBfcmVmMTMudmFsdWVzO1xuICAgIHJldHVybiAnWycgKyBqb2luKHZhbHVlcywgJywgJykgKyAnXSc7XG4gIH0sXG4gIE9iamVjdFZhbHVlOiBmdW5jdGlvbiBPYmplY3RWYWx1ZShfcmVmMTQpIHtcbiAgICB2YXIgZmllbGRzID0gX3JlZjE0LmZpZWxkcztcbiAgICByZXR1cm4gJ3snICsgam9pbihmaWVsZHMsICcsICcpICsgJ30nO1xuICB9LFxuICBPYmplY3RGaWVsZDogZnVuY3Rpb24gT2JqZWN0RmllbGQoX3JlZjE1KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMTUubmFtZSxcbiAgICAgICAgdmFsdWUgPSBfcmVmMTUudmFsdWU7XG4gICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgdmFsdWU7XG4gIH0sXG4gIC8vIERpcmVjdGl2ZVxuICBEaXJlY3RpdmU6IGZ1bmN0aW9uIERpcmVjdGl2ZShfcmVmMTYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYxNi5uYW1lLFxuICAgICAgICBhcmdzID0gX3JlZjE2LmFyZ3VtZW50cztcbiAgICByZXR1cm4gJ0AnICsgbmFtZSArIHdyYXAoJygnLCBqb2luKGFyZ3MsICcsICcpLCAnKScpO1xuICB9LFxuICAvLyBUeXBlXG4gIE5hbWVkVHlwZTogZnVuY3Rpb24gTmFtZWRUeXBlKF9yZWYxNykge1xuICAgIHZhciBuYW1lID0gX3JlZjE3Lm5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH0sXG4gIExpc3RUeXBlOiBmdW5jdGlvbiBMaXN0VHlwZShfcmVmMTgpIHtcbiAgICB2YXIgdHlwZSA9IF9yZWYxOC50eXBlO1xuICAgIHJldHVybiAnWycgKyB0eXBlICsgJ10nO1xuICB9LFxuICBOb25OdWxsVHlwZTogZnVuY3Rpb24gTm9uTnVsbFR5cGUoX3JlZjE5KSB7XG4gICAgdmFyIHR5cGUgPSBfcmVmMTkudHlwZTtcbiAgICByZXR1cm4gdHlwZSArICchJztcbiAgfSxcbiAgLy8gVHlwZSBTeXN0ZW0gRGVmaW5pdGlvbnNcbiAgU2NoZW1hRGVmaW5pdGlvbjogZnVuY3Rpb24gU2NoZW1hRGVmaW5pdGlvbihfcmVmMjApIHtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IF9yZWYyMC5kaXJlY3RpdmVzLFxuICAgICAgICBvcGVyYXRpb25UeXBlcyA9IF9yZWYyMC5vcGVyYXRpb25UeXBlcztcbiAgICByZXR1cm4gam9pbihbJ3NjaGVtYScsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2sob3BlcmF0aW9uVHlwZXMpXSwgJyAnKTtcbiAgfSxcbiAgT3BlcmF0aW9uVHlwZURlZmluaXRpb246IGZ1bmN0aW9uIE9wZXJhdGlvblR5cGVEZWZpbml0aW9uKF9yZWYyMSkge1xuICAgIHZhciBvcGVyYXRpb24gPSBfcmVmMjEub3BlcmF0aW9uLFxuICAgICAgICB0eXBlID0gX3JlZjIxLnR5cGU7XG4gICAgcmV0dXJuIG9wZXJhdGlvbiArICc6ICcgKyB0eXBlO1xuICB9LFxuICBTY2FsYXJUeXBlRGVmaW5pdGlvbjogYWRkRGVzY3JpcHRpb24oZnVuY3Rpb24gKF9yZWYyMikge1xuICAgIHZhciBuYW1lID0gX3JlZjIyLm5hbWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMjIuZGlyZWN0aXZlcztcbiAgICByZXR1cm4gam9pbihbJ3NjYWxhcicsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKV0sICcgJyk7XG4gIH0pLFxuICBPYmplY3RUeXBlRGVmaW5pdGlvbjogYWRkRGVzY3JpcHRpb24oZnVuY3Rpb24gKF9yZWYyMykge1xuICAgIHZhciBuYW1lID0gX3JlZjIzLm5hbWUsXG4gICAgICAgIGludGVyZmFjZXMgPSBfcmVmMjMuaW50ZXJmYWNlcyxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYyMy5kaXJlY3RpdmVzLFxuICAgICAgICBmaWVsZHMgPSBfcmVmMjMuZmllbGRzO1xuICAgIHJldHVybiBqb2luKFsndHlwZScsIG5hbWUsIHdyYXAoJ2ltcGxlbWVudHMgJywgam9pbihpbnRlcmZhY2VzLCAnICYgJykpLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKGZpZWxkcyldLCAnICcpO1xuICB9KSxcbiAgRmllbGREZWZpbml0aW9uOiBhZGREZXNjcmlwdGlvbihmdW5jdGlvbiAoX3JlZjI0KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjQubmFtZSxcbiAgICAgICAgYXJncyA9IF9yZWYyNC5hcmd1bWVudHMsXG4gICAgICAgIHR5cGUgPSBfcmVmMjQudHlwZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYyNC5kaXJlY3RpdmVzO1xuICAgIHJldHVybiBuYW1lICsgKGhhc011bHRpbGluZUl0ZW1zKGFyZ3MpID8gd3JhcCgnKFxcbicsIGluZGVudChqb2luKGFyZ3MsICdcXG4nKSksICdcXG4pJykgOiB3cmFwKCcoJywgam9pbihhcmdzLCAnLCAnKSwgJyknKSkgKyAnOiAnICsgdHlwZSArIHdyYXAoJyAnLCBqb2luKGRpcmVjdGl2ZXMsICcgJykpO1xuICB9KSxcbiAgSW5wdXRWYWx1ZURlZmluaXRpb246IGFkZERlc2NyaXB0aW9uKGZ1bmN0aW9uIChfcmVmMjUpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyNS5uYW1lLFxuICAgICAgICB0eXBlID0gX3JlZjI1LnR5cGUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IF9yZWYyNS5kZWZhdWx0VmFsdWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMjUuZGlyZWN0aXZlcztcbiAgICByZXR1cm4gam9pbihbbmFtZSArICc6ICcgKyB0eXBlLCB3cmFwKCc9ICcsIGRlZmF1bHRWYWx1ZSksIGpvaW4oZGlyZWN0aXZlcywgJyAnKV0sICcgJyk7XG4gIH0pLFxuICBJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbjogYWRkRGVzY3JpcHRpb24oZnVuY3Rpb24gKF9yZWYyNikge1xuICAgIHZhciBuYW1lID0gX3JlZjI2Lm5hbWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMjYuZGlyZWN0aXZlcyxcbiAgICAgICAgZmllbGRzID0gX3JlZjI2LmZpZWxkcztcbiAgICByZXR1cm4gam9pbihbJ2ludGVyZmFjZScsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2soZmllbGRzKV0sICcgJyk7XG4gIH0pLFxuICBVbmlvblR5cGVEZWZpbml0aW9uOiBhZGREZXNjcmlwdGlvbihmdW5jdGlvbiAoX3JlZjI3KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjcubmFtZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYyNy5kaXJlY3RpdmVzLFxuICAgICAgICB0eXBlcyA9IF9yZWYyNy50eXBlcztcbiAgICByZXR1cm4gam9pbihbJ3VuaW9uJywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCB0eXBlcyAmJiB0eXBlcy5sZW5ndGggIT09IDAgPyAnPSAnICsgam9pbih0eXBlcywgJyB8ICcpIDogJyddLCAnICcpO1xuICB9KSxcbiAgRW51bVR5cGVEZWZpbml0aW9uOiBhZGREZXNjcmlwdGlvbihmdW5jdGlvbiAoX3JlZjI4KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjgubmFtZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYyOC5kaXJlY3RpdmVzLFxuICAgICAgICB2YWx1ZXMgPSBfcmVmMjgudmFsdWVzO1xuICAgIHJldHVybiBqb2luKFsnZW51bScsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2sodmFsdWVzKV0sICcgJyk7XG4gIH0pLFxuICBFbnVtVmFsdWVEZWZpbml0aW9uOiBhZGREZXNjcmlwdGlvbihmdW5jdGlvbiAoX3JlZjI5KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjkubmFtZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYyOS5kaXJlY3RpdmVzO1xuICAgIHJldHVybiBqb2luKFtuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyldLCAnICcpO1xuICB9KSxcbiAgSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbjogYWRkRGVzY3JpcHRpb24oZnVuY3Rpb24gKF9yZWYzMCkge1xuICAgIHZhciBuYW1lID0gX3JlZjMwLm5hbWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMzAuZGlyZWN0aXZlcyxcbiAgICAgICAgZmllbGRzID0gX3JlZjMwLmZpZWxkcztcbiAgICByZXR1cm4gam9pbihbJ2lucHV0JywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayhmaWVsZHMpXSwgJyAnKTtcbiAgfSksXG4gIERpcmVjdGl2ZURlZmluaXRpb246IGFkZERlc2NyaXB0aW9uKGZ1bmN0aW9uIChfcmVmMzEpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYzMS5uYW1lLFxuICAgICAgICBhcmdzID0gX3JlZjMxLmFyZ3VtZW50cyxcbiAgICAgICAgcmVwZWF0YWJsZSA9IF9yZWYzMS5yZXBlYXRhYmxlLFxuICAgICAgICBsb2NhdGlvbnMgPSBfcmVmMzEubG9jYXRpb25zO1xuICAgIHJldHVybiAnZGlyZWN0aXZlIEAnICsgbmFtZSArIChoYXNNdWx0aWxpbmVJdGVtcyhhcmdzKSA/IHdyYXAoJyhcXG4nLCBpbmRlbnQoam9pbihhcmdzLCAnXFxuJykpLCAnXFxuKScpIDogd3JhcCgnKCcsIGpvaW4oYXJncywgJywgJyksICcpJykpICsgKHJlcGVhdGFibGUgPyAnIHJlcGVhdGFibGUnIDogJycpICsgJyBvbiAnICsgam9pbihsb2NhdGlvbnMsICcgfCAnKTtcbiAgfSksXG4gIFNjaGVtYUV4dGVuc2lvbjogZnVuY3Rpb24gU2NoZW1hRXh0ZW5zaW9uKF9yZWYzMikge1xuICAgIHZhciBkaXJlY3RpdmVzID0gX3JlZjMyLmRpcmVjdGl2ZXMsXG4gICAgICAgIG9wZXJhdGlvblR5cGVzID0gX3JlZjMyLm9wZXJhdGlvblR5cGVzO1xuICAgIHJldHVybiBqb2luKFsnZXh0ZW5kIHNjaGVtYScsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2sob3BlcmF0aW9uVHlwZXMpXSwgJyAnKTtcbiAgfSxcbiAgU2NhbGFyVHlwZUV4dGVuc2lvbjogZnVuY3Rpb24gU2NhbGFyVHlwZUV4dGVuc2lvbihfcmVmMzMpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYzMy5uYW1lLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjMzLmRpcmVjdGl2ZXM7XG4gICAgcmV0dXJuIGpvaW4oWydleHRlbmQgc2NhbGFyJywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpXSwgJyAnKTtcbiAgfSxcbiAgT2JqZWN0VHlwZUV4dGVuc2lvbjogZnVuY3Rpb24gT2JqZWN0VHlwZUV4dGVuc2lvbihfcmVmMzQpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYzNC5uYW1lLFxuICAgICAgICBpbnRlcmZhY2VzID0gX3JlZjM0LmludGVyZmFjZXMsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMzQuZGlyZWN0aXZlcyxcbiAgICAgICAgZmllbGRzID0gX3JlZjM0LmZpZWxkcztcbiAgICByZXR1cm4gam9pbihbJ2V4dGVuZCB0eXBlJywgbmFtZSwgd3JhcCgnaW1wbGVtZW50cyAnLCBqb2luKGludGVyZmFjZXMsICcgJiAnKSksIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2soZmllbGRzKV0sICcgJyk7XG4gIH0sXG4gIEludGVyZmFjZVR5cGVFeHRlbnNpb246IGZ1bmN0aW9uIEludGVyZmFjZVR5cGVFeHRlbnNpb24oX3JlZjM1KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMzUubmFtZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYzNS5kaXJlY3RpdmVzLFxuICAgICAgICBmaWVsZHMgPSBfcmVmMzUuZmllbGRzO1xuICAgIHJldHVybiBqb2luKFsnZXh0ZW5kIGludGVyZmFjZScsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2soZmllbGRzKV0sICcgJyk7XG4gIH0sXG4gIFVuaW9uVHlwZUV4dGVuc2lvbjogZnVuY3Rpb24gVW5pb25UeXBlRXh0ZW5zaW9uKF9yZWYzNikge1xuICAgIHZhciBuYW1lID0gX3JlZjM2Lm5hbWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMzYuZGlyZWN0aXZlcyxcbiAgICAgICAgdHlwZXMgPSBfcmVmMzYudHlwZXM7XG4gICAgcmV0dXJuIGpvaW4oWydleHRlbmQgdW5pb24nLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIHR5cGVzICYmIHR5cGVzLmxlbmd0aCAhPT0gMCA/ICc9ICcgKyBqb2luKHR5cGVzLCAnIHwgJykgOiAnJ10sICcgJyk7XG4gIH0sXG4gIEVudW1UeXBlRXh0ZW5zaW9uOiBmdW5jdGlvbiBFbnVtVHlwZUV4dGVuc2lvbihfcmVmMzcpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYzNy5uYW1lLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjM3LmRpcmVjdGl2ZXMsXG4gICAgICAgIHZhbHVlcyA9IF9yZWYzNy52YWx1ZXM7XG4gICAgcmV0dXJuIGpvaW4oWydleHRlbmQgZW51bScsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2sodmFsdWVzKV0sICcgJyk7XG4gIH0sXG4gIElucHV0T2JqZWN0VHlwZUV4dGVuc2lvbjogZnVuY3Rpb24gSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uKF9yZWYzOCkge1xuICAgIHZhciBuYW1lID0gX3JlZjM4Lm5hbWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMzguZGlyZWN0aXZlcyxcbiAgICAgICAgZmllbGRzID0gX3JlZjM4LmZpZWxkcztcbiAgICByZXR1cm4gam9pbihbJ2V4dGVuZCBpbnB1dCcsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2soZmllbGRzKV0sICcgJyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFkZERlc2NyaXB0aW9uKGNiKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBqb2luKFtub2RlLmRlc2NyaXB0aW9uLCBjYihub2RlKV0sICdcXG4nKTtcbiAgfTtcbn1cbi8qKlxuICogR2l2ZW4gbWF5YmVBcnJheSwgcHJpbnQgYW4gZW1wdHkgc3RyaW5nIGlmIGl0IGlzIG51bGwgb3IgZW1wdHksIG90aGVyd2lzZVxuICogcHJpbnQgYWxsIGl0ZW1zIHRvZ2V0aGVyIHNlcGFyYXRlZCBieSBzZXBhcmF0b3IgaWYgcHJvdmlkZWRcbiAqL1xuXG5cbmZ1bmN0aW9uIGpvaW4obWF5YmVBcnJheSwgc2VwYXJhdG9yKSB7XG4gIHJldHVybiBtYXliZUFycmF5ID8gbWF5YmVBcnJheS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfSkuam9pbihzZXBhcmF0b3IgfHwgJycpIDogJyc7XG59XG4vKipcbiAqIEdpdmVuIGFycmF5LCBwcmludCBlYWNoIGl0ZW0gb24gaXRzIG93biBsaW5lLCB3cmFwcGVkIGluIGFuXG4gKiBpbmRlbnRlZCBcInsgfVwiIGJsb2NrLlxuICovXG5cblxuZnVuY3Rpb24gYmxvY2soYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCAhPT0gMCA/ICd7XFxuJyArIGluZGVudChqb2luKGFycmF5LCAnXFxuJykpICsgJ1xcbn0nIDogJyc7XG59XG4vKipcbiAqIElmIG1heWJlU3RyaW5nIGlzIG5vdCBudWxsIG9yIGVtcHR5LCB0aGVuIHdyYXAgd2l0aCBzdGFydCBhbmQgZW5kLCBvdGhlcndpc2VcbiAqIHByaW50IGFuIGVtcHR5IHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdyYXAoc3RhcnQsIG1heWJlU3RyaW5nLCBlbmQpIHtcbiAgcmV0dXJuIG1heWJlU3RyaW5nID8gc3RhcnQgKyBtYXliZVN0cmluZyArIChlbmQgfHwgJycpIDogJyc7XG59XG5cbmZ1bmN0aW9uIGluZGVudChtYXliZVN0cmluZykge1xuICByZXR1cm4gbWF5YmVTdHJpbmcgJiYgJyAgJyArIG1heWJlU3RyaW5nLnJlcGxhY2UoL1xcbi9nLCAnXFxuICAnKTtcbn1cblxuZnVuY3Rpb24gaXNNdWx0aWxpbmUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuaW5kZXhPZignXFxuJykgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBoYXNNdWx0aWxpbmVJdGVtcyhtYXliZUFycmF5KSB7XG4gIHJldHVybiBtYXliZUFycmF5ICYmIG1heWJlQXJyYXkuc29tZShpc011bHRpbGluZSk7XG59XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IHByaW50IH0gZnJvbSAnZ3JhcGhxbC9sYW5ndWFnZS9wcmludGVyJztcbmltcG9ydCB7IEludmFyaWFudEVycm9yIH0gZnJvbSAndHMtaW52YXJpYW50JztcblxudmFyIGRlZmF1bHRIdHRwT3B0aW9ucyA9IHtcbiAgICBpbmNsdWRlUXVlcnk6IHRydWUsXG4gICAgaW5jbHVkZUV4dGVuc2lvbnM6IGZhbHNlLFxufTtcbnZhciBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICBhY2NlcHQ6ICcqLyonLFxuICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG59O1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxufTtcbnZhciBmYWxsYmFja0h0dHBDb25maWcgPSB7XG4gICAgaHR0cDogZGVmYXVsdEh0dHBPcHRpb25zLFxuICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzLFxuICAgIG9wdGlvbnM6IGRlZmF1bHRPcHRpb25zLFxufTtcbnZhciB0aHJvd1NlcnZlckVycm9yID0gZnVuY3Rpb24gKHJlc3BvbnNlLCByZXN1bHQsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IubmFtZSA9ICdTZXJ2ZXJFcnJvcic7XG4gICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICBlcnJvci5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIGVycm9yLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB0aHJvdyBlcnJvcjtcbn07XG52YXIgcGFyc2VBbmRDaGVja0h0dHBSZXNwb25zZSA9IGZ1bmN0aW9uIChvcGVyYXRpb25zKSB7IHJldHVybiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKHJlc3BvbnNlXG4gICAgICAgIC50ZXh0KClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJvZHlUZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShib2R5VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdmFyIHBhcnNlRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICBwYXJzZUVycm9yLm5hbWUgPSAnU2VydmVyUGFyc2VFcnJvcic7XG4gICAgICAgICAgICBwYXJzZUVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBwYXJzZUVycm9yLnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICBwYXJzZUVycm9yLmJvZHlUZXh0ID0gYm9keVRleHQ7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocGFyc2VFcnJvcik7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gMzAwKSB7XG4gICAgICAgICAgICB0aHJvd1NlcnZlckVycm9yKHJlc3BvbnNlLCByZXN1bHQsIFwiUmVzcG9uc2Ugbm90IHN1Y2Nlc3NmdWw6IFJlY2VpdmVkIHN0YXR1cyBjb2RlIFwiICsgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSAmJlxuICAgICAgICAgICAgIXJlc3VsdC5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpICYmXG4gICAgICAgICAgICAhcmVzdWx0Lmhhc093blByb3BlcnR5KCdlcnJvcnMnKSkge1xuICAgICAgICAgICAgdGhyb3dTZXJ2ZXJFcnJvcihyZXNwb25zZSwgcmVzdWx0LCBcIlNlcnZlciByZXNwb25zZSB3YXMgbWlzc2luZyBmb3IgcXVlcnkgJ1wiICsgKEFycmF5LmlzQXJyYXkob3BlcmF0aW9ucylcbiAgICAgICAgICAgICAgICA/IG9wZXJhdGlvbnMubWFwKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3Aub3BlcmF0aW9uTmFtZTsgfSlcbiAgICAgICAgICAgICAgICA6IG9wZXJhdGlvbnMub3BlcmF0aW9uTmFtZSkgKyBcIicuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkpO1xufTsgfTtcbnZhciBjaGVja0ZldGNoZXIgPSBmdW5jdGlvbiAoZmV0Y2hlcikge1xuICAgIGlmICghZmV0Y2hlciAmJiB0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBsaWJyYXJ5ID0gJ3VuZmV0Y2gnO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBsaWJyYXJ5ID0gJ25vZGUtZmV0Y2gnO1xuICAgICAgICB0aHJvdyBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoMSkgOiBuZXcgSW52YXJpYW50RXJyb3IoXCJcXG5mZXRjaCBpcyBub3QgZm91bmQgZ2xvYmFsbHkgYW5kIG5vIGZldGNoZXIgcGFzc2VkLCB0byBmaXggcGFzcyBhIGZldGNoIGZvclxcbnlvdXIgZW52aXJvbm1lbnQgbGlrZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9cIiArIGxpYnJhcnkgKyBcIi5cXG5cXG5Gb3IgZXhhbXBsZTpcXG5pbXBvcnQgZmV0Y2ggZnJvbSAnXCIgKyBsaWJyYXJ5ICsgXCInO1xcbmltcG9ydCB7IGNyZWF0ZUh0dHBMaW5rIH0gZnJvbSAnYXBvbGxvLWxpbmstaHR0cCc7XFxuXFxuY29uc3QgbGluayA9IGNyZWF0ZUh0dHBMaW5rKHsgdXJpOiAnL2dyYXBocWwnLCBmZXRjaDogZmV0Y2ggfSk7XCIpO1xuICAgIH1cbn07XG52YXIgY3JlYXRlU2lnbmFsSWZTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4geyBjb250cm9sbGVyOiBmYWxzZSwgc2lnbmFsOiBmYWxzZSB9O1xuICAgIHZhciBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHZhciBzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbDtcbiAgICByZXR1cm4geyBjb250cm9sbGVyOiBjb250cm9sbGVyLCBzaWduYWw6IHNpZ25hbCB9O1xufTtcbnZhciBzZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHkgPSBmdW5jdGlvbiAob3BlcmF0aW9uLCBmYWxsYmFja0NvbmZpZykge1xuICAgIHZhciBjb25maWdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgY29uZmlnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSBfX2Fzc2lnbih7fSwgZmFsbGJhY2tDb25maWcub3B0aW9ucywgeyBoZWFkZXJzOiBmYWxsYmFja0NvbmZpZy5oZWFkZXJzLCBjcmVkZW50aWFsczogZmFsbGJhY2tDb25maWcuY3JlZGVudGlhbHMgfSk7XG4gICAgdmFyIGh0dHAgPSBmYWxsYmFja0NvbmZpZy5odHRwO1xuICAgIGNvbmZpZ3MuZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIG9wdGlvbnMgPSBfX2Fzc2lnbih7fSwgb3B0aW9ucywgY29uZmlnLm9wdGlvbnMsIHsgaGVhZGVyczogX19hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywgY29uZmlnLmhlYWRlcnMpIH0pO1xuICAgICAgICBpZiAoY29uZmlnLmNyZWRlbnRpYWxzKVxuICAgICAgICAgICAgb3B0aW9ucy5jcmVkZW50aWFscyA9IGNvbmZpZy5jcmVkZW50aWFscztcbiAgICAgICAgaHR0cCA9IF9fYXNzaWduKHt9LCBodHRwLCBjb25maWcuaHR0cCk7XG4gICAgfSk7XG4gICAgdmFyIG9wZXJhdGlvbk5hbWUgPSBvcGVyYXRpb24ub3BlcmF0aW9uTmFtZSwgZXh0ZW5zaW9ucyA9IG9wZXJhdGlvbi5leHRlbnNpb25zLCB2YXJpYWJsZXMgPSBvcGVyYXRpb24udmFyaWFibGVzLCBxdWVyeSA9IG9wZXJhdGlvbi5xdWVyeTtcbiAgICB2YXIgYm9keSA9IHsgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uTmFtZSwgdmFyaWFibGVzOiB2YXJpYWJsZXMgfTtcbiAgICBpZiAoaHR0cC5pbmNsdWRlRXh0ZW5zaW9ucylcbiAgICAgICAgYm9keS5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICBpZiAoaHR0cC5pbmNsdWRlUXVlcnkpXG4gICAgICAgIGJvZHkucXVlcnkgPSBwcmludChxdWVyeSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgYm9keTogYm9keSxcbiAgICB9O1xufTtcbnZhciBzZXJpYWxpemVGZXRjaFBhcmFtZXRlciA9IGZ1bmN0aW9uIChwLCBsYWJlbCkge1xuICAgIHZhciBzZXJpYWxpemVkO1xuICAgIHRyeSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIHBhcnNlRXJyb3IgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoMikgOiBuZXcgSW52YXJpYW50RXJyb3IoXCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkLiBcIiArIGxhYmVsICsgXCIgaXMgbm90IHNlcmlhbGl6YWJsZTogXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICBwYXJzZUVycm9yLnBhcnNlRXJyb3IgPSBlO1xuICAgICAgICB0aHJvdyBwYXJzZUVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG52YXIgc2VsZWN0VVJJID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgZmFsbGJhY2tVUkkpIHtcbiAgICB2YXIgY29udGV4dCA9IG9wZXJhdGlvbi5nZXRDb250ZXh0KCk7XG4gICAgdmFyIGNvbnRleHRVUkkgPSBjb250ZXh0LnVyaTtcbiAgICBpZiAoY29udGV4dFVSSSkge1xuICAgICAgICByZXR1cm4gY29udGV4dFVSSTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZhbGxiYWNrVVJJID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1VSSShvcGVyYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrVVJJIHx8ICcvZ3JhcGhxbCc7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgY2hlY2tGZXRjaGVyLCBjcmVhdGVTaWduYWxJZlN1cHBvcnRlZCwgZmFsbGJhY2tIdHRwQ29uZmlnLCBwYXJzZUFuZENoZWNrSHR0cFJlc3BvbnNlLCBzZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHksIHNlbGVjdFVSSSwgc2VyaWFsaXplRmV0Y2hQYXJhbWV0ZXIsIHRocm93U2VydmVyRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBfX3Jlc3QsIF9fYXNzaWduLCBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBBcG9sbG9MaW5rLCBmcm9tRXJyb3IsIE9ic2VydmFibGUgfSBmcm9tICdhcG9sbG8tbGluayc7XG5pbXBvcnQgeyBjaGVja0ZldGNoZXIsIHNlbGVjdFVSSSwgc2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5LCBmYWxsYmFja0h0dHBDb25maWcsIGNyZWF0ZVNpZ25hbElmU3VwcG9ydGVkLCBzZXJpYWxpemVGZXRjaFBhcmFtZXRlciwgcGFyc2VBbmRDaGVja0h0dHBSZXNwb25zZSB9IGZyb20gJ2Fwb2xsby1saW5rLWh0dHAtY29tbW9uJztcblxudmFyIGNyZWF0ZUh0dHBMaW5rID0gZnVuY3Rpb24gKGxpbmtPcHRpb25zKSB7XG4gICAgaWYgKGxpbmtPcHRpb25zID09PSB2b2lkIDApIHsgbGlua09wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IGxpbmtPcHRpb25zLnVyaSwgdXJpID0gX2EgPT09IHZvaWQgMCA/ICcvZ3JhcGhxbCcgOiBfYSwgZmV0Y2hlciA9IGxpbmtPcHRpb25zLmZldGNoLCBpbmNsdWRlRXh0ZW5zaW9ucyA9IGxpbmtPcHRpb25zLmluY2x1ZGVFeHRlbnNpb25zLCB1c2VHRVRGb3JRdWVyaWVzID0gbGlua09wdGlvbnMudXNlR0VURm9yUXVlcmllcywgcmVxdWVzdE9wdGlvbnMgPSBfX3Jlc3QobGlua09wdGlvbnMsIFtcInVyaVwiLCBcImZldGNoXCIsIFwiaW5jbHVkZUV4dGVuc2lvbnNcIiwgXCJ1c2VHRVRGb3JRdWVyaWVzXCJdKTtcbiAgICBjaGVja0ZldGNoZXIoZmV0Y2hlcik7XG4gICAgaWYgKCFmZXRjaGVyKSB7XG4gICAgICAgIGZldGNoZXIgPSBmZXRjaDtcbiAgICB9XG4gICAgdmFyIGxpbmtDb25maWcgPSB7XG4gICAgICAgIGh0dHA6IHsgaW5jbHVkZUV4dGVuc2lvbnM6IGluY2x1ZGVFeHRlbnNpb25zIH0sXG4gICAgICAgIG9wdGlvbnM6IHJlcXVlc3RPcHRpb25zLmZldGNoT3B0aW9ucyxcbiAgICAgICAgY3JlZGVudGlhbHM6IHJlcXVlc3RPcHRpb25zLmNyZWRlbnRpYWxzLFxuICAgICAgICBoZWFkZXJzOiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLFxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgdmFyIGNob3NlblVSSSA9IHNlbGVjdFVSSShvcGVyYXRpb24sIHVyaSk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gb3BlcmF0aW9uLmdldENvbnRleHQoKTtcbiAgICAgICAgdmFyIGNsaWVudEF3YXJlbmVzc0hlYWRlcnMgPSB7fTtcbiAgICAgICAgaWYgKGNvbnRleHQuY2xpZW50QXdhcmVuZXNzKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBjb250ZXh0LmNsaWVudEF3YXJlbmVzcywgbmFtZV8xID0gX2EubmFtZSwgdmVyc2lvbiA9IF9hLnZlcnNpb247XG4gICAgICAgICAgICBpZiAobmFtZV8xKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50QXdhcmVuZXNzSGVhZGVyc1snYXBvbGxvZ3JhcGhxbC1jbGllbnQtbmFtZSddID0gbmFtZV8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBjbGllbnRBd2FyZW5lc3NIZWFkZXJzWydhcG9sbG9ncmFwaHFsLWNsaWVudC12ZXJzaW9uJ10gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZXh0SGVhZGVycyA9IF9fYXNzaWduKHt9LCBjbGllbnRBd2FyZW5lc3NIZWFkZXJzLCBjb250ZXh0LmhlYWRlcnMpO1xuICAgICAgICB2YXIgY29udGV4dENvbmZpZyA9IHtcbiAgICAgICAgICAgIGh0dHA6IGNvbnRleHQuaHR0cCxcbiAgICAgICAgICAgIG9wdGlvbnM6IGNvbnRleHQuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6IGNvbnRleHQuY3JlZGVudGlhbHMsXG4gICAgICAgICAgICBoZWFkZXJzOiBjb250ZXh0SGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9iID0gc2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5KG9wZXJhdGlvbiwgZmFsbGJhY2tIdHRwQ29uZmlnLCBsaW5rQ29uZmlnLCBjb250ZXh0Q29uZmlnKSwgb3B0aW9ucyA9IF9iLm9wdGlvbnMsIGJvZHkgPSBfYi5ib2R5O1xuICAgICAgICB2YXIgY29udHJvbGxlcjtcbiAgICAgICAgaWYgKCFvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgdmFyIF9jID0gY3JlYXRlU2lnbmFsSWZTdXBwb3J0ZWQoKSwgX2NvbnRyb2xsZXIgPSBfYy5jb250cm9sbGVyLCBzaWduYWwgPSBfYy5zaWduYWw7XG4gICAgICAgICAgICBjb250cm9sbGVyID0gX2NvbnRyb2xsZXI7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlcilcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmaW5pdGlvbklzTXV0YXRpb24gPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nICYmIGQub3BlcmF0aW9uID09PSAnbXV0YXRpb24nO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodXNlR0VURm9yUXVlcmllcyAmJlxuICAgICAgICAgICAgIW9wZXJhdGlvbi5xdWVyeS5kZWZpbml0aW9ucy5zb21lKGRlZmluaXRpb25Jc011dGF0aW9uKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnR0VUJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgICB2YXIgX2QgPSByZXdyaXRlVVJJRm9yR0VUKGNob3NlblVSSSwgYm9keSksIG5ld1VSSSA9IF9kLm5ld1VSSSwgcGFyc2VFcnJvciA9IF9kLnBhcnNlRXJyb3I7XG4gICAgICAgICAgICBpZiAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRXJyb3IocGFyc2VFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaG9zZW5VUkkgPSBuZXdVUkk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IHNlcmlhbGl6ZUZldGNoUGFyYW1ldGVyKGJvZHksICdQYXlsb2FkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRXJyb3IocGFyc2VFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgZmV0Y2hlcihjaG9zZW5VUkksIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnNldENvbnRleHQoeyByZXNwb25zZTogcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihwYXJzZUFuZENoZWNrSHR0cFJlc3BvbnNlKG9wZXJhdGlvbikpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLnJlc3VsdCAmJiBlcnIucmVzdWx0LmVycm9ycyAmJiBlcnIucmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChlcnIucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlcilcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gcmV3cml0ZVVSSUZvckdFVChjaG9zZW5VUkksIGJvZHkpIHtcbiAgICB2YXIgcXVlcnlQYXJhbXMgPSBbXTtcbiAgICB2YXIgYWRkUXVlcnlQYXJhbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLnB1c2goa2V5ICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICB9O1xuICAgIGlmICgncXVlcnknIGluIGJvZHkpIHtcbiAgICAgICAgYWRkUXVlcnlQYXJhbSgncXVlcnknLCBib2R5LnF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKGJvZHkub3BlcmF0aW9uTmFtZSkge1xuICAgICAgICBhZGRRdWVyeVBhcmFtKCdvcGVyYXRpb25OYW1lJywgYm9keS5vcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgaWYgKGJvZHkudmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkVmFyaWFibGVzID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VyaWFsaXplZFZhcmlhYmxlcyA9IHNlcmlhbGl6ZUZldGNoUGFyYW1ldGVyKGJvZHkudmFyaWFibGVzLCAnVmFyaWFibGVzIG1hcCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXJzZUVycm9yOiBwYXJzZUVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgYWRkUXVlcnlQYXJhbSgndmFyaWFibGVzJywgc2VyaWFsaXplZFZhcmlhYmxlcyk7XG4gICAgfVxuICAgIGlmIChib2R5LmV4dGVuc2lvbnMpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWRFeHRlbnNpb25zID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VyaWFsaXplZEV4dGVuc2lvbnMgPSBzZXJpYWxpemVGZXRjaFBhcmFtZXRlcihib2R5LmV4dGVuc2lvbnMsICdFeHRlbnNpb25zIG1hcCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXJzZUVycm9yOiBwYXJzZUVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgYWRkUXVlcnlQYXJhbSgnZXh0ZW5zaW9ucycsIHNlcmlhbGl6ZWRFeHRlbnNpb25zKTtcbiAgICB9XG4gICAgdmFyIGZyYWdtZW50ID0gJycsIHByZUZyYWdtZW50ID0gY2hvc2VuVVJJO1xuICAgIHZhciBmcmFnbWVudFN0YXJ0ID0gY2hvc2VuVVJJLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoZnJhZ21lbnRTdGFydCAhPT0gLTEpIHtcbiAgICAgICAgZnJhZ21lbnQgPSBjaG9zZW5VUkkuc3Vic3RyKGZyYWdtZW50U3RhcnQpO1xuICAgICAgICBwcmVGcmFnbWVudCA9IGNob3NlblVSSS5zdWJzdHIoMCwgZnJhZ21lbnRTdGFydCk7XG4gICAgfVxuICAgIHZhciBxdWVyeVBhcmFtc1ByZWZpeCA9IHByZUZyYWdtZW50LmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJic7XG4gICAgdmFyIG5ld1VSSSA9IHByZUZyYWdtZW50ICsgcXVlcnlQYXJhbXNQcmVmaXggKyBxdWVyeVBhcmFtcy5qb2luKCcmJykgKyBmcmFnbWVudDtcbiAgICByZXR1cm4geyBuZXdVUkk6IG5ld1VSSSB9O1xufVxudmFyIEh0dHBMaW5rID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSHR0cExpbmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHR0cExpbmsob3B0cykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY3JlYXRlSHR0cExpbmsob3B0cykucmVxdWVzdCkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEh0dHBMaW5rO1xufShBcG9sbG9MaW5rKSk7XG5cbmV4cG9ydCB7IEh0dHBMaW5rLCBjcmVhdGVIdHRwTGluayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVuZGxlLmVzbS5qcy5tYXBcbiIsImltcG9ydCB7IF9fZXh0ZW5kcywgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IE9ic2VydmFibGUsIEFwb2xsb0xpbmsgfSBmcm9tICdhcG9sbG8tbGluayc7XG5cbmZ1bmN0aW9uIGJ1aWxkRGVsYXlGdW5jdGlvbihkZWxheU9wdGlvbnMpIHtcbiAgICB2YXIgX2EgPSBkZWxheU9wdGlvbnMgfHwge30sIF9iID0gX2EuaW5pdGlhbCwgaW5pdGlhbCA9IF9iID09PSB2b2lkIDAgPyAzMDAgOiBfYiwgX2MgPSBfYS5qaXR0ZXIsIGppdHRlciA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gX2EubWF4LCBtYXggPSBfZCA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfZDtcbiAgICB2YXIgYmFzZURlbGF5ID0gaml0dGVyID8gaW5pdGlhbCA6IGluaXRpYWwgLyAyO1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKG1heCwgYmFzZURlbGF5ICogTWF0aC5wb3coMiwgY291bnQpKTtcbiAgICAgICAgaWYgKGppdHRlcikge1xuICAgICAgICAgICAgZGVsYXkgPSBNYXRoLnJhbmRvbSgpICogZGVsYXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbGF5O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmV0cnlGdW5jdGlvbihyZXRyeU9wdGlvbnMpIHtcbiAgICB2YXIgX2EgPSByZXRyeU9wdGlvbnMgfHwge30sIHJldHJ5SWYgPSBfYS5yZXRyeUlmLCBfYiA9IF9hLm1heCwgbWF4ID0gX2IgPT09IHZvaWQgMCA/IDUgOiBfYjtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmV0cnlGdW5jdGlvbihjb3VudCwgb3BlcmF0aW9uLCBlcnJvcikge1xuICAgICAgICBpZiAoY291bnQgPj0gbWF4KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gcmV0cnlJZiA/IHJldHJ5SWYoZXJyb3IsIG9wZXJhdGlvbikgOiAhIWVycm9yO1xuICAgIH07XG59XG5cbnZhciBSZXRyeWFibGVPcGVyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJldHJ5YWJsZU9wZXJhdGlvbihvcGVyYXRpb24sIG5leHRMaW5rLCBkZWxheUZvciwgcmV0cnlJZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgdGhpcy5uZXh0TGluayA9IG5leHRMaW5rO1xuICAgICAgICB0aGlzLmRlbGF5Rm9yID0gZGVsYXlGb3I7XG4gICAgICAgIHRoaXMucmV0cnlJZiA9IHJldHJ5SWY7XG4gICAgICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9uTmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgX3RoaXMudmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IF90aGlzLm9ic2VydmVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKCFvYnNlcnZlcilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Db21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5vYnNlcnZlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmICghb2JzZXJ2ZXIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNob3VsZFJldHJ5LCBfaSwgX2EsIG9ic2VydmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeUNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMucmV0cnlJZih0aGlzLnJldHJ5Q291bnQsIHRoaXMub3BlcmF0aW9uLCBlcnJvcildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRSZXRyeSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZXRyeSh0aGlzLmRlbGF5Rm9yKHRoaXMucmV0cnlDb3VudCwgdGhpcy5vcGVyYXRpb24sIGVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfYSA9IHRoaXMub2JzZXJ2ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2JzZXJ2ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9O1xuICAgIH1cbiAgICBSZXRyeWFibGVPcGVyYXRpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3Vic2NyaWJpbmcgdG8gYSByZXRyeWFibGUgbGluayB0aGF0IHdhcyBjYW5jZWxlZCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy52YWx1ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYVtfaV07XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmV0cnlhYmxlT3BlcmF0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLm9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmV0cnlMaW5rIEJVRyEgQXR0ZW1wdGluZyB0byB1bnN1YnNjcmliZSB1bmtub3duIG9ic2VydmVyIVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVyc1tpbmRleF0gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gPT09IG51bGw7IH0pKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXRyeWFibGVPcGVyYXRpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnRyeSgpO1xuICAgIH07XG4gICAgUmV0cnlhYmxlT3BlcmF0aW9uLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgICAgICB0aGlzLnRpbWVySWQgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFJldHJ5YWJsZU9wZXJhdGlvbi5wcm90b3R5cGUudHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLm5leHRMaW5rKHRoaXMub3BlcmF0aW9uKS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogdGhpcy5vbk5leHQsXG4gICAgICAgICAgICBlcnJvcjogdGhpcy5vbkVycm9yLFxuICAgICAgICAgICAgY29tcGxldGU6IHRoaXMub25Db21wbGV0ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXRyeWFibGVPcGVyYXRpb24ucHJvdG90eXBlLnNjaGVkdWxlUmV0cnkgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMudGltZXJJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmV0cnlMaW5rIEJVRyEgRW5jb3VudGVyZWQgb3ZlcmxhcHBpbmcgcmV0cmllc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnRpbWVySWQgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMudHJ5KCk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXRyeWFibGVPcGVyYXRpb247XG59KCkpO1xudmFyIFJldHJ5TGluayA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJldHJ5TGluaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXRyeUxpbmsob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgX2EgPSBvcHRpb25zIHx8IHt9LCBhdHRlbXB0cyA9IF9hLmF0dGVtcHRzLCBkZWxheSA9IF9hLmRlbGF5O1xuICAgICAgICBfdGhpcy5kZWxheUZvciA9XG4gICAgICAgICAgICB0eXBlb2YgZGVsYXkgPT09ICdmdW5jdGlvbicgPyBkZWxheSA6IGJ1aWxkRGVsYXlGdW5jdGlvbihkZWxheSk7XG4gICAgICAgIF90aGlzLnJldHJ5SWYgPVxuICAgICAgICAgICAgdHlwZW9mIGF0dGVtcHRzID09PSAnZnVuY3Rpb24nID8gYXR0ZW1wdHMgOiBidWlsZFJldHJ5RnVuY3Rpb24oYXR0ZW1wdHMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJldHJ5TGluay5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIG5leHRMaW5rKSB7XG4gICAgICAgIHZhciByZXRyeWFibGUgPSBuZXcgUmV0cnlhYmxlT3BlcmF0aW9uKG9wZXJhdGlvbiwgbmV4dExpbmssIHRoaXMuZGVsYXlGb3IsIHRoaXMucmV0cnlJZik7XG4gICAgICAgIHJldHJ5YWJsZS5zdGFydCgpO1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICByZXRyeWFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0cnlhYmxlLnVuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJldHJ5TGluaztcbn0oQXBvbGxvTGluaykpO1xuXG5leHBvcnQgeyBSZXRyeUxpbmsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBnZXRGcmFnbWVudFF1ZXJ5RG9jdW1lbnQgfSBmcm9tICdhcG9sbG8tdXRpbGl0aWVzJztcblxuZnVuY3Rpb24gcXVlcnlGcm9tUG9qbyhvYmopIHtcbiAgICB2YXIgb3AgPSB7XG4gICAgICAgIGtpbmQ6ICdPcGVyYXRpb25EZWZpbml0aW9uJyxcbiAgICAgICAgb3BlcmF0aW9uOiAncXVlcnknLFxuICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICBraW5kOiAnTmFtZScsXG4gICAgICAgICAgICB2YWx1ZTogJ0dlbmVyYXRlZENsaWVudFF1ZXJ5JyxcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0aW9uU2V0OiBzZWxlY3Rpb25TZXRGcm9tT2JqKG9iaiksXG4gICAgfTtcbiAgICB2YXIgb3V0ID0ge1xuICAgICAgICBraW5kOiAnRG9jdW1lbnQnLFxuICAgICAgICBkZWZpbml0aW9uczogW29wXSxcbiAgICB9O1xuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBmcmFnbWVudEZyb21Qb2pvKG9iaiwgdHlwZW5hbWUpIHtcbiAgICB2YXIgZnJhZyA9IHtcbiAgICAgICAga2luZDogJ0ZyYWdtZW50RGVmaW5pdGlvbicsXG4gICAgICAgIHR5cGVDb25kaXRpb246IHtcbiAgICAgICAgICAgIGtpbmQ6ICdOYW1lZFR5cGUnLFxuICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdOYW1lJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW5hbWUgfHwgJ19fRmFrZVR5cGUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgICAga2luZDogJ05hbWUnLFxuICAgICAgICAgICAgdmFsdWU6ICdHZW5lcmF0ZWRDbGllbnRRdWVyeScsXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGlvblNldDogc2VsZWN0aW9uU2V0RnJvbU9iaihvYmopLFxuICAgIH07XG4gICAgdmFyIG91dCA9IHtcbiAgICAgICAga2luZDogJ0RvY3VtZW50JyxcbiAgICAgICAgZGVmaW5pdGlvbnM6IFtmcmFnXSxcbiAgICB9O1xuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25TZXRGcm9tT2JqKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2Ygb2JqID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25TZXRGcm9tT2JqKG9ialswXSk7XG4gICAgfVxuICAgIHZhciBzZWxlY3Rpb25zID0gW107XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIG5lc3RlZFNlbFNldCA9IHNlbGVjdGlvblNldEZyb21PYmoob2JqW2tleV0pO1xuICAgICAgICB2YXIgZmllbGQgPSB7XG4gICAgICAgICAgICBraW5kOiAnRmllbGQnLFxuICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdOYW1lJyxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2V5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdGlvblNldDogbmVzdGVkU2VsU2V0IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZWN0aW9ucy5wdXNoKGZpZWxkKTtcbiAgICB9KTtcbiAgICB2YXIgc2VsZWN0aW9uU2V0ID0ge1xuICAgICAgICBraW5kOiAnU2VsZWN0aW9uU2V0JyxcbiAgICAgICAgc2VsZWN0aW9uczogc2VsZWN0aW9ucyxcbiAgICB9O1xuICAgIHJldHVybiBzZWxlY3Rpb25TZXQ7XG59XG52YXIganVzdFR5cGVuYW1lUXVlcnkgPSB7XG4gICAga2luZDogJ0RvY3VtZW50JyxcbiAgICBkZWZpbml0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBraW5kOiAnT3BlcmF0aW9uRGVmaW5pdGlvbicsXG4gICAgICAgICAgICBvcGVyYXRpb246ICdxdWVyeScsXG4gICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgdmFyaWFibGVEZWZpbml0aW9uczogbnVsbCxcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtdLFxuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiB7XG4gICAgICAgICAgICAgICAga2luZDogJ1NlbGVjdGlvblNldCcsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAnRmllbGQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogJ05hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnX190eXBlbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF0sXG59O1xuXG52YXIgQXBvbGxvQ2FjaGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwb2xsb0NhY2hlKCkge1xuICAgIH1cbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUudHJhbnNmb3JtRG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLnRyYW5zZm9ybUZvckxpbmsgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLnJlYWRRdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zLCBvcHRpbWlzdGljKSB7XG4gICAgICAgIGlmIChvcHRpbWlzdGljID09PSB2b2lkIDApIHsgb3B0aW1pc3RpYyA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWQoe1xuICAgICAgICAgICAgcXVlcnk6IG9wdGlvbnMucXVlcnksXG4gICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgb3B0aW1pc3RpYzogb3B0aW1pc3RpYyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUucmVhZEZyYWdtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGltaXN0aWMpIHtcbiAgICAgICAgaWYgKG9wdGltaXN0aWMgPT09IHZvaWQgMCkgeyBvcHRpbWlzdGljID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZCh7XG4gICAgICAgICAgICBxdWVyeTogZ2V0RnJhZ21lbnRRdWVyeURvY3VtZW50KG9wdGlvbnMuZnJhZ21lbnQsIG9wdGlvbnMuZnJhZ21lbnROYW1lKSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICByb290SWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljOiBvcHRpbWlzdGljLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS53cml0ZVF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy53cml0ZSh7XG4gICAgICAgICAgICBkYXRhSWQ6ICdST09UX1FVRVJZJyxcbiAgICAgICAgICAgIHJlc3VsdDogb3B0aW9ucy5kYXRhLFxuICAgICAgICAgICAgcXVlcnk6IG9wdGlvbnMucXVlcnksXG4gICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS53cml0ZUZyYWdtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy53cml0ZSh7XG4gICAgICAgICAgICBkYXRhSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICByZXN1bHQ6IG9wdGlvbnMuZGF0YSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICBxdWVyeTogZ2V0RnJhZ21lbnRRdWVyeURvY3VtZW50KG9wdGlvbnMuZnJhZ21lbnQsIG9wdGlvbnMuZnJhZ21lbnROYW1lKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUud3JpdGVEYXRhID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBpZCA9IF9hLmlkLCBkYXRhID0gX2EuZGF0YTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhciB0eXBlbmFtZVJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHR5cGVuYW1lUmVzdWx0ID0gdGhpcy5yZWFkKHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdElkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBqdXN0VHlwZW5hbWVRdWVyeSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX190eXBlbmFtZSA9ICh0eXBlbmFtZVJlc3VsdCAmJiB0eXBlbmFtZVJlc3VsdC5fX3R5cGVuYW1lKSB8fCAnX19DbGllbnREYXRhJztcbiAgICAgICAgICAgIHZhciBkYXRhVG9Xcml0ZSA9IE9iamVjdC5hc3NpZ24oeyBfX3R5cGVuYW1lOiBfX3R5cGVuYW1lIH0sIGRhdGEpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUZyYWdtZW50KHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQ6IGZyYWdtZW50RnJvbVBvam8oZGF0YVRvV3JpdGUsIF9fdHlwZW5hbWUpLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFUb1dyaXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlUXVlcnkoeyBxdWVyeTogcXVlcnlGcm9tUG9qbyhkYXRhKSwgZGF0YTogZGF0YSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFwb2xsb0NhY2hlO1xufSgpKTtcblxudmFyIENhY2hlO1xuKGZ1bmN0aW9uIChDYWNoZSkge1xufSkoQ2FjaGUgfHwgKENhY2hlID0ge30pKTtcblxuZXhwb3J0IHsgQXBvbGxvQ2FjaGUsIENhY2hlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUuZXNtLmpzLm1hcFxuIiwiLy8gVGhpcyBjdXJyZW50Q29udGV4dCB2YXJpYWJsZSB3aWxsIG9ubHkgYmUgdXNlZCBpZiB0aGUgbWFrZVNsb3RDbGFzc1xyXG4vLyBmdW5jdGlvbiBpcyBjYWxsZWQsIHdoaWNoIGhhcHBlbnMgb25seSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBjb3B5IG9mIHRoZVxyXG4vLyBAd3J5L2NvbnRleHQgcGFja2FnZSB0byBiZSBpbXBvcnRlZC5cclxudmFyIGN1cnJlbnRDb250ZXh0ID0gbnVsbDtcclxuLy8gVGhpcyB1bmlxdWUgaW50ZXJuYWwgb2JqZWN0IGlzIHVzZWQgdG8gZGVub3RlIHRoZSBhYnNlbmNlIG9mIGEgdmFsdWVcclxuLy8gZm9yIGEgZ2l2ZW4gU2xvdCwgYW5kIGlzIG5ldmVyIGV4cG9zZWQgdG8gb3V0c2lkZSBjb2RlLlxyXG52YXIgTUlTU0lOR19WQUxVRSA9IHt9O1xyXG52YXIgaWRDb3VudGVyID0gMTtcclxuLy8gQWx0aG91Z2ggd2UgY2FuJ3QgZG8gYW55dGhpbmcgYWJvdXQgdGhlIGNvc3Qgb2YgZHVwbGljYXRlZCBjb2RlIGZyb21cclxuLy8gYWNjaWRlbnRhbGx5IGJ1bmRsaW5nIG11bHRpcGxlIGNvcGllcyBvZiB0aGUgQHdyeS9jb250ZXh0IHBhY2thZ2UsIHdlIGNhblxyXG4vLyBhdm9pZCBjcmVhdGluZyB0aGUgU2xvdCBjbGFzcyBtb3JlIHRoYW4gb25jZSB1c2luZyBtYWtlU2xvdENsYXNzLlxyXG52YXIgbWFrZVNsb3RDbGFzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNsb3QoKSB7XHJcbiAgICAgICAgLy8gSWYgeW91IGhhdmUgYSBTbG90IG9iamVjdCwgeW91IGNhbiBmaW5kIG91dCBpdHMgc2xvdC5pZCwgYnV0IHlvdSBjYW5ub3RcclxuICAgICAgICAvLyBndWVzcyB0aGUgc2xvdC5pZCBvZiBhIFNsb3QgeW91IGRvbid0IGhhdmUgYWNjZXNzIHRvLCB0aGFua3MgdG8gdGhlXHJcbiAgICAgICAgLy8gcmFuZG9taXplZCBzdWZmaXguXHJcbiAgICAgICAgdGhpcy5pZCA9IFtcclxuICAgICAgICAgICAgXCJzbG90XCIsXHJcbiAgICAgICAgICAgIGlkQ291bnRlcisrLFxyXG4gICAgICAgICAgICBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxcclxuICAgICAgICBdLmpvaW4oXCI6XCIpO1xyXG4gICAgfVxyXG4gICAgU2xvdC5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgY29udGV4dF8xID0gY3VycmVudENvbnRleHQ7IGNvbnRleHRfMTsgY29udGV4dF8xID0gY29udGV4dF8xLnBhcmVudCkge1xyXG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIFNsb3Qgb2JqZWN0IGlzZWxmIGFzIGEga2V5IHRvIGl0cyB2YWx1ZSwgd2hpY2ggbWVhbnMgdGhlXHJcbiAgICAgICAgICAgIC8vIHZhbHVlIGNhbm5vdCBiZSBvYnRhaW5lZCB3aXRob3V0IGEgcmVmZXJlbmNlIHRvIHRoZSBTbG90IG9iamVjdC5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaWQgaW4gY29udGV4dF8xLnNsb3RzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250ZXh0XzEuc2xvdHNbdGhpcy5pZF07XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IE1JU1NJTkdfVkFMVUUpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dF8xICE9PSBjdXJyZW50Q29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSB2YWx1ZSBpbiBjdXJyZW50Q29udGV4dC5zbG90cyBzbyB0aGUgbmV4dCBsb29rdXAgd2lsbFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIGZhc3Rlci4gVGhpcyBjYWNoaW5nIGlzIHNhZmUgYmVjYXVzZSB0aGUgdHJlZSBvZiBjb250ZXh0cyBhbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdmFsdWVzIG9mIHRoZSBzbG90cyBhcmUgbG9naWNhbGx5IGltbXV0YWJsZS5cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dC5zbG90c1t0aGlzLmlkXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnRDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIElmIGEgdmFsdWUgd2FzIG5vdCBmb3VuZCBmb3IgdGhpcyBTbG90LCBpdCdzIG5ldmVyIGdvaW5nIHRvIGJlIGZvdW5kXHJcbiAgICAgICAgICAgIC8vIG5vIG1hdHRlciBob3cgbWFueSB0aW1lcyB3ZSBsb29rIGl0IHVwLCBzbyB3ZSBtaWdodCBhcyB3ZWxsIGNhY2hlXHJcbiAgICAgICAgICAgIC8vIHRoZSBhYnNlbmNlIG9mIHRoZSB2YWx1ZSwgdG9vLlxyXG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dC5zbG90c1t0aGlzLmlkXSA9IE1JU1NJTkdfVkFMVUU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBTbG90LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q29udGV4dC5zbG90c1t0aGlzLmlkXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU2xvdC5wcm90b3R5cGUud2l0aFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBjYWxsYmFjaywgXHJcbiAgICAvLyBHaXZlbiB0aGUgcHJldmFsZW5jZSBvZiBhcnJvdyBmdW5jdGlvbnMsIHNwZWNpZnlpbmcgYXJndW1lbnRzIGlzIGxpa2VseVxyXG4gICAgLy8gdG8gYmUgbXVjaCBtb3JlIGNvbW1vbiB0aGFuIHNwZWNpZnlpbmcgYHRoaXNgLCBoZW5jZSB0aGlzIG9yZGVyaW5nOlxyXG4gICAgYXJncywgdGhpc0FyZykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgc2xvdHMgPSAoX2EgPSB7XHJcbiAgICAgICAgICAgICAgICBfX3Byb3RvX186IG51bGxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX2FbdGhpcy5pZF0gPSB2YWx1ZSxcclxuICAgICAgICAgICAgX2EpO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSBjdXJyZW50Q29udGV4dDtcclxuICAgICAgICBjdXJyZW50Q29udGV4dCA9IHsgcGFyZW50OiBwYXJlbnQsIHNsb3RzOiBzbG90cyB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSBhbGxvd3MgdGhlIGFyZ3VtZW50cyBhcnJheSBhcmd1bWVudCB0byBiZVxyXG4gICAgICAgICAgICAvLyBvbWl0dGVkIG9yIHVuZGVmaW5lZCwgc28gYXJncyEgaXMgZmluZSBoZXJlLlxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc0FyZywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IHBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FwdHVyZSB0aGUgY3VycmVudCBjb250ZXh0IGFuZCB3cmFwIGEgY2FsbGJhY2sgZnVuY3Rpb24gc28gdGhhdCBpdFxyXG4gICAgLy8gcmVlc3RhYmxpc2hlcyB0aGUgY2FwdHVyZWQgY29udGV4dCB3aGVuIGNhbGxlZC5cclxuICAgIFNsb3QuYmluZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gY3VycmVudENvbnRleHQ7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNhdmVkID0gY3VycmVudENvbnRleHQ7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gc2F2ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIEltbWVkaWF0ZWx5IHJ1biBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGhvdXQgYW55IGNhcHR1cmVkIGNvbnRleHQuXHJcbiAgICBTbG90Lm5vQ29udGV4dCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgXHJcbiAgICAvLyBHaXZlbiB0aGUgcHJldmFsZW5jZSBvZiBhcnJvdyBmdW5jdGlvbnMsIHNwZWNpZnlpbmcgYXJndW1lbnRzIGlzIGxpa2VseVxyXG4gICAgLy8gdG8gYmUgbXVjaCBtb3JlIGNvbW1vbiB0aGFuIHNwZWNpZnlpbmcgYHRoaXNgLCBoZW5jZSB0aGlzIG9yZGVyaW5nOlxyXG4gICAgYXJncywgdGhpc0FyZykge1xyXG4gICAgICAgIGlmIChjdXJyZW50Q29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgc2F2ZWQgPSBjdXJyZW50Q29udGV4dDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSBhbGxvd3MgdGhlIGFyZ3VtZW50cyBhcnJheSBhcmd1bWVudCB0byBiZVxyXG4gICAgICAgICAgICAgICAgLy8gb21pdHRlZCBvciB1bmRlZmluZWQsIHNvIGFyZ3MhIGlzIGZpbmUgaGVyZS5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gc2F2ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNsb3Q7XHJcbn0oKSk7IH07XHJcbi8vIFdlIHN0b3JlIGEgc2luZ2xlIGdsb2JhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2xvdCBjbGFzcyBhcyBhIHBlcm1hbmVudFxyXG4vLyBub24tZW51bWVyYWJsZSBzeW1ib2wgcHJvcGVydHkgb2YgdGhlIEFycmF5IGNvbnN0cnVjdG9yLiBUaGlzIG9iZnVzY2F0aW9uXHJcbi8vIGRvZXMgbm90aGluZyB0byBwcmV2ZW50IGFjY2VzcyB0byB0aGUgU2xvdCBjbGFzcywgYnV0IGF0IGxlYXN0IGl0IGVuc3VyZXNcclxuLy8gdGhlIGltcGxlbWVudGF0aW9uIChpLmUuIGN1cnJlbnRDb250ZXh0KSBjYW5ub3QgYmUgdGFtcGVyZWQgd2l0aCwgYW5kIGFsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIEB3cnkvY29udGV4dCBwYWNrYWdlIChob3BlZnVsbHkganVzdCBvbmUpIHdpbGwgc2hhcmUgdGhlXHJcbi8vIHNhbWUgU2xvdCBpbXBsZW1lbnRhdGlvbi4gU2luY2UgdGhlIGZpcnN0IGNvcHkgb2YgdGhlIEB3cnkvY29udGV4dCBwYWNrYWdlXHJcbi8vIHRvIGJlIGltcG9ydGVkIHdpbnMsIHRoaXMgdGVjaG5pcXVlIGltcG9zZXMgYSB2ZXJ5IGhpZ2ggY29zdCBmb3IgYW55XHJcbi8vIGZ1dHVyZSBicmVha2luZyBjaGFuZ2VzIHRvIHRoZSBTbG90IGNsYXNzLlxyXG52YXIgZ2xvYmFsS2V5ID0gXCJAd3J5L2NvbnRleHQ6U2xvdFwiO1xyXG52YXIgaG9zdCA9IEFycmF5O1xyXG52YXIgU2xvdCA9IGhvc3RbZ2xvYmFsS2V5XSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgU2xvdCA9IG1ha2VTbG90Q2xhc3MoKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3QsIGdsb2JhbEtleSwge1xyXG4gICAgICAgICAgICB2YWx1ZTogaG9zdFtnbG9iYWxLZXldID0gU2xvdCxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHJldHVybiBTbG90O1xyXG4gICAgfVxyXG59KCk7XG5cbnZhciBiaW5kID0gU2xvdC5iaW5kLCBub0NvbnRleHQgPSBTbG90Lm5vQ29udGV4dDtcclxuZnVuY3Rpb24gc2V0VGltZW91dFdpdGhDb250ZXh0KGNhbGxiYWNrLCBkZWxheSkge1xyXG4gICAgcmV0dXJuIHNldFRpbWVvdXQoYmluZChjYWxsYmFjayksIGRlbGF5KTtcclxufVxyXG4vLyBUdXJuIGFueSBnZW5lcmF0b3IgZnVuY3Rpb24gaW50byBhbiBhc3luYyBmdW5jdGlvbiAodXNpbmcgeWllbGQgaW5zdGVhZFxyXG4vLyBvZiBhd2FpdCksIHdpdGggY29udGV4dCBhdXRvbWF0aWNhbGx5IHByZXNlcnZlZCBhY3Jvc3MgeWllbGRzLlxyXG5mdW5jdGlvbiBhc3luY0Zyb21HZW4oZ2VuRm4pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdlbiA9IGdlbkZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdmFyIGJvdW5kTmV4dCA9IGJpbmQoZ2VuLm5leHQpO1xyXG4gICAgICAgIHZhciBib3VuZFRocm93ID0gYmluZChnZW4udGhyb3cpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBtZXRob2QuY2FsbChnZW4sIGFyZ3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSByZXN1bHQuZG9uZSA/IHJlc29sdmUgOiBpbnZva2VOZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UocmVzdWx0LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZS50aGVuKG5leHQsIHJlc3VsdC5kb25lID8gcmVqZWN0IDogaW52b2tlVGhyb3cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dChyZXN1bHQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbnZva2VOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpbnZva2UoYm91bmROZXh0LCB2YWx1ZSk7IH07XHJcbiAgICAgICAgICAgIHZhciBpbnZva2VUaHJvdyA9IGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gaW52b2tlKGJvdW5kVGhyb3csIGVycm9yKTsgfTtcclxuICAgICAgICAgICAgaW52b2tlTmV4dCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1Byb21pc2VMaWtlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG4vLyBJZiB5b3UgdXNlIHRoZSBmaWJlcnMgbnBtIHBhY2thZ2UgdG8gaW1wbGVtZW50IGNvcm91dGluZXMgaW4gTm9kZS5qcyxcclxuLy8geW91IHNob3VsZCBjYWxsIHRoaXMgZnVuY3Rpb24gYXQgbGVhc3Qgb25jZSB0byBlbnN1cmUgY29udGV4dCBtYW5hZ2VtZW50XHJcbi8vIHJlbWFpbnMgY29oZXJlbnQgYWNyb3NzIGFueSB5aWVsZHMuXHJcbnZhciB3cmFwcGVkRmliZXJzID0gW107XHJcbmZ1bmN0aW9uIHdyYXBZaWVsZGluZ0ZpYmVyTWV0aG9kcyhGaWJlcikge1xyXG4gICAgLy8gVGhlcmUgY2FuIGJlIG9ubHkgb25lIGltcGxlbWVudGF0aW9uIG9mIEZpYmVyIHBlciBwcm9jZXNzLCBzbyB0aGlzIGFycmF5XHJcbiAgICAvLyBzaG91bGQgbmV2ZXIgZ3JvdyBsb25nZXIgdGhhbiBvbmUgZWxlbWVudC5cclxuICAgIGlmICh3cmFwcGVkRmliZXJzLmluZGV4T2YoRmliZXIpIDwgMCkge1xyXG4gICAgICAgIHZhciB3cmFwID0gZnVuY3Rpb24gKG9iaiwgbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHZhciBmbiA9IG9ialttZXRob2RdO1xyXG4gICAgICAgICAgICBvYmpbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub0NvbnRleHQoZm4sIGFyZ3VtZW50cywgdGhpcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUaGVzZSBtZXRob2RzIGNhbiB5aWVsZCwgYWNjb3JkaW5nIHRvXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xhdmVyZGV0L25vZGUtZmliZXJzL2Jsb2IvZGRlYmVkOWI4YWUzODgzZTU3ZjgyMmUyMTA4ZTY5NDNlNWM4ZDJhOC9maWJlcnMuanMjTDk3LUwxMDBcclxuICAgICAgICB3cmFwKEZpYmVyLCBcInlpZWxkXCIpO1xyXG4gICAgICAgIHdyYXAoRmliZXIucHJvdG90eXBlLCBcInJ1blwiKTtcclxuICAgICAgICB3cmFwKEZpYmVyLnByb3RvdHlwZSwgXCJ0aHJvd0ludG9cIik7XHJcbiAgICAgICAgd3JhcHBlZEZpYmVycy5wdXNoKEZpYmVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBGaWJlcjtcclxufVxuXG5leHBvcnQgeyBTbG90LCBhc3luY0Zyb21HZW4sIGJpbmQsIG5vQ29udGV4dCwgc2V0VGltZW91dFdpdGhDb250ZXh0IGFzIHNldFRpbWVvdXQsIHdyYXBZaWVsZGluZ0ZpYmVyTWV0aG9kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dC5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBTbG90IH0gZnJvbSAnQHdyeS9jb250ZXh0JztcbmV4cG9ydCB7IGFzeW5jRnJvbUdlbiwgYmluZCBhcyBiaW5kQ29udGV4dCwgbm9Db250ZXh0LCBzZXRUaW1lb3V0IH0gZnJvbSAnQHdyeS9jb250ZXh0JztcblxuZnVuY3Rpb24gZGVmYXVsdERpc3Bvc2UoKSB7IH1cclxudmFyIENhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FjaGUobWF4LCBkaXNwb3NlKSB7XHJcbiAgICAgICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IEluZmluaXR5OyB9XHJcbiAgICAgICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkgeyBkaXNwb3NlID0gZGVmYXVsdERpc3Bvc2U7IH1cclxuICAgICAgICB0aGlzLm1heCA9IG1heDtcclxuICAgICAgICB0aGlzLmRpc3Bvc2UgPSBkaXNwb3NlO1xyXG4gICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMubmV3ZXN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9sZGVzdCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXMoa2V5KTtcclxuICAgIH07XHJcbiAgICBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZ2V0RW50cnkoa2V5KTtcclxuICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgQ2FjaGUucHJvdG90eXBlLmdldEVudHJ5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMubWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeSAhPT0gdGhpcy5uZXdlc3QpIHtcclxuICAgICAgICAgICAgdmFyIG9sZGVyID0gZW50cnkub2xkZXIsIG5ld2VyID0gZW50cnkubmV3ZXI7XHJcbiAgICAgICAgICAgIGlmIChuZXdlcikge1xyXG4gICAgICAgICAgICAgICAgbmV3ZXIub2xkZXIgPSBvbGRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2xkZXIpIHtcclxuICAgICAgICAgICAgICAgIG9sZGVyLm5ld2VyID0gbmV3ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW50cnkub2xkZXIgPSB0aGlzLm5ld2VzdDtcclxuICAgICAgICAgICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeTtcclxuICAgICAgICAgICAgZW50cnkubmV3ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm5ld2VzdCA9IGVudHJ5O1xyXG4gICAgICAgICAgICBpZiAoZW50cnkgPT09IHRoaXMub2xkZXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9sZGVzdCA9IG5ld2VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgIH07XHJcbiAgICBDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmdldEVudHJ5KGtleSk7XHJcbiAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbnRyeSA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgbmV3ZXI6IG51bGwsXHJcbiAgICAgICAgICAgIG9sZGVyOiB0aGlzLm5ld2VzdFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMubmV3ZXN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV3ZXN0Lm5ld2VyID0gZW50cnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubmV3ZXN0ID0gZW50cnk7XHJcbiAgICAgICAgdGhpcy5vbGRlc3QgPSB0aGlzLm9sZGVzdCB8fCBlbnRyeTtcclxuICAgICAgICB0aGlzLm1hcC5zZXQoa2V5LCBlbnRyeSk7XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xyXG4gICAgfTtcclxuICAgIENhY2hlLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5vbGRlc3QgJiYgdGhpcy5tYXAuc2l6ZSA+IHRoaXMubWF4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKHRoaXMub2xkZXN0LmtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhY2hlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5tYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeSA9PT0gdGhpcy5uZXdlc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV3ZXN0ID0gZW50cnkub2xkZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudHJ5ID09PSB0aGlzLm9sZGVzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbGRlc3QgPSBlbnRyeS5uZXdlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50cnkubmV3ZXIpIHtcclxuICAgICAgICAgICAgICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gZW50cnkub2xkZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudHJ5Lm9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5vbGRlci5uZXdlciA9IGVudHJ5Lm5ld2VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubWFwLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoZW50cnkudmFsdWUsIGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENhY2hlO1xyXG59KCkpO1xuXG52YXIgcGFyZW50RW50cnlTbG90ID0gbmV3IFNsb3QoKTtcblxudmFyIHJldXNhYmxlRW1wdHlBcnJheSA9IFtdO1xyXG52YXIgZW1wdHlTZXRQb29sID0gW107XHJcbnZhciBQT09MX1RBUkdFVF9TSVpFID0gMTAwO1xyXG4vLyBTaW5jZSB0aGlzIHBhY2thZ2UgbWlnaHQgYmUgdXNlZCBicm93c2Vycywgd2Ugc2hvdWxkIGF2b2lkIHVzaW5nIHRoZVxyXG4vLyBOb2RlIGJ1aWx0LWluIGFzc2VydCBtb2R1bGUuXHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG9wdGlvbmFsTWVzc2FnZSkge1xyXG4gICAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3B0aW9uYWxNZXNzYWdlIHx8IFwiYXNzZXJ0aW9uIGZhaWx1cmVcIik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsdWVJcyhhLCBiKSB7XHJcbiAgICB2YXIgbGVuID0gYS5sZW5ndGg7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgLy8gVW5rbm93biB2YWx1ZXMgYXJlIG5vdCBlcXVhbCB0byBlYWNoIG90aGVyLlxyXG4gICAgbGVuID4gMCAmJlxyXG4gICAgICAgIC8vIEJvdGggdmFsdWVzIG11c3QgYmUgb3JkaW5hcnkgKG9yIGJvdGggZXhjZXB0aW9uYWwpIHRvIGJlIGVxdWFsLlxyXG4gICAgICAgIGxlbiA9PT0gYi5sZW5ndGggJiZcclxuICAgICAgICAvLyBUaGUgdW5kZXJseWluZyB2YWx1ZSBvciBleGNlcHRpb24gbXVzdCBiZSB0aGUgc2FtZS5cclxuICAgICAgICBhW2xlbiAtIDFdID09PSBiW2xlbiAtIDFdKTtcclxufVxyXG5mdW5jdGlvbiB2YWx1ZUdldCh2YWx1ZSkge1xyXG4gICAgc3dpdGNoICh2YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDA6IHRocm93IG5ldyBFcnJvcihcInVua25vd24gdmFsdWVcIik7XHJcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gdmFsdWVbMF07XHJcbiAgICAgICAgY2FzZSAyOiB0aHJvdyB2YWx1ZVsxXTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWx1ZUNvcHkodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZS5zbGljZSgwKTtcclxufVxyXG52YXIgRW50cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbnRyeShmbiwgYXJncykge1xyXG4gICAgICAgIHRoaXMuZm4gPSBmbjtcclxuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xyXG4gICAgICAgIHRoaXMucGFyZW50cyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmNoaWxkVmFsdWVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vIFdoZW4gdGhpcyBFbnRyeSBoYXMgY2hpbGRyZW4gdGhhdCBhcmUgZGlydHksIHRoaXMgcHJvcGVydHkgYmVjb21lc1xyXG4gICAgICAgIC8vIGEgU2V0IGNvbnRhaW5pbmcgb3RoZXIgRW50cnkgb2JqZWN0cywgYm9ycm93ZWQgZnJvbSBlbXB0eVNldFBvb2wuXHJcbiAgICAgICAgLy8gV2hlbiB0aGUgc2V0IGJlY29tZXMgZW1wdHksIGl0IGdldHMgcmVjeWNsZWQgYmFjayB0byBlbXB0eVNldFBvb2wuXHJcbiAgICAgICAgdGhpcy5kaXJ0eUNoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJlY29tcHV0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xyXG4gICAgICAgICsrRW50cnkuY291bnQ7XHJcbiAgICB9XHJcbiAgICAvLyBUaGlzIGlzIHRoZSBtb3N0IGltcG9ydGFudCBtZXRob2Qgb2YgdGhlIEVudHJ5IEFQSSwgYmVjYXVzZSBpdFxyXG4gICAgLy8gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjYWNoZWQgdGhpcy52YWx1ZSBjYW4gYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHksXHJcbiAgICAvLyBvciBtdXN0IGJlIHJlY29tcHV0ZWQuIFRoZSBvdmVyYWxsIHBlcmZvcm1hbmNlIG9mIHRoZSBjYWNoaW5nIHN5c3RlbVxyXG4gICAgLy8gZGVwZW5kcyBvbiB0aGUgdHJ1dGggb2YgdGhlIGZvbGxvd2luZyBvYnNlcnZhdGlvbnM6ICgxKSB0aGlzLmRpcnR5IGlzXHJcbiAgICAvLyB1c3VhbGx5IGZhbHNlLCAoMikgdGhpcy5kaXJ0eUNoaWxkcmVuIGlzIHVzdWFsbHkgbnVsbC9lbXB0eSwgYW5kIHRodXNcclxuICAgIC8vICgzKSB2YWx1ZUdldCh0aGlzLnZhbHVlKSBpcyB1c3VhbGx5IHJldHVybmVkIHdpdGhvdXQgcmVjb21wdXRhdGlvbi5cclxuICAgIEVudHJ5LnByb3RvdHlwZS5yZWNvbXB1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYXNzZXJ0KCF0aGlzLnJlY29tcHV0aW5nLCBcImFscmVhZHkgcmVjb21wdXRpbmdcIik7XHJcbiAgICAgICAgaWYgKCFyZW1lbWJlclBhcmVudCh0aGlzKSAmJiBtYXliZVJlcG9ydE9ycGhhbih0aGlzKSkge1xyXG4gICAgICAgICAgICAvLyBUaGUgcmVjaXBpZW50IG9mIHRoZSBlbnRyeS5yZXBvcnRPcnBoYW4gY2FsbGJhY2sgZGVjaWRlZCB0byBkaXNwb3NlXHJcbiAgICAgICAgICAgIC8vIG9mIHRoaXMgb3JwaGFuIGVudHJ5IGJ5IGNhbGxpbmcgZW50cnkuZGlzcG9zZSgpLCBzbyB3ZSBkb24ndCBuZWVkIHRvXHJcbiAgICAgICAgICAgIC8vIChhbmQgc2hvdWxkIG5vdCkgcHJvY2VlZCB3aXRoIHRoZSByZWNvbXB1dGF0aW9uLlxyXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWlnaHRCZURpcnR5KHRoaXMpXHJcbiAgICAgICAgICAgID8gcmVhbGx5UmVjb21wdXRlKHRoaXMpXHJcbiAgICAgICAgICAgIDogdmFsdWVHZXQodGhpcy52YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgRW50cnkucHJvdG90eXBlLnNldERpcnR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy52YWx1ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIHJlcG9ydERpcnR5KHRoaXMpO1xyXG4gICAgICAgIC8vIFdlIGNhbiBnbyBhaGVhZCBhbmQgdW5zdWJzY3JpYmUgaGVyZSwgc2luY2UgYW55IGZ1cnRoZXIgZGlydHlcclxuICAgICAgICAvLyBub3RpZmljYXRpb25zIHdlIHJlY2VpdmUgd2lsbCBiZSByZWR1bmRhbnQsIGFuZCB1bnN1YnNjcmliaW5nIG1heVxyXG4gICAgICAgIC8vIGZyZWUgdXAgc29tZSByZXNvdXJjZXMsIGUuZy4gZmlsZSB3YXRjaGVycy5cclxuICAgICAgICBtYXliZVVuc3Vic2NyaWJlKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEVudHJ5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgZm9yZ2V0Q2hpbGRyZW4odGhpcykuZm9yRWFjaChtYXliZVJlcG9ydE9ycGhhbik7XHJcbiAgICAgICAgbWF5YmVVbnN1YnNjcmliZSh0aGlzKTtcclxuICAgICAgICAvLyBCZWNhdXNlIHRoaXMgZW50cnkgaGFzIGJlZW4ga2lja2VkIG91dCBvZiB0aGUgY2FjaGUgKGluIGluZGV4LmpzKSxcclxuICAgICAgICAvLyB3ZSd2ZSBsb3N0IHRoZSBhYmlsaXR5IHRvIGZpbmQgb3V0IGlmL3doZW4gdGhpcyBlbnRyeSBiZWNvbWVzIGRpcnR5LFxyXG4gICAgICAgIC8vIHdoZXRoZXIgdGhhdCBoYXBwZW5zIHRocm91Z2ggYSBzdWJzY3JpcHRpb24sIGJlY2F1c2Ugb2YgYSBkaXJlY3QgY2FsbFxyXG4gICAgICAgIC8vIHRvIGVudHJ5LnNldERpcnR5KCksIG9yIGJlY2F1c2Ugb25lIG9mIGl0cyBjaGlsZHJlbiBiZWNvbWVzIGRpcnR5LlxyXG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhpcyBsb3NzIG9mIGZ1dHVyZSBpbmZvcm1hdGlvbiwgd2UgaGF2ZSB0byBhc3N1bWUgdGhlXHJcbiAgICAgICAgLy8gd29yc3QgKHRoYXQgdGhpcyBlbnRyeSBtaWdodCBoYXZlIGJlY29tZSBkaXJ0eSB2ZXJ5IHNvb24pLCBzbyB3ZSBtdXN0XHJcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgbWFyayB0aGlzIGVudHJ5J3MgcGFyZW50cyBhcyBkaXJ0eS4gTm9ybWFsbHkgd2UgY291bGRcclxuICAgICAgICAvLyBqdXN0IGNhbGwgZW50cnkuc2V0RGlydHkoKSByYXRoZXIgdGhhbiBjYWxsaW5nIHBhcmVudC5zZXREaXJ0eSgpIGZvclxyXG4gICAgICAgIC8vIGVhY2ggcGFyZW50LCBidXQgdGhhdCB3b3VsZCBsZWF2ZSB0aGlzIGVudHJ5IGluIHBhcmVudC5jaGlsZFZhbHVlc1xyXG4gICAgICAgIC8vIGFuZCBwYXJlbnQuZGlydHlDaGlsZHJlbiwgd2hpY2ggd291bGQgcHJldmVudCB0aGUgY2hpbGQgZnJvbSBiZWluZ1xyXG4gICAgICAgIC8vIHRydWx5IGZvcmdvdHRlbi5cclxuICAgICAgICB0aGlzLnBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5zZXREaXJ0eSgpO1xyXG4gICAgICAgICAgICBmb3JnZXRDaGlsZChwYXJlbnQsIF90aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFbnRyeS5jb3VudCA9IDA7XHJcbiAgICByZXR1cm4gRW50cnk7XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIHJlbWVtYmVyUGFyZW50KGNoaWxkKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50RW50cnlTbG90LmdldFZhbHVlKCk7XHJcbiAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgY2hpbGQucGFyZW50cy5hZGQocGFyZW50KTtcclxuICAgICAgICBpZiAoIXBhcmVudC5jaGlsZFZhbHVlcy5oYXMoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZFZhbHVlcy5zZXQoY2hpbGQsIFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pZ2h0QmVEaXJ0eShjaGlsZCkpIHtcclxuICAgICAgICAgICAgcmVwb3J0RGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcG9ydENsZWFuQ2hpbGQocGFyZW50LCBjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJlbnQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVhbGx5UmVjb21wdXRlKGVudHJ5KSB7XHJcbiAgICAvLyBTaW5jZSB0aGlzIHJlY29tcHV0YXRpb24gaXMgbGlrZWx5IHRvIHJlLXJlbWVtYmVyIHNvbWUgb2YgdGhpc1xyXG4gICAgLy8gZW50cnkncyBjaGlsZHJlbiwgd2UgZm9yZ2V0IG91ciBjaGlsZHJlbiBoZXJlIGJ1dCBkbyBub3QgY2FsbFxyXG4gICAgLy8gbWF5YmVSZXBvcnRPcnBoYW4gdW50aWwgYWZ0ZXIgdGhlIHJlY29tcHV0YXRpb24gZmluaXNoZXMuXHJcbiAgICB2YXIgb3JpZ2luYWxDaGlsZHJlbiA9IGZvcmdldENoaWxkcmVuKGVudHJ5KTtcclxuICAgIC8vIFNldCBlbnRyeSBhcyB0aGUgcGFyZW50IGVudHJ5IHdoaWxlIGNhbGxpbmcgcmVjb21wdXRlTmV3VmFsdWUoZW50cnkpLlxyXG4gICAgcGFyZW50RW50cnlTbG90LndpdGhWYWx1ZShlbnRyeSwgcmVjb21wdXRlTmV3VmFsdWUsIFtlbnRyeV0pO1xyXG4gICAgaWYgKG1heWJlU3Vic2NyaWJlKGVudHJ5KSkge1xyXG4gICAgICAgIC8vIElmIHdlIHN1Y2Nlc3NmdWxseSByZWNvbXB1dGVkIGVudHJ5LnZhbHVlIGFuZCBkaWQgbm90IGZhaWwgdG9cclxuICAgICAgICAvLyAocmUpc3Vic2NyaWJlLCB0aGVuIHRoaXMgRW50cnkgaXMgbm8gbG9uZ2VyIGV4cGxpY2l0bHkgZGlydHkuXHJcbiAgICAgICAgc2V0Q2xlYW4oZW50cnkpO1xyXG4gICAgfVxyXG4gICAgLy8gTm93IHRoYXQgd2UndmUgaGFkIGEgY2hhbmNlIHRvIHJlLXJlbWVtYmVyIGFueSBjaGlsZHJlbiB0aGF0IHdlcmVcclxuICAgIC8vIGludm9sdmVkIGluIHRoZSByZWNvbXB1dGF0aW9uLCB3ZSBjYW4gc2FmZWx5IHJlcG9ydCBhbnkgb3JwaGFuXHJcbiAgICAvLyBjaGlsZHJlbiB0aGF0IHJlbWFpbi5cclxuICAgIG9yaWdpbmFsQ2hpbGRyZW4uZm9yRWFjaChtYXliZVJlcG9ydE9ycGhhbik7XHJcbiAgICByZXR1cm4gdmFsdWVHZXQoZW50cnkudmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHJlY29tcHV0ZU5ld1ZhbHVlKGVudHJ5KSB7XHJcbiAgICBlbnRyeS5yZWNvbXB1dGluZyA9IHRydWU7XHJcbiAgICAvLyBTZXQgZW50cnkudmFsdWUgYXMgdW5rbm93bi5cclxuICAgIGVudHJ5LnZhbHVlLmxlbmd0aCA9IDA7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIElmIGVudHJ5LmZuIHN1Y2NlZWRzLCBlbnRyeS52YWx1ZSB3aWxsIGJlY29tZSBhIG5vcm1hbCBWYWx1ZS5cclxuICAgICAgICBlbnRyeS52YWx1ZVswXSA9IGVudHJ5LmZuLmFwcGx5KG51bGwsIGVudHJ5LmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBJZiBlbnRyeS5mbiB0aHJvd3MsIGVudHJ5LnZhbHVlIHdpbGwgYmVjb21lIGV4Y2VwdGlvbmFsLlxyXG4gICAgICAgIGVudHJ5LnZhbHVlWzFdID0gZTtcclxuICAgIH1cclxuICAgIC8vIEVpdGhlciB3YXksIHRoaXMgbGluZSBpcyBhbHdheXMgcmVhY2hlZC5cclxuICAgIGVudHJ5LnJlY29tcHV0aW5nID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gbWlnaHRCZURpcnR5KGVudHJ5KSB7XHJcbiAgICByZXR1cm4gZW50cnkuZGlydHkgfHwgISEoZW50cnkuZGlydHlDaGlsZHJlbiAmJiBlbnRyeS5kaXJ0eUNoaWxkcmVuLnNpemUpO1xyXG59XHJcbmZ1bmN0aW9uIHNldENsZWFuKGVudHJ5KSB7XHJcbiAgICBlbnRyeS5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgaWYgKG1pZ2h0QmVEaXJ0eShlbnRyeSkpIHtcclxuICAgICAgICAvLyBUaGlzIEVudHJ5IG1heSBzdGlsbCBoYXZlIGRpcnR5IGNoaWxkcmVuLCBpbiB3aGljaCBjYXNlIHdlIGNhbid0XHJcbiAgICAgICAgLy8gbGV0IG91ciBwYXJlbnRzIGtub3cgd2UncmUgY2xlYW4ganVzdCB5ZXQuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmVwb3J0Q2xlYW4oZW50cnkpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9ydERpcnR5KGNoaWxkKSB7XHJcbiAgICBjaGlsZC5wYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudCkgeyByZXR1cm4gcmVwb3J0RGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb3J0Q2xlYW4oY2hpbGQpIHtcclxuICAgIGNoaWxkLnBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50KSB7IHJldHVybiByZXBvcnRDbGVhbkNoaWxkKHBhcmVudCwgY2hpbGQpOyB9KTtcclxufVxyXG4vLyBMZXQgYSBwYXJlbnQgRW50cnkga25vdyB0aGF0IG9uZSBvZiBpdHMgY2hpbGRyZW4gbWF5IGJlIGRpcnR5LlxyXG5mdW5jdGlvbiByZXBvcnREaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpIHtcclxuICAgIC8vIE11c3QgaGF2ZSBjYWxsZWQgcmVtZW1iZXJQYXJlbnQoY2hpbGQpIGJlZm9yZSBjYWxsaW5nXHJcbiAgICAvLyByZXBvcnREaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpLlxyXG4gICAgYXNzZXJ0KHBhcmVudC5jaGlsZFZhbHVlcy5oYXMoY2hpbGQpKTtcclxuICAgIGFzc2VydChtaWdodEJlRGlydHkoY2hpbGQpKTtcclxuICAgIGlmICghcGFyZW50LmRpcnR5Q2hpbGRyZW4pIHtcclxuICAgICAgICBwYXJlbnQuZGlydHlDaGlsZHJlbiA9IGVtcHR5U2V0UG9vbC5wb3AoKSB8fCBuZXcgU2V0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGFyZW50LmRpcnR5Q2hpbGRyZW4uaGFzKGNoaWxkKSkge1xyXG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkga25vdyB0aGlzIGNoaWxkIGlzIGRpcnR5LCB0aGVuIHdlIG11c3QgaGF2ZSBhbHJlYWR5XHJcbiAgICAgICAgLy8gaW5mb3JtZWQgb3VyIG93biBwYXJlbnRzIHRoYXQgd2UgYXJlIGRpcnR5LCBzbyB3ZSBjYW4gdGVybWluYXRlXHJcbiAgICAgICAgLy8gdGhlIHJlY3Vyc2lvbiBlYXJseS5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBwYXJlbnQuZGlydHlDaGlsZHJlbi5hZGQoY2hpbGQpO1xyXG4gICAgcmVwb3J0RGlydHkocGFyZW50KTtcclxufVxyXG4vLyBMZXQgYSBwYXJlbnQgRW50cnkga25vdyB0aGF0IG9uZSBvZiBpdHMgY2hpbGRyZW4gaXMgbm8gbG9uZ2VyIGRpcnR5LlxyXG5mdW5jdGlvbiByZXBvcnRDbGVhbkNoaWxkKHBhcmVudCwgY2hpbGQpIHtcclxuICAgIC8vIE11c3QgaGF2ZSBjYWxsZWQgcmVtZW1iZXJDaGlsZChjaGlsZCkgYmVmb3JlIGNhbGxpbmdcclxuICAgIC8vIHJlcG9ydENsZWFuQ2hpbGQocGFyZW50LCBjaGlsZCkuXHJcbiAgICBhc3NlcnQocGFyZW50LmNoaWxkVmFsdWVzLmhhcyhjaGlsZCkpO1xyXG4gICAgYXNzZXJ0KCFtaWdodEJlRGlydHkoY2hpbGQpKTtcclxuICAgIHZhciBjaGlsZFZhbHVlID0gcGFyZW50LmNoaWxkVmFsdWVzLmdldChjaGlsZCk7XHJcbiAgICBpZiAoY2hpbGRWYWx1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBwYXJlbnQuY2hpbGRWYWx1ZXMuc2V0KGNoaWxkLCB2YWx1ZUNvcHkoY2hpbGQudmFsdWUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCF2YWx1ZUlzKGNoaWxkVmFsdWUsIGNoaWxkLnZhbHVlKSkge1xyXG4gICAgICAgIHBhcmVudC5zZXREaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlRGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKTtcclxuICAgIGlmIChtaWdodEJlRGlydHkocGFyZW50KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJlcG9ydENsZWFuKHBhcmVudCk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlRGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKSB7XHJcbiAgICB2YXIgZGMgPSBwYXJlbnQuZGlydHlDaGlsZHJlbjtcclxuICAgIGlmIChkYykge1xyXG4gICAgICAgIGRjLmRlbGV0ZShjaGlsZCk7XHJcbiAgICAgICAgaWYgKGRjLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGVtcHR5U2V0UG9vbC5sZW5ndGggPCBQT09MX1RBUkdFVF9TSVpFKSB7XHJcbiAgICAgICAgICAgICAgICBlbXB0eVNldFBvb2wucHVzaChkYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyZW50LmRpcnR5Q2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyBJZiB0aGUgZ2l2ZW4gZW50cnkgaGFzIGEgcmVwb3J0T3JwaGFuIG1ldGhvZCwgYW5kIG5vIHJlbWFpbmluZyBwYXJlbnRzLFxyXG4vLyBjYWxsIGVudHJ5LnJlcG9ydE9ycGhhbiBhbmQgcmV0dXJuIHRydWUgaWZmIGl0IHJldHVybnMgdHJ1ZS4gVGhlXHJcbi8vIHJlcG9ydE9ycGhhbiBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHRydWUgdG8gaW5kaWNhdGUgZW50cnkuZGlzcG9zZSgpXHJcbi8vIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHRoZSBlbnRyeSBoYXMgYmVlbiByZW1vdmVkIGZyb20gYW55IG90aGVyIGNhY2hlc1xyXG4vLyAoc2VlIGluZGV4LmpzIGZvciB0aGUgb25seSBjdXJyZW50IGV4YW1wbGUpLlxyXG5mdW5jdGlvbiBtYXliZVJlcG9ydE9ycGhhbihlbnRyeSkge1xyXG4gICAgcmV0dXJuIGVudHJ5LnBhcmVudHMuc2l6ZSA9PT0gMCAmJlxyXG4gICAgICAgIHR5cGVvZiBlbnRyeS5yZXBvcnRPcnBoYW4gPT09IFwiZnVuY3Rpb25cIiAmJlxyXG4gICAgICAgIGVudHJ5LnJlcG9ydE9ycGhhbigpID09PSB0cnVlO1xyXG59XHJcbi8vIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhpcyBlbnRyeSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVcclxuLy8gcmVtb3ZlZCBjaGlsZHJlbi5cclxuZnVuY3Rpb24gZm9yZ2V0Q2hpbGRyZW4ocGFyZW50KSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSByZXVzYWJsZUVtcHR5QXJyYXk7XHJcbiAgICBpZiAocGFyZW50LmNoaWxkVmFsdWVzLnNpemUgPiAwKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICBwYXJlbnQuY2hpbGRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAoX3ZhbHVlLCBjaGlsZCkge1xyXG4gICAgICAgICAgICBmb3JnZXRDaGlsZChwYXJlbnQsIGNoaWxkKTtcclxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBBZnRlciB3ZSBmb3JnZXQgYWxsIG91ciBjaGlsZHJlbiwgdGhpcy5kaXJ0eUNoaWxkcmVuIG11c3QgYmUgZW1wdHlcclxuICAgIC8vIGFuZCB0aGVyZWZvcmUgbXVzdCBoYXZlIGJlZW4gcmVzZXQgdG8gbnVsbC5cclxuICAgIGFzc2VydChwYXJlbnQuZGlydHlDaGlsZHJlbiA9PT0gbnVsbCk7XHJcbiAgICByZXR1cm4gY2hpbGRyZW47XHJcbn1cclxuZnVuY3Rpb24gZm9yZ2V0Q2hpbGQocGFyZW50LCBjaGlsZCkge1xyXG4gICAgY2hpbGQucGFyZW50cy5kZWxldGUocGFyZW50KTtcclxuICAgIHBhcmVudC5jaGlsZFZhbHVlcy5kZWxldGUoY2hpbGQpO1xyXG4gICAgcmVtb3ZlRGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKTtcclxufVxyXG5mdW5jdGlvbiBtYXliZVN1YnNjcmliZShlbnRyeSkge1xyXG4gICAgaWYgKHR5cGVvZiBlbnRyeS5zdWJzY3JpYmUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG1heWJlVW5zdWJzY3JpYmUoZW50cnkpOyAvLyBQcmV2ZW50IGRvdWJsZSBzdWJzY3JpcHRpb25zLlxyXG4gICAgICAgICAgICBlbnRyeS51bnN1YnNjcmliZSA9IGVudHJ5LnN1YnNjcmliZS5hcHBseShudWxsLCBlbnRyeS5hcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhpcyBFbnRyeSBoYXMgYSBzdWJzY3JpYmUgZnVuY3Rpb24gYW5kIGl0IHRocmV3IGFuIGV4Y2VwdGlvblxyXG4gICAgICAgICAgICAvLyAob3IgYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24gaXQgcHJldmlvdXNseSByZXR1cm5lZCBub3cgdGhyb3dzKSxcclxuICAgICAgICAgICAgLy8gcmV0dXJuIGZhbHNlIHRvIGluZGljYXRlIHRoYXQgd2Ugd2VyZSBub3QgYWJsZSB0byBzdWJzY3JpYmUgKG9yXHJcbiAgICAgICAgICAgIC8vIHVuc3Vic2NyaWJlKSwgYW5kIHRoaXMgRW50cnkgc2hvdWxkIHJlbWFpbiBkaXJ0eS5cclxuICAgICAgICAgICAgZW50cnkuc2V0RGlydHkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFJldHVybmluZyB0cnVlIGluZGljYXRlcyBlaXRoZXIgdGhhdCB0aGVyZSB3YXMgbm8gZW50cnkuc3Vic2NyaWJlXHJcbiAgICAvLyBmdW5jdGlvbiBvciB0aGF0IGl0IHN1Y2NlZWRlZC5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG1heWJlVW5zdWJzY3JpYmUoZW50cnkpIHtcclxuICAgIHZhciB1bnN1YnNjcmliZSA9IGVudHJ5LnVuc3Vic2NyaWJlO1xyXG4gICAgaWYgKHR5cGVvZiB1bnN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgZW50cnkudW5zdWJzY3JpYmUgPSB2b2lkIDA7XHJcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxufVxuXG4vLyBBIHRyaWUgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBob2xkcyBvYmplY3Qga2V5cyB3ZWFrbHksIHlldCBjYW4gYWxzbyBob2xkXHJcbi8vIG5vbi1vYmplY3Qga2V5cywgdW5saWtlIHRoZSBuYXRpdmUgYFdlYWtNYXBgLlxyXG52YXIgS2V5VHJpZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEtleVRyaWUod2Vha25lc3MpIHtcclxuICAgICAgICB0aGlzLndlYWtuZXNzID0gd2Vha25lc3M7XHJcbiAgICB9XHJcbiAgICBLZXlUcmllLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFycmF5ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyYXlbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwQXJyYXkoYXJyYXkpO1xyXG4gICAgfTtcclxuICAgIEtleVRyaWUucHJvdG90eXBlLmxvb2t1cEFycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzO1xyXG4gICAgICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbm9kZSA9IG5vZGUuZ2V0Q2hpbGRUcmllKGtleSk7IH0pO1xyXG4gICAgICAgIHJldHVybiBub2RlLmRhdGEgfHwgKG5vZGUuZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xyXG4gICAgfTtcclxuICAgIEtleVRyaWUucHJvdG90eXBlLmdldENoaWxkVHJpZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgbWFwID0gdGhpcy53ZWFrbmVzcyAmJiBpc09ialJlZihrZXkpXHJcbiAgICAgICAgICAgID8gdGhpcy53ZWFrIHx8ICh0aGlzLndlYWsgPSBuZXcgV2Vha01hcCgpKVxyXG4gICAgICAgICAgICA6IHRoaXMuc3Ryb25nIHx8ICh0aGlzLnN0cm9uZyA9IG5ldyBNYXAoKSk7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gbWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghY2hpbGQpXHJcbiAgICAgICAgICAgIG1hcC5zZXQoa2V5LCBjaGlsZCA9IG5ldyBLZXlUcmllKHRoaXMud2Vha25lc3MpKTtcclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEtleVRyaWU7XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIGlzT2JqUmVmKHZhbHVlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xyXG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoIHRvIHJldHVybiB0cnVlLi4uXHJcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XG5cbi8vIFRoZSBkZWZhdWx0TWFrZUNhY2hlS2V5IGZ1bmN0aW9uIGlzIHJlbWFya2FibHkgcG93ZXJmdWwsIGJlY2F1c2UgaXQgZ2l2ZXNcclxuLy8gYSB1bmlxdWUgb2JqZWN0IGZvciBhbnkgc2hhbGxvdy1pZGVudGljYWwgbGlzdCBvZiBhcmd1bWVudHMuIElmIHlvdSBuZWVkXHJcbi8vIHRvIGltcGxlbWVudCBhIGN1c3RvbSBtYWtlQ2FjaGVLZXkgZnVuY3Rpb24sIHlvdSBtYXkgZmluZCBpdCBoZWxwZnVsIHRvXHJcbi8vIGRlbGVnYXRlIHRoZSBmaW5hbCB3b3JrIHRvIGRlZmF1bHRNYWtlQ2FjaGVLZXksIHdoaWNoIGlzIHdoeSB3ZSBleHBvcnQgaXRcclxuLy8gaGVyZS4gSG93ZXZlciwgeW91IG1heSB3YW50IHRvIGF2b2lkIGRlZmF1bHRNYWtlQ2FjaGVLZXkgaWYgeW91ciBydW50aW1lXHJcbi8vIGRvZXMgbm90IHN1cHBvcnQgV2Vha01hcCwgb3IgeW91IGhhdmUgdGhlIGFiaWxpdHkgdG8gcmV0dXJuIGEgc3RyaW5nIGtleS5cclxuLy8gSW4gdGhvc2UgY2FzZXMsIGp1c3Qgd3JpdGUgeW91ciBvd24gY3VzdG9tIG1ha2VDYWNoZUtleSBmdW5jdGlvbnMuXHJcbnZhciBrZXlUcmllID0gbmV3IEtleVRyaWUodHlwZW9mIFdlYWtNYXAgPT09IFwiZnVuY3Rpb25cIik7XHJcbmZ1bmN0aW9uIGRlZmF1bHRNYWtlQ2FjaGVLZXkoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5VHJpZS5sb29rdXBBcnJheShhcmdzKTtcclxufVxyXG52YXIgY2FjaGVzID0gbmV3IFNldCgpO1xyXG5mdW5jdGlvbiB3cmFwKG9yaWdpbmFsRnVuY3Rpb24sIG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cclxuICAgIHZhciBjYWNoZSA9IG5ldyBDYWNoZShvcHRpb25zLm1heCB8fCBNYXRoLnBvdygyLCAxNiksIGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkuZGlzcG9zZSgpOyB9KTtcclxuICAgIHZhciBkaXNwb3NhYmxlID0gISFvcHRpb25zLmRpc3Bvc2FibGU7XHJcbiAgICB2YXIgbWFrZUNhY2hlS2V5ID0gb3B0aW9ucy5tYWtlQ2FjaGVLZXkgfHwgZGVmYXVsdE1ha2VDYWNoZUtleTtcclxuICAgIGZ1bmN0aW9uIG9wdGltaXN0aWMoKSB7XHJcbiAgICAgICAgaWYgKGRpc3Bvc2FibGUgJiYgIXBhcmVudEVudHJ5U2xvdC5oYXNWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gY3VycmVudCBwYXJlbnQgY29tcHV0YXRpb24sIGFuZCB0aGlzIHdyYXBwZWRcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb24gaXMgZGlzcG9zYWJsZSAobWVhbmluZyB3ZSBkb24ndCBjYXJlIGFib3V0IGVudHJ5LnZhbHVlLFxyXG4gICAgICAgICAgICAvLyBqdXN0IGRlcGVuZGVuY3kgdHJhY2tpbmcpLCB0aGVuIHdlIGNhbiBzaG9ydC1jdXQgZXZlcnl0aGluZyBlbHNlXHJcbiAgICAgICAgICAgIC8vIGluIHRoaXMgZnVuY3Rpb24sIGJlY2F1c2UgZW50cnkucmVjb21wdXRlKCkgaXMgZ29pbmcgdG8gcmVjeWNsZVxyXG4gICAgICAgICAgICAvLyB0aGUgZW50cnkgb2JqZWN0IHdpdGhvdXQgcmVjb21wdXRpbmcgYW55dGhpbmcsIGFueXdheS5cclxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGtleSA9IG1ha2VDYWNoZUtleS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmIChrZXkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIGVudHJ5LmFyZ3MgPSBhcmdzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZW50cnkgPSBuZXcgRW50cnkob3JpZ2luYWxGdW5jdGlvbiwgYXJncyk7XHJcbiAgICAgICAgICAgIGNhY2hlLnNldChrZXksIGVudHJ5KTtcclxuICAgICAgICAgICAgZW50cnkuc3Vic2NyaWJlID0gb3B0aW9ucy5zdWJzY3JpYmU7XHJcbiAgICAgICAgICAgIGlmIChkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5yZXBvcnRPcnBoYW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZS5kZWxldGUoa2V5KTsgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSBlbnRyeS5yZWNvbXB1dGUoKTtcclxuICAgICAgICAvLyBNb3ZlIHRoaXMgZW50cnkgdG8gdGhlIGZyb250IG9mIHRoZSBsZWFzdC1yZWNlbnRseSB1c2VkIHF1ZXVlLFxyXG4gICAgICAgIC8vIHNpbmNlIHdlIGp1c3QgZmluaXNoZWQgY29tcHV0aW5nIGl0cyB2YWx1ZS5cclxuICAgICAgICBjYWNoZS5zZXQoa2V5LCBlbnRyeSk7XHJcbiAgICAgICAgY2FjaGVzLmFkZChjYWNoZSk7XHJcbiAgICAgICAgLy8gQ2xlYW4gdXAgYW55IGV4Y2VzcyBlbnRyaWVzIGluIHRoZSBjYWNoZSwgYnV0IG9ubHkgaWYgdGhlcmUgaXMgbm9cclxuICAgICAgICAvLyBhY3RpdmUgcGFyZW50IGVudHJ5LCBtZWFuaW5nIHdlJ3JlIG5vdCBpbiB0aGUgbWlkZGxlIG9mIGEgbGFyZ2VyXHJcbiAgICAgICAgLy8gY29tcHV0YXRpb24gdGhhdCBtaWdodCBiZSBmbHVtbW94ZWQgYnkgdGhlIGNsZWFuaW5nLlxyXG4gICAgICAgIGlmICghcGFyZW50RW50cnlTbG90Lmhhc1ZhbHVlKCkpIHtcclxuICAgICAgICAgICAgY2FjaGVzLmZvckVhY2goZnVuY3Rpb24gKGNhY2hlKSB7IHJldHVybiBjYWNoZS5jbGVhbigpOyB9KTtcclxuICAgICAgICAgICAgY2FjaGVzLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIG9wdGlvbnMuZGlzcG9zYWJsZSBpcyB0cnV0aHksIHRoZSBjYWxsZXIgb2Ygd3JhcCBpcyB0ZWxsaW5nIHVzXHJcbiAgICAgICAgLy8gdGhleSBkb24ndCBjYXJlIGFib3V0IHRoZSByZXN1bHQgb2YgZW50cnkucmVjb21wdXRlKCksIHNvIHdlIHNob3VsZFxyXG4gICAgICAgIC8vIGF2b2lkIHJldHVybmluZyB0aGUgdmFsdWUsIHNvIGl0IHdvbid0IGJlIGFjY2lkZW50YWxseSB1c2VkLlxyXG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlID8gdm9pZCAwIDogdmFsdWU7XHJcbiAgICB9XHJcbiAgICBvcHRpbWlzdGljLmRpcnR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBrZXkgPSBtYWtlQ2FjaGVLZXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICB2YXIgY2hpbGQgPSBrZXkgIT09IHZvaWQgMCAmJiBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgY2hpbGQuc2V0RGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG9wdGltaXN0aWM7XHJcbn1cblxuZXhwb3J0IHsgS2V5VHJpZSwgZGVmYXVsdE1ha2VDYWNoZUtleSwgd3JhcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVuZGxlLmVzbS5qcy5tYXBcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBBcG9sbG9DYWNoZSB9IGZyb20gJ2Fwb2xsby1jYWNoZSc7XG5pbXBvcnQgeyBpc1Rlc3QsIGdldFF1ZXJ5RGVmaW5pdGlvbiwgYXNzaWduLCBnZXREZWZhdWx0VmFsdWVzLCBpc0VxdWFsLCBnZXRNYWluRGVmaW5pdGlvbiwgZ2V0RnJhZ21lbnREZWZpbml0aW9ucywgY3JlYXRlRnJhZ21lbnRNYXAsIHNob3VsZEluY2x1ZGUsIGlzRmllbGQsIHJlc3VsdEtleU5hbWVGcm9tRmllbGQsIGlzSW5saW5lRnJhZ21lbnQsIG1lcmdlRGVlcEFycmF5LCBhcmd1bWVudHNPYmplY3RGcm9tRmllbGQsIGdldERpcmVjdGl2ZUluZm9Gcm9tRmllbGQsIG1heWJlRGVlcEZyZWV6ZSwgaXNJZFZhbHVlLCBnZXRTdG9yZUtleU5hbWUsIHRvSWRWYWx1ZSwgaXNKc29uVmFsdWUsIGNhblVzZVdlYWtNYXAsIGdldE9wZXJhdGlvbkRlZmluaXRpb24sIGlzUHJvZHVjdGlvbiwgc3RvcmVLZXlOYW1lRnJvbUZpZWxkLCBhZGRUeXBlbmFtZVRvRG9jdW1lbnQgfSBmcm9tICdhcG9sbG8tdXRpbGl0aWVzJztcbmltcG9ydCB7IHdyYXAsIEtleVRyaWUgfSBmcm9tICdvcHRpbWlzbSc7XG5pbXBvcnQgeyBpbnZhcmlhbnQsIEludmFyaWFudEVycm9yIH0gZnJvbSAndHMtaW52YXJpYW50JztcblxudmFyIGhhdmVXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNob3VsZFdhcm4oKSB7XG4gICAgdmFyIGFuc3dlciA9ICFoYXZlV2FybmVkO1xuICAgIGlmICghaXNUZXN0KCkpIHtcbiAgICAgICAgaGF2ZVdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhbnN3ZXI7XG59XG52YXIgSGV1cmlzdGljRnJhZ21lbnRNYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIZXVyaXN0aWNGcmFnbWVudE1hdGNoZXIoKSB7XG4gICAgfVxuICAgIEhldXJpc3RpY0ZyYWdtZW50TWF0Y2hlci5wcm90b3R5cGUuZW5zdXJlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIEhldXJpc3RpY0ZyYWdtZW50TWF0Y2hlci5wcm90b3R5cGUuY2FuQnlwYXNzSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBIZXVyaXN0aWNGcmFnbWVudE1hdGNoZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGlkVmFsdWUsIHR5cGVDb25kaXRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG9iaiA9IGNvbnRleHQuc3RvcmUuZ2V0KGlkVmFsdWUuaWQpO1xuICAgICAgICB2YXIgaXNSb290UXVlcnkgPSBpZFZhbHVlLmlkID09PSAnUk9PVF9RVUVSWSc7XG4gICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNSb290UXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gb2JqLl9fdHlwZW5hbWUsIF9fdHlwZW5hbWUgPSBfYSA9PT0gdm9pZCAwID8gaXNSb290UXVlcnkgJiYgJ1F1ZXJ5JyA6IF9hO1xuICAgICAgICBpZiAoIV9fdHlwZW5hbWUpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRXYXJuKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgaW52YXJpYW50Lndhcm4oXCJZb3UncmUgdXNpbmcgZnJhZ21lbnRzIGluIHlvdXIgcXVlcmllcywgYnV0IGVpdGhlciBkb24ndCBoYXZlIHRoZSBhZGRUeXBlbmFtZTpcXG4gIHRydWUgb3B0aW9uIHNldCBpbiBBcG9sbG8gQ2xpZW50LCBvciB5b3UgYXJlIHRyeWluZyB0byB3cml0ZSBhIGZyYWdtZW50IHRvIHRoZSBzdG9yZSB3aXRob3V0IHRoZSBfX3R5cGVuYW1lLlxcbiAgIFBsZWFzZSB0dXJuIG9uIHRoZSBhZGRUeXBlbmFtZSBvcHRpb24gYW5kIGluY2x1ZGUgX190eXBlbmFtZSB3aGVuIHdyaXRpbmcgZnJhZ21lbnRzIHNvIHRoYXQgQXBvbGxvIENsaWVudFxcbiAgIGNhbiBhY2N1cmF0ZWx5IG1hdGNoIGZyYWdtZW50cy5cIik7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IGludmFyaWFudC53YXJuKCdDb3VsZCBub3QgZmluZCBfX3R5cGVuYW1lIG9uIEZyYWdtZW50ICcsIHR5cGVDb25kaXRpb24sIG9iaik7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IGludmFyaWFudC53YXJuKFwiREVQUkVDQVRJT04gV0FSTklORzogdXNpbmcgZnJhZ21lbnRzIHdpdGhvdXQgX190eXBlbmFtZSBpcyB1bnN1cHBvcnRlZCBiZWhhdmlvciBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgQXBvbGxvIGNsaWVudC4gWW91IHNob3VsZCBmaXggdGhpcyBhbmQgc2V0IGFkZFR5cGVuYW1lIHRvIHRydWUgbm93LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnaGV1cmlzdGljJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoX190eXBlbmFtZSA9PT0gdHlwZUNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFdhcm4oKSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IGludmFyaWFudC5lcnJvcignWW91IGFyZSB1c2luZyB0aGUgc2ltcGxlIChoZXVyaXN0aWMpIGZyYWdtZW50IG1hdGNoZXIsIGJ1dCB5b3VyICcgK1xuICAgICAgICAgICAgICAgICdxdWVyaWVzIGNvbnRhaW4gdW5pb24gb3IgaW50ZXJmYWNlIHR5cGVzLiBBcG9sbG8gQ2xpZW50IHdpbGwgbm90IGJlICcgK1xuICAgICAgICAgICAgICAgICdhYmxlIHRvIGFjY3VyYXRlbHkgbWFwIGZyYWdtZW50cy4gVG8gbWFrZSB0aGlzIGVycm9yIGdvIGF3YXksIHVzZSAnICtcbiAgICAgICAgICAgICAgICAndGhlIGBJbnRyb3NwZWN0aW9uRnJhZ21lbnRNYXRjaGVyYCBhcyBkZXNjcmliZWQgaW4gdGhlIGRvY3M6ICcgK1xuICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5hcG9sbG9ncmFwaHFsLmNvbS9kb2NzL3JlYWN0L2FkdmFuY2VkL2ZyYWdtZW50cy5odG1sI2ZyYWdtZW50LW1hdGNoZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2hldXJpc3RpYyc7XG4gICAgfTtcbiAgICByZXR1cm4gSGV1cmlzdGljRnJhZ21lbnRNYXRjaGVyO1xufSgpKTtcbnZhciBJbnRyb3NwZWN0aW9uRnJhZ21lbnRNYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRyb3NwZWN0aW9uRnJhZ21lbnRNYXRjaGVyKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbnRyb3NwZWN0aW9uUXVlcnlSZXN1bHREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnBvc3NpYmxlVHlwZXNNYXAgPSB0aGlzLnBhcnNlSW50cm9zcGVjdGlvblJlc3VsdChvcHRpb25zLmludHJvc3BlY3Rpb25RdWVyeVJlc3VsdERhdGEpO1xuICAgICAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNSZWFkeSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIEludHJvc3BlY3Rpb25GcmFnbWVudE1hdGNoZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGlkVmFsdWUsIHR5cGVDb25kaXRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KHRoaXMuaXNSZWFkeSwgMSkgOiBpbnZhcmlhbnQodGhpcy5pc1JlYWR5LCAnRnJhZ21lbnRNYXRjaGVyLm1hdGNoKCkgd2FzIGNhbGxlZCBiZWZvcmUgRnJhZ21lbnRNYXRjaGVyLmluaXQoKScpO1xuICAgICAgICB2YXIgb2JqID0gY29udGV4dC5zdG9yZS5nZXQoaWRWYWx1ZS5pZCk7XG4gICAgICAgIHZhciBpc1Jvb3RRdWVyeSA9IGlkVmFsdWUuaWQgPT09ICdST09UX1FVRVJZJztcbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBpc1Jvb3RRdWVyeTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBvYmouX190eXBlbmFtZSwgX190eXBlbmFtZSA9IF9hID09PSB2b2lkIDAgPyBpc1Jvb3RRdWVyeSAmJiAnUXVlcnknIDogX2E7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChfX3R5cGVuYW1lLCAyKSA6IGludmFyaWFudChfX3R5cGVuYW1lLCBcIkNhbm5vdCBtYXRjaCBmcmFnbWVudCBiZWNhdXNlIF9fdHlwZW5hbWUgcHJvcGVydHkgaXMgbWlzc2luZzogXCIgKyBKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICAgICAgaWYgKF9fdHlwZW5hbWUgPT09IHR5cGVDb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbXBsZW1lbnRpbmdUeXBlcyA9IHRoaXMucG9zc2libGVUeXBlc01hcFt0eXBlQ29uZGl0aW9uXTtcbiAgICAgICAgaWYgKF9fdHlwZW5hbWUgJiZcbiAgICAgICAgICAgIGltcGxlbWVudGluZ1R5cGVzICYmXG4gICAgICAgICAgICBpbXBsZW1lbnRpbmdUeXBlcy5pbmRleE9mKF9fdHlwZW5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEludHJvc3BlY3Rpb25GcmFnbWVudE1hdGNoZXIucHJvdG90eXBlLnBhcnNlSW50cm9zcGVjdGlvblJlc3VsdCA9IGZ1bmN0aW9uIChpbnRyb3NwZWN0aW9uUmVzdWx0RGF0YSkge1xuICAgICAgICB2YXIgdHlwZU1hcCA9IHt9O1xuICAgICAgICBpbnRyb3NwZWN0aW9uUmVzdWx0RGF0YS5fX3NjaGVtYS50eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZS5raW5kID09PSAnVU5JT04nIHx8IHR5cGUua2luZCA9PT0gJ0lOVEVSRkFDRScpIHtcbiAgICAgICAgICAgICAgICB0eXBlTWFwW3R5cGUubmFtZV0gPSB0eXBlLnBvc3NpYmxlVHlwZXMubWFwKGZ1bmN0aW9uIChpbXBsZW1lbnRpbmdUeXBlKSB7IHJldHVybiBpbXBsZW1lbnRpbmdUeXBlLm5hbWU7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGVNYXA7XG4gICAgfTtcbiAgICByZXR1cm4gSW50cm9zcGVjdGlvbkZyYWdtZW50TWF0Y2hlcjtcbn0oKSk7XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIERlcFRyYWNraW5nQ2FjaGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlcFRyYWNraW5nQ2FjaGUoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7IGRhdGEgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZGVwZW5kID0gd3JhcChmdW5jdGlvbiAoZGF0YUlkKSB7IHJldHVybiBfdGhpcy5kYXRhW2RhdGFJZF07IH0sIHtcbiAgICAgICAgICAgIGRpc3Bvc2FibGU6IHRydWUsXG4gICAgICAgICAgICBtYWtlQ2FjaGVLZXk6IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIERlcFRyYWNraW5nQ2FjaGUucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH07XG4gICAgRGVwVHJhY2tpbmdDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICB0aGlzLmRlcGVuZChkYXRhSWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2RhdGFJZF07XG4gICAgfTtcbiAgICBEZXBUcmFja2luZ0NhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoZGF0YUlkLCB2YWx1ZSkge1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLmRhdGFbZGF0YUlkXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2RhdGFJZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZGVwZW5kLmRpcnR5KGRhdGFJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlcFRyYWNraW5nQ2FjaGUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgaWYgKGhhc093bi5jYWxsKHRoaXMuZGF0YSwgZGF0YUlkKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtkYXRhSWRdO1xuICAgICAgICAgICAgdGhpcy5kZXBlbmQuZGlydHkoZGF0YUlkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVwVHJhY2tpbmdDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZShudWxsKTtcbiAgICB9O1xuICAgIERlcFRyYWNraW5nQ2FjaGUucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobmV3RGF0YSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3RGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0KGRhdGFJZCwgbmV3RGF0YVtkYXRhSWRdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5kYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc093bi5jYWxsKG5ld0RhdGEsIGRhdGFJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGVsZXRlKGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRlbGV0ZShkYXRhSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZXBUcmFja2luZ0NhY2hlO1xufSgpKTtcbmZ1bmN0aW9uIGRlZmF1bHROb3JtYWxpemVkQ2FjaGVGYWN0b3J5KHNlZWQpIHtcbiAgICByZXR1cm4gbmV3IERlcFRyYWNraW5nQ2FjaGUoc2VlZCk7XG59XG5cbnZhciBTdG9yZVJlYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RvcmVSZWFkZXIoX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuY2FjaGVLZXlSb290LCBjYWNoZUtleVJvb3QgPSBfYyA9PT0gdm9pZCAwID8gbmV3IEtleVRyaWUoY2FuVXNlV2Vha01hcCkgOiBfYywgX2QgPSBfYi5mcmVlemVSZXN1bHRzLCBmcmVlemVSZXN1bHRzID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2Q7XG4gICAgICAgIHZhciBfZSA9IHRoaXMsIGV4ZWN1dGVTdG9yZVF1ZXJ5ID0gX2UuZXhlY3V0ZVN0b3JlUXVlcnksIGV4ZWN1dGVTZWxlY3Rpb25TZXQgPSBfZS5leGVjdXRlU2VsZWN0aW9uU2V0LCBleGVjdXRlU3ViU2VsZWN0ZWRBcnJheSA9IF9lLmV4ZWN1dGVTdWJTZWxlY3RlZEFycmF5O1xuICAgICAgICB0aGlzLmZyZWV6ZVJlc3VsdHMgPSBmcmVlemVSZXN1bHRzO1xuICAgICAgICB0aGlzLmV4ZWN1dGVTdG9yZVF1ZXJ5ID0gd3JhcChmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVTdG9yZVF1ZXJ5LmNhbGwoX3RoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYWtlQ2FjaGVLZXk6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IF9hLnF1ZXJ5LCByb290VmFsdWUgPSBfYS5yb290VmFsdWUsIGNvbnRleHRWYWx1ZSA9IF9hLmNvbnRleHRWYWx1ZSwgdmFyaWFibGVWYWx1ZXMgPSBfYS52YXJpYWJsZVZhbHVlcywgZnJhZ21lbnRNYXRjaGVyID0gX2EuZnJhZ21lbnRNYXRjaGVyO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0VmFsdWUuc3RvcmUgaW5zdGFuY2VvZiBEZXBUcmFja2luZ0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUtleVJvb3QubG9va3VwKGNvbnRleHRWYWx1ZS5zdG9yZSwgcXVlcnksIGZyYWdtZW50TWF0Y2hlciwgSlNPTi5zdHJpbmdpZnkodmFyaWFibGVWYWx1ZXMpLCByb290VmFsdWUuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZVNlbGVjdGlvblNldCA9IHdyYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBleGVjdXRlU2VsZWN0aW9uU2V0LmNhbGwoX3RoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYWtlQ2FjaGVLZXk6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25TZXQgPSBfYS5zZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSA9IF9hLnJvb3RWYWx1ZSwgZXhlY0NvbnRleHQgPSBfYS5leGVjQ29udGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoZXhlY0NvbnRleHQuY29udGV4dFZhbHVlLnN0b3JlIGluc3RhbmNlb2YgRGVwVHJhY2tpbmdDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVLZXlSb290Lmxvb2t1cChleGVjQ29udGV4dC5jb250ZXh0VmFsdWUuc3RvcmUsIHNlbGVjdGlvblNldCwgZXhlY0NvbnRleHQuZnJhZ21lbnRNYXRjaGVyLCBKU09OLnN0cmluZ2lmeShleGVjQ29udGV4dC52YXJpYWJsZVZhbHVlcyksIHJvb3RWYWx1ZS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5leGVjdXRlU3ViU2VsZWN0ZWRBcnJheSA9IHdyYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBleGVjdXRlU3ViU2VsZWN0ZWRBcnJheS5jYWxsKF90aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWFrZUNhY2hlS2V5OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBfYS5maWVsZCwgYXJyYXkgPSBfYS5hcnJheSwgZXhlY0NvbnRleHQgPSBfYS5leGVjQ29udGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoZXhlY0NvbnRleHQuY29udGV4dFZhbHVlLnN0b3JlIGluc3RhbmNlb2YgRGVwVHJhY2tpbmdDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVLZXlSb290Lmxvb2t1cChleGVjQ29udGV4dC5jb250ZXh0VmFsdWUuc3RvcmUsIGZpZWxkLCBhcnJheSwgSlNPTi5zdHJpbmdpZnkoZXhlY0NvbnRleHQudmFyaWFibGVWYWx1ZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBTdG9yZVJlYWRlci5wcm90b3R5cGUucmVhZFF1ZXJ5RnJvbVN0b3JlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlmZlF1ZXJ5QWdhaW5zdFN0b3JlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyByZXR1cm5QYXJ0aWFsRGF0YTogZmFsc2UgfSkpLnJlc3VsdDtcbiAgICB9O1xuICAgIFN0b3JlUmVhZGVyLnByb3RvdHlwZS5kaWZmUXVlcnlBZ2FpbnN0U3RvcmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gX2Euc3RvcmUsIHF1ZXJ5ID0gX2EucXVlcnksIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgcHJldmlvdXNSZXN1bHQgPSBfYS5wcmV2aW91c1Jlc3VsdCwgX2IgPSBfYS5yZXR1cm5QYXJ0aWFsRGF0YSwgcmV0dXJuUGFydGlhbERhdGEgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IF9hLnJvb3RJZCwgcm9vdElkID0gX2MgPT09IHZvaWQgMCA/ICdST09UX1FVRVJZJyA6IF9jLCBmcmFnbWVudE1hdGNoZXJGdW5jdGlvbiA9IF9hLmZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uLCBjb25maWcgPSBfYS5jb25maWc7XG4gICAgICAgIHZhciBxdWVyeURlZmluaXRpb24gPSBnZXRRdWVyeURlZmluaXRpb24ocXVlcnkpO1xuICAgICAgICB2YXJpYWJsZXMgPSBhc3NpZ24oe30sIGdldERlZmF1bHRWYWx1ZXMocXVlcnlEZWZpbml0aW9uKSwgdmFyaWFibGVzKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICBzdG9yZTogc3RvcmUsXG4gICAgICAgICAgICBkYXRhSWRGcm9tT2JqZWN0OiBjb25maWcgJiYgY29uZmlnLmRhdGFJZEZyb21PYmplY3QsXG4gICAgICAgICAgICBjYWNoZVJlZGlyZWN0czogKGNvbmZpZyAmJiBjb25maWcuY2FjaGVSZWRpcmVjdHMpIHx8IHt9LFxuICAgICAgICB9O1xuICAgICAgICB2YXIgZXhlY1Jlc3VsdCA9IHRoaXMuZXhlY3V0ZVN0b3JlUXVlcnkoe1xuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgcm9vdFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2lkJyxcbiAgICAgICAgICAgICAgICBpZDogcm9vdElkLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlbmFtZTogJ1F1ZXJ5JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZXh0VmFsdWU6IGNvbnRleHQsXG4gICAgICAgICAgICB2YXJpYWJsZVZhbHVlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgZnJhZ21lbnRNYXRjaGVyOiBmcmFnbWVudE1hdGNoZXJGdW5jdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBoYXNNaXNzaW5nRmllbGRzID0gZXhlY1Jlc3VsdC5taXNzaW5nICYmIGV4ZWNSZXN1bHQubWlzc2luZy5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoaGFzTWlzc2luZ0ZpZWxkcyAmJiAhcmV0dXJuUGFydGlhbERhdGEpIHtcbiAgICAgICAgICAgIGV4ZWNSZXN1bHQubWlzc2luZy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8udG9sZXJhYmxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbmV3IEludmFyaWFudEVycm9yKDgpIDogbmV3IEludmFyaWFudEVycm9yKFwiQ2FuJ3QgZmluZCBmaWVsZCBcIiArIGluZm8uZmllbGROYW1lICsgXCIgb24gb2JqZWN0IFwiICsgSlNPTi5zdHJpbmdpZnkoaW5mby5vYmplY3QsIG51bGwsIDIpICsgXCIuXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZpb3VzUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoaXNFcXVhbChwcmV2aW91c1Jlc3VsdCwgZXhlY1Jlc3VsdC5yZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgZXhlY1Jlc3VsdC5yZXN1bHQgPSBwcmV2aW91c1Jlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBleGVjUmVzdWx0LnJlc3VsdCxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAhaGFzTWlzc2luZ0ZpZWxkcyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFN0b3JlUmVhZGVyLnByb3RvdHlwZS5leGVjdXRlU3RvcmVRdWVyeSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgcXVlcnkgPSBfYS5xdWVyeSwgcm9vdFZhbHVlID0gX2Eucm9vdFZhbHVlLCBjb250ZXh0VmFsdWUgPSBfYS5jb250ZXh0VmFsdWUsIHZhcmlhYmxlVmFsdWVzID0gX2EudmFyaWFibGVWYWx1ZXMsIF9iID0gX2EuZnJhZ21lbnRNYXRjaGVyLCBmcmFnbWVudE1hdGNoZXIgPSBfYiA9PT0gdm9pZCAwID8gZGVmYXVsdEZyYWdtZW50TWF0Y2hlciA6IF9iO1xuICAgICAgICB2YXIgbWFpbkRlZmluaXRpb24gPSBnZXRNYWluRGVmaW5pdGlvbihxdWVyeSk7XG4gICAgICAgIHZhciBmcmFnbWVudHMgPSBnZXRGcmFnbWVudERlZmluaXRpb25zKHF1ZXJ5KTtcbiAgICAgICAgdmFyIGZyYWdtZW50TWFwID0gY3JlYXRlRnJhZ21lbnRNYXAoZnJhZ21lbnRzKTtcbiAgICAgICAgdmFyIGV4ZWNDb250ZXh0ID0ge1xuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgZnJhZ21lbnRNYXA6IGZyYWdtZW50TWFwLFxuICAgICAgICAgICAgY29udGV4dFZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgICAgICAgICB2YXJpYWJsZVZhbHVlczogdmFyaWFibGVWYWx1ZXMsXG4gICAgICAgICAgICBmcmFnbWVudE1hdGNoZXI6IGZyYWdtZW50TWF0Y2hlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVNlbGVjdGlvblNldCh7XG4gICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IG1haW5EZWZpbml0aW9uLnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgIHJvb3RWYWx1ZTogcm9vdFZhbHVlLFxuICAgICAgICAgICAgZXhlY0NvbnRleHQ6IGV4ZWNDb250ZXh0LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0b3JlUmVhZGVyLnByb3RvdHlwZS5leGVjdXRlU2VsZWN0aW9uU2V0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxlY3Rpb25TZXQgPSBfYS5zZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSA9IF9hLnJvb3RWYWx1ZSwgZXhlY0NvbnRleHQgPSBfYS5leGVjQ29udGV4dDtcbiAgICAgICAgdmFyIGZyYWdtZW50TWFwID0gZXhlY0NvbnRleHQuZnJhZ21lbnRNYXAsIGNvbnRleHRWYWx1ZSA9IGV4ZWNDb250ZXh0LmNvbnRleHRWYWx1ZSwgdmFyaWFibGVzID0gZXhlY0NvbnRleHQudmFyaWFibGVWYWx1ZXM7XG4gICAgICAgIHZhciBmaW5hbFJlc3VsdCA9IHsgcmVzdWx0OiBudWxsIH07XG4gICAgICAgIHZhciBvYmplY3RzVG9NZXJnZSA9IFtdO1xuICAgICAgICB2YXIgb2JqZWN0ID0gY29udGV4dFZhbHVlLnN0b3JlLmdldChyb290VmFsdWUuaWQpO1xuICAgICAgICB2YXIgdHlwZW5hbWUgPSAob2JqZWN0ICYmIG9iamVjdC5fX3R5cGVuYW1lKSB8fFxuICAgICAgICAgICAgKHJvb3RWYWx1ZS5pZCA9PT0gJ1JPT1RfUVVFUlknICYmICdRdWVyeScpIHx8XG4gICAgICAgICAgICB2b2lkIDA7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1pc3NpbmcocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdC5taXNzaW5nID0gZmluYWxSZXN1bHQubWlzc2luZyB8fCBbXTtcbiAgICAgICAgICAgICAgICAoX2EgPSBmaW5hbFJlc3VsdC5taXNzaW5nKS5wdXNoLmFwcGx5KF9hLCByZXN1bHQubWlzc2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghc2hvdWxkSW5jbHVkZShzZWxlY3Rpb24sIHZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNGaWVsZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkUmVzdWx0ID0gaGFuZGxlTWlzc2luZyhfdGhpcy5leGVjdXRlRmllbGQob2JqZWN0LCB0eXBlbmFtZSwgc2VsZWN0aW9uLCBleGVjQ29udGV4dCkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGRSZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdHNUb01lcmdlLnB1c2goKF9hID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBfYVtyZXN1bHRLZXlOYW1lRnJvbUZpZWxkKHNlbGVjdGlvbildID0gZmllbGRSZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbmxpbmVGcmFnbWVudChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudE1hcFtzZWxlY3Rpb24ubmFtZS52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG5ldyBJbnZhcmlhbnRFcnJvcig5KSA6IG5ldyBJbnZhcmlhbnRFcnJvcihcIk5vIGZyYWdtZW50IG5hbWVkIFwiICsgc2VsZWN0aW9uLm5hbWUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0eXBlQ29uZGl0aW9uID0gZnJhZ21lbnQudHlwZUNvbmRpdGlvbiAmJiBmcmFnbWVudC50eXBlQ29uZGl0aW9uLm5hbWUudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gIXR5cGVDb25kaXRpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgZXhlY0NvbnRleHQuZnJhZ21lbnRNYXRjaGVyKHJvb3RWYWx1ZSwgdHlwZUNvbmRpdGlvbiwgY29udGV4dFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50RXhlY1Jlc3VsdCA9IF90aGlzLmV4ZWN1dGVTZWxlY3Rpb25TZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBmcmFnbWVudC5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICByb290VmFsdWU6IHJvb3RWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNDb250ZXh0OiBleGVjQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gJ2hldXJpc3RpYycgJiYgZnJhZ21lbnRFeGVjUmVzdWx0Lm1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50RXhlY1Jlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBmcmFnbWVudEV4ZWNSZXN1bHQpLCB7IG1pc3Npbmc6IGZyYWdtZW50RXhlY1Jlc3VsdC5taXNzaW5nLm1hcChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGluZm8pLCB7IHRvbGVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYmplY3RzVG9NZXJnZS5wdXNoKGhhbmRsZU1pc3NpbmcoZnJhZ21lbnRFeGVjUmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZmluYWxSZXN1bHQucmVzdWx0ID0gbWVyZ2VEZWVwQXJyYXkob2JqZWN0c1RvTWVyZ2UpO1xuICAgICAgICBpZiAodGhpcy5mcmVlemVSZXN1bHRzICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUoZmluYWxSZXN1bHQucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluYWxSZXN1bHQ7XG4gICAgfTtcbiAgICBTdG9yZVJlYWRlci5wcm90b3R5cGUuZXhlY3V0ZUZpZWxkID0gZnVuY3Rpb24gKG9iamVjdCwgdHlwZW5hbWUsIGZpZWxkLCBleGVjQ29udGV4dCkge1xuICAgICAgICB2YXIgdmFyaWFibGVzID0gZXhlY0NvbnRleHQudmFyaWFibGVWYWx1ZXMsIGNvbnRleHRWYWx1ZSA9IGV4ZWNDb250ZXh0LmNvbnRleHRWYWx1ZTtcbiAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWUudmFsdWU7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzT2JqZWN0RnJvbUZpZWxkKGZpZWxkLCB2YXJpYWJsZXMpO1xuICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHJlc3VsdEtleTogcmVzdWx0S2V5TmFtZUZyb21GaWVsZChmaWVsZCksXG4gICAgICAgICAgICBkaXJlY3RpdmVzOiBnZXREaXJlY3RpdmVJbmZvRnJvbUZpZWxkKGZpZWxkLCB2YXJpYWJsZXMpLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVhZFN0b3JlUmVzdWx0ID0gcmVhZFN0b3JlUmVzb2x2ZXIob2JqZWN0LCB0eXBlbmFtZSwgZmllbGROYW1lLCBhcmdzLCBjb250ZXh0VmFsdWUsIGluZm8pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWFkU3RvcmVSZXN1bHQucmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tYmluZUV4ZWNSZXN1bHRzKHJlYWRTdG9yZVJlc3VsdCwgdGhpcy5leGVjdXRlU3ViU2VsZWN0ZWRBcnJheSh7XG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgIGFycmF5OiByZWFkU3RvcmVSZXN1bHQucmVzdWx0LFxuICAgICAgICAgICAgICAgIGV4ZWNDb250ZXh0OiBleGVjQ29udGV4dCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZpZWxkLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgYXNzZXJ0U2VsZWN0aW9uU2V0Rm9ySWRWYWx1ZShmaWVsZCwgcmVhZFN0b3JlUmVzdWx0LnJlc3VsdCk7XG4gICAgICAgICAgICBpZiAodGhpcy5mcmVlemVSZXN1bHRzICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtYXliZURlZXBGcmVlemUocmVhZFN0b3JlUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWFkU3RvcmVSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWRTdG9yZVJlc3VsdC5yZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRTdG9yZVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21iaW5lRXhlY1Jlc3VsdHMocmVhZFN0b3JlUmVzdWx0LCB0aGlzLmV4ZWN1dGVTZWxlY3Rpb25TZXQoe1xuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBmaWVsZC5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgICByb290VmFsdWU6IHJlYWRTdG9yZVJlc3VsdC5yZXN1bHQsXG4gICAgICAgICAgICBleGVjQ29udGV4dDogZXhlY0NvbnRleHQsXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIFN0b3JlUmVhZGVyLnByb3RvdHlwZS5jb21iaW5lRXhlY1Jlc3VsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBleGVjUmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgZXhlY1Jlc3VsdHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWlzc2luZztcbiAgICAgICAgZXhlY1Jlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAoZXhlY1Jlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGV4ZWNSZXN1bHQubWlzc2luZykge1xuICAgICAgICAgICAgICAgIG1pc3NpbmcgPSBtaXNzaW5nIHx8IFtdO1xuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaC5hcHBseShtaXNzaW5nLCBleGVjUmVzdWx0Lm1pc3NpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogZXhlY1Jlc3VsdHMucG9wKCkucmVzdWx0LFxuICAgICAgICAgICAgbWlzc2luZzogbWlzc2luZyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFN0b3JlUmVhZGVyLnByb3RvdHlwZS5leGVjdXRlU3ViU2VsZWN0ZWRBcnJheSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmllbGQgPSBfYS5maWVsZCwgYXJyYXkgPSBfYS5hcnJheSwgZXhlY0NvbnRleHQgPSBfYS5leGVjQ29udGV4dDtcbiAgICAgICAgdmFyIG1pc3Npbmc7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1pc3NpbmcoY2hpbGRSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZFJlc3VsdC5taXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZyA9IG1pc3NpbmcgfHwgW107XG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoLmFwcGx5KG1pc3NpbmcsIGNoaWxkUmVzdWx0Lm1pc3NpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBhcnJheSA9IGFycmF5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU1pc3NpbmcoX3RoaXMuZXhlY3V0ZVN1YlNlbGVjdGVkQXJyYXkoe1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIGFycmF5OiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBleGVjQ29udGV4dDogZXhlY0NvbnRleHQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZWxkLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVNaXNzaW5nKF90aGlzLmV4ZWN1dGVTZWxlY3Rpb25TZXQoe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IGZpZWxkLnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgICAgICAgICAgcm9vdFZhbHVlOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBleGVjQ29udGV4dDogZXhlY0NvbnRleHQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0U2VsZWN0aW9uU2V0Rm9ySWRWYWx1ZShmaWVsZCwgaXRlbSk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmZyZWV6ZVJlc3VsdHMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBhcnJheSwgbWlzc2luZzogbWlzc2luZyB9O1xuICAgIH07XG4gICAgcmV0dXJuIFN0b3JlUmVhZGVyO1xufSgpKTtcbmZ1bmN0aW9uIGFzc2VydFNlbGVjdGlvblNldEZvcklkVmFsdWUoZmllbGQsIHZhbHVlKSB7XG4gICAgaWYgKCFmaWVsZC5zZWxlY3Rpb25TZXQgJiYgaXNJZFZhbHVlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZXcgSW52YXJpYW50RXJyb3IoMTApIDogbmV3IEludmFyaWFudEVycm9yKFwiTWlzc2luZyBzZWxlY3Rpb24gc2V0IGZvciBvYmplY3Qgb2YgdHlwZSBcIiArIHZhbHVlLnR5cGVuYW1lICsgXCIgcmV0dXJuZWQgZm9yIHF1ZXJ5IGZpZWxkIFwiICsgZmllbGQubmFtZS52YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVmYXVsdEZyYWdtZW50TWF0Y2hlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydElkVmFsdWUoaWRWYWx1ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChpc0lkVmFsdWUoaWRWYWx1ZSksIDExKSA6IGludmFyaWFudChpc0lkVmFsdWUoaWRWYWx1ZSksIFwiRW5jb3VudGVyZWQgYSBzdWItc2VsZWN0aW9uIG9uIHRoZSBxdWVyeSwgYnV0IHRoZSBzdG9yZSBkb2Vzbid0IGhhdmUgYW4gb2JqZWN0IHJlZmVyZW5jZS4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIGR1cmluZyBub3JtYWwgdXNlIHVubGVzcyB5b3UgaGF2ZSBjdXN0b20gY29kZSB0aGF0IGlzIGRpcmVjdGx5IG1hbmlwdWxhdGluZyB0aGUgc3RvcmU7IHBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbn1cbmZ1bmN0aW9uIHJlYWRTdG9yZVJlc29sdmVyKG9iamVjdCwgdHlwZW5hbWUsIGZpZWxkTmFtZSwgYXJncywgY29udGV4dCwgX2EpIHtcbiAgICB2YXIgcmVzdWx0S2V5ID0gX2EucmVzdWx0S2V5LCBkaXJlY3RpdmVzID0gX2EuZGlyZWN0aXZlcztcbiAgICB2YXIgc3RvcmVLZXlOYW1lID0gZmllbGROYW1lO1xuICAgIGlmIChhcmdzIHx8IGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgc3RvcmVLZXlOYW1lID0gZ2V0U3RvcmVLZXlOYW1lKHN0b3JlS2V5TmFtZSwgYXJncywgZGlyZWN0aXZlcyk7XG4gICAgfVxuICAgIHZhciBmaWVsZFZhbHVlID0gdm9pZCAwO1xuICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgZmllbGRWYWx1ZSA9IG9iamVjdFtzdG9yZUtleU5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkVmFsdWUgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBjb250ZXh0LmNhY2hlUmVkaXJlY3RzICYmXG4gICAgICAgICAgICB0eXBlb2YgdHlwZW5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGNvbnRleHQuY2FjaGVSZWRpcmVjdHNbdHlwZW5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZXIgPSB0eXBlW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSByZXNvbHZlcihvYmplY3QsIGFyZ3MsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENhY2hlS2V5OiBmdW5jdGlvbiAoc3RvcmVPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBjb250ZXh0LmRhdGFJZEZyb21PYmplY3Qoc3RvcmVPYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZCAmJiB0b0lkVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVuYW1lOiBzdG9yZU9iai5fX3R5cGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZmllbGRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogZmllbGRWYWx1ZSxcbiAgICAgICAgICAgIG1pc3Npbmc6IFt7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IHN0b3JlS2V5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzSnNvblZhbHVlKGZpZWxkVmFsdWUpKSB7XG4gICAgICAgIGZpZWxkVmFsdWUgPSBmaWVsZFZhbHVlLmpzb247XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogZmllbGRWYWx1ZSxcbiAgICB9O1xufVxuXG52YXIgT2JqZWN0Q2FjaGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9iamVjdENhY2hlKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkgeyBkYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBPYmplY3RDYWNoZS5wcm90b3R5cGUudG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfTtcbiAgICBPYmplY3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2RhdGFJZF07XG4gICAgfTtcbiAgICBPYmplY3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGRhdGFJZCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYXRhW2RhdGFJZF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIE9iamVjdENhY2hlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHRoaXMuZGF0YVtkYXRhSWRdID0gdm9pZCAwO1xuICAgIH07XG4gICAgT2JqZWN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG4gICAgT2JqZWN0Q2FjaGUucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXdEYXRhIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JqZWN0Q2FjaGU7XG59KCkpO1xuZnVuY3Rpb24gZGVmYXVsdE5vcm1hbGl6ZWRDYWNoZUZhY3RvcnkkMShzZWVkKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RDYWNoZShzZWVkKTtcbn1cblxudmFyIFdyaXRlRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXcml0ZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdyaXRlRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gJ1dyaXRlRXJyb3InO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBXcml0ZUVycm9yO1xufShFcnJvcikpO1xuZnVuY3Rpb24gZW5oYW5jZUVycm9yV2l0aERvY3VtZW50KGVycm9yLCBkb2N1bWVudCkge1xuICAgIHZhciBlbmhhbmNlZEVycm9yID0gbmV3IFdyaXRlRXJyb3IoXCJFcnJvciB3cml0aW5nIHJlc3VsdCB0byBzdG9yZSBmb3IgcXVlcnk6XFxuIFwiICsgSlNPTi5zdHJpbmdpZnkoZG9jdW1lbnQpKTtcbiAgICBlbmhhbmNlZEVycm9yLm1lc3NhZ2UgKz0gJ1xcbicgKyBlcnJvci5tZXNzYWdlO1xuICAgIGVuaGFuY2VkRXJyb3Iuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICByZXR1cm4gZW5oYW5jZWRFcnJvcjtcbn1cbnZhciBTdG9yZVdyaXRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RvcmVXcml0ZXIoKSB7XG4gICAgfVxuICAgIFN0b3JlV3JpdGVyLnByb3RvdHlwZS53cml0ZVF1ZXJ5VG9TdG9yZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgcXVlcnkgPSBfYS5xdWVyeSwgcmVzdWx0ID0gX2EucmVzdWx0LCBfYiA9IF9hLnN0b3JlLCBzdG9yZSA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0Tm9ybWFsaXplZENhY2hlRmFjdG9yeSgpIDogX2IsIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgZGF0YUlkRnJvbU9iamVjdCA9IF9hLmRhdGFJZEZyb21PYmplY3QsIGZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uID0gX2EuZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb247XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlUmVzdWx0VG9TdG9yZSh7XG4gICAgICAgICAgICBkYXRhSWQ6ICdST09UX1FVRVJZJyxcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgZG9jdW1lbnQ6IHF1ZXJ5LFxuICAgICAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICBkYXRhSWRGcm9tT2JqZWN0OiBkYXRhSWRGcm9tT2JqZWN0LFxuICAgICAgICAgICAgZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb246IGZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0b3JlV3JpdGVyLnByb3RvdHlwZS53cml0ZVJlc3VsdFRvU3RvcmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRhdGFJZCA9IF9hLmRhdGFJZCwgcmVzdWx0ID0gX2EucmVzdWx0LCBkb2N1bWVudCA9IF9hLmRvY3VtZW50LCBfYiA9IF9hLnN0b3JlLCBzdG9yZSA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0Tm9ybWFsaXplZENhY2hlRmFjdG9yeSgpIDogX2IsIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgZGF0YUlkRnJvbU9iamVjdCA9IF9hLmRhdGFJZEZyb21PYmplY3QsIGZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uID0gX2EuZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb247XG4gICAgICAgIHZhciBvcGVyYXRpb25EZWZpbml0aW9uID0gZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbihkb2N1bWVudCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cml0ZVNlbGVjdGlvblNldFRvU3RvcmUoe1xuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGRhdGFJZDogZGF0YUlkLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblNldDogb3BlcmF0aW9uRGVmaW5pdGlvbi5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZTogc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZERhdGE6IHt9LFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IGFzc2lnbih7fSwgZ2V0RGVmYXVsdFZhbHVlcyhvcGVyYXRpb25EZWZpbml0aW9uKSwgdmFyaWFibGVzKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUlkRnJvbU9iamVjdDogZGF0YUlkRnJvbU9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRNYXA6IGNyZWF0ZUZyYWdtZW50TWFwKGdldEZyYWdtZW50RGVmaW5pdGlvbnMoZG9jdW1lbnQpKSxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb246IGZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgZW5oYW5jZUVycm9yV2l0aERvY3VtZW50KGUsIGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVXcml0ZXIucHJvdG90eXBlLndyaXRlU2VsZWN0aW9uU2V0VG9TdG9yZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gX2EucmVzdWx0LCBkYXRhSWQgPSBfYS5kYXRhSWQsIHNlbGVjdGlvblNldCA9IF9hLnNlbGVjdGlvblNldCwgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSBjb250ZXh0LnZhcmlhYmxlcywgc3RvcmUgPSBjb250ZXh0LnN0b3JlLCBmcmFnbWVudE1hcCA9IGNvbnRleHQuZnJhZ21lbnRNYXA7XG4gICAgICAgIHNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRJbmNsdWRlKHNlbGVjdGlvbiwgdmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZpZWxkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0RmllbGRLZXkgPSByZXN1bHRLZXlOYW1lRnJvbUZpZWxkKHNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0W3Jlc3VsdEZpZWxkS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy53cml0ZUZpZWxkVG9TdG9yZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSWQ6IGRhdGFJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0RlZmVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQ2xpZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uZGlyZWN0aXZlcyAmJiBzZWxlY3Rpb24uZGlyZWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGVmZXJlZCA9IHNlbGVjdGlvbi5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLm5hbWUgJiYgZGlyZWN0aXZlLm5hbWUudmFsdWUgPT09ICdkZWZlcic7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDbGllbnQgPSBzZWxlY3Rpb24uZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5uYW1lICYmIGRpcmVjdGl2ZS5uYW1lLnZhbHVlID09PSAnY2xpZW50JzsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0RlZmVyZWQgJiYgIWlzQ2xpZW50ICYmIGNvbnRleHQuZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQud2FybihcIk1pc3NpbmcgZmllbGQgXCIgKyByZXN1bHRGaWVsZEtleSArIFwiIGluIFwiICsgSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAyKS5zdWJzdHJpbmcoMCwgMTAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5saW5lRnJhZ21lbnQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gKGZyYWdtZW50TWFwIHx8IHt9KVtzZWxlY3Rpb24ubmFtZS52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmcmFnbWVudCwgMykgOiBpbnZhcmlhbnQoZnJhZ21lbnQsIFwiTm8gZnJhZ21lbnQgbmFtZWQgXCIgKyBzZWxlY3Rpb24ubmFtZS52YWx1ZSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uICYmIGZyYWdtZW50LnR5cGVDb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gZGF0YUlkIHx8ICdzZWxmJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkVmFsdWUgPSB0b0lkVmFsdWUoeyBpZDogaWQsIHR5cGVuYW1lOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWtlQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlOiBuZXcgT2JqZWN0Q2FjaGUoKF9hID0ge30sIF9hW2lkXSA9IHJlc3VsdCwgX2EpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlUmVkaXJlY3RzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gY29udGV4dC5mcmFnbWVudE1hdGNoZXJGdW5jdGlvbihpZFZhbHVlLCBmcmFnbWVudC50eXBlQ29uZGl0aW9uLm5hbWUudmFsdWUsIGZha2VDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Byb2R1Y3Rpb24oKSAmJiBtYXRjaCA9PT0gJ2hldXJpc3RpYycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQuZXJyb3IoJ1dBUk5JTkc6IGhldXJpc3RpYyBmcmFnbWVudCBtYXRjaGluZyBnb2luZyBvbiEnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gISFtYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMud3JpdGVTZWxlY3Rpb25TZXRUb1N0b3JlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBmcmFnbWVudC5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSWQ6IGRhdGFJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9O1xuICAgIFN0b3JlV3JpdGVyLnByb3RvdHlwZS53cml0ZUZpZWxkVG9TdG9yZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciBmaWVsZCA9IF9hLmZpZWxkLCB2YWx1ZSA9IF9hLnZhbHVlLCBkYXRhSWQgPSBfYS5kYXRhSWQsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgdmFyaWFibGVzID0gY29udGV4dC52YXJpYWJsZXMsIGRhdGFJZEZyb21PYmplY3QgPSBjb250ZXh0LmRhdGFJZEZyb21PYmplY3QsIHN0b3JlID0gY29udGV4dC5zdG9yZTtcbiAgICAgICAgdmFyIHN0b3JlVmFsdWU7XG4gICAgICAgIHZhciBzdG9yZU9iamVjdDtcbiAgICAgICAgdmFyIHN0b3JlRmllbGROYW1lID0gc3RvcmVLZXlOYW1lRnJvbUZpZWxkKGZpZWxkLCB2YXJpYWJsZXMpO1xuICAgICAgICBpZiAoIWZpZWxkLnNlbGVjdGlvblNldCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcmVWYWx1ZSA9XG4gICAgICAgICAgICAgICAgdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ2pzb24nLCBqc29uOiB2YWx1ZSB9XG4gICAgICAgICAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgZ2VuZXJhdGVkSWQgPSBkYXRhSWQgKyBcIi5cIiArIHN0b3JlRmllbGROYW1lO1xuICAgICAgICAgICAgc3RvcmVWYWx1ZSA9IHRoaXMucHJvY2Vzc0FycmF5VmFsdWUodmFsdWUsIGdlbmVyYXRlZElkLCBmaWVsZC5zZWxlY3Rpb25TZXQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbHVlRGF0YUlkID0gZGF0YUlkICsgXCIuXCIgKyBzdG9yZUZpZWxkTmFtZTtcbiAgICAgICAgICAgIHZhciBnZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFpc0dlbmVyYXRlZElkKHZhbHVlRGF0YUlkKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlRGF0YUlkID0gJyQnICsgdmFsdWVEYXRhSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YUlkRnJvbU9iamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBzZW1hbnRpY0lkID0gZGF0YUlkRnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCFzZW1hbnRpY0lkIHx8ICFpc0dlbmVyYXRlZElkKHNlbWFudGljSWQpLCA0KSA6IGludmFyaWFudCghc2VtYW50aWNJZCB8fCAhaXNHZW5lcmF0ZWRJZChzZW1hbnRpY0lkKSwgJ0lEcyByZXR1cm5lZCBieSBkYXRhSWRGcm9tT2JqZWN0IGNhbm5vdCBiZWdpbiB3aXRoIHRoZSBcIiRcIiBjaGFyYWN0ZXIuJyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbWFudGljSWQgfHxcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBzZW1hbnRpY0lkID09PSAnbnVtYmVyJyAmJiBzZW1hbnRpY0lkID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZURhdGFJZCA9IHNlbWFudGljSWQ7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNEYXRhUHJvY2Vzc2VkKHZhbHVlRGF0YUlkLCBmaWVsZCwgY29udGV4dC5wcm9jZXNzZWREYXRhKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVTZWxlY3Rpb25TZXRUb1N0b3JlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUlkOiB2YWx1ZURhdGFJZCxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBmaWVsZC5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHlwZW5hbWUgPSB2YWx1ZS5fX3R5cGVuYW1lO1xuICAgICAgICAgICAgc3RvcmVWYWx1ZSA9IHRvSWRWYWx1ZSh7IGlkOiB2YWx1ZURhdGFJZCwgdHlwZW5hbWU6IHR5cGVuYW1lIH0sIGdlbmVyYXRlZCk7XG4gICAgICAgICAgICBzdG9yZU9iamVjdCA9IHN0b3JlLmdldChkYXRhSWQpO1xuICAgICAgICAgICAgdmFyIGVzY2FwZWRJZCA9IHN0b3JlT2JqZWN0ICYmIHN0b3JlT2JqZWN0W3N0b3JlRmllbGROYW1lXTtcbiAgICAgICAgICAgIGlmIChlc2NhcGVkSWQgIT09IHN0b3JlVmFsdWUgJiYgaXNJZFZhbHVlKGVzY2FwZWRJZCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFkVHlwZW5hbWUgPSBlc2NhcGVkSWQudHlwZW5hbWUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgaGFzVHlwZW5hbWUgPSB0eXBlbmFtZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlbmFtZUNoYW5nZWQgPSBoYWRUeXBlbmFtZSAmJiBoYXNUeXBlbmFtZSAmJiBlc2NhcGVkSWQudHlwZW5hbWUgIT09IHR5cGVuYW1lO1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCghZ2VuZXJhdGVkIHx8IGVzY2FwZWRJZC5nZW5lcmF0ZWQgfHwgdHlwZW5hbWVDaGFuZ2VkLCA1KSA6IGludmFyaWFudCghZ2VuZXJhdGVkIHx8IGVzY2FwZWRJZC5nZW5lcmF0ZWQgfHwgdHlwZW5hbWVDaGFuZ2VkLCBcIlN0b3JlIGVycm9yOiB0aGUgYXBwbGljYXRpb24gYXR0ZW1wdGVkIHRvIHdyaXRlIGFuIG9iamVjdCB3aXRoIG5vIHByb3ZpZGVkIGlkIGJ1dCB0aGUgc3RvcmUgYWxyZWFkeSBjb250YWlucyBhbiBpZCBvZiBcIiArIGVzY2FwZWRJZC5pZCArIFwiIGZvciB0aGlzIG9iamVjdC4gVGhlIHNlbGVjdGlvblNldCB0aGF0IHdhcyB0cnlpbmcgdG8gYmUgd3JpdHRlbiBpczpcXG5cIiArIEpTT04uc3RyaW5naWZ5KGZpZWxkKSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCFoYWRUeXBlbmFtZSB8fCBoYXNUeXBlbmFtZSwgNikgOiBpbnZhcmlhbnQoIWhhZFR5cGVuYW1lIHx8IGhhc1R5cGVuYW1lLCBcIlN0b3JlIGVycm9yOiB0aGUgYXBwbGljYXRpb24gYXR0ZW1wdGVkIHRvIHdyaXRlIGFuIG9iamVjdCB3aXRoIG5vIHByb3ZpZGVkIHR5cGVuYW1lIGJ1dCB0aGUgc3RvcmUgYWxyZWFkeSBjb250YWlucyBhbiBvYmplY3Qgd2l0aCB0eXBlbmFtZSBvZiBcIiArIGVzY2FwZWRJZC50eXBlbmFtZSArIFwiIGZvciB0aGUgb2JqZWN0IG9mIGlkIFwiICsgZXNjYXBlZElkLmlkICsgXCIuIFRoZSBzZWxlY3Rpb25TZXQgdGhhdCB3YXMgdHJ5aW5nIHRvIGJlIHdyaXR0ZW4gaXM6XFxuXCIgKyBKU09OLnN0cmluZ2lmeShmaWVsZCkpO1xuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVkSWQuZ2VuZXJhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlbmFtZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZ2VuZXJhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGVsZXRlKGVzY2FwZWRJZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZVdpdGhHZW5lcmF0ZWQoZXNjYXBlZElkLmlkLCBzdG9yZVZhbHVlLmlkLCBzdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmVPYmplY3QgPSBzdG9yZS5nZXQoZGF0YUlkKTtcbiAgICAgICAgaWYgKCFzdG9yZU9iamVjdCB8fCAhaXNFcXVhbChzdG9yZVZhbHVlLCBzdG9yZU9iamVjdFtzdG9yZUZpZWxkTmFtZV0pKSB7XG4gICAgICAgICAgICBzdG9yZS5zZXQoZGF0YUlkLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RvcmVPYmplY3QpLCAoX2IgPSB7fSwgX2Jbc3RvcmVGaWVsZE5hbWVdID0gc3RvcmVWYWx1ZSwgX2IpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlV3JpdGVyLnByb3RvdHlwZS5wcm9jZXNzQXJyYXlWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZ2VuZXJhdGVkSWQsIHNlbGVjdGlvblNldCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpdGVtRGF0YUlkID0gZ2VuZXJhdGVkSWQgKyBcIi5cIiArIGluZGV4O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvY2Vzc0FycmF5VmFsdWUoaXRlbSwgaXRlbURhdGFJZCwgc2VsZWN0aW9uU2V0LCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBnZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGF0YUlkRnJvbU9iamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBzZW1hbnRpY0lkID0gY29udGV4dC5kYXRhSWRGcm9tT2JqZWN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChzZW1hbnRpY0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1EYXRhSWQgPSBzZW1hbnRpY0lkO1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRGF0YVByb2Nlc3NlZChpdGVtRGF0YUlkLCBzZWxlY3Rpb25TZXQsIGNvbnRleHQucHJvY2Vzc2VkRGF0YSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53cml0ZVNlbGVjdGlvblNldFRvU3RvcmUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhSWQ6IGl0ZW1EYXRhSWQsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBzZWxlY3Rpb25TZXQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9JZFZhbHVlKHsgaWQ6IGl0ZW1EYXRhSWQsIHR5cGVuYW1lOiBpdGVtLl9fdHlwZW5hbWUgfSwgZ2VuZXJhdGVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RvcmVXcml0ZXI7XG59KCkpO1xuZnVuY3Rpb24gaXNHZW5lcmF0ZWRJZChpZCkge1xuICAgIHJldHVybiBpZFswXSA9PT0gJyQnO1xufVxuZnVuY3Rpb24gbWVyZ2VXaXRoR2VuZXJhdGVkKGdlbmVyYXRlZEtleSwgcmVhbEtleSwgY2FjaGUpIHtcbiAgICBpZiAoZ2VuZXJhdGVkS2V5ID09PSByZWFsS2V5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGdlbmVyYXRlZCA9IGNhY2hlLmdldChnZW5lcmF0ZWRLZXkpO1xuICAgIHZhciByZWFsID0gY2FjaGUuZ2V0KHJlYWxLZXkpO1xuICAgIHZhciBtYWRlQ2hhbmdlcyA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKGdlbmVyYXRlZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdlbmVyYXRlZFtrZXldO1xuICAgICAgICB2YXIgcmVhbFZhbHVlID0gcmVhbFtrZXldO1xuICAgICAgICBpZiAoaXNJZFZhbHVlKHZhbHVlKSAmJlxuICAgICAgICAgICAgaXNHZW5lcmF0ZWRJZCh2YWx1ZS5pZCkgJiZcbiAgICAgICAgICAgIGlzSWRWYWx1ZShyZWFsVmFsdWUpICYmXG4gICAgICAgICAgICAhaXNFcXVhbCh2YWx1ZSwgcmVhbFZhbHVlKSAmJlxuICAgICAgICAgICAgbWVyZ2VXaXRoR2VuZXJhdGVkKHZhbHVlLmlkLCByZWFsVmFsdWUuaWQsIGNhY2hlKSkge1xuICAgICAgICAgICAgbWFkZUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY2FjaGUuZGVsZXRlKGdlbmVyYXRlZEtleSk7XG4gICAgdmFyIG5ld1JlYWxWYWx1ZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZW5lcmF0ZWQpLCByZWFsKTtcbiAgICBpZiAoaXNFcXVhbChuZXdSZWFsVmFsdWUsIHJlYWwpKSB7XG4gICAgICAgIHJldHVybiBtYWRlQ2hhbmdlcztcbiAgICB9XG4gICAgY2FjaGUuc2V0KHJlYWxLZXksIG5ld1JlYWxWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc0RhdGFQcm9jZXNzZWQoZGF0YUlkLCBmaWVsZCwgcHJvY2Vzc2VkRGF0YSkge1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzZWREYXRhW2RhdGFJZF0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3NlZERhdGFbZGF0YUlkXS5pbmRleE9mKGZpZWxkKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGFbZGF0YUlkXS5wdXNoKGZpZWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc2VkRGF0YVtkYXRhSWRdID0gW2ZpZWxkXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBmcmFnbWVudE1hdGNoZXI6IG5ldyBIZXVyaXN0aWNGcmFnbWVudE1hdGNoZXIoKSxcbiAgICBkYXRhSWRGcm9tT2JqZWN0OiBkZWZhdWx0RGF0YUlkRnJvbU9iamVjdCxcbiAgICBhZGRUeXBlbmFtZTogdHJ1ZSxcbiAgICByZXN1bHRDYWNoaW5nOiB0cnVlLFxuICAgIGZyZWV6ZVJlc3VsdHM6IGZhbHNlLFxufTtcbmZ1bmN0aW9uIGRlZmF1bHREYXRhSWRGcm9tT2JqZWN0KHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuX190eXBlbmFtZSkge1xuICAgICAgICBpZiAocmVzdWx0LmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuX190eXBlbmFtZSArIFwiOlwiICsgcmVzdWx0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuX190eXBlbmFtZSArIFwiOlwiICsgcmVzdWx0Ll9pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbnZhciBoYXNPd24kMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgT3B0aW1pc3RpY0NhY2hlTGF5ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPcHRpbWlzdGljQ2FjaGVMYXllciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPcHRpbWlzdGljQ2FjaGVMYXllcihvcHRpbWlzdGljSWQsIHBhcmVudCwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgT2JqZWN0LmNyZWF0ZShudWxsKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3B0aW1pc3RpY0lkID0gb3B0aW1pc3RpY0lkO1xuICAgICAgICBfdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIF90aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT3B0aW1pc3RpY0NhY2hlTGF5ZXIucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMucGFyZW50LnRvT2JqZWN0KCkpLCB0aGlzLmRhdGEpO1xuICAgIH07XG4gICAgT3B0aW1pc3RpY0NhY2hlTGF5ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc093biQxLmNhbGwodGhpcy5kYXRhLCBkYXRhSWQpXG4gICAgICAgICAgICA/IHRoaXMuZGF0YVtkYXRhSWRdXG4gICAgICAgICAgICA6IHRoaXMucGFyZW50LmdldChkYXRhSWQpO1xuICAgIH07XG4gICAgcmV0dXJuIE9wdGltaXN0aWNDYWNoZUxheWVyO1xufShPYmplY3RDYWNoZSkpO1xudmFyIEluTWVtb3J5Q2FjaGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbk1lbW9yeUNhY2hlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluTWVtb3J5Q2FjaGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy53YXRjaGVzID0gbmV3IFNldCgpO1xuICAgICAgICBfdGhpcy50eXBlbmFtZURvY3VtZW50Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLmNhY2hlS2V5Um9vdCA9IG5ldyBLZXlUcmllKGNhblVzZVdlYWtNYXApO1xuICAgICAgICBfdGhpcy5zaWxlbmNlQnJvYWRjYXN0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmNvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0Q29uZmlnKSwgY29uZmlnKTtcbiAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5jdXN0b21SZXNvbHZlcnMpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQud2FybignY3VzdG9tUmVzb2x2ZXJzIGhhdmUgYmVlbiByZW5hbWVkIHRvIGNhY2hlUmVkaXJlY3RzLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29uZmlnIGFzIHdlIHdpbGwgYmUgZGVwcmVjYXRpbmcgY3VzdG9tUmVzb2x2ZXJzIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uJyk7XG4gICAgICAgICAgICBfdGhpcy5jb25maWcuY2FjaGVSZWRpcmVjdHMgPSBfdGhpcy5jb25maWcuY3VzdG9tUmVzb2x2ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpcy5jb25maWcuY2FjaGVSZXNvbHZlcnMpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCBpbnZhcmlhbnQud2FybignY2FjaGVSZXNvbHZlcnMgaGF2ZSBiZWVuIHJlbmFtZWQgdG8gY2FjaGVSZWRpcmVjdHMuIFBsZWFzZSB1cGRhdGUgeW91ciBjb25maWcgYXMgd2Ugd2lsbCBiZSBkZXByZWNhdGluZyBjYWNoZVJlc29sdmVycyBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLicpO1xuICAgICAgICAgICAgX3RoaXMuY29uZmlnLmNhY2hlUmVkaXJlY3RzID0gX3RoaXMuY29uZmlnLmNhY2hlUmVzb2x2ZXJzO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmFkZFR5cGVuYW1lID0gISFfdGhpcy5jb25maWcuYWRkVHlwZW5hbWU7XG4gICAgICAgIF90aGlzLmRhdGEgPSBfdGhpcy5jb25maWcucmVzdWx0Q2FjaGluZ1xuICAgICAgICAgICAgPyBuZXcgRGVwVHJhY2tpbmdDYWNoZSgpXG4gICAgICAgICAgICA6IG5ldyBPYmplY3RDYWNoZSgpO1xuICAgICAgICBfdGhpcy5vcHRpbWlzdGljRGF0YSA9IF90aGlzLmRhdGE7XG4gICAgICAgIF90aGlzLnN0b3JlV3JpdGVyID0gbmV3IFN0b3JlV3JpdGVyKCk7XG4gICAgICAgIF90aGlzLnN0b3JlUmVhZGVyID0gbmV3IFN0b3JlUmVhZGVyKHtcbiAgICAgICAgICAgIGNhY2hlS2V5Um9vdDogX3RoaXMuY2FjaGVLZXlSb290LFxuICAgICAgICAgICAgZnJlZXplUmVzdWx0czogY29uZmlnLmZyZWV6ZVJlc3VsdHMsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2FjaGUgPSBfdGhpcztcbiAgICAgICAgdmFyIG1heWJlQnJvYWRjYXN0V2F0Y2ggPSBjYWNoZS5tYXliZUJyb2FkY2FzdFdhdGNoO1xuICAgICAgICBfdGhpcy5tYXliZUJyb2FkY2FzdFdhdGNoID0gd3JhcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIG1heWJlQnJvYWRjYXN0V2F0Y2guY2FsbChfdGhpcywgYyk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1ha2VDYWNoZUtleTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5vcHRpbWlzdGljKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMucHJldmlvdXNSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FjaGUuZGF0YSBpbnN0YW5jZW9mIERlcFRyYWNraW5nQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmNhY2hlS2V5Um9vdC5sb29rdXAoYy5xdWVyeSwgSlNPTi5zdHJpbmdpZnkoYy52YXJpYWJsZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSlcbiAgICAgICAgICAgIHRoaXMuZGF0YS5yZXBsYWNlKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAob3B0aW1pc3RpYykge1xuICAgICAgICBpZiAob3B0aW1pc3RpYyA9PT0gdm9pZCAwKSB7IG9wdGltaXN0aWMgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gKG9wdGltaXN0aWMgPyB0aGlzLm9wdGltaXN0aWNEYXRhIDogdGhpcy5kYXRhKS50b09iamVjdCgpO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yb290SWQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5kYXRhLmdldChvcHRpb25zLnJvb3RJZCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJhZ21lbnRNYXRjaGVyID0gdGhpcy5jb25maWcuZnJhZ21lbnRNYXRjaGVyO1xuICAgICAgICB2YXIgZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24gPSBmcmFnbWVudE1hdGNoZXIgJiYgZnJhZ21lbnRNYXRjaGVyLm1hdGNoO1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZVJlYWRlci5yZWFkUXVlcnlGcm9tU3RvcmUoe1xuICAgICAgICAgICAgc3RvcmU6IG9wdGlvbnMub3B0aW1pc3RpYyA/IHRoaXMub3B0aW1pc3RpY0RhdGEgOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICBxdWVyeTogdGhpcy50cmFuc2Zvcm1Eb2N1bWVudChvcHRpb25zLnF1ZXJ5KSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICByb290SWQ6IG9wdGlvbnMucm9vdElkLFxuICAgICAgICAgICAgZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb246IGZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uLFxuICAgICAgICAgICAgcHJldmlvdXNSZXN1bHQ6IG9wdGlvbnMucHJldmlvdXNSZXN1bHQsXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KSB8fCBudWxsO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAod3JpdGUpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50TWF0Y2hlciA9IHRoaXMuY29uZmlnLmZyYWdtZW50TWF0Y2hlcjtcbiAgICAgICAgdmFyIGZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uID0gZnJhZ21lbnRNYXRjaGVyICYmIGZyYWdtZW50TWF0Y2hlci5tYXRjaDtcbiAgICAgICAgdGhpcy5zdG9yZVdyaXRlci53cml0ZVJlc3VsdFRvU3RvcmUoe1xuICAgICAgICAgICAgZGF0YUlkOiB3cml0ZS5kYXRhSWQsXG4gICAgICAgICAgICByZXN1bHQ6IHdyaXRlLnJlc3VsdCxcbiAgICAgICAgICAgIHZhcmlhYmxlczogd3JpdGUudmFyaWFibGVzLFxuICAgICAgICAgICAgZG9jdW1lbnQ6IHRoaXMudHJhbnNmb3JtRG9jdW1lbnQod3JpdGUucXVlcnkpLFxuICAgICAgICAgICAgc3RvcmU6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGRhdGFJZEZyb21PYmplY3Q6IHRoaXMuY29uZmlnLmRhdGFJZEZyb21PYmplY3QsXG4gICAgICAgICAgICBmcmFnbWVudE1hdGNoZXJGdW5jdGlvbjogZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb24sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJyb2FkY2FzdFdhdGNoZXMoKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50TWF0Y2hlciA9IHRoaXMuY29uZmlnLmZyYWdtZW50TWF0Y2hlcjtcbiAgICAgICAgdmFyIGZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uID0gZnJhZ21lbnRNYXRjaGVyICYmIGZyYWdtZW50TWF0Y2hlci5tYXRjaDtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmVSZWFkZXIuZGlmZlF1ZXJ5QWdhaW5zdFN0b3JlKHtcbiAgICAgICAgICAgIHN0b3JlOiBxdWVyeS5vcHRpbWlzdGljID8gdGhpcy5vcHRpbWlzdGljRGF0YSA6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHF1ZXJ5OiB0aGlzLnRyYW5zZm9ybURvY3VtZW50KHF1ZXJ5LnF1ZXJ5KSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogcXVlcnkudmFyaWFibGVzLFxuICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHF1ZXJ5LnJldHVyblBhcnRpYWxEYXRhLFxuICAgICAgICAgICAgcHJldmlvdXNSZXN1bHQ6IHF1ZXJ5LnByZXZpb3VzUmVzdWx0LFxuICAgICAgICAgICAgZnJhZ21lbnRNYXRjaGVyRnVuY3Rpb246IGZyYWdtZW50TWF0Y2hlckZ1bmN0aW9uLFxuICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uICh3YXRjaCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLndhdGNoZXMuYWRkKHdhdGNoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLndhdGNoZXMuZGVsZXRlKHdhdGNoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmV2aWN0ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHRocm93IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG5ldyBJbnZhcmlhbnRFcnJvcig3KSA6IG5ldyBJbnZhcmlhbnRFcnJvcihcImV2aWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBvbiBJbk1lbW9yeSBDYWNoZVwiKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RXYXRjaGVzKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnJlbW92ZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoaWRUb1JlbW92ZSkge1xuICAgICAgICB2YXIgdG9SZWFwcGx5ID0gW107XG4gICAgICAgIHZhciByZW1vdmVkQ291bnQgPSAwO1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLm9wdGltaXN0aWNEYXRhO1xuICAgICAgICB3aGlsZSAobGF5ZXIgaW5zdGFuY2VvZiBPcHRpbWlzdGljQ2FjaGVMYXllcikge1xuICAgICAgICAgICAgaWYgKGxheWVyLm9wdGltaXN0aWNJZCA9PT0gaWRUb1JlbW92ZSkge1xuICAgICAgICAgICAgICAgICsrcmVtb3ZlZENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9SZWFwcGx5LnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXIgPSBsYXllci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW1pc3RpY0RhdGEgPSBsYXllcjtcbiAgICAgICAgICAgIHdoaWxlICh0b1JlYXBwbHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXllcl8xID0gdG9SZWFwcGx5LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybVRyYW5zYWN0aW9uKGxheWVyXzEudHJhbnNhY3Rpb24sIGxheWVyXzEub3B0aW1pc3RpY0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0V2F0Y2hlcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5wZXJmb3JtVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIG9wdGltaXN0aWNJZCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBkYXRhID0gX2EuZGF0YSwgc2lsZW5jZUJyb2FkY2FzdCA9IF9hLnNpbGVuY2VCcm9hZGNhc3Q7XG4gICAgICAgIHRoaXMuc2lsZW5jZUJyb2FkY2FzdCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW1pc3RpY0lkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5vcHRpbWlzdGljRGF0YSA9IG5ldyBPcHRpbWlzdGljQ2FjaGVMYXllcihvcHRpbWlzdGljSWQsIHRoaXMub3B0aW1pc3RpY0RhdGEsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnNpbGVuY2VCcm9hZGNhc3QgPSBzaWxlbmNlQnJvYWRjYXN0O1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdhdGNoZXMoKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnJlY29yZE9wdGltaXN0aWNUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBpZCk7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS50cmFuc2Zvcm1Eb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICBpZiAodGhpcy5hZGRUeXBlbmFtZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudHlwZW5hbWVEb2N1bWVudENhY2hlLmdldChkb2N1bWVudCk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFkZFR5cGVuYW1lVG9Eb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlbmFtZURvY3VtZW50Q2FjaGUuc2V0KGRvY3VtZW50LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZW5hbWVEb2N1bWVudENhY2hlLnNldChyZXN1bHQsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmJyb2FkY2FzdFdhdGNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zaWxlbmNlQnJvYWRjYXN0KSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gX3RoaXMubWF5YmVCcm9hZGNhc3RXYXRjaChjKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLm1heWJlQnJvYWRjYXN0V2F0Y2ggPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBjLmNhbGxiYWNrKHRoaXMuZGlmZih7XG4gICAgICAgICAgICBxdWVyeTogYy5xdWVyeSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogYy52YXJpYWJsZXMsXG4gICAgICAgICAgICBwcmV2aW91c1Jlc3VsdDogYy5wcmV2aW91c1Jlc3VsdCAmJiBjLnByZXZpb3VzUmVzdWx0KCksXG4gICAgICAgICAgICBvcHRpbWlzdGljOiBjLm9wdGltaXN0aWMsXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBJbk1lbW9yeUNhY2hlO1xufShBcG9sbG9DYWNoZSkpO1xuXG5leHBvcnQgeyBIZXVyaXN0aWNGcmFnbWVudE1hdGNoZXIsIEluTWVtb3J5Q2FjaGUsIEludHJvc3BlY3Rpb25GcmFnbWVudE1hdGNoZXIsIE9iamVjdENhY2hlLCBTdG9yZVJlYWRlciwgU3RvcmVXcml0ZXIsIFdyaXRlRXJyb3IsIGFzc2VydElkVmFsdWUsIGRlZmF1bHREYXRhSWRGcm9tT2JqZWN0LCBkZWZhdWx0Tm9ybWFsaXplZENhY2hlRmFjdG9yeSQxIGFzIGRlZmF1bHROb3JtYWxpemVkQ2FjaGVGYWN0b3J5LCBlbmhhbmNlRXJyb3JXaXRoRG9jdW1lbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBBcG9sbG9MaW5rLCBPYnNlcnZhYmxlIH0gZnJvbSAnYXBvbGxvLWxpbmsnO1xuXG5mdW5jdGlvbiBvbkVycm9yKGVycm9ySGFuZGxlcikge1xuICAgIHJldHVybiBuZXcgQXBvbGxvTGluayhmdW5jdGlvbiAob3BlcmF0aW9uLCBmb3J3YXJkKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHZhciBzdWI7XG4gICAgICAgICAgICB2YXIgcmV0cmllZFN1YjtcbiAgICAgICAgICAgIHZhciByZXRyaWVkUmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdWIgPSBmb3J3YXJkKG9wZXJhdGlvbikuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyaWVkUmVzdWx0ID0gZXJyb3JIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhRTEVycm9yczogcmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmQ6IGZvcndhcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHJpZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmllZFN1YiA9IHJldHJpZWRSZXN1bHQuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IG9ic2VydmVyLm5leHQuYmluZChvYnNlcnZlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogb2JzZXJ2ZXIuZXJyb3IuYmluZChvYnNlcnZlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogb2JzZXJ2ZXIuY29tcGxldGUuYmluZChvYnNlcnZlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKG5ldHdvcmtFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmllZFJlc3VsdCA9IGVycm9ySGFuZGxlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya0Vycm9yOiBuZXR3b3JrRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhRTEVycm9yczogbmV0d29ya0Vycm9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtFcnJvci5yZXN1bHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya0Vycm9yLnJlc3VsdC5lcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZDogZm9yd2FyZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHJpZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyaWVkU3ViID0gcmV0cmllZFJlc3VsdC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiBvYnNlcnZlci5uZXh0LmJpbmQob2JzZXJ2ZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogb2JzZXJ2ZXIuZXJyb3IuYmluZChvYnNlcnZlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBvYnNlcnZlci5jb21wbGV0ZS5iaW5kKG9ic2VydmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihuZXR3b3JrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXRyaWVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUuYmluZChvYnNlcnZlcikoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKHsgbmV0d29ya0Vycm9yOiBlLCBvcGVyYXRpb246IG9wZXJhdGlvbiwgZm9yd2FyZDogZm9yd2FyZCB9KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YilcbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHJpZWRTdWIpXG4gICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG52YXIgRXJyb3JMaW5rID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXJyb3JMaW5rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVycm9yTGluayhlcnJvckhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGluayA9IG9uRXJyb3IoZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFcnJvckxpbmsucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3BlcmF0aW9uLCBmb3J3YXJkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmsucmVxdWVzdChvcGVyYXRpb24sIGZvcndhcmQpO1xuICAgIH07XG4gICAgcmV0dXJuIEVycm9yTGluaztcbn0oQXBvbGxvTGluaykpO1xuXG5leHBvcnQgeyBFcnJvckxpbmssIG9uRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgQXBvbGxvQ2xpZW50X19kZWZhdWx0IGZyb20gJ2Fwb2xsby1jbGllbnQnO1xuZXhwb3J0ICogZnJvbSAnYXBvbGxvLWNsaWVudCc7XG5pbXBvcnQgeyBBcG9sbG9MaW5rLCBPYnNlcnZhYmxlIH0gZnJvbSAnYXBvbGxvLWxpbmsnO1xuZXhwb3J0ICogZnJvbSAnYXBvbGxvLWxpbmsnO1xuaW1wb3J0IHsgSW5NZW1vcnlDYWNoZSB9IGZyb20gJ2Fwb2xsby1jYWNoZS1pbm1lbW9yeSc7XG5leHBvcnQgKiBmcm9tICdhcG9sbG8tY2FjaGUtaW5tZW1vcnknO1xuaW1wb3J0IHsgSHR0cExpbmsgfSBmcm9tICdhcG9sbG8tbGluay1odHRwJztcbmV4cG9ydCB7IEh0dHBMaW5rIH0gZnJvbSAnYXBvbGxvLWxpbmstaHR0cCc7XG5pbXBvcnQgeyBvbkVycm9yIH0gZnJvbSAnYXBvbGxvLWxpbmstZXJyb3InO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBncWwgfSBmcm9tICdncmFwaHFsLXRhZyc7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICd0cy1pbnZhcmlhbnQnO1xuXG52YXIgUFJFU0VUX0NPTkZJR19LRVlTID0gW1xuICAgICdyZXF1ZXN0JyxcbiAgICAndXJpJyxcbiAgICAnY3JlZGVudGlhbHMnLFxuICAgICdoZWFkZXJzJyxcbiAgICAnZmV0Y2gnLFxuICAgICdmZXRjaE9wdGlvbnMnLFxuICAgICdjbGllbnRTdGF0ZScsXG4gICAgJ29uRXJyb3InLFxuICAgICdjYWNoZVJlZGlyZWN0cycsXG4gICAgJ2NhY2hlJyxcbiAgICAnbmFtZScsXG4gICAgJ3ZlcnNpb24nLFxuICAgICdyZXNvbHZlcnMnLFxuICAgICd0eXBlRGVmcycsXG4gICAgJ2ZyYWdtZW50TWF0Y2hlcicsXG5dO1xudmFyIERlZmF1bHRDbGllbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWZhdWx0Q2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlZmF1bHRDbGllbnQoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFBSRVNFVF9DT05GSUdfS0VZUy5pbmRleE9mKGtleSkgPT09IC0xOyB9KTtcbiAgICAgICAgICAgIGlmIChkaWZmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgaW52YXJpYW50Lndhcm4oJ0Fwb2xsb0Jvb3N0IHdhcyBpbml0aWFsaXplZCB3aXRoIHVuc3VwcG9ydGVkIG9wdGlvbnM6ICcgK1xuICAgICAgICAgICAgICAgICAgICAoXCJcIiArIGRpZmYuam9pbignICcpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjb25maWcucmVxdWVzdCwgdXJpID0gY29uZmlnLnVyaSwgY3JlZGVudGlhbHMgPSBjb25maWcuY3JlZGVudGlhbHMsIGhlYWRlcnMgPSBjb25maWcuaGVhZGVycywgZmV0Y2ggPSBjb25maWcuZmV0Y2gsIGZldGNoT3B0aW9ucyA9IGNvbmZpZy5mZXRjaE9wdGlvbnMsIGNsaWVudFN0YXRlID0gY29uZmlnLmNsaWVudFN0YXRlLCBjYWNoZVJlZGlyZWN0cyA9IGNvbmZpZy5jYWNoZVJlZGlyZWN0cywgZXJyb3JDYWxsYmFjayA9IGNvbmZpZy5vbkVycm9yLCBuYW1lID0gY29uZmlnLm5hbWUsIHZlcnNpb24gPSBjb25maWcudmVyc2lvbiwgcmVzb2x2ZXJzID0gY29uZmlnLnJlc29sdmVycywgdHlwZURlZnMgPSBjb25maWcudHlwZURlZnMsIGZyYWdtZW50TWF0Y2hlciA9IGNvbmZpZy5mcmFnbWVudE1hdGNoZXI7XG4gICAgICAgIHZhciBjYWNoZSA9IGNvbmZpZy5jYWNoZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCFjYWNoZSB8fCAhY2FjaGVSZWRpcmVjdHMsIDEpIDogaW52YXJpYW50KCFjYWNoZSB8fCAhY2FjaGVSZWRpcmVjdHMsICdJbmNvbXBhdGlibGUgY2FjaGUgY29uZmlndXJhdGlvbi4gV2hlbiBub3QgcHJvdmlkaW5nIGBjYWNoZWAsICcgK1xuICAgICAgICAgICAgJ2NvbmZpZ3VyZSB0aGUgcHJvdmlkZWQgaW5zdGFuY2Ugd2l0aCBgY2FjaGVSZWRpcmVjdHNgIGluc3RlYWQuJyk7XG4gICAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVSZWRpcmVjdHNcbiAgICAgICAgICAgICAgICA/IG5ldyBJbk1lbW9yeUNhY2hlKHsgY2FjaGVSZWRpcmVjdHM6IGNhY2hlUmVkaXJlY3RzIH0pXG4gICAgICAgICAgICAgICAgOiBuZXcgSW5NZW1vcnlDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvckxpbmsgPSBlcnJvckNhbGxiYWNrXG4gICAgICAgICAgICA/IG9uRXJyb3IoZXJyb3JDYWxsYmFjaylcbiAgICAgICAgICAgIDogb25FcnJvcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhcGhRTEVycm9ycyA9IF9hLmdyYXBoUUxFcnJvcnMsIG5ldHdvcmtFcnJvciA9IF9hLm5ldHdvcmtFcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoZ3JhcGhRTEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBncmFwaFFMRXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IF9hLm1lc3NhZ2UsIGxvY2F0aW9ucyA9IF9hLmxvY2F0aW9ucywgcGF0aCA9IF9hLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IGludmFyaWFudC53YXJuKFwiW0dyYXBoUUwgZXJyb3JdOiBNZXNzYWdlOiBcIiArIG1lc3NhZ2UgKyBcIiwgTG9jYXRpb246IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYXRpb25zICsgXCIsIFBhdGg6IFwiICsgcGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ldHdvcmtFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgaW52YXJpYW50Lndhcm4oXCJbTmV0d29yayBlcnJvcl06IFwiICsgbmV0d29ya0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlcXVlc3RIYW5kbGVyID0gcmVxdWVzdFxuICAgICAgICAgICAgPyBuZXcgQXBvbGxvTGluayhmdW5jdGlvbiAob3BlcmF0aW9uLCBmb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlO1xuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUob3BlcmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9wZXIpIHsgcmV0dXJuIHJlcXVlc3Qob3Blcik7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSBmb3J3YXJkKG9wZXJhdGlvbikuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiBvYnNlcnZlci5uZXh0LmJpbmQob2JzZXJ2ZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBvYnNlcnZlci5lcnJvci5iaW5kKG9ic2VydmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogb2JzZXJ2ZXIuY29tcGxldGUuYmluZChvYnNlcnZlciksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChvYnNlcnZlci5lcnJvci5iaW5kKG9ic2VydmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgdmFyIGh0dHBMaW5rID0gbmV3IEh0dHBMaW5rKHtcbiAgICAgICAgICAgIHVyaTogdXJpIHx8ICcvZ3JhcGhxbCcsXG4gICAgICAgICAgICBmZXRjaDogZmV0Y2gsXG4gICAgICAgICAgICBmZXRjaE9wdGlvbnM6IGZldGNoT3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBjcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyB8fCB7fSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsaW5rID0gQXBvbGxvTGluay5mcm9tKFtlcnJvckxpbmssIHJlcXVlc3RIYW5kbGVyLCBodHRwTGlua10uZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiAhIXg7IH0pKTtcbiAgICAgICAgdmFyIGFjdGl2ZVJlc29sdmVycyA9IHJlc29sdmVycztcbiAgICAgICAgdmFyIGFjdGl2ZVR5cGVEZWZzID0gdHlwZURlZnM7XG4gICAgICAgIHZhciBhY3RpdmVGcmFnbWVudE1hdGNoZXIgPSBmcmFnbWVudE1hdGNoZXI7XG4gICAgICAgIGlmIChjbGllbnRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKGNsaWVudFN0YXRlLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgY2FjaGUud3JpdGVEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY2xpZW50U3RhdGUuZGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3RpdmVSZXNvbHZlcnMgPSBjbGllbnRTdGF0ZS5yZXNvbHZlcnM7XG4gICAgICAgICAgICBhY3RpdmVUeXBlRGVmcyA9IGNsaWVudFN0YXRlLnR5cGVEZWZzO1xuICAgICAgICAgICAgYWN0aXZlRnJhZ21lbnRNYXRjaGVyID0gY2xpZW50U3RhdGUuZnJhZ21lbnRNYXRjaGVyO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgbGluazogbGluayxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICAgICAgcmVzb2x2ZXJzOiBhY3RpdmVSZXNvbHZlcnMsXG4gICAgICAgICAgICB0eXBlRGVmczogYWN0aXZlVHlwZURlZnMsXG4gICAgICAgICAgICBmcmFnbWVudE1hdGNoZXI6IGFjdGl2ZUZyYWdtZW50TWF0Y2hlcixcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGVmYXVsdENsaWVudDtcbn0oQXBvbGxvQ2xpZW50X19kZWZhdWx0KSk7XG5cbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUuZXNtLmpzLm1hcFxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCBNYWluIGZyb20gXCIuLi9jb21wb25lbnRzL01haW4uanN4XCI7XG5cbmltcG9ydCB7IGNvbmNhdCB9IGZyb20gXCJhcG9sbG8tbGlua1wiO1xuaW1wb3J0IHsgY3JlYXRlSHR0cExpbmsgfSBmcm9tIFwiYXBvbGxvLWxpbmstaHR0cFwiO1xuaW1wb3J0IHsgUmV0cnlMaW5rIH0gZnJvbSBcImFwb2xsby1saW5rLXJldHJ5XCI7XG5pbXBvcnQgeyBJbk1lbW9yeUNhY2hlIH0gZnJvbSBcImFwb2xsby1jYWNoZS1pbm1lbW9yeVwiO1xuaW1wb3J0IHsgcGVyc2lzdENhY2hlIH0gZnJvbSBcImFwb2xsby1jYWNoZS1wZXJzaXN0XCI7XG5cbmltcG9ydCBBcG9sbG9DbGllbnQgZnJvbSBcImFwb2xsby1ib29zdFwiO1xuaW1wb3J0IHsgQXBvbGxvUHJvdmlkZXIgfSBmcm9tIFwiQGFwb2xsby9yZWFjdC1ob29rc1wiO1xuXG5jb25zdCByZXRyeSA9IG5ldyBSZXRyeUxpbmsoeyBhdHRlbXB0czogeyBtYXg6IEluZmluaXR5IH0gfSk7XG5jb25zdCBodHRwID0gbmV3IGNyZWF0ZUh0dHBMaW5rKHtcbiAgdXJpOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NDAwMC9ncmFwaHFsXCIsXG59KTtcbmNvbnN0IGxpbmsgPSBjb25jYXQocmV0cnksIGh0dHApO1xuXG4vLyBVc2UgYW4gSW5NZW1vcnlDYWNoZSwgYnV0IGtlZXAgaXQgc3luY2VkIHRvIGxvY2FsU3RvcmFnZVxuY29uc3QgY2FjaGUgPSBuZXcgSW5NZW1vcnlDYWNoZSgpO1xuY29uc3Qgc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG5jb25zdCB3YWl0T25DYWNoZSA9IHBlcnNpc3RDYWNoZSh7IGNhY2hlLCBzdG9yYWdlIH0pO1xuXG5jb25zdCBjbGllbnQgPSBuZXcgQXBvbGxvQ2xpZW50KHtcbiAgY2FjaGUsXG4gIHVyaTogXCJodHRwOi8vbG9jYWxob3N0OjQwMDAvZ3JhcGhxbFwiLFxufSk7XG5cbi8vIGNvbnN0IGNsaWVudCA9IG5ldyBBcG9sbG9DbGllbnQoe1xuLy8gICB1cmk6IFwiaHR0cDovL2xvY2FsaG9zdDo0MDAwL2dyYXBocWxcIixcbi8vIH0pO1xuXG4vLyBSZWFjdERPTS5yZW5kZXIoPE1haW4gLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9vdFwiKSk7XG4vLyBjb25zdCBnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbi8vIGcuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJyb290XCIpO1xuXG53YWl0T25DYWNoZS50aGVuKCgpID0+IHtcbiAgUmVhY3RET00ucmVuZGVyKFxuICAgIDxBcG9sbG9Qcm92aWRlciBjbGllbnQ9e2NsaWVudH0+XG4gICAgICA8TWFpbiAvPlxuICAgIDwvQXBvbGxvUHJvdmlkZXI+LFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9vdFwiKVxuICApO1xufSk7XG5cbmlmIChcInNlcnZpY2VXb3JrZXJcIiBpbiBuYXZpZ2F0b3IpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlclxuICAgICAgLnJlZ2lzdGVyKFwiL3NlcnZpY2Utd29ya2VyLmpzXCIpXG4gICAgICAudGhlbigocmVnaXN0cmF0aW9uKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU1cgcmVnaXN0ZXJlZDogXCIsIHJlZ2lzdHJhdGlvbik7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChyZWdpc3RyYXRpb25FcnJvcikgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNXIHJlZ2lzdHJhdGlvbiBmYWlsZWQ6IFwiLCByZWdpc3RyYXRpb25FcnJvcik7XG4gICAgICB9KTtcbiAgfSk7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNXFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFLQTtBQUNBO0FBQ0E7QUFDQSxpQkFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0EsYUFFQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDWEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUlBO0FBQ0E7QUFDQSxlQUlBO0FBQ0E7QUFDQSxlQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBNkRBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUlBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBR0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQW9CQTtBQUNBO0FBQ0EsaUJBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkEwREE7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkEwQkE7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQTZCQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkF1RUE7QUFDQTtBQUNBO0FBQ0E7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFxRUE7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFFQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkF5Q0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQXlEQTtBQUNBO0FBQ0E7O0FDNUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkF5Q0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBc0tBO0FBQ0E7QUFDQTtBQUNBOztBQzllQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQXVHQTtBQUNBO0FBQ0E7QUFDQTs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBeURBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkE0REE7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFzQkE7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQStDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBMkxBO0FBQ0E7QUFDQTtBQUNBOztBQzNvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFpSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFpSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQW9DQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQTZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkEyREE7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFtRUE7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFpRkE7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBbUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNKQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFrQ0E7QUFDQTtBQUNBLGFBR0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBbURBO0FBQ0E7QUFDQSxhQUdBO0FBQ0E7QUFDQTs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBV0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBOEhBO0FBQ0E7O0FDMVlBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQXVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFxRUE7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFpTUE7QUFDQTtBQUNBO0FBQ0E7O0FDbmlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBK0NBO0FBQ0E7O0FDbFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBaUhBO0FBQ0E7QUFDQTtBQUNBOztBQy9RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkE4SkE7QUFDQTs7QUN2a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQW1FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBNkRBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBa0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQXNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkErTEE7QUFDQTtBQUNBO0FBQ0E7O0FDblhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBbUdBO0FBQ0E7QUFDQTtBQUNBOztBQ3BiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUZBO0FBQ0E7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFDQTtBQWxCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUZBO0FBS0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFKQTtBQVdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQUE7QUFHQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVNBOzs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBRUE7QUFDQSxvSUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2dUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVVBO0FBV0E7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdjlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1SEE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///43\n")},function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"parse\", function() { return /* binding */ parse; });\n__webpack_require__.d(__webpack_exports__, \"parseValue\", function() { return /* binding */ parseValue; });\n__webpack_require__.d(__webpack_exports__, \"parseType\", function() { return /* binding */ parseType; });\n\n// EXTERNAL MODULE: ./node_modules/graphql/jsutils/inspect.mjs\nvar inspect = __webpack_require__(13);\n\n// CONCATENATED MODULE: ./node_modules/graphql/jsutils/devAssert.mjs\nfunction devAssert(condition, message) {\n  var booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(message);\n  }\n}\n\n// EXTERNAL MODULE: ./node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs\nvar nodejsCustomInspectSymbol = __webpack_require__(10);\n\n// CONCATENATED MODULE: ./node_modules/graphql/jsutils/defineToJSON.mjs\n\n/**\n * The `defineToJSON()` function defines toJSON() and inspect() prototype\n * methods, if no function provided they become aliases for toString().\n */\n\nfunction defineToJSON(classObject) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : classObject.prototype.toString;\n  classObject.prototype.toJSON = fn;\n  classObject.prototype.inspect = fn;\n\n  if (nodejsCustomInspectSymbol[\"a\" /* default */]) {\n    classObject.prototype[nodejsCustomInspectSymbol[\"a\" /* default */]] = fn;\n  }\n}\n\n// CONCATENATED MODULE: ./node_modules/graphql/jsutils/isObjectLike.mjs\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nfunction isObjectLike(value) {\n  return _typeof(value) == 'object' && value !== null;\n}\n\n// CONCATENATED MODULE: ./node_modules/graphql/language/location.mjs\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nfunction getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match;\n\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n\n// CONCATENATED MODULE: ./node_modules/graphql/language/printLocation.mjs\n\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nfunction printLocation(location) {\n  return printSourceLocation(location.source, getLocation(location.source, location.start));\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nfunction printSourceLocation(source, sourceLocation) {\n  var firstLineColumnOffset = source.locationOffset.column - 1;\n  var body = whitespace(firstLineColumnOffset) + source.body;\n  var lineIndex = sourceLocation.line - 1;\n  var lineOffset = source.locationOffset.line - 1;\n  var lineNum = sourceLocation.line + lineOffset;\n  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  var columnNum = sourceLocation.column + columnOffset;\n  var locationStr = \"\".concat(source.name, \":\").concat(lineNum, \":\").concat(columnNum, \"\\n\");\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n  var locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    var sublineIndex = Math.floor(columnNum / 80);\n    var sublineColumnNum = columnNum % 80;\n    var sublines = [];\n\n    for (var i = 0; i < locationLine.length; i += 80) {\n      sublines.push(locationLine.slice(i, i + 80));\n    }\n\n    return locationStr + printPrefixedLines([[\"\".concat(lineNum), sublines[0]]].concat(sublines.slice(1, sublineIndex + 1).map(function (subline) {\n      return ['', subline];\n    }), [[' ', whitespace(sublineColumnNum - 1) + '^'], ['', sublines[sublineIndex + 1]]]));\n  }\n\n  return locationStr + printPrefixedLines([// Lines specified like this: [\"prefix\", \"string\"],\n  [\"\".concat(lineNum - 1), lines[lineIndex - 1]], [\"\".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], [\"\".concat(lineNum + 1), lines[lineIndex + 1]]]);\n}\n\nfunction printPrefixedLines(lines) {\n  var existingLines = lines.filter(function (_ref) {\n    var _ = _ref[0],\n        line = _ref[1];\n    return line !== undefined;\n  });\n  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {\n    var prefix = _ref2[0];\n    return prefix.length;\n  }));\n  return existingLines.map(function (_ref3) {\n    var prefix = _ref3[0],\n        line = _ref3[1];\n    return lpad(padLen, prefix) + (line ? ' | ' + line : ' |');\n  }).join('\\n');\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction lpad(len, str) {\n  return whitespace(len - str.length) + str;\n}\n\n// CONCATENATED MODULE: ./node_modules/graphql/error/GraphQLError.mjs\n\n\n\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nfunction GraphQLError( // eslint-disable-line no-redeclare\nmessage, nodes, source, positions, path, originalError, extensions) {\n  // Compute list of blame nodes.\n  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.\n\n\n  var _source = source;\n\n  if (!_source && _nodes) {\n    var node = _nodes[0];\n    _source = node && node.loc && node.loc.source;\n  }\n\n  var _positions = positions;\n\n  if (!_positions && _nodes) {\n    _positions = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(node.loc.start);\n      }\n\n      return list;\n    }, []);\n  }\n\n  if (_positions && _positions.length === 0) {\n    _positions = undefined;\n  }\n\n  var _locations;\n\n  if (positions && source) {\n    _locations = positions.map(function (pos) {\n      return getLocation(source, pos);\n    });\n  } else if (_nodes) {\n    _locations = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(getLocation(node.loc.source, node.loc.start));\n      }\n\n      return list;\n    }, []);\n  }\n\n  var _extensions = extensions;\n\n  if (_extensions == null && originalError != null) {\n    var originalExtensions = originalError.extensions;\n\n    if (isObjectLike(originalExtensions)) {\n      _extensions = originalExtensions;\n    }\n  }\n\n  Object.defineProperties(this, {\n    message: {\n      value: message,\n      // By being enumerable, JSON.stringify will include `message` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true,\n      writable: true\n    },\n    locations: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _locations || undefined,\n      // By being enumerable, JSON.stringify will include `locations` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_locations)\n    },\n    path: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: path || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(path)\n    },\n    nodes: {\n      value: _nodes || undefined\n    },\n    source: {\n      value: _source || undefined\n    },\n    positions: {\n      value: _positions || undefined\n    },\n    originalError: {\n      value: originalError\n    },\n    extensions: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _extensions || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_extensions)\n    }\n  }); // Include (non-enumerable) stack trace.\n\n  if (originalError && originalError.stack) {\n    Object.defineProperty(this, 'stack', {\n      value: originalError.stack,\n      writable: true,\n      configurable: true\n    });\n  } else if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, GraphQLError);\n  } else {\n    Object.defineProperty(this, 'stack', {\n      value: Error().stack,\n      writable: true,\n      configurable: true\n    });\n  }\n}\nGraphQLError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: GraphQLError\n  },\n  name: {\n    value: 'GraphQLError'\n  },\n  toString: {\n    value: function toString() {\n      return printError(this);\n    }\n  }\n});\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n */\n\nfunction printError(error) {\n  var output = error.message;\n\n  if (error.nodes) {\n    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {\n      var node = _error$nodes2[_i2];\n\n      if (node.loc) {\n        output += '\\n\\n' + printLocation(node.loc);\n      }\n    }\n  } else if (error.source && error.locations) {\n    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {\n      var location = _error$locations2[_i4];\n      output += '\\n\\n' + printSourceLocation(error.source, location);\n    }\n  }\n\n  return output;\n}\n\n// CONCATENATED MODULE: ./node_modules/graphql/error/syntaxError.mjs\n\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nfunction syntaxError(source, position, description) {\n  return new GraphQLError(\"Syntax Error: \".concat(description), undefined, source, [position]);\n}\n\n// CONCATENATED MODULE: ./node_modules/graphql/language/kinds.mjs\n/**\n * The set of allowed kind values for AST nodes.\n */\nvar Kind = Object.freeze({\n  // Name\n  NAME: 'Name',\n  // Document\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  // Fragments\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  // Values\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  // Directives\n  DIRECTIVE: 'Directive',\n  // Types\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n  // Type System Definitions\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  // Type Definitions\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  // Directive Definitions\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  // Type System Extensions\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  // Type Extensions\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'\n});\n/**\n * The enum type representing the possible kind values of AST nodes.\n */\n\n// CONCATENATED MODULE: ./node_modules/graphql/jsutils/defineToStringTag.mjs\n/**\n * The `defineToStringTag()` function checks first to see if the runtime\n * supports the `Symbol` class and then if the `Symbol.toStringTag` constant\n * is defined as a `Symbol` instance. If both conditions are met, the\n * Symbol.toStringTag property is defined as a getter that returns the\n * supplied class constructor's name.\n *\n * @method defineToStringTag\n *\n * @param {Class<any>} classObject a class such as Object, String, Number but\n * typically one of your own creation through the class keyword; `class A {}`,\n * for example.\n */\nfunction defineToStringTag(classObject) {\n  if (typeof Symbol === 'function' && Symbol.toStringTag) {\n    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {\n      get: function get() {\n        return this.constructor.name;\n      }\n    });\n  }\n}\n\n// CONCATENATED MODULE: ./node_modules/graphql/language/source.mjs\n\n\n\n/**\n * A representation of source input to GraphQL.\n * `name` and `locationOffset` are optional. They are useful for clients who\n * store GraphQL documents in source files; for example, if the GraphQL input\n * starts at line 40 in a file named Foo.graphql, it might be useful for name to\n * be \"Foo.graphql\" and location to be `{ line: 40, column: 0 }`.\n * line and column in locationOffset are 1-indexed\n */\nvar source_Source = function Source(body, name, locationOffset) {\n  this.body = body;\n  this.name = name || 'GraphQL request';\n  this.locationOffset = locationOffset || {\n    line: 1,\n    column: 1\n  };\n  this.locationOffset.line > 0 || devAssert(0, 'line in locationOffset is 1-indexed and must be positive');\n  this.locationOffset.column > 0 || devAssert(0, 'column in locationOffset is 1-indexed and must be positive');\n}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(source_Source);\n\n// EXTERNAL MODULE: ./node_modules/graphql/language/blockString.mjs\nvar blockString = __webpack_require__(14);\n\n// CONCATENATED MODULE: ./node_modules/graphql/language/tokenKind.mjs\n/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nvar TokenKind = Object.freeze({\n  SOF: '<SOF>',\n  EOF: '<EOF>',\n  BANG: '!',\n  DOLLAR: '$',\n  AMP: '&',\n  PAREN_L: '(',\n  PAREN_R: ')',\n  SPREAD: '...',\n  COLON: ':',\n  EQUALS: '=',\n  AT: '@',\n  BRACKET_L: '[',\n  BRACKET_R: ']',\n  BRACE_L: '{',\n  PIPE: '|',\n  BRACE_R: '}',\n  NAME: 'Name',\n  INT: 'Int',\n  FLOAT: 'Float',\n  STRING: 'String',\n  BLOCK_STRING: 'BlockString',\n  COMMENT: 'Comment'\n});\n/**\n * The enum type representing the token kinds values.\n */\n\n// CONCATENATED MODULE: ./node_modules/graphql/language/lexer.mjs\n\n\n\n\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nfunction createLexer(source, options) {\n  var startOfFileToken = new Tok(TokenKind.SOF, 0, 0, 0, 0, null);\n  var lexer = {\n    source: source,\n    options: options,\n    lastToken: startOfFileToken,\n    token: startOfFileToken,\n    line: 1,\n    lineStart: 0,\n    advance: advanceLexer,\n    lookahead: lookahead\n  };\n  return lexer;\n}\n\nfunction advanceLexer() {\n  this.lastToken = this.token;\n  var token = this.token = this.lookahead();\n  return token;\n}\n\nfunction lookahead() {\n  var token = this.token;\n\n  if (token.kind !== TokenKind.EOF) {\n    do {\n      // Note: next is only mutable during parsing, so we cast to allow this.\n      token = token.next || (token.next = readToken(this, token));\n    } while (token.kind === TokenKind.COMMENT);\n  }\n\n  return token;\n}\n/**\n * The return type of createLexer.\n */\n\n\n// @internal\nfunction isPunctuatorToken(token) {\n  var kind = token.kind;\n  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;\n}\n/**\n * Helper function for constructing the Token object.\n */\n\nfunction Tok(kind, start, end, line, column, prev, value) {\n  this.kind = kind;\n  this.start = start;\n  this.end = end;\n  this.line = line;\n  this.column = column;\n  this.value = value;\n  this.prev = prev;\n  this.next = null;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\ndefineToJSON(Tok, function () {\n  return {\n    kind: this.kind,\n    value: this.value,\n    line: this.line,\n    column: this.column\n  };\n});\n\nfunction printCharCode(code) {\n  return (// NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    \"\\\"\\\\u\".concat(('00' + code.toString(16).toUpperCase()).slice(-4), \"\\\"\")\n  );\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n  var pos = positionAfterWhitespace(body, prev.end, lexer);\n  var line = lexer.line;\n  var col = 1 + pos - lexer.lineStart;\n\n  if (pos >= bodyLength) {\n    return new Tok(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = body.charCodeAt(pos); // SourceCharacter\n\n  switch (code) {\n    // !\n    case 33:\n      return new Tok(TokenKind.BANG, pos, pos + 1, line, col, prev);\n    // #\n\n    case 35:\n      return readComment(source, pos, line, col, prev);\n    // $\n\n    case 36:\n      return new Tok(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);\n    // &\n\n    case 38:\n      return new Tok(TokenKind.AMP, pos, pos + 1, line, col, prev);\n    // (\n\n    case 40:\n      return new Tok(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);\n    // )\n\n    case 41:\n      return new Tok(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);\n    // .\n\n    case 46:\n      if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {\n        return new Tok(TokenKind.SPREAD, pos, pos + 3, line, col, prev);\n      }\n\n      break;\n    // :\n\n    case 58:\n      return new Tok(TokenKind.COLON, pos, pos + 1, line, col, prev);\n    // =\n\n    case 61:\n      return new Tok(TokenKind.EQUALS, pos, pos + 1, line, col, prev);\n    // @\n\n    case 64:\n      return new Tok(TokenKind.AT, pos, pos + 1, line, col, prev);\n    // [\n\n    case 91:\n      return new Tok(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);\n    // ]\n\n    case 93:\n      return new Tok(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);\n    // {\n\n    case 123:\n      return new Tok(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);\n    // |\n\n    case 124:\n      return new Tok(TokenKind.PIPE, pos, pos + 1, line, col, prev);\n    // }\n\n    case 125:\n      return new Tok(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);\n    // A-Z _ a-z\n\n    case 65:\n    case 66:\n    case 67:\n    case 68:\n    case 69:\n    case 70:\n    case 71:\n    case 72:\n    case 73:\n    case 74:\n    case 75:\n    case 76:\n    case 77:\n    case 78:\n    case 79:\n    case 80:\n    case 81:\n    case 82:\n    case 83:\n    case 84:\n    case 85:\n    case 86:\n    case 87:\n    case 88:\n    case 89:\n    case 90:\n    case 95:\n    case 97:\n    case 98:\n    case 99:\n    case 100:\n    case 101:\n    case 102:\n    case 103:\n    case 104:\n    case 105:\n    case 106:\n    case 107:\n    case 108:\n    case 109:\n    case 110:\n    case 111:\n    case 112:\n    case 113:\n    case 114:\n    case 115:\n    case 116:\n    case 117:\n    case 118:\n    case 119:\n    case 120:\n    case 121:\n    case 122:\n      return readName(source, pos, line, col, prev);\n    // - 0-9\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return readNumber(source, pos, code, line, col, prev);\n    // \"\n\n    case 34:\n      if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {\n        return readBlockString(source, pos, line, col, prev, lexer);\n      }\n\n      return readString(source, pos, line, col, prev);\n  }\n\n  throw syntaxError(source, pos, unexpectedCharacterMessage(code));\n}\n/**\n * Report a message that an unexpected character was encountered.\n */\n\n\nfunction unexpectedCharacterMessage(code) {\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    return \"Cannot contain the invalid character \".concat(printCharCode(code), \".\");\n  }\n\n  if (code === 39) {\n    // '\n    return 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?';\n  }\n\n  return \"Cannot parse the unexpected character \".concat(printCharCode(code), \".\");\n}\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * character, then returns the position of that character for lexing.\n */\n\n\nfunction positionAfterWhitespace(body, startPosition, lexer) {\n  var bodyLength = body.length;\n  var position = startPosition;\n\n  while (position < bodyLength) {\n    var code = body.charCodeAt(position); // tab | space | comma | BOM\n\n    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {\n      ++position;\n    } else if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n\n  return position;\n}\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\n\n\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code;\n  var position = start;\n\n  do {\n    code = body.charCodeAt(++position);\n  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Tok(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\n\n\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = body.charCodeAt(++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = body.charCodeAt(++position);\n\n    if (code >= 48 && code <= 57) {\n      throw syntaxError(source, position, \"Invalid number, unexpected digit after 0: \".concat(printCharCode(code), \".\"));\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n    code = body.charCodeAt(++position);\n\n    if (code === 43 || code === 45) {\n      // + -\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or e\n\n\n  if (code === 46 || code === 69 || code === 101) {\n    throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n  }\n\n  return new Tok(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));\n}\n/**\n * Returns the new position in the source after reading digits.\n */\n\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = body.charCodeAt(++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n\n\n    return position;\n  }\n\n  throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n}\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\n\n\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += body.slice(chunkStart, position);\n      return new Tok(TokenKind.STRING, start, position + 1, line, col, prev, value);\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    ++position;\n\n    if (code === 92) {\n      // \\\n      value += body.slice(chunkStart, position - 1);\n      code = body.charCodeAt(position);\n\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n\n        case 47:\n          value += '/';\n          break;\n\n        case 92:\n          value += '\\\\';\n          break;\n\n        case 98:\n          value += '\\b';\n          break;\n\n        case 102:\n          value += '\\f';\n          break;\n\n        case 110:\n          value += '\\n';\n          break;\n\n        case 114:\n          value += '\\r';\n          break;\n\n        case 116:\n          value += '\\t';\n          break;\n\n        case 117:\n          {\n            // uXXXX\n            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));\n\n            if (charCode < 0) {\n              var invalidSequence = body.slice(position + 1, position + 5);\n              throw syntaxError(source, position, \"Invalid character escape sequence: \\\\u\".concat(invalidSequence, \".\"));\n            }\n\n            value += String.fromCharCode(charCode);\n            position += 4;\n            break;\n          }\n\n        default:\n          throw syntaxError(source, position, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code), \".\"));\n      }\n\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\n\n\nfunction readBlockString(source, start, line, col, prev, lexer) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {\n      rawValue += body.slice(chunkStart, position);\n      return new Tok(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, Object(blockString[\"a\" /* dedentBlockStringValue */])(rawValue));\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if ( // Escape Triple-Quote (\\\"\"\")\n    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {\n      rawValue += body.slice(chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Converts four hexadecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\n\n\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\n\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\n\n\nfunction readName(source, start, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var position = start + 1;\n  var code = 0;\n\n  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++position;\n  }\n\n  return new Tok(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));\n}\n\n// CONCATENATED MODULE: ./node_modules/graphql/language/directiveLocation.mjs\n/**\n * The set of allowed directive location values.\n */\nvar DirectiveLocation = Object.freeze({\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n});\n/**\n * The enum type representing the directive location values.\n */\n\n// CONCATENATED MODULE: ./node_modules/graphql/language/parser.mjs\n\n\n\n\n\n\n\n\n\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nfunction parse(source, options) {\n  var parser = new parser_Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nfunction parseValue(source, options) {\n  var parser = new parser_Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nfunction parseType(source, options) {\n  var parser = new parser_Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n\nvar parser_Parser =\n/*#__PURE__*/\nfunction () {\n  function Parser(source, options) {\n    var sourceObj = typeof source === 'string' ? new source_Source(source) : source;\n    sourceObj instanceof source_Source || devAssert(0, \"Must provide Source. Received: \".concat(Object(inspect[\"a\" /* default */])(sourceObj)));\n    this._lexer = createLexer(sourceObj);\n    this._options = options || {};\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.experimentalFragmentVariables) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        if (token.value === 'true' || token.value === 'false') {\n          this._lexer.advance();\n\n          return {\n            kind: Kind.BOOLEAN,\n            value: token.value === 'true',\n            loc: this.loc(token)\n          };\n        } else if (token.value === 'null') {\n          this._lexer.advance();\n\n          return {\n            kind: Kind.NULL,\n            loc: this.loc(token)\n          };\n        }\n\n        this._lexer.advance();\n\n        return {\n          kind: Kind.ENUM,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var types = [];\n\n    if (this.expectOptionalKeyword('implements')) {\n      // Optional leading ampersand\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || // Legacy support for the SDL?\n      this._options.allowLegacySDLImplementsInterfaces && this.peek(TokenKind.NAME));\n    }\n\n    return types;\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    // Legacy support for the SDL?\n    if (this._options.allowLegacySDLEmptyFields && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    var types = [];\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      // Optional leading pipe\n      this.expectOptionalToken(TokenKind.PIPE);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.PIPE));\n    }\n\n    return types;\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *   - extend interface Name Directives[Const]? FieldsDefinition\n   *   - extend interface Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    // Optional leading pipe\n    this.expectOptionalToken(TokenKind.PIPE);\n    var locations = [];\n\n    do {\n      locations.push(this.parseDirectiveLocation());\n    } while (this.expectOptionalToken(TokenKind.PIPE));\n\n    return locations;\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in\n   * the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    if (!this._options.noLocation) {\n      return new Loc(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(kind, \", found \").concat(getTokenDesc(token)));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token)));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing\n   * the lexer. Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token\n   * is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken || this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token)));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always\n   * return non-empty list that begins with a lex token of openKind and ends\n   * with a lex token of closeKind. Advances the parser to the next lex token\n   * after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\ndefineToJSON(Loc, function () {\n  return {\n    start: this.start,\n    end: this.end\n  };\n});\n/**\n * A helper function to describe a token as a string for debugging\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return value ? \"\".concat(token.kind, \" \\\"\").concat(value, \"\\\"\") : token.kind;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2RldkFzc2VydC5tanM/Yjc3NCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2RlZmluZVRvSlNPTi5tanM/YmM5OSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2lzT2JqZWN0TGlrZS5tanM/Y2U5NiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9sb2NhdGlvbi5tanM/Y2I4NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9wcmludExvY2F0aW9uLm1qcz9jZWMyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2Vycm9yL0dyYXBoUUxFcnJvci5tanM/NzU2NCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9lcnJvci9zeW50YXhFcnJvci5tanM/YTMyNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS9raW5kcy5tanM/ZmUzNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2RlZmluZVRvU3RyaW5nVGFnLm1qcz82NTk5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3NvdXJjZS5tanM/OWRlMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9sYW5ndWFnZS90b2tlbktpbmQubWpzPzI2ZjMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvbGV4ZXIubWpzPzA5YjUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvZGlyZWN0aXZlTG9jYXRpb24ubWpzPzE3YzUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcGFyc2VyLm1qcz8xMGNjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldkFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgdmFyIGJvb2xlYW5Db25kaXRpb24gPSBCb29sZWFuKGNvbmRpdGlvbik7XG5cbiAgaWYgKCFib29sZWFuQ29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG4iLCJpbXBvcnQgbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbCBmcm9tICcuL25vZGVqc0N1c3RvbUluc3BlY3RTeW1ib2wnO1xuLyoqXG4gKiBUaGUgYGRlZmluZVRvSlNPTigpYCBmdW5jdGlvbiBkZWZpbmVzIHRvSlNPTigpIGFuZCBpbnNwZWN0KCkgcHJvdG90eXBlXG4gKiBtZXRob2RzLCBpZiBubyBmdW5jdGlvbiBwcm92aWRlZCB0aGV5IGJlY29tZSBhbGlhc2VzIGZvciB0b1N0cmluZygpLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZmluZVRvSlNPTihjbGFzc09iamVjdCkge1xuICB2YXIgZm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGNsYXNzT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgY2xhc3NPYmplY3QucHJvdG90eXBlLnRvSlNPTiA9IGZuO1xuICBjbGFzc09iamVjdC5wcm90b3R5cGUuaW5zcGVjdCA9IGZuO1xuXG4gIGlmIChub2RlanNDdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gICAgY2xhc3NPYmplY3QucHJvdG90eXBlW25vZGVqc0N1c3RvbUluc3BlY3RTeW1ib2xdID0gZm47XG4gIH1cbn1cbiIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdFxuICogYG51bGxgIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiBfdHlwZW9mKHZhbHVlKSA9PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbiIsIi8qKlxuICogUmVwcmVzZW50cyBhIGxvY2F0aW9uIGluIGEgU291cmNlLlxuICovXG5cbi8qKlxuICogVGFrZXMgYSBTb3VyY2UgYW5kIGEgVVRGLTggY2hhcmFjdGVyIG9mZnNldCwgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIGxpbmUgYW5kIGNvbHVtbiBhcyBhIFNvdXJjZUxvY2F0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRpb24oc291cmNlLCBwb3NpdGlvbikge1xuICB2YXIgbGluZVJlZ2V4cCA9IC9cXHJcXG58W1xcblxccl0vZztcbiAgdmFyIGxpbmUgPSAxO1xuICB2YXIgY29sdW1uID0gcG9zaXRpb24gKyAxO1xuICB2YXIgbWF0Y2g7XG5cbiAgd2hpbGUgKChtYXRjaCA9IGxpbmVSZWdleHAuZXhlYyhzb3VyY2UuYm9keSkpICYmIG1hdGNoLmluZGV4IDwgcG9zaXRpb24pIHtcbiAgICBsaW5lICs9IDE7XG4gICAgY29sdW1uID0gcG9zaXRpb24gKyAxIC0gKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGluZTogbGluZSxcbiAgICBjb2x1bW46IGNvbHVtblxuICB9O1xufVxuIiwiaW1wb3J0IHsgZ2V0TG9jYXRpb24gfSBmcm9tICcuLi9sYW5ndWFnZS9sb2NhdGlvbic7XG4vKipcbiAqIFJlbmRlciBhIGhlbHBmdWwgZGVzY3JpcHRpb24gb2YgdGhlIGxvY2F0aW9uIGluIHRoZSBHcmFwaFFMIFNvdXJjZSBkb2N1bWVudC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gcHJpbnRTb3VyY2VMb2NhdGlvbihsb2NhdGlvbi5zb3VyY2UsIGdldExvY2F0aW9uKGxvY2F0aW9uLnNvdXJjZSwgbG9jYXRpb24uc3RhcnQpKTtcbn1cbi8qKlxuICogUmVuZGVyIGEgaGVscGZ1bCBkZXNjcmlwdGlvbiBvZiB0aGUgbG9jYXRpb24gaW4gdGhlIEdyYXBoUUwgU291cmNlIGRvY3VtZW50LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludFNvdXJjZUxvY2F0aW9uKHNvdXJjZSwgc291cmNlTG9jYXRpb24pIHtcbiAgdmFyIGZpcnN0TGluZUNvbHVtbk9mZnNldCA9IHNvdXJjZS5sb2NhdGlvbk9mZnNldC5jb2x1bW4gLSAxO1xuICB2YXIgYm9keSA9IHdoaXRlc3BhY2UoZmlyc3RMaW5lQ29sdW1uT2Zmc2V0KSArIHNvdXJjZS5ib2R5O1xuICB2YXIgbGluZUluZGV4ID0gc291cmNlTG9jYXRpb24ubGluZSAtIDE7XG4gIHZhciBsaW5lT2Zmc2V0ID0gc291cmNlLmxvY2F0aW9uT2Zmc2V0LmxpbmUgLSAxO1xuICB2YXIgbGluZU51bSA9IHNvdXJjZUxvY2F0aW9uLmxpbmUgKyBsaW5lT2Zmc2V0O1xuICB2YXIgY29sdW1uT2Zmc2V0ID0gc291cmNlTG9jYXRpb24ubGluZSA9PT0gMSA/IGZpcnN0TGluZUNvbHVtbk9mZnNldCA6IDA7XG4gIHZhciBjb2x1bW5OdW0gPSBzb3VyY2VMb2NhdGlvbi5jb2x1bW4gKyBjb2x1bW5PZmZzZXQ7XG4gIHZhciBsb2NhdGlvblN0ciA9IFwiXCIuY29uY2F0KHNvdXJjZS5uYW1lLCBcIjpcIikuY29uY2F0KGxpbmVOdW0sIFwiOlwiKS5jb25jYXQoY29sdW1uTnVtLCBcIlxcblwiKTtcbiAgdmFyIGxpbmVzID0gYm9keS5zcGxpdCgvXFxyXFxufFtcXG5cXHJdL2cpO1xuICB2YXIgbG9jYXRpb25MaW5lID0gbGluZXNbbGluZUluZGV4XTsgLy8gU3BlY2lhbCBjYXNlIGZvciBtaW5pZmllZCBkb2N1bWVudHNcblxuICBpZiAobG9jYXRpb25MaW5lLmxlbmd0aCA+IDEyMCkge1xuICAgIHZhciBzdWJsaW5lSW5kZXggPSBNYXRoLmZsb29yKGNvbHVtbk51bSAvIDgwKTtcbiAgICB2YXIgc3VibGluZUNvbHVtbk51bSA9IGNvbHVtbk51bSAlIDgwO1xuICAgIHZhciBzdWJsaW5lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhdGlvbkxpbmUubGVuZ3RoOyBpICs9IDgwKSB7XG4gICAgICBzdWJsaW5lcy5wdXNoKGxvY2F0aW9uTGluZS5zbGljZShpLCBpICsgODApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYXRpb25TdHIgKyBwcmludFByZWZpeGVkTGluZXMoW1tcIlwiLmNvbmNhdChsaW5lTnVtKSwgc3VibGluZXNbMF1dXS5jb25jYXQoc3VibGluZXMuc2xpY2UoMSwgc3VibGluZUluZGV4ICsgMSkubWFwKGZ1bmN0aW9uIChzdWJsaW5lKSB7XG4gICAgICByZXR1cm4gWycnLCBzdWJsaW5lXTtcbiAgICB9KSwgW1snICcsIHdoaXRlc3BhY2Uoc3VibGluZUNvbHVtbk51bSAtIDEpICsgJ14nXSwgWycnLCBzdWJsaW5lc1tzdWJsaW5lSW5kZXggKyAxXV1dKSk7XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb25TdHIgKyBwcmludFByZWZpeGVkTGluZXMoWy8vIExpbmVzIHNwZWNpZmllZCBsaWtlIHRoaXM6IFtcInByZWZpeFwiLCBcInN0cmluZ1wiXSxcbiAgW1wiXCIuY29uY2F0KGxpbmVOdW0gLSAxKSwgbGluZXNbbGluZUluZGV4IC0gMV1dLCBbXCJcIi5jb25jYXQobGluZU51bSksIGxvY2F0aW9uTGluZV0sIFsnJywgd2hpdGVzcGFjZShjb2x1bW5OdW0gLSAxKSArICdeJ10sIFtcIlwiLmNvbmNhdChsaW5lTnVtICsgMSksIGxpbmVzW2xpbmVJbmRleCArIDFdXV0pO1xufVxuXG5mdW5jdGlvbiBwcmludFByZWZpeGVkTGluZXMobGluZXMpIHtcbiAgdmFyIGV4aXN0aW5nTGluZXMgPSBsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgXyA9IF9yZWZbMF0sXG4gICAgICAgIGxpbmUgPSBfcmVmWzFdO1xuICAgIHJldHVybiBsaW5lICE9PSB1bmRlZmluZWQ7XG4gIH0pO1xuICB2YXIgcGFkTGVuID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZXhpc3RpbmdMaW5lcy5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHByZWZpeCA9IF9yZWYyWzBdO1xuICAgIHJldHVybiBwcmVmaXgubGVuZ3RoO1xuICB9KSk7XG4gIHJldHVybiBleGlzdGluZ0xpbmVzLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgcHJlZml4ID0gX3JlZjNbMF0sXG4gICAgICAgIGxpbmUgPSBfcmVmM1sxXTtcbiAgICByZXR1cm4gbHBhZChwYWRMZW4sIHByZWZpeCkgKyAobGluZSA/ICcgfCAnICsgbGluZSA6ICcgfCcpO1xuICB9KS5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gd2hpdGVzcGFjZShsZW4pIHtcbiAgcmV0dXJuIEFycmF5KGxlbiArIDEpLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gbHBhZChsZW4sIHN0cikge1xuICByZXR1cm4gd2hpdGVzcGFjZShsZW4gLSBzdHIubGVuZ3RoKSArIHN0cjtcbn1cbiIsImltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi4vanN1dGlscy9pc09iamVjdExpa2UnO1xuaW1wb3J0IHsgZ2V0TG9jYXRpb24gfSBmcm9tICcuLi9sYW5ndWFnZS9sb2NhdGlvbic7XG5pbXBvcnQgeyBwcmludExvY2F0aW9uLCBwcmludFNvdXJjZUxvY2F0aW9uIH0gZnJvbSAnLi4vbGFuZ3VhZ2UvcHJpbnRMb2NhdGlvbic7XG4vKipcbiAqIEEgR3JhcGhRTEVycm9yIGRlc2NyaWJlcyBhbiBFcnJvciBmb3VuZCBkdXJpbmcgdGhlIHBhcnNlLCB2YWxpZGF0ZSwgb3JcbiAqIGV4ZWN1dGUgcGhhc2VzIG9mIHBlcmZvcm1pbmcgYSBHcmFwaFFMIG9wZXJhdGlvbi4gSW4gYWRkaXRpb24gdG8gYSBtZXNzYWdlXG4gKiBhbmQgc3RhY2sgdHJhY2UsIGl0IGFsc28gaW5jbHVkZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxvY2F0aW9ucyBpbiBhXG4gKiBHcmFwaFFMIGRvY3VtZW50IGFuZC9vciBleGVjdXRpb24gcmVzdWx0IHRoYXQgY29ycmVzcG9uZCB0byB0aGUgRXJyb3IuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIEdyYXBoUUxFcnJvciggLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZWRlY2xhcmVcbm1lc3NhZ2UsIG5vZGVzLCBzb3VyY2UsIHBvc2l0aW9ucywgcGF0aCwgb3JpZ2luYWxFcnJvciwgZXh0ZW5zaW9ucykge1xuICAvLyBDb21wdXRlIGxpc3Qgb2YgYmxhbWUgbm9kZXMuXG4gIHZhciBfbm9kZXMgPSBBcnJheS5pc0FycmF5KG5vZGVzKSA/IG5vZGVzLmxlbmd0aCAhPT0gMCA/IG5vZGVzIDogdW5kZWZpbmVkIDogbm9kZXMgPyBbbm9kZXNdIDogdW5kZWZpbmVkOyAvLyBDb21wdXRlIGxvY2F0aW9ucyBpbiB0aGUgc291cmNlIGZvciB0aGUgZ2l2ZW4gbm9kZXMvcG9zaXRpb25zLlxuXG5cbiAgdmFyIF9zb3VyY2UgPSBzb3VyY2U7XG5cbiAgaWYgKCFfc291cmNlICYmIF9ub2Rlcykge1xuICAgIHZhciBub2RlID0gX25vZGVzWzBdO1xuICAgIF9zb3VyY2UgPSBub2RlICYmIG5vZGUubG9jICYmIG5vZGUubG9jLnNvdXJjZTtcbiAgfVxuXG4gIHZhciBfcG9zaXRpb25zID0gcG9zaXRpb25zO1xuXG4gIGlmICghX3Bvc2l0aW9ucyAmJiBfbm9kZXMpIHtcbiAgICBfcG9zaXRpb25zID0gX25vZGVzLnJlZHVjZShmdW5jdGlvbiAobGlzdCwgbm9kZSkge1xuICAgICAgaWYgKG5vZGUubG9jKSB7XG4gICAgICAgIGxpc3QucHVzaChub2RlLmxvYy5zdGFydCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sIFtdKTtcbiAgfVxuXG4gIGlmIChfcG9zaXRpb25zICYmIF9wb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgX3Bvc2l0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBfbG9jYXRpb25zO1xuXG4gIGlmIChwb3NpdGlvbnMgJiYgc291cmNlKSB7XG4gICAgX2xvY2F0aW9ucyA9IHBvc2l0aW9ucy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIGdldExvY2F0aW9uKHNvdXJjZSwgcG9zKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChfbm9kZXMpIHtcbiAgICBfbG9jYXRpb25zID0gX25vZGVzLnJlZHVjZShmdW5jdGlvbiAobGlzdCwgbm9kZSkge1xuICAgICAgaWYgKG5vZGUubG9jKSB7XG4gICAgICAgIGxpc3QucHVzaChnZXRMb2NhdGlvbihub2RlLmxvYy5zb3VyY2UsIG5vZGUubG9jLnN0YXJ0KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sIFtdKTtcbiAgfVxuXG4gIHZhciBfZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG5cbiAgaWYgKF9leHRlbnNpb25zID09IG51bGwgJiYgb3JpZ2luYWxFcnJvciAhPSBudWxsKSB7XG4gICAgdmFyIG9yaWdpbmFsRXh0ZW5zaW9ucyA9IG9yaWdpbmFsRXJyb3IuZXh0ZW5zaW9ucztcblxuICAgIGlmIChpc09iamVjdExpa2Uob3JpZ2luYWxFeHRlbnNpb25zKSkge1xuICAgICAgX2V4dGVuc2lvbnMgPSBvcmlnaW5hbEV4dGVuc2lvbnM7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIG1lc3NhZ2U6IHtcbiAgICAgIHZhbHVlOiBtZXNzYWdlLFxuICAgICAgLy8gQnkgYmVpbmcgZW51bWVyYWJsZSwgSlNPTi5zdHJpbmdpZnkgd2lsbCBpbmNsdWRlIGBtZXNzYWdlYCBpbiB0aGVcbiAgICAgIC8vIHJlc3VsdGluZyBvdXRwdXQuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBzaW1wbGVzdCBwb3NzaWJsZSBHcmFwaFFMXG4gICAgICAvLyBzZXJ2aWNlIGFkaGVyZXMgdG8gdGhlIHNwZWMuXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuICAgIGxvY2F0aW9uczoge1xuICAgICAgLy8gQ29lcmNpbmcgZmFsc2V5IHZhbHVlcyB0byB1bmRlZmluZWQgZW5zdXJlcyB0aGV5IHdpbGwgbm90IGJlIGluY2x1ZGVkXG4gICAgICAvLyBpbiBKU09OLnN0cmluZ2lmeSgpIHdoZW4gbm90IHByb3ZpZGVkLlxuICAgICAgdmFsdWU6IF9sb2NhdGlvbnMgfHwgdW5kZWZpbmVkLFxuICAgICAgLy8gQnkgYmVpbmcgZW51bWVyYWJsZSwgSlNPTi5zdHJpbmdpZnkgd2lsbCBpbmNsdWRlIGBsb2NhdGlvbnNgIGluIHRoZVxuICAgICAgLy8gcmVzdWx0aW5nIG91dHB1dC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHNpbXBsZXN0IHBvc3NpYmxlIEdyYXBoUUxcbiAgICAgIC8vIHNlcnZpY2UgYWRoZXJlcyB0byB0aGUgc3BlYy5cbiAgICAgIGVudW1lcmFibGU6IEJvb2xlYW4oX2xvY2F0aW9ucylcbiAgICB9LFxuICAgIHBhdGg6IHtcbiAgICAgIC8vIENvZXJjaW5nIGZhbHNleSB2YWx1ZXMgdG8gdW5kZWZpbmVkIGVuc3VyZXMgdGhleSB3aWxsIG5vdCBiZSBpbmNsdWRlZFxuICAgICAgLy8gaW4gSlNPTi5zdHJpbmdpZnkoKSB3aGVuIG5vdCBwcm92aWRlZC5cbiAgICAgIHZhbHVlOiBwYXRoIHx8IHVuZGVmaW5lZCxcbiAgICAgIC8vIEJ5IGJlaW5nIGVudW1lcmFibGUsIEpTT04uc3RyaW5naWZ5IHdpbGwgaW5jbHVkZSBgcGF0aGAgaW4gdGhlXG4gICAgICAvLyByZXN1bHRpbmcgb3V0cHV0LiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgc2ltcGxlc3QgcG9zc2libGUgR3JhcGhRTFxuICAgICAgLy8gc2VydmljZSBhZGhlcmVzIHRvIHRoZSBzcGVjLlxuICAgICAgZW51bWVyYWJsZTogQm9vbGVhbihwYXRoKVxuICAgIH0sXG4gICAgbm9kZXM6IHtcbiAgICAgIHZhbHVlOiBfbm9kZXMgfHwgdW5kZWZpbmVkXG4gICAgfSxcbiAgICBzb3VyY2U6IHtcbiAgICAgIHZhbHVlOiBfc291cmNlIHx8IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgcG9zaXRpb25zOiB7XG4gICAgICB2YWx1ZTogX3Bvc2l0aW9ucyB8fCB1bmRlZmluZWRcbiAgICB9LFxuICAgIG9yaWdpbmFsRXJyb3I6IHtcbiAgICAgIHZhbHVlOiBvcmlnaW5hbEVycm9yXG4gICAgfSxcbiAgICBleHRlbnNpb25zOiB7XG4gICAgICAvLyBDb2VyY2luZyBmYWxzZXkgdmFsdWVzIHRvIHVuZGVmaW5lZCBlbnN1cmVzIHRoZXkgd2lsbCBub3QgYmUgaW5jbHVkZWRcbiAgICAgIC8vIGluIEpTT04uc3RyaW5naWZ5KCkgd2hlbiBub3QgcHJvdmlkZWQuXG4gICAgICB2YWx1ZTogX2V4dGVuc2lvbnMgfHwgdW5kZWZpbmVkLFxuICAgICAgLy8gQnkgYmVpbmcgZW51bWVyYWJsZSwgSlNPTi5zdHJpbmdpZnkgd2lsbCBpbmNsdWRlIGBwYXRoYCBpbiB0aGVcbiAgICAgIC8vIHJlc3VsdGluZyBvdXRwdXQuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBzaW1wbGVzdCBwb3NzaWJsZSBHcmFwaFFMXG4gICAgICAvLyBzZXJ2aWNlIGFkaGVyZXMgdG8gdGhlIHNwZWMuXG4gICAgICBlbnVtZXJhYmxlOiBCb29sZWFuKF9leHRlbnNpb25zKVxuICAgIH1cbiAgfSk7IC8vIEluY2x1ZGUgKG5vbi1lbnVtZXJhYmxlKSBzdGFjayB0cmFjZS5cblxuICBpZiAob3JpZ2luYWxFcnJvciAmJiBvcmlnaW5hbEVycm9yLnN0YWNrKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGFjaycsIHtcbiAgICAgIHZhbHVlOiBvcmlnaW5hbEVycm9yLnN0YWNrLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEdyYXBoUUxFcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGFjaycsIHtcbiAgICAgIHZhbHVlOiBFcnJvcigpLnN0YWNrLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuR3JhcGhRTEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7XG4gICAgdmFsdWU6IEdyYXBoUUxFcnJvclxuICB9LFxuICBuYW1lOiB7XG4gICAgdmFsdWU6ICdHcmFwaFFMRXJyb3InXG4gIH0sXG4gIHRvU3RyaW5nOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHByaW50RXJyb3IodGhpcyk7XG4gICAgfVxuICB9XG59KTtcbi8qKlxuICogUHJpbnRzIGEgR3JhcGhRTEVycm9yIHRvIGEgc3RyaW5nLCByZXByZXNlbnRpbmcgdXNlZnVsIGxvY2F0aW9uIGluZm9ybWF0aW9uXG4gKiBhYm91dCB0aGUgZXJyb3IncyBwb3NpdGlvbiBpbiB0aGUgc291cmNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludEVycm9yKGVycm9yKSB7XG4gIHZhciBvdXRwdXQgPSBlcnJvci5tZXNzYWdlO1xuXG4gIGlmIChlcnJvci5ub2Rlcykge1xuICAgIGZvciAodmFyIF9pMiA9IDAsIF9lcnJvciRub2RlczIgPSBlcnJvci5ub2RlczsgX2kyIDwgX2Vycm9yJG5vZGVzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgbm9kZSA9IF9lcnJvciRub2RlczJbX2kyXTtcblxuICAgICAgaWYgKG5vZGUubG9jKSB7XG4gICAgICAgIG91dHB1dCArPSAnXFxuXFxuJyArIHByaW50TG9jYXRpb24obm9kZS5sb2MpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChlcnJvci5zb3VyY2UgJiYgZXJyb3IubG9jYXRpb25zKSB7XG4gICAgZm9yICh2YXIgX2k0ID0gMCwgX2Vycm9yJGxvY2F0aW9uczIgPSBlcnJvci5sb2NhdGlvbnM7IF9pNCA8IF9lcnJvciRsb2NhdGlvbnMyLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IF9lcnJvciRsb2NhdGlvbnMyW19pNF07XG4gICAgICBvdXRwdXQgKz0gJ1xcblxcbicgKyBwcmludFNvdXJjZUxvY2F0aW9uKGVycm9yLnNvdXJjZSwgbG9jYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4iLCJpbXBvcnQgeyBHcmFwaFFMRXJyb3IgfSBmcm9tICcuL0dyYXBoUUxFcnJvcic7XG4vKipcbiAqIFByb2R1Y2VzIGEgR3JhcGhRTEVycm9yIHJlcHJlc2VudGluZyBhIHN5bnRheCBlcnJvciwgY29udGFpbmluZyB1c2VmdWxcbiAqIGRlc2NyaXB0aXZlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzeW50YXggZXJyb3IncyBwb3NpdGlvbiBpbiB0aGUgc291cmNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzeW50YXhFcnJvcihzb3VyY2UsIHBvc2l0aW9uLCBkZXNjcmlwdGlvbikge1xuICByZXR1cm4gbmV3IEdyYXBoUUxFcnJvcihcIlN5bnRheCBFcnJvcjogXCIuY29uY2F0KGRlc2NyaXB0aW9uKSwgdW5kZWZpbmVkLCBzb3VyY2UsIFtwb3NpdGlvbl0pO1xufVxuIiwiLyoqXG4gKiBUaGUgc2V0IG9mIGFsbG93ZWQga2luZCB2YWx1ZXMgZm9yIEFTVCBub2Rlcy5cbiAqL1xuZXhwb3J0IHZhciBLaW5kID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC8vIE5hbWVcbiAgTkFNRTogJ05hbWUnLFxuICAvLyBEb2N1bWVudFxuICBET0NVTUVOVDogJ0RvY3VtZW50JyxcbiAgT1BFUkFUSU9OX0RFRklOSVRJT046ICdPcGVyYXRpb25EZWZpbml0aW9uJyxcbiAgVkFSSUFCTEVfREVGSU5JVElPTjogJ1ZhcmlhYmxlRGVmaW5pdGlvbicsXG4gIFNFTEVDVElPTl9TRVQ6ICdTZWxlY3Rpb25TZXQnLFxuICBGSUVMRDogJ0ZpZWxkJyxcbiAgQVJHVU1FTlQ6ICdBcmd1bWVudCcsXG4gIC8vIEZyYWdtZW50c1xuICBGUkFHTUVOVF9TUFJFQUQ6ICdGcmFnbWVudFNwcmVhZCcsXG4gIElOTElORV9GUkFHTUVOVDogJ0lubGluZUZyYWdtZW50JyxcbiAgRlJBR01FTlRfREVGSU5JVElPTjogJ0ZyYWdtZW50RGVmaW5pdGlvbicsXG4gIC8vIFZhbHVlc1xuICBWQVJJQUJMRTogJ1ZhcmlhYmxlJyxcbiAgSU5UOiAnSW50VmFsdWUnLFxuICBGTE9BVDogJ0Zsb2F0VmFsdWUnLFxuICBTVFJJTkc6ICdTdHJpbmdWYWx1ZScsXG4gIEJPT0xFQU46ICdCb29sZWFuVmFsdWUnLFxuICBOVUxMOiAnTnVsbFZhbHVlJyxcbiAgRU5VTTogJ0VudW1WYWx1ZScsXG4gIExJU1Q6ICdMaXN0VmFsdWUnLFxuICBPQkpFQ1Q6ICdPYmplY3RWYWx1ZScsXG4gIE9CSkVDVF9GSUVMRDogJ09iamVjdEZpZWxkJyxcbiAgLy8gRGlyZWN0aXZlc1xuICBESVJFQ1RJVkU6ICdEaXJlY3RpdmUnLFxuICAvLyBUeXBlc1xuICBOQU1FRF9UWVBFOiAnTmFtZWRUeXBlJyxcbiAgTElTVF9UWVBFOiAnTGlzdFR5cGUnLFxuICBOT05fTlVMTF9UWVBFOiAnTm9uTnVsbFR5cGUnLFxuICAvLyBUeXBlIFN5c3RlbSBEZWZpbml0aW9uc1xuICBTQ0hFTUFfREVGSU5JVElPTjogJ1NjaGVtYURlZmluaXRpb24nLFxuICBPUEVSQVRJT05fVFlQRV9ERUZJTklUSU9OOiAnT3BlcmF0aW9uVHlwZURlZmluaXRpb24nLFxuICAvLyBUeXBlIERlZmluaXRpb25zXG4gIFNDQUxBUl9UWVBFX0RFRklOSVRJT046ICdTY2FsYXJUeXBlRGVmaW5pdGlvbicsXG4gIE9CSkVDVF9UWVBFX0RFRklOSVRJT046ICdPYmplY3RUeXBlRGVmaW5pdGlvbicsXG4gIEZJRUxEX0RFRklOSVRJT046ICdGaWVsZERlZmluaXRpb24nLFxuICBJTlBVVF9WQUxVRV9ERUZJTklUSU9OOiAnSW5wdXRWYWx1ZURlZmluaXRpb24nLFxuICBJTlRFUkZBQ0VfVFlQRV9ERUZJTklUSU9OOiAnSW50ZXJmYWNlVHlwZURlZmluaXRpb24nLFxuICBVTklPTl9UWVBFX0RFRklOSVRJT046ICdVbmlvblR5cGVEZWZpbml0aW9uJyxcbiAgRU5VTV9UWVBFX0RFRklOSVRJT046ICdFbnVtVHlwZURlZmluaXRpb24nLFxuICBFTlVNX1ZBTFVFX0RFRklOSVRJT046ICdFbnVtVmFsdWVEZWZpbml0aW9uJyxcbiAgSU5QVVRfT0JKRUNUX1RZUEVfREVGSU5JVElPTjogJ0lucHV0T2JqZWN0VHlwZURlZmluaXRpb24nLFxuICAvLyBEaXJlY3RpdmUgRGVmaW5pdGlvbnNcbiAgRElSRUNUSVZFX0RFRklOSVRJT046ICdEaXJlY3RpdmVEZWZpbml0aW9uJyxcbiAgLy8gVHlwZSBTeXN0ZW0gRXh0ZW5zaW9uc1xuICBTQ0hFTUFfRVhURU5TSU9OOiAnU2NoZW1hRXh0ZW5zaW9uJyxcbiAgLy8gVHlwZSBFeHRlbnNpb25zXG4gIFNDQUxBUl9UWVBFX0VYVEVOU0lPTjogJ1NjYWxhclR5cGVFeHRlbnNpb24nLFxuICBPQkpFQ1RfVFlQRV9FWFRFTlNJT046ICdPYmplY3RUeXBlRXh0ZW5zaW9uJyxcbiAgSU5URVJGQUNFX1RZUEVfRVhURU5TSU9OOiAnSW50ZXJmYWNlVHlwZUV4dGVuc2lvbicsXG4gIFVOSU9OX1RZUEVfRVhURU5TSU9OOiAnVW5pb25UeXBlRXh0ZW5zaW9uJyxcbiAgRU5VTV9UWVBFX0VYVEVOU0lPTjogJ0VudW1UeXBlRXh0ZW5zaW9uJyxcbiAgSU5QVVRfT0JKRUNUX1RZUEVfRVhURU5TSU9OOiAnSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uJ1xufSk7XG4vKipcbiAqIFRoZSBlbnVtIHR5cGUgcmVwcmVzZW50aW5nIHRoZSBwb3NzaWJsZSBraW5kIHZhbHVlcyBvZiBBU1Qgbm9kZXMuXG4gKi9cbiIsIi8qKlxuICogVGhlIGBkZWZpbmVUb1N0cmluZ1RhZygpYCBmdW5jdGlvbiBjaGVja3MgZmlyc3QgdG8gc2VlIGlmIHRoZSBydW50aW1lXG4gKiBzdXBwb3J0cyB0aGUgYFN5bWJvbGAgY2xhc3MgYW5kIHRoZW4gaWYgdGhlIGBTeW1ib2wudG9TdHJpbmdUYWdgIGNvbnN0YW50XG4gKiBpcyBkZWZpbmVkIGFzIGEgYFN5bWJvbGAgaW5zdGFuY2UuIElmIGJvdGggY29uZGl0aW9ucyBhcmUgbWV0LCB0aGVcbiAqIFN5bWJvbC50b1N0cmluZ1RhZyBwcm9wZXJ0eSBpcyBkZWZpbmVkIGFzIGEgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGVcbiAqIHN1cHBsaWVkIGNsYXNzIGNvbnN0cnVjdG9yJ3MgbmFtZS5cbiAqXG4gKiBAbWV0aG9kIGRlZmluZVRvU3RyaW5nVGFnXG4gKlxuICogQHBhcmFtIHtDbGFzczxhbnk+fSBjbGFzc09iamVjdCBhIGNsYXNzIHN1Y2ggYXMgT2JqZWN0LCBTdHJpbmcsIE51bWJlciBidXRcbiAqIHR5cGljYWxseSBvbmUgb2YgeW91ciBvd24gY3JlYXRpb24gdGhyb3VnaCB0aGUgY2xhc3Mga2V5d29yZDsgYGNsYXNzIEEge31gLFxuICogZm9yIGV4YW1wbGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZmluZVRvU3RyaW5nVGFnKGNsYXNzT2JqZWN0KSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc09iamVjdC5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBkZXZBc3NlcnQgZnJvbSAnLi4vanN1dGlscy9kZXZBc3NlcnQnO1xuaW1wb3J0IGRlZmluZVRvU3RyaW5nVGFnIGZyb20gJy4uL2pzdXRpbHMvZGVmaW5lVG9TdHJpbmdUYWcnO1xuXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2Ygc291cmNlIGlucHV0IHRvIEdyYXBoUUwuXG4gKiBgbmFtZWAgYW5kIGBsb2NhdGlvbk9mZnNldGAgYXJlIG9wdGlvbmFsLiBUaGV5IGFyZSB1c2VmdWwgZm9yIGNsaWVudHMgd2hvXG4gKiBzdG9yZSBHcmFwaFFMIGRvY3VtZW50cyBpbiBzb3VyY2UgZmlsZXM7IGZvciBleGFtcGxlLCBpZiB0aGUgR3JhcGhRTCBpbnB1dFxuICogc3RhcnRzIGF0IGxpbmUgNDAgaW4gYSBmaWxlIG5hbWVkIEZvby5ncmFwaHFsLCBpdCBtaWdodCBiZSB1c2VmdWwgZm9yIG5hbWUgdG9cbiAqIGJlIFwiRm9vLmdyYXBocWxcIiBhbmQgbG9jYXRpb24gdG8gYmUgYHsgbGluZTogNDAsIGNvbHVtbjogMCB9YC5cbiAqIGxpbmUgYW5kIGNvbHVtbiBpbiBsb2NhdGlvbk9mZnNldCBhcmUgMS1pbmRleGVkXG4gKi9cbmV4cG9ydCB2YXIgU291cmNlID0gZnVuY3Rpb24gU291cmNlKGJvZHksIG5hbWUsIGxvY2F0aW9uT2Zmc2V0KSB7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG4gIHRoaXMubmFtZSA9IG5hbWUgfHwgJ0dyYXBoUUwgcmVxdWVzdCc7XG4gIHRoaXMubG9jYXRpb25PZmZzZXQgPSBsb2NhdGlvbk9mZnNldCB8fCB7XG4gICAgbGluZTogMSxcbiAgICBjb2x1bW46IDFcbiAgfTtcbiAgdGhpcy5sb2NhdGlvbk9mZnNldC5saW5lID4gMCB8fCBkZXZBc3NlcnQoMCwgJ2xpbmUgaW4gbG9jYXRpb25PZmZzZXQgaXMgMS1pbmRleGVkIGFuZCBtdXN0IGJlIHBvc2l0aXZlJyk7XG4gIHRoaXMubG9jYXRpb25PZmZzZXQuY29sdW1uID4gMCB8fCBkZXZBc3NlcnQoMCwgJ2NvbHVtbiBpbiBsb2NhdGlvbk9mZnNldCBpcyAxLWluZGV4ZWQgYW5kIG11c3QgYmUgcG9zaXRpdmUnKTtcbn07IC8vIENvbmRpdGlvbmFsbHkgYXBwbHkgYFtTeW1ib2wudG9TdHJpbmdUYWddYCBpZiBgU3ltYm9sYHMgYXJlIHN1cHBvcnRlZFxuXG5kZWZpbmVUb1N0cmluZ1RhZyhTb3VyY2UpO1xuIiwiLyoqXG4gKiBBbiBleHBvcnRlZCBlbnVtIGRlc2NyaWJpbmcgdGhlIGRpZmZlcmVudCBraW5kcyBvZiB0b2tlbnMgdGhhdCB0aGVcbiAqIGxleGVyIGVtaXRzLlxuICovXG5leHBvcnQgdmFyIFRva2VuS2luZCA9IE9iamVjdC5mcmVlemUoe1xuICBTT0Y6ICc8U09GPicsXG4gIEVPRjogJzxFT0Y+JyxcbiAgQkFORzogJyEnLFxuICBET0xMQVI6ICckJyxcbiAgQU1QOiAnJicsXG4gIFBBUkVOX0w6ICcoJyxcbiAgUEFSRU5fUjogJyknLFxuICBTUFJFQUQ6ICcuLi4nLFxuICBDT0xPTjogJzonLFxuICBFUVVBTFM6ICc9JyxcbiAgQVQ6ICdAJyxcbiAgQlJBQ0tFVF9MOiAnWycsXG4gIEJSQUNLRVRfUjogJ10nLFxuICBCUkFDRV9MOiAneycsXG4gIFBJUEU6ICd8JyxcbiAgQlJBQ0VfUjogJ30nLFxuICBOQU1FOiAnTmFtZScsXG4gIElOVDogJ0ludCcsXG4gIEZMT0FUOiAnRmxvYXQnLFxuICBTVFJJTkc6ICdTdHJpbmcnLFxuICBCTE9DS19TVFJJTkc6ICdCbG9ja1N0cmluZycsXG4gIENPTU1FTlQ6ICdDb21tZW50J1xufSk7XG4vKipcbiAqIFRoZSBlbnVtIHR5cGUgcmVwcmVzZW50aW5nIHRoZSB0b2tlbiBraW5kcyB2YWx1ZXMuXG4gKi9cbiIsImltcG9ydCBkZWZpbmVUb0pTT04gZnJvbSAnLi4vanN1dGlscy9kZWZpbmVUb0pTT04nO1xuaW1wb3J0IHsgc3ludGF4RXJyb3IgfSBmcm9tICcuLi9lcnJvci9zeW50YXhFcnJvcic7XG5pbXBvcnQgeyBkZWRlbnRCbG9ja1N0cmluZ1ZhbHVlIH0gZnJvbSAnLi9ibG9ja1N0cmluZyc7XG5pbXBvcnQgeyBUb2tlbktpbmQgfSBmcm9tICcuL3Rva2VuS2luZCc7XG4vKipcbiAqIEdpdmVuIGEgU291cmNlIG9iamVjdCwgdGhpcyByZXR1cm5zIGEgTGV4ZXIgZm9yIHRoYXQgc291cmNlLlxuICogQSBMZXhlciBpcyBhIHN0YXRlZnVsIHN0cmVhbSBnZW5lcmF0b3IgaW4gdGhhdCBldmVyeSB0aW1lXG4gKiBpdCBpcyBhZHZhbmNlZCwgaXQgcmV0dXJucyB0aGUgbmV4dCB0b2tlbiBpbiB0aGUgU291cmNlLiBBc3N1bWluZyB0aGVcbiAqIHNvdXJjZSBsZXhlcywgdGhlIGZpbmFsIFRva2VuIGVtaXR0ZWQgYnkgdGhlIGxleGVyIHdpbGwgYmUgb2Yga2luZFxuICogRU9GLCBhZnRlciB3aGljaCB0aGUgbGV4ZXIgd2lsbCByZXBlYXRlZGx5IHJldHVybiB0aGUgc2FtZSBFT0YgdG9rZW5cbiAqIHdoZW5ldmVyIGNhbGxlZC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGV4ZXIoc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBzdGFydE9mRmlsZVRva2VuID0gbmV3IFRvayhUb2tlbktpbmQuU09GLCAwLCAwLCAwLCAwLCBudWxsKTtcbiAgdmFyIGxleGVyID0ge1xuICAgIHNvdXJjZTogc291cmNlLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgbGFzdFRva2VuOiBzdGFydE9mRmlsZVRva2VuLFxuICAgIHRva2VuOiBzdGFydE9mRmlsZVRva2VuLFxuICAgIGxpbmU6IDEsXG4gICAgbGluZVN0YXJ0OiAwLFxuICAgIGFkdmFuY2U6IGFkdmFuY2VMZXhlcixcbiAgICBsb29rYWhlYWQ6IGxvb2thaGVhZFxuICB9O1xuICByZXR1cm4gbGV4ZXI7XG59XG5cbmZ1bmN0aW9uIGFkdmFuY2VMZXhlcigpIHtcbiAgdGhpcy5sYXN0VG9rZW4gPSB0aGlzLnRva2VuO1xuICB2YXIgdG9rZW4gPSB0aGlzLnRva2VuID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgcmV0dXJuIHRva2VuO1xufVxuXG5mdW5jdGlvbiBsb29rYWhlYWQoKSB7XG4gIHZhciB0b2tlbiA9IHRoaXMudG9rZW47XG5cbiAgaWYgKHRva2VuLmtpbmQgIT09IFRva2VuS2luZC5FT0YpIHtcbiAgICBkbyB7XG4gICAgICAvLyBOb3RlOiBuZXh0IGlzIG9ubHkgbXV0YWJsZSBkdXJpbmcgcGFyc2luZywgc28gd2UgY2FzdCB0byBhbGxvdyB0aGlzLlxuICAgICAgdG9rZW4gPSB0b2tlbi5uZXh0IHx8ICh0b2tlbi5uZXh0ID0gcmVhZFRva2VuKHRoaXMsIHRva2VuKSk7XG4gICAgfSB3aGlsZSAodG9rZW4ua2luZCA9PT0gVG9rZW5LaW5kLkNPTU1FTlQpO1xuICB9XG5cbiAgcmV0dXJuIHRva2VuO1xufVxuLyoqXG4gKiBUaGUgcmV0dXJuIHR5cGUgb2YgY3JlYXRlTGV4ZXIuXG4gKi9cblxuXG4vLyBAaW50ZXJuYWxcbmV4cG9ydCBmdW5jdGlvbiBpc1B1bmN0dWF0b3JUb2tlbih0b2tlbikge1xuICB2YXIga2luZCA9IHRva2VuLmtpbmQ7XG4gIHJldHVybiBraW5kID09PSBUb2tlbktpbmQuQkFORyB8fCBraW5kID09PSBUb2tlbktpbmQuRE9MTEFSIHx8IGtpbmQgPT09IFRva2VuS2luZC5BTVAgfHwga2luZCA9PT0gVG9rZW5LaW5kLlBBUkVOX0wgfHwga2luZCA9PT0gVG9rZW5LaW5kLlBBUkVOX1IgfHwga2luZCA9PT0gVG9rZW5LaW5kLlNQUkVBRCB8fCBraW5kID09PSBUb2tlbktpbmQuQ09MT04gfHwga2luZCA9PT0gVG9rZW5LaW5kLkVRVUFMUyB8fCBraW5kID09PSBUb2tlbktpbmQuQVQgfHwga2luZCA9PT0gVG9rZW5LaW5kLkJSQUNLRVRfTCB8fCBraW5kID09PSBUb2tlbktpbmQuQlJBQ0tFVF9SIHx8IGtpbmQgPT09IFRva2VuS2luZC5CUkFDRV9MIHx8IGtpbmQgPT09IFRva2VuS2luZC5QSVBFIHx8IGtpbmQgPT09IFRva2VuS2luZC5CUkFDRV9SO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGNvbnN0cnVjdGluZyB0aGUgVG9rZW4gb2JqZWN0LlxuICovXG5cbmZ1bmN0aW9uIFRvayhraW5kLCBzdGFydCwgZW5kLCBsaW5lLCBjb2x1bW4sIHByZXYsIHZhbHVlKSB7XG4gIHRoaXMua2luZCA9IGtpbmQ7XG4gIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgdGhpcy5lbmQgPSBlbmQ7XG4gIHRoaXMubGluZSA9IGxpbmU7XG4gIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMucHJldiA9IHByZXY7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59IC8vIFByaW50IGEgc2ltcGxpZmllZCBmb3JtIHdoZW4gYXBwZWFyaW5nIGluIEpTT04vdXRpbC5pbnNwZWN0LlxuXG5cbmRlZmluZVRvSlNPTihUb2ssIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgbGluZTogdGhpcy5saW5lLFxuICAgIGNvbHVtbjogdGhpcy5jb2x1bW5cbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBwcmludENoYXJDb2RlKGNvZGUpIHtcbiAgcmV0dXJuICgvLyBOYU4vdW5kZWZpbmVkIHJlcHJlc2VudHMgYWNjZXNzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuICAgIGlzTmFOKGNvZGUpID8gVG9rZW5LaW5kLkVPRiA6IC8vIFRydXN0IEpTT04gZm9yIEFTQ0lJLlxuICAgIGNvZGUgPCAweDAwN2YgPyBKU09OLnN0cmluZ2lmeShTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSA6IC8vIE90aGVyd2lzZSBwcmludCB0aGUgZXNjYXBlZCBmb3JtLlxuICAgIFwiXFxcIlxcXFx1XCIuY29uY2F0KCgnMDAnICsgY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTQpLCBcIlxcXCJcIilcbiAgKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgbmV4dCB0b2tlbiBmcm9tIHRoZSBzb3VyY2Ugc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICpcbiAqIFRoaXMgc2tpcHMgb3ZlciB3aGl0ZXNwYWNlIHVudGlsIGl0IGZpbmRzIHRoZSBuZXh0IGxleGFibGUgdG9rZW4sIHRoZW4gbGV4ZXNcbiAqIHB1bmN0dWF0b3JzIGltbWVkaWF0ZWx5IG9yIGNhbGxzIHRoZSBhcHByb3ByaWF0ZSBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vcmVcbiAqIGNvbXBsaWNhdGVkIHRva2Vucy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlYWRUb2tlbihsZXhlciwgcHJldikge1xuICB2YXIgc291cmNlID0gbGV4ZXIuc291cmNlO1xuICB2YXIgYm9keSA9IHNvdXJjZS5ib2R5O1xuICB2YXIgYm9keUxlbmd0aCA9IGJvZHkubGVuZ3RoO1xuICB2YXIgcG9zID0gcG9zaXRpb25BZnRlcldoaXRlc3BhY2UoYm9keSwgcHJldi5lbmQsIGxleGVyKTtcbiAgdmFyIGxpbmUgPSBsZXhlci5saW5lO1xuICB2YXIgY29sID0gMSArIHBvcyAtIGxleGVyLmxpbmVTdGFydDtcblxuICBpZiAocG9zID49IGJvZHlMZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFRvayhUb2tlbktpbmQuRU9GLCBib2R5TGVuZ3RoLCBib2R5TGVuZ3RoLCBsaW5lLCBjb2wsIHByZXYpO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zKTsgLy8gU291cmNlQ2hhcmFjdGVyXG5cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgLy8gIVxuICAgIGNhc2UgMzM6XG4gICAgICByZXR1cm4gbmV3IFRvayhUb2tlbktpbmQuQkFORywgcG9zLCBwb3MgKyAxLCBsaW5lLCBjb2wsIHByZXYpO1xuICAgIC8vICNcblxuICAgIGNhc2UgMzU6XG4gICAgICByZXR1cm4gcmVhZENvbW1lbnQoc291cmNlLCBwb3MsIGxpbmUsIGNvbCwgcHJldik7XG4gICAgLy8gJFxuXG4gICAgY2FzZSAzNjpcbiAgICAgIHJldHVybiBuZXcgVG9rKFRva2VuS2luZC5ET0xMQVIsIHBvcywgcG9zICsgMSwgbGluZSwgY29sLCBwcmV2KTtcbiAgICAvLyAmXG5cbiAgICBjYXNlIDM4OlxuICAgICAgcmV0dXJuIG5ldyBUb2soVG9rZW5LaW5kLkFNUCwgcG9zLCBwb3MgKyAxLCBsaW5lLCBjb2wsIHByZXYpO1xuICAgIC8vIChcblxuICAgIGNhc2UgNDA6XG4gICAgICByZXR1cm4gbmV3IFRvayhUb2tlbktpbmQuUEFSRU5fTCwgcG9zLCBwb3MgKyAxLCBsaW5lLCBjb2wsIHByZXYpO1xuICAgIC8vIClcblxuICAgIGNhc2UgNDE6XG4gICAgICByZXR1cm4gbmV3IFRvayhUb2tlbktpbmQuUEFSRU5fUiwgcG9zLCBwb3MgKyAxLCBsaW5lLCBjb2wsIHByZXYpO1xuICAgIC8vIC5cblxuICAgIGNhc2UgNDY6XG4gICAgICBpZiAoYm9keS5jaGFyQ29kZUF0KHBvcyArIDEpID09PSA0NiAmJiBib2R5LmNoYXJDb2RlQXQocG9zICsgMikgPT09IDQ2KSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rKFRva2VuS2luZC5TUFJFQUQsIHBvcywgcG9zICsgMywgbGluZSwgY29sLCBwcmV2KTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgLy8gOlxuXG4gICAgY2FzZSA1ODpcbiAgICAgIHJldHVybiBuZXcgVG9rKFRva2VuS2luZC5DT0xPTiwgcG9zLCBwb3MgKyAxLCBsaW5lLCBjb2wsIHByZXYpO1xuICAgIC8vID1cblxuICAgIGNhc2UgNjE6XG4gICAgICByZXR1cm4gbmV3IFRvayhUb2tlbktpbmQuRVFVQUxTLCBwb3MsIHBvcyArIDEsIGxpbmUsIGNvbCwgcHJldik7XG4gICAgLy8gQFxuXG4gICAgY2FzZSA2NDpcbiAgICAgIHJldHVybiBuZXcgVG9rKFRva2VuS2luZC5BVCwgcG9zLCBwb3MgKyAxLCBsaW5lLCBjb2wsIHByZXYpO1xuICAgIC8vIFtcblxuICAgIGNhc2UgOTE6XG4gICAgICByZXR1cm4gbmV3IFRvayhUb2tlbktpbmQuQlJBQ0tFVF9MLCBwb3MsIHBvcyArIDEsIGxpbmUsIGNvbCwgcHJldik7XG4gICAgLy8gXVxuXG4gICAgY2FzZSA5MzpcbiAgICAgIHJldHVybiBuZXcgVG9rKFRva2VuS2luZC5CUkFDS0VUX1IsIHBvcywgcG9zICsgMSwgbGluZSwgY29sLCBwcmV2KTtcbiAgICAvLyB7XG5cbiAgICBjYXNlIDEyMzpcbiAgICAgIHJldHVybiBuZXcgVG9rKFRva2VuS2luZC5CUkFDRV9MLCBwb3MsIHBvcyArIDEsIGxpbmUsIGNvbCwgcHJldik7XG4gICAgLy8gfFxuXG4gICAgY2FzZSAxMjQ6XG4gICAgICByZXR1cm4gbmV3IFRvayhUb2tlbktpbmQuUElQRSwgcG9zLCBwb3MgKyAxLCBsaW5lLCBjb2wsIHByZXYpO1xuICAgIC8vIH1cblxuICAgIGNhc2UgMTI1OlxuICAgICAgcmV0dXJuIG5ldyBUb2soVG9rZW5LaW5kLkJSQUNFX1IsIHBvcywgcG9zICsgMSwgbGluZSwgY29sLCBwcmV2KTtcbiAgICAvLyBBLVogXyBhLXpcblxuICAgIGNhc2UgNjU6XG4gICAgY2FzZSA2NjpcbiAgICBjYXNlIDY3OlxuICAgIGNhc2UgNjg6XG4gICAgY2FzZSA2OTpcbiAgICBjYXNlIDcwOlxuICAgIGNhc2UgNzE6XG4gICAgY2FzZSA3MjpcbiAgICBjYXNlIDczOlxuICAgIGNhc2UgNzQ6XG4gICAgY2FzZSA3NTpcbiAgICBjYXNlIDc2OlxuICAgIGNhc2UgNzc6XG4gICAgY2FzZSA3ODpcbiAgICBjYXNlIDc5OlxuICAgIGNhc2UgODA6XG4gICAgY2FzZSA4MTpcbiAgICBjYXNlIDgyOlxuICAgIGNhc2UgODM6XG4gICAgY2FzZSA4NDpcbiAgICBjYXNlIDg1OlxuICAgIGNhc2UgODY6XG4gICAgY2FzZSA4NzpcbiAgICBjYXNlIDg4OlxuICAgIGNhc2UgODk6XG4gICAgY2FzZSA5MDpcbiAgICBjYXNlIDk1OlxuICAgIGNhc2UgOTc6XG4gICAgY2FzZSA5ODpcbiAgICBjYXNlIDk5OlxuICAgIGNhc2UgMTAwOlxuICAgIGNhc2UgMTAxOlxuICAgIGNhc2UgMTAyOlxuICAgIGNhc2UgMTAzOlxuICAgIGNhc2UgMTA0OlxuICAgIGNhc2UgMTA1OlxuICAgIGNhc2UgMTA2OlxuICAgIGNhc2UgMTA3OlxuICAgIGNhc2UgMTA4OlxuICAgIGNhc2UgMTA5OlxuICAgIGNhc2UgMTEwOlxuICAgIGNhc2UgMTExOlxuICAgIGNhc2UgMTEyOlxuICAgIGNhc2UgMTEzOlxuICAgIGNhc2UgMTE0OlxuICAgIGNhc2UgMTE1OlxuICAgIGNhc2UgMTE2OlxuICAgIGNhc2UgMTE3OlxuICAgIGNhc2UgMTE4OlxuICAgIGNhc2UgMTE5OlxuICAgIGNhc2UgMTIwOlxuICAgIGNhc2UgMTIxOlxuICAgIGNhc2UgMTIyOlxuICAgICAgcmV0dXJuIHJlYWROYW1lKHNvdXJjZSwgcG9zLCBsaW5lLCBjb2wsIHByZXYpO1xuICAgIC8vIC0gMC05XG5cbiAgICBjYXNlIDQ1OlxuICAgIGNhc2UgNDg6XG4gICAgY2FzZSA0OTpcbiAgICBjYXNlIDUwOlxuICAgIGNhc2UgNTE6XG4gICAgY2FzZSA1MjpcbiAgICBjYXNlIDUzOlxuICAgIGNhc2UgNTQ6XG4gICAgY2FzZSA1NTpcbiAgICBjYXNlIDU2OlxuICAgIGNhc2UgNTc6XG4gICAgICByZXR1cm4gcmVhZE51bWJlcihzb3VyY2UsIHBvcywgY29kZSwgbGluZSwgY29sLCBwcmV2KTtcbiAgICAvLyBcIlxuXG4gICAgY2FzZSAzNDpcbiAgICAgIGlmIChib2R5LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDM0ICYmIGJvZHkuY2hhckNvZGVBdChwb3MgKyAyKSA9PT0gMzQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9ja1N0cmluZyhzb3VyY2UsIHBvcywgbGluZSwgY29sLCBwcmV2LCBsZXhlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWFkU3RyaW5nKHNvdXJjZSwgcG9zLCBsaW5lLCBjb2wsIHByZXYpO1xuICB9XG5cbiAgdGhyb3cgc3ludGF4RXJyb3Ioc291cmNlLCBwb3MsIHVuZXhwZWN0ZWRDaGFyYWN0ZXJNZXNzYWdlKGNvZGUpKTtcbn1cbi8qKlxuICogUmVwb3J0IGEgbWVzc2FnZSB0aGF0IGFuIHVuZXhwZWN0ZWQgY2hhcmFjdGVyIHdhcyBlbmNvdW50ZXJlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHVuZXhwZWN0ZWRDaGFyYWN0ZXJNZXNzYWdlKGNvZGUpIHtcbiAgaWYgKGNvZGUgPCAweDAwMjAgJiYgY29kZSAhPT0gMHgwMDA5ICYmIGNvZGUgIT09IDB4MDAwYSAmJiBjb2RlICE9PSAweDAwMGQpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgY29udGFpbiB0aGUgaW52YWxpZCBjaGFyYWN0ZXIgXCIuY29uY2F0KHByaW50Q2hhckNvZGUoY29kZSksIFwiLlwiKTtcbiAgfVxuXG4gIGlmIChjb2RlID09PSAzOSkge1xuICAgIC8vICdcbiAgICByZXR1cm4gJ1VuZXhwZWN0ZWQgc2luZ2xlIHF1b3RlIGNoYXJhY3RlciAoXFwnKSwgZGlkIHlvdSBtZWFuIHRvIHVzZSBhIGRvdWJsZSBxdW90ZSAoXCIpPyc7XG4gIH1cblxuICByZXR1cm4gXCJDYW5ub3QgcGFyc2UgdGhlIHVuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiLmNvbmNhdChwcmludENoYXJDb2RlKGNvZGUpLCBcIi5cIik7XG59XG4vKipcbiAqIFJlYWRzIGZyb20gYm9keSBzdGFydGluZyBhdCBzdGFydFBvc2l0aW9uIHVudGlsIGl0IGZpbmRzIGEgbm9uLXdoaXRlc3BhY2VcbiAqIGNoYXJhY3RlciwgdGhlbiByZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGF0IGNoYXJhY3RlciBmb3IgbGV4aW5nLlxuICovXG5cblxuZnVuY3Rpb24gcG9zaXRpb25BZnRlcldoaXRlc3BhY2UoYm9keSwgc3RhcnRQb3NpdGlvbiwgbGV4ZXIpIHtcbiAgdmFyIGJvZHlMZW5ndGggPSBib2R5Lmxlbmd0aDtcbiAgdmFyIHBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcblxuICB3aGlsZSAocG9zaXRpb24gPCBib2R5TGVuZ3RoKSB7XG4gICAgdmFyIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pOyAvLyB0YWIgfCBzcGFjZSB8IGNvbW1hIHwgQk9NXG5cbiAgICBpZiAoY29kZSA9PT0gOSB8fCBjb2RlID09PSAzMiB8fCBjb2RlID09PSA0NCB8fCBjb2RlID09PSAweGZlZmYpIHtcbiAgICAgICsrcG9zaXRpb247XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAxMCkge1xuICAgICAgLy8gbmV3IGxpbmVcbiAgICAgICsrcG9zaXRpb247XG4gICAgICArK2xleGVyLmxpbmU7XG4gICAgICBsZXhlci5saW5lU3RhcnQgPSBwb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDEzKSB7XG4gICAgICAvLyBjYXJyaWFnZSByZXR1cm5cbiAgICAgIGlmIChib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA9PT0gMTApIHtcbiAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICsrcG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgICsrbGV4ZXIubGluZTtcbiAgICAgIGxleGVyLmxpbmVTdGFydCA9IHBvc2l0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb247XG59XG4vKipcbiAqIFJlYWRzIGEgY29tbWVudCB0b2tlbiBmcm9tIHRoZSBzb3VyY2UgZmlsZS5cbiAqXG4gKiAjW1xcdTAwMDlcXHUwMDIwLVxcdUZGRkZdKlxuICovXG5cblxuZnVuY3Rpb24gcmVhZENvbW1lbnQoc291cmNlLCBzdGFydCwgbGluZSwgY29sLCBwcmV2KSB7XG4gIHZhciBib2R5ID0gc291cmNlLmJvZHk7XG4gIHZhciBjb2RlO1xuICB2YXIgcG9zaXRpb24gPSBzdGFydDtcblxuICBkbyB7XG4gICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcbiAgfSB3aGlsZSAoIWlzTmFOKGNvZGUpICYmICggLy8gU291cmNlQ2hhcmFjdGVyIGJ1dCBub3QgTGluZVRlcm1pbmF0b3JcbiAgY29kZSA+IDB4MDAxZiB8fCBjb2RlID09PSAweDAwMDkpKTtcblxuICByZXR1cm4gbmV3IFRvayhUb2tlbktpbmQuQ09NTUVOVCwgc3RhcnQsIHBvc2l0aW9uLCBsaW5lLCBjb2wsIHByZXYsIGJvZHkuc2xpY2Uoc3RhcnQgKyAxLCBwb3NpdGlvbikpO1xufVxuLyoqXG4gKiBSZWFkcyBhIG51bWJlciB0b2tlbiBmcm9tIHRoZSBzb3VyY2UgZmlsZSwgZWl0aGVyIGEgZmxvYXRcbiAqIG9yIGFuIGludCBkZXBlbmRpbmcgb24gd2hldGhlciBhIGRlY2ltYWwgcG9pbnQgYXBwZWFycy5cbiAqXG4gKiBJbnQ6ICAgLT8oMHxbMS05XVswLTldKilcbiAqIEZsb2F0OiAtPygwfFsxLTldWzAtOV0qKShcXC5bMC05XSspPygoRXxlKSgrfC0pP1swLTldKyk/XG4gKi9cblxuXG5mdW5jdGlvbiByZWFkTnVtYmVyKHNvdXJjZSwgc3RhcnQsIGZpcnN0Q29kZSwgbGluZSwgY29sLCBwcmV2KSB7XG4gIHZhciBib2R5ID0gc291cmNlLmJvZHk7XG4gIHZhciBjb2RlID0gZmlyc3RDb2RlO1xuICB2YXIgcG9zaXRpb24gPSBzdGFydDtcbiAgdmFyIGlzRmxvYXQgPSBmYWxzZTtcblxuICBpZiAoY29kZSA9PT0gNDUpIHtcbiAgICAvLyAtXG4gICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChjb2RlID09PSA0OCkge1xuICAgIC8vIDBcbiAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xuXG4gICAgaWYgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1Nykge1xuICAgICAgdGhyb3cgc3ludGF4RXJyb3Ioc291cmNlLCBwb3NpdGlvbiwgXCJJbnZhbGlkIG51bWJlciwgdW5leHBlY3RlZCBkaWdpdCBhZnRlciAwOiBcIi5jb25jYXQocHJpbnRDaGFyQ29kZShjb2RlKSwgXCIuXCIpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcG9zaXRpb24gPSByZWFkRGlnaXRzKHNvdXJjZSwgcG9zaXRpb24sIGNvZGUpO1xuICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICB9XG5cbiAgaWYgKGNvZGUgPT09IDQ2KSB7XG4gICAgLy8gLlxuICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XG4gICAgcG9zaXRpb24gPSByZWFkRGlnaXRzKHNvdXJjZSwgcG9zaXRpb24sIGNvZGUpO1xuICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICB9XG5cbiAgaWYgKGNvZGUgPT09IDY5IHx8IGNvZGUgPT09IDEwMSkge1xuICAgIC8vIEUgZVxuICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XG5cbiAgICBpZiAoY29kZSA9PT0gNDMgfHwgY29kZSA9PT0gNDUpIHtcbiAgICAgIC8vICsgLVxuICAgICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBwb3NpdGlvbiA9IHJlYWREaWdpdHMoc291cmNlLCBwb3NpdGlvbiwgY29kZSk7XG4gICAgY29kZSA9IGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gIH0gLy8gTnVtYmVycyBjYW5ub3QgYmUgZm9sbG93ZWQgYnkgLiBvciBlXG5cblxuICBpZiAoY29kZSA9PT0gNDYgfHwgY29kZSA9PT0gNjkgfHwgY29kZSA9PT0gMTAxKSB7XG4gICAgdGhyb3cgc3ludGF4RXJyb3Ioc291cmNlLCBwb3NpdGlvbiwgXCJJbnZhbGlkIG51bWJlciwgZXhwZWN0ZWQgZGlnaXQgYnV0IGdvdDogXCIuY29uY2F0KHByaW50Q2hhckNvZGUoY29kZSksIFwiLlwiKSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFRvayhpc0Zsb2F0ID8gVG9rZW5LaW5kLkZMT0FUIDogVG9rZW5LaW5kLklOVCwgc3RhcnQsIHBvc2l0aW9uLCBsaW5lLCBjb2wsIHByZXYsIGJvZHkuc2xpY2Uoc3RhcnQsIHBvc2l0aW9uKSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5ldyBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGFmdGVyIHJlYWRpbmcgZGlnaXRzLlxuICovXG5cblxuZnVuY3Rpb24gcmVhZERpZ2l0cyhzb3VyY2UsIHN0YXJ0LCBmaXJzdENvZGUpIHtcbiAgdmFyIGJvZHkgPSBzb3VyY2UuYm9keTtcbiAgdmFyIHBvc2l0aW9uID0gc3RhcnQ7XG4gIHZhciBjb2RlID0gZmlyc3RDb2RlO1xuXG4gIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHtcbiAgICAvLyAwIC0gOVxuICAgIGRvIHtcbiAgICAgIGNvZGUgPSBib2R5LmNoYXJDb2RlQXQoKytwb3NpdGlvbik7XG4gICAgfSB3aGlsZSAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KTsgLy8gMCAtIDlcblxuXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG5cbiAgdGhyb3cgc3ludGF4RXJyb3Ioc291cmNlLCBwb3NpdGlvbiwgXCJJbnZhbGlkIG51bWJlciwgZXhwZWN0ZWQgZGlnaXQgYnV0IGdvdDogXCIuY29uY2F0KHByaW50Q2hhckNvZGUoY29kZSksIFwiLlwiKSk7XG59XG4vKipcbiAqIFJlYWRzIGEgc3RyaW5nIHRva2VuIGZyb20gdGhlIHNvdXJjZSBmaWxlLlxuICpcbiAqIFwiKFteXCJcXFxcXFx1MDAwQVxcdTAwMERdfChcXFxcKHVbMC05YS1mQS1GXXs0fXxbXCJcXFxcL2JmbnJ0XSkpKSpcIlxuICovXG5cblxuZnVuY3Rpb24gcmVhZFN0cmluZyhzb3VyY2UsIHN0YXJ0LCBsaW5lLCBjb2wsIHByZXYpIHtcbiAgdmFyIGJvZHkgPSBzb3VyY2UuYm9keTtcbiAgdmFyIHBvc2l0aW9uID0gc3RhcnQgKyAxO1xuICB2YXIgY2h1bmtTdGFydCA9IHBvc2l0aW9uO1xuICB2YXIgY29kZSA9IDA7XG4gIHZhciB2YWx1ZSA9ICcnO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGJvZHkubGVuZ3RoICYmICFpc05hTihjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKSkgJiYgLy8gbm90IExpbmVUZXJtaW5hdG9yXG4gIGNvZGUgIT09IDB4MDAwYSAmJiBjb2RlICE9PSAweDAwMGQpIHtcbiAgICAvLyBDbG9zaW5nIFF1b3RlIChcIilcbiAgICBpZiAoY29kZSA9PT0gMzQpIHtcbiAgICAgIHZhbHVlICs9IGJvZHkuc2xpY2UoY2h1bmtTdGFydCwgcG9zaXRpb24pO1xuICAgICAgcmV0dXJuIG5ldyBUb2soVG9rZW5LaW5kLlNUUklORywgc3RhcnQsIHBvc2l0aW9uICsgMSwgbGluZSwgY29sLCBwcmV2LCB2YWx1ZSk7XG4gICAgfSAvLyBTb3VyY2VDaGFyYWN0ZXJcblxuXG4gICAgaWYgKGNvZGUgPCAweDAwMjAgJiYgY29kZSAhPT0gMHgwMDA5KSB7XG4gICAgICB0aHJvdyBzeW50YXhFcnJvcihzb3VyY2UsIHBvc2l0aW9uLCBcIkludmFsaWQgY2hhcmFjdGVyIHdpdGhpbiBTdHJpbmc6IFwiLmNvbmNhdChwcmludENoYXJDb2RlKGNvZGUpLCBcIi5cIikpO1xuICAgIH1cblxuICAgICsrcG9zaXRpb247XG5cbiAgICBpZiAoY29kZSA9PT0gOTIpIHtcbiAgICAgIC8vIFxcXG4gICAgICB2YWx1ZSArPSBib2R5LnNsaWNlKGNodW5rU3RhcnQsIHBvc2l0aW9uIC0gMSk7XG4gICAgICBjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcblxuICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgdmFsdWUgKz0gJ1wiJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgIHZhbHVlICs9ICcvJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDkyOlxuICAgICAgICAgIHZhbHVlICs9ICdcXFxcJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgIHZhbHVlICs9ICdcXGInO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgIHZhbHVlICs9ICdcXGYnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTEwOlxuICAgICAgICAgIHZhbHVlICs9ICdcXG4nO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTE0OlxuICAgICAgICAgIHZhbHVlICs9ICdcXHInO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTE2OlxuICAgICAgICAgIHZhbHVlICs9ICdcXHQnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIHVYWFhYXG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB1bmlDaGFyQ29kZShib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSwgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMiksIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDMpLCBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyA0KSk7XG5cbiAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDApIHtcbiAgICAgICAgICAgICAgdmFyIGludmFsaWRTZXF1ZW5jZSA9IGJvZHkuc2xpY2UocG9zaXRpb24gKyAxLCBwb3NpdGlvbiArIDUpO1xuICAgICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihzb3VyY2UsIHBvc2l0aW9uLCBcIkludmFsaWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZTogXFxcXHVcIi5jb25jYXQoaW52YWxpZFNlcXVlbmNlLCBcIi5cIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihzb3VyY2UsIHBvc2l0aW9uLCBcIkludmFsaWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZTogXFxcXFwiLmNvbmNhdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpLCBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICArK3Bvc2l0aW9uO1xuICAgICAgY2h1bmtTdGFydCA9IHBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IHN5bnRheEVycm9yKHNvdXJjZSwgcG9zaXRpb24sICdVbnRlcm1pbmF0ZWQgc3RyaW5nLicpO1xufVxuLyoqXG4gKiBSZWFkcyBhIGJsb2NrIHN0cmluZyB0b2tlbiBmcm9tIHRoZSBzb3VyY2UgZmlsZS5cbiAqXG4gKiBcIlwiXCIoXCI/XCI/KFxcXFxcIlwiXCJ8XFxcXCg/IT1cIlwiXCIpfFteXCJcXFxcXSkpKlwiXCJcIlxuICovXG5cblxuZnVuY3Rpb24gcmVhZEJsb2NrU3RyaW5nKHNvdXJjZSwgc3RhcnQsIGxpbmUsIGNvbCwgcHJldiwgbGV4ZXIpIHtcbiAgdmFyIGJvZHkgPSBzb3VyY2UuYm9keTtcbiAgdmFyIHBvc2l0aW9uID0gc3RhcnQgKyAzO1xuICB2YXIgY2h1bmtTdGFydCA9IHBvc2l0aW9uO1xuICB2YXIgY29kZSA9IDA7XG4gIHZhciByYXdWYWx1ZSA9ICcnO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGJvZHkubGVuZ3RoICYmICFpc05hTihjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKSkpIHtcbiAgICAvLyBDbG9zaW5nIFRyaXBsZS1RdW90ZSAoXCJcIlwiKVxuICAgIGlmIChjb2RlID09PSAzNCAmJiBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA9PT0gMzQgJiYgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMikgPT09IDM0KSB7XG4gICAgICByYXdWYWx1ZSArPSBib2R5LnNsaWNlKGNodW5rU3RhcnQsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiBuZXcgVG9rKFRva2VuS2luZC5CTE9DS19TVFJJTkcsIHN0YXJ0LCBwb3NpdGlvbiArIDMsIGxpbmUsIGNvbCwgcHJldiwgZGVkZW50QmxvY2tTdHJpbmdWYWx1ZShyYXdWYWx1ZSkpO1xuICAgIH0gLy8gU291cmNlQ2hhcmFjdGVyXG5cblxuICAgIGlmIChjb2RlIDwgMHgwMDIwICYmIGNvZGUgIT09IDB4MDAwOSAmJiBjb2RlICE9PSAweDAwMGEgJiYgY29kZSAhPT0gMHgwMDBkKSB7XG4gICAgICB0aHJvdyBzeW50YXhFcnJvcihzb3VyY2UsIHBvc2l0aW9uLCBcIkludmFsaWQgY2hhcmFjdGVyIHdpdGhpbiBTdHJpbmc6IFwiLmNvbmNhdChwcmludENoYXJDb2RlKGNvZGUpLCBcIi5cIikpO1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAxMCkge1xuICAgICAgLy8gbmV3IGxpbmVcbiAgICAgICsrcG9zaXRpb247XG4gICAgICArK2xleGVyLmxpbmU7XG4gICAgICBsZXhlci5saW5lU3RhcnQgPSBwb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDEzKSB7XG4gICAgICAvLyBjYXJyaWFnZSByZXR1cm5cbiAgICAgIGlmIChib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA9PT0gMTApIHtcbiAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICsrcG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgICsrbGV4ZXIubGluZTtcbiAgICAgIGxleGVyLmxpbmVTdGFydCA9IHBvc2l0aW9uO1xuICAgIH0gZWxzZSBpZiAoIC8vIEVzY2FwZSBUcmlwbGUtUXVvdGUgKFxcXCJcIlwiKVxuICAgIGNvZGUgPT09IDkyICYmIGJvZHkuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpID09PSAzNCAmJiBib2R5LmNoYXJDb2RlQXQocG9zaXRpb24gKyAyKSA9PT0gMzQgJiYgYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMykgPT09IDM0KSB7XG4gICAgICByYXdWYWx1ZSArPSBib2R5LnNsaWNlKGNodW5rU3RhcnQsIHBvc2l0aW9uKSArICdcIlwiXCInO1xuICAgICAgcG9zaXRpb24gKz0gNDtcbiAgICAgIGNodW5rU3RhcnQgPSBwb3NpdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgKytwb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBzeW50YXhFcnJvcihzb3VyY2UsIHBvc2l0aW9uLCAnVW50ZXJtaW5hdGVkIHN0cmluZy4nKTtcbn1cbi8qKlxuICogQ29udmVydHMgZm91ciBoZXhhZGVjaW1hbCBjaGFycyB0byB0aGUgaW50ZWdlciB0aGF0IHRoZVxuICogc3RyaW5nIHJlcHJlc2VudHMuIEZvciBleGFtcGxlLCB1bmlDaGFyQ29kZSgnMCcsJzAnLCcwJywnZicpXG4gKiB3aWxsIHJldHVybiAxNSwgYW5kIHVuaUNoYXJDb2RlKCcwJywnMCcsJ2YnLCdmJykgcmV0dXJucyAyNTUuXG4gKlxuICogUmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlciBvbiBlcnJvciwgaWYgYSBjaGFyIHdhcyBpbnZhbGlkLlxuICpcbiAqIFRoaXMgaXMgaW1wbGVtZW50ZWQgYnkgbm90aW5nIHRoYXQgY2hhcjJoZXgoKSByZXR1cm5zIC0xIG9uIGVycm9yLFxuICogd2hpY2ggbWVhbnMgdGhlIHJlc3VsdCBvZiBPUmluZyB0aGUgY2hhcjJoZXgoKSB3aWxsIGFsc28gYmUgbmVnYXRpdmUuXG4gKi9cblxuXG5mdW5jdGlvbiB1bmlDaGFyQ29kZShhLCBiLCBjLCBkKSB7XG4gIHJldHVybiBjaGFyMmhleChhKSA8PCAxMiB8IGNoYXIyaGV4KGIpIDw8IDggfCBjaGFyMmhleChjKSA8PCA0IHwgY2hhcjJoZXgoZCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgaGV4IGNoYXJhY3RlciB0byBpdHMgaW50ZWdlciB2YWx1ZS5cbiAqICcwJyBiZWNvbWVzIDAsICc5JyBiZWNvbWVzIDlcbiAqICdBJyBiZWNvbWVzIDEwLCAnRicgYmVjb21lcyAxNVxuICogJ2EnIGJlY29tZXMgMTAsICdmJyBiZWNvbWVzIDE1XG4gKlxuICogUmV0dXJucyAtMSBvbiBlcnJvci5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNoYXIyaGV4KGEpIHtcbiAgcmV0dXJuIGEgPj0gNDggJiYgYSA8PSA1NyA/IGEgLSA0OCAvLyAwLTlcbiAgOiBhID49IDY1ICYmIGEgPD0gNzAgPyBhIC0gNTUgLy8gQS1GXG4gIDogYSA+PSA5NyAmJiBhIDw9IDEwMiA/IGEgLSA4NyAvLyBhLWZcbiAgOiAtMTtcbn1cbi8qKlxuICogUmVhZHMgYW4gYWxwaGFudW1lcmljICsgdW5kZXJzY29yZSBuYW1lIGZyb20gdGhlIHNvdXJjZS5cbiAqXG4gKiBbX0EtWmEtel1bXzAtOUEtWmEtel0qXG4gKi9cblxuXG5mdW5jdGlvbiByZWFkTmFtZShzb3VyY2UsIHN0YXJ0LCBsaW5lLCBjb2wsIHByZXYpIHtcbiAgdmFyIGJvZHkgPSBzb3VyY2UuYm9keTtcbiAgdmFyIGJvZHlMZW5ndGggPSBib2R5Lmxlbmd0aDtcbiAgdmFyIHBvc2l0aW9uID0gc3RhcnQgKyAxO1xuICB2YXIgY29kZSA9IDA7XG5cbiAgd2hpbGUgKHBvc2l0aW9uICE9PSBib2R5TGVuZ3RoICYmICFpc05hTihjb2RlID0gYm9keS5jaGFyQ29kZUF0KHBvc2l0aW9uKSkgJiYgKGNvZGUgPT09IDk1IHx8IC8vIF9cbiAgY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3IHx8IC8vIDAtOVxuICBjb2RlID49IDY1ICYmIGNvZGUgPD0gOTAgfHwgLy8gQS1aXG4gIGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpIC8vIGEtelxuICApIHtcbiAgICArK3Bvc2l0aW9uO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUb2soVG9rZW5LaW5kLk5BTUUsIHN0YXJ0LCBwb3NpdGlvbiwgbGluZSwgY29sLCBwcmV2LCBib2R5LnNsaWNlKHN0YXJ0LCBwb3NpdGlvbikpO1xufVxuIiwiLyoqXG4gKiBUaGUgc2V0IG9mIGFsbG93ZWQgZGlyZWN0aXZlIGxvY2F0aW9uIHZhbHVlcy5cbiAqL1xuZXhwb3J0IHZhciBEaXJlY3RpdmVMb2NhdGlvbiA9IE9iamVjdC5mcmVlemUoe1xuICAvLyBSZXF1ZXN0IERlZmluaXRpb25zXG4gIFFVRVJZOiAnUVVFUlknLFxuICBNVVRBVElPTjogJ01VVEFUSU9OJyxcbiAgU1VCU0NSSVBUSU9OOiAnU1VCU0NSSVBUSU9OJyxcbiAgRklFTEQ6ICdGSUVMRCcsXG4gIEZSQUdNRU5UX0RFRklOSVRJT046ICdGUkFHTUVOVF9ERUZJTklUSU9OJyxcbiAgRlJBR01FTlRfU1BSRUFEOiAnRlJBR01FTlRfU1BSRUFEJyxcbiAgSU5MSU5FX0ZSQUdNRU5UOiAnSU5MSU5FX0ZSQUdNRU5UJyxcbiAgVkFSSUFCTEVfREVGSU5JVElPTjogJ1ZBUklBQkxFX0RFRklOSVRJT04nLFxuICAvLyBUeXBlIFN5c3RlbSBEZWZpbml0aW9uc1xuICBTQ0hFTUE6ICdTQ0hFTUEnLFxuICBTQ0FMQVI6ICdTQ0FMQVInLFxuICBPQkpFQ1Q6ICdPQkpFQ1QnLFxuICBGSUVMRF9ERUZJTklUSU9OOiAnRklFTERfREVGSU5JVElPTicsXG4gIEFSR1VNRU5UX0RFRklOSVRJT046ICdBUkdVTUVOVF9ERUZJTklUSU9OJyxcbiAgSU5URVJGQUNFOiAnSU5URVJGQUNFJyxcbiAgVU5JT046ICdVTklPTicsXG4gIEVOVU06ICdFTlVNJyxcbiAgRU5VTV9WQUxVRTogJ0VOVU1fVkFMVUUnLFxuICBJTlBVVF9PQkpFQ1Q6ICdJTlBVVF9PQkpFQ1QnLFxuICBJTlBVVF9GSUVMRF9ERUZJTklUSU9OOiAnSU5QVVRfRklFTERfREVGSU5JVElPTidcbn0pO1xuLyoqXG4gKiBUaGUgZW51bSB0eXBlIHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aXZlIGxvY2F0aW9uIHZhbHVlcy5cbiAqL1xuIiwiaW1wb3J0IGluc3BlY3QgZnJvbSAnLi4vanN1dGlscy9pbnNwZWN0JztcbmltcG9ydCBkZXZBc3NlcnQgZnJvbSAnLi4vanN1dGlscy9kZXZBc3NlcnQnO1xuaW1wb3J0IGRlZmluZVRvSlNPTiBmcm9tICcuLi9qc3V0aWxzL2RlZmluZVRvSlNPTic7XG5pbXBvcnQgeyBzeW50YXhFcnJvciB9IGZyb20gJy4uL2Vycm9yL3N5bnRheEVycm9yJztcbmltcG9ydCB7IEtpbmQgfSBmcm9tICcuL2tpbmRzJztcbmltcG9ydCB7IFNvdXJjZSB9IGZyb20gJy4vc291cmNlJztcbmltcG9ydCB7IGNyZWF0ZUxleGVyIH0gZnJvbSAnLi9sZXhlcic7XG5pbXBvcnQgeyBEaXJlY3RpdmVMb2NhdGlvbiB9IGZyb20gJy4vZGlyZWN0aXZlTG9jYXRpb24nO1xuaW1wb3J0IHsgVG9rZW5LaW5kIH0gZnJvbSAnLi90b2tlbktpbmQnO1xuXG4vKipcbiAqIEdpdmVuIGEgR3JhcGhRTCBzb3VyY2UsIHBhcnNlcyBpdCBpbnRvIGEgRG9jdW1lbnQuXG4gKiBUaHJvd3MgR3JhcGhRTEVycm9yIGlmIGEgc3ludGF4IGVycm9yIGlzIGVuY291bnRlcmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uoc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKHNvdXJjZSwgb3B0aW9ucyk7XG4gIHJldHVybiBwYXJzZXIucGFyc2VEb2N1bWVudCgpO1xufVxuLyoqXG4gKiBHaXZlbiBhIHN0cmluZyBjb250YWluaW5nIGEgR3JhcGhRTCB2YWx1ZSAoZXguIGBbNDJdYCksIHBhcnNlIHRoZSBBU1QgZm9yXG4gKiB0aGF0IHZhbHVlLlxuICogVGhyb3dzIEdyYXBoUUxFcnJvciBpZiBhIHN5bnRheCBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCB3aXRoaW4gdG9vbHMgdGhhdCBvcGVyYXRlIHVwb24gR3JhcGhRTCBWYWx1ZXMgZGlyZWN0bHkgYW5kXG4gKiBpbiBpc29sYXRpb24gb2YgY29tcGxldGUgR3JhcGhRTCBkb2N1bWVudHMuXG4gKlxuICogQ29uc2lkZXIgcHJvdmlkaW5nIHRoZSByZXN1bHRzIHRvIHRoZSB1dGlsaXR5IGZ1bmN0aW9uOiB2YWx1ZUZyb21BU1QoKS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VWYWx1ZShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIoc291cmNlLCBvcHRpb25zKTtcbiAgcGFyc2VyLmV4cGVjdFRva2VuKFRva2VuS2luZC5TT0YpO1xuICB2YXIgdmFsdWUgPSBwYXJzZXIucGFyc2VWYWx1ZUxpdGVyYWwoZmFsc2UpO1xuICBwYXJzZXIuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkVPRik7XG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogR2l2ZW4gYSBzdHJpbmcgY29udGFpbmluZyBhIEdyYXBoUUwgVHlwZSAoZXguIGBbSW50IV1gKSwgcGFyc2UgdGhlIEFTVCBmb3JcbiAqIHRoYXQgdHlwZS5cbiAqIFRocm93cyBHcmFwaFFMRXJyb3IgaWYgYSBzeW50YXggZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgd2l0aGluIHRvb2xzIHRoYXQgb3BlcmF0ZSB1cG9uIEdyYXBoUUwgVHlwZXMgZGlyZWN0bHkgYW5kXG4gKiBpbiBpc29sYXRpb24gb2YgY29tcGxldGUgR3JhcGhRTCBkb2N1bWVudHMuXG4gKlxuICogQ29uc2lkZXIgcHJvdmlkaW5nIHRoZSByZXN1bHRzIHRvIHRoZSB1dGlsaXR5IGZ1bmN0aW9uOiB0eXBlRnJvbUFTVCgpLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVR5cGUoc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKHNvdXJjZSwgb3B0aW9ucyk7XG4gIHBhcnNlci5leHBlY3RUb2tlbihUb2tlbktpbmQuU09GKTtcbiAgdmFyIHR5cGUgPSBwYXJzZXIucGFyc2VUeXBlUmVmZXJlbmNlKCk7XG4gIHBhcnNlci5leHBlY3RUb2tlbihUb2tlbktpbmQuRU9GKTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbnZhciBQYXJzZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJzZXIoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIHNvdXJjZU9iaiA9IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gbmV3IFNvdXJjZShzb3VyY2UpIDogc291cmNlO1xuICAgIHNvdXJjZU9iaiBpbnN0YW5jZW9mIFNvdXJjZSB8fCBkZXZBc3NlcnQoMCwgXCJNdXN0IHByb3ZpZGUgU291cmNlLiBSZWNlaXZlZDogXCIuY29uY2F0KGluc3BlY3Qoc291cmNlT2JqKSkpO1xuICAgIHRoaXMuX2xleGVyID0gY3JlYXRlTGV4ZXIoc291cmNlT2JqKTtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYSBuYW1lIGxleCB0b2tlbiBpbnRvIGEgbmFtZSBwYXJzZSBub2RlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5wYXJzZU5hbWUgPSBmdW5jdGlvbiBwYXJzZU5hbWUoKSB7XG4gICAgdmFyIHRva2VuID0gdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuTkFNRSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IEtpbmQuTkFNRSxcbiAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZSxcbiAgICAgIGxvYzogdGhpcy5sb2ModG9rZW4pXG4gICAgfTtcbiAgfSAvLyBJbXBsZW1lbnRzIHRoZSBwYXJzaW5nIHJ1bGVzIGluIHRoZSBEb2N1bWVudCBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBEb2N1bWVudCA6IERlZmluaXRpb24rXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlRG9jdW1lbnQgPSBmdW5jdGlvbiBwYXJzZURvY3VtZW50KCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLkRPQ1VNRU5ULFxuICAgICAgZGVmaW5pdGlvbnM6IHRoaXMubWFueShUb2tlbktpbmQuU09GLCB0aGlzLnBhcnNlRGVmaW5pdGlvbiwgVG9rZW5LaW5kLkVPRiksXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERlZmluaXRpb24gOlxuICAgKiAgIC0gRXhlY3V0YWJsZURlZmluaXRpb25cbiAgICogICAtIFR5cGVTeXN0ZW1EZWZpbml0aW9uXG4gICAqICAgLSBUeXBlU3lzdGVtRXh0ZW5zaW9uXG4gICAqXG4gICAqIEV4ZWN1dGFibGVEZWZpbml0aW9uIDpcbiAgICogICAtIE9wZXJhdGlvbkRlZmluaXRpb25cbiAgICogICAtIEZyYWdtZW50RGVmaW5pdGlvblxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZURlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZURlZmluaXRpb24oKSB7XG4gICAgaWYgKHRoaXMucGVlayhUb2tlbktpbmQuTkFNRSkpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fbGV4ZXIudG9rZW4udmFsdWUpIHtcbiAgICAgICAgY2FzZSAncXVlcnknOlxuICAgICAgICBjYXNlICdtdXRhdGlvbic6XG4gICAgICAgIGNhc2UgJ3N1YnNjcmlwdGlvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYXRpb25EZWZpbml0aW9uKCk7XG5cbiAgICAgICAgY2FzZSAnZnJhZ21lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnJhZ21lbnREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgY2FzZSAnc2NoZW1hJzpcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XG4gICAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgY2FzZSAnZGlyZWN0aXZlJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVR5cGVTeXN0ZW1EZWZpbml0aW9uKCk7XG5cbiAgICAgICAgY2FzZSAnZXh0ZW5kJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVR5cGVTeXN0ZW1FeHRlbnNpb24oKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucGVlayhUb2tlbktpbmQuQlJBQ0VfTCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmF0aW9uRGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wZWVrRGVzY3JpcHRpb24oKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUeXBlU3lzdGVtRGVmaW5pdGlvbigpO1xuICAgIH1cblxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICB9IC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIE9wZXJhdGlvbnMgc2VjdGlvbi5cblxuICAvKipcbiAgICogT3BlcmF0aW9uRGVmaW5pdGlvbiA6XG4gICAqICAtIFNlbGVjdGlvblNldFxuICAgKiAgLSBPcGVyYXRpb25UeXBlIE5hbWU/IFZhcmlhYmxlRGVmaW5pdGlvbnM/IERpcmVjdGl2ZXM/IFNlbGVjdGlvblNldFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZU9wZXJhdGlvbkRlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZU9wZXJhdGlvbkRlZmluaXRpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG5cbiAgICBpZiAodGhpcy5wZWVrKFRva2VuS2luZC5CUkFDRV9MKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogS2luZC5PUEVSQVRJT05fREVGSU5JVElPTixcbiAgICAgICAgb3BlcmF0aW9uOiAncXVlcnknLFxuICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbnM6IFtdLFxuICAgICAgICBkaXJlY3RpdmVzOiBbXSxcbiAgICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCksXG4gICAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBvcGVyYXRpb24gPSB0aGlzLnBhcnNlT3BlcmF0aW9uVHlwZSgpO1xuICAgIHZhciBuYW1lO1xuXG4gICAgaWYgKHRoaXMucGVlayhUb2tlbktpbmQuTkFNRSkpIHtcbiAgICAgIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLk9QRVJBVElPTl9ERUZJTklUSU9OLFxuICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb24sXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFyaWFibGVEZWZpbml0aW9uczogdGhpcy5wYXJzZVZhcmlhYmxlRGVmaW5pdGlvbnMoKSxcbiAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VEaXJlY3RpdmVzKGZhbHNlKSxcbiAgICAgIHNlbGVjdGlvblNldDogdGhpcy5wYXJzZVNlbGVjdGlvblNldCgpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPcGVyYXRpb25UeXBlIDogb25lIG9mIHF1ZXJ5IG11dGF0aW9uIHN1YnNjcmlwdGlvblxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZU9wZXJhdGlvblR5cGUgPSBmdW5jdGlvbiBwYXJzZU9wZXJhdGlvblR5cGUoKSB7XG4gICAgdmFyIG9wZXJhdGlvblRva2VuID0gdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuTkFNRSk7XG5cbiAgICBzd2l0Y2ggKG9wZXJhdGlvblRva2VuLnZhbHVlKSB7XG4gICAgICBjYXNlICdxdWVyeSc6XG4gICAgICAgIHJldHVybiAncXVlcnknO1xuXG4gICAgICBjYXNlICdtdXRhdGlvbic6XG4gICAgICAgIHJldHVybiAnbXV0YXRpb24nO1xuXG4gICAgICBjYXNlICdzdWJzY3JpcHRpb24nOlxuICAgICAgICByZXR1cm4gJ3N1YnNjcmlwdGlvbic7XG4gICAgfVxuXG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKG9wZXJhdGlvblRva2VuKTtcbiAgfVxuICAvKipcbiAgICogVmFyaWFibGVEZWZpbml0aW9ucyA6ICggVmFyaWFibGVEZWZpbml0aW9uKyApXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlVmFyaWFibGVEZWZpbml0aW9ucyA9IGZ1bmN0aW9uIHBhcnNlVmFyaWFibGVEZWZpbml0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkoVG9rZW5LaW5kLlBBUkVOX0wsIHRoaXMucGFyc2VWYXJpYWJsZURlZmluaXRpb24sIFRva2VuS2luZC5QQVJFTl9SKTtcbiAgfVxuICAvKipcbiAgICogVmFyaWFibGVEZWZpbml0aW9uIDogVmFyaWFibGUgOiBUeXBlIERlZmF1bHRWYWx1ZT8gRGlyZWN0aXZlc1tDb25zdF0/XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlVmFyaWFibGVEZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlZmluaXRpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IEtpbmQuVkFSSUFCTEVfREVGSU5JVElPTixcbiAgICAgIHZhcmlhYmxlOiB0aGlzLnBhcnNlVmFyaWFibGUoKSxcbiAgICAgIHR5cGU6ICh0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5DT0xPTiksIHRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCkpLFxuICAgICAgZGVmYXVsdFZhbHVlOiB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oVG9rZW5LaW5kLkVRVUFMUykgPyB0aGlzLnBhcnNlVmFsdWVMaXRlcmFsKHRydWUpIDogdW5kZWZpbmVkLFxuICAgICAgZGlyZWN0aXZlczogdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSksXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFZhcmlhYmxlIDogJCBOYW1lXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlVmFyaWFibGUgPSBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkRPTExBUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IEtpbmQuVkFSSUFCTEUsXG4gICAgICBuYW1lOiB0aGlzLnBhcnNlTmFtZSgpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3Rpb25TZXQgOiB7IFNlbGVjdGlvbisgfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZVNlbGVjdGlvblNldCA9IGZ1bmN0aW9uIHBhcnNlU2VsZWN0aW9uU2V0KCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLlNFTEVDVElPTl9TRVQsXG4gICAgICBzZWxlY3Rpb25zOiB0aGlzLm1hbnkoVG9rZW5LaW5kLkJSQUNFX0wsIHRoaXMucGFyc2VTZWxlY3Rpb24sIFRva2VuS2luZC5CUkFDRV9SKSxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0aW9uIDpcbiAgICogICAtIEZpZWxkXG4gICAqICAgLSBGcmFnbWVudFNwcmVhZFxuICAgKiAgIC0gSW5saW5lRnJhZ21lbnRcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VTZWxlY3Rpb24gPSBmdW5jdGlvbiBwYXJzZVNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wZWVrKFRva2VuS2luZC5TUFJFQUQpID8gdGhpcy5wYXJzZUZyYWdtZW50KCkgOiB0aGlzLnBhcnNlRmllbGQoKTtcbiAgfVxuICAvKipcbiAgICogRmllbGQgOiBBbGlhcz8gTmFtZSBBcmd1bWVudHM/IERpcmVjdGl2ZXM/IFNlbGVjdGlvblNldD9cbiAgICpcbiAgICogQWxpYXMgOiBOYW1lIDpcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VGaWVsZCA9IGZ1bmN0aW9uIHBhcnNlRmllbGQoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdmFyIG5hbWVPckFsaWFzID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgYWxpYXM7XG4gICAgdmFyIG5hbWU7XG5cbiAgICBpZiAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKFRva2VuS2luZC5DT0xPTikpIHtcbiAgICAgIGFsaWFzID0gbmFtZU9yQWxpYXM7XG4gICAgICBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWVPckFsaWFzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLkZJRUxELFxuICAgICAgYWxpYXM6IGFsaWFzLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGFyZ3VtZW50czogdGhpcy5wYXJzZUFyZ3VtZW50cyhmYWxzZSksXG4gICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyhmYWxzZSksXG4gICAgICBzZWxlY3Rpb25TZXQ6IHRoaXMucGVlayhUb2tlbktpbmQuQlJBQ0VfTCkgPyB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCkgOiB1bmRlZmluZWQsXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFyZ3VtZW50c1tDb25zdF0gOiAoIEFyZ3VtZW50Wz9Db25zdF0rIClcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VBcmd1bWVudHMgPSBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cyhpc0NvbnN0KSB7XG4gICAgdmFyIGl0ZW0gPSBpc0NvbnN0ID8gdGhpcy5wYXJzZUNvbnN0QXJndW1lbnQgOiB0aGlzLnBhcnNlQXJndW1lbnQ7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KFRva2VuS2luZC5QQVJFTl9MLCBpdGVtLCBUb2tlbktpbmQuUEFSRU5fUik7XG4gIH1cbiAgLyoqXG4gICAqIEFyZ3VtZW50W0NvbnN0XSA6IE5hbWUgOiBWYWx1ZVs/Q29uc3RdXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlQXJndW1lbnQgPSBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50KCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5DT0xPTik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IEtpbmQuQVJHVU1FTlQsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwoZmFsc2UpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUNvbnN0QXJndW1lbnQgPSBmdW5jdGlvbiBwYXJzZUNvbnN0QXJndW1lbnQoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IEtpbmQuQVJHVU1FTlQsXG4gICAgICBuYW1lOiB0aGlzLnBhcnNlTmFtZSgpLFxuICAgICAgdmFsdWU6ICh0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5DT0xPTiksIHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwodHJ1ZSkpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9IC8vIEltcGxlbWVudHMgdGhlIHBhcnNpbmcgcnVsZXMgaW4gdGhlIEZyYWdtZW50cyBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBDb3JyZXNwb25kcyB0byBib3RoIEZyYWdtZW50U3ByZWFkIGFuZCBJbmxpbmVGcmFnbWVudCBpbiB0aGUgc3BlYy5cbiAgICpcbiAgICogRnJhZ21lbnRTcHJlYWQgOiAuLi4gRnJhZ21lbnROYW1lIERpcmVjdGl2ZXM/XG4gICAqXG4gICAqIElubGluZUZyYWdtZW50IDogLi4uIFR5cGVDb25kaXRpb24/IERpcmVjdGl2ZXM/IFNlbGVjdGlvblNldFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUZyYWdtZW50ID0gZnVuY3Rpb24gcGFyc2VGcmFnbWVudCgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5TUFJFQUQpO1xuICAgIHZhciBoYXNUeXBlQ29uZGl0aW9uID0gdGhpcy5leHBlY3RPcHRpb25hbEtleXdvcmQoJ29uJyk7XG5cbiAgICBpZiAoIWhhc1R5cGVDb25kaXRpb24gJiYgdGhpcy5wZWVrKFRva2VuS2luZC5OQU1FKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogS2luZC5GUkFHTUVOVF9TUFJFQUQsXG4gICAgICAgIG5hbWU6IHRoaXMucGFyc2VGcmFnbWVudE5hbWUoKSxcbiAgICAgICAgZGlyZWN0aXZlczogdGhpcy5wYXJzZURpcmVjdGl2ZXMoZmFsc2UpLFxuICAgICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5JTkxJTkVfRlJBR01FTlQsXG4gICAgICB0eXBlQ29uZGl0aW9uOiBoYXNUeXBlQ29uZGl0aW9uID8gdGhpcy5wYXJzZU5hbWVkVHlwZSgpIDogdW5kZWZpbmVkLFxuICAgICAgZGlyZWN0aXZlczogdGhpcy5wYXJzZURpcmVjdGl2ZXMoZmFsc2UpLFxuICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCksXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEZyYWdtZW50RGVmaW5pdGlvbiA6XG4gICAqICAgLSBmcmFnbWVudCBGcmFnbWVudE5hbWUgb24gVHlwZUNvbmRpdGlvbiBEaXJlY3RpdmVzPyBTZWxlY3Rpb25TZXRcbiAgICpcbiAgICogVHlwZUNvbmRpdGlvbiA6IE5hbWVkVHlwZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUZyYWdtZW50RGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHBhcnNlRnJhZ21lbnREZWZpbml0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZnJhZ21lbnQnKTsgLy8gRXhwZXJpbWVudGFsIHN1cHBvcnQgZm9yIGRlZmluaW5nIHZhcmlhYmxlcyB3aXRoaW4gZnJhZ21lbnRzIGNoYW5nZXNcbiAgICAvLyB0aGUgZ3JhbW1hciBvZiBGcmFnbWVudERlZmluaXRpb246XG4gICAgLy8gICAtIGZyYWdtZW50IEZyYWdtZW50TmFtZSBWYXJpYWJsZURlZmluaXRpb25zPyBvbiBUeXBlQ29uZGl0aW9uIERpcmVjdGl2ZXM/IFNlbGVjdGlvblNldFxuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IEtpbmQuRlJBR01FTlRfREVGSU5JVElPTixcbiAgICAgICAgbmFtZTogdGhpcy5wYXJzZUZyYWdtZW50TmFtZSgpLFxuICAgICAgICB2YXJpYWJsZURlZmluaXRpb25zOiB0aGlzLnBhcnNlVmFyaWFibGVEZWZpbml0aW9ucygpLFxuICAgICAgICB0eXBlQ29uZGl0aW9uOiAodGhpcy5leHBlY3RLZXl3b3JkKCdvbicpLCB0aGlzLnBhcnNlTmFtZWRUeXBlKCkpLFxuICAgICAgICBkaXJlY3RpdmVzOiB0aGlzLnBhcnNlRGlyZWN0aXZlcyhmYWxzZSksXG4gICAgICAgIHNlbGVjdGlvblNldDogdGhpcy5wYXJzZVNlbGVjdGlvblNldCgpLFxuICAgICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5GUkFHTUVOVF9ERUZJTklUSU9OLFxuICAgICAgbmFtZTogdGhpcy5wYXJzZUZyYWdtZW50TmFtZSgpLFxuICAgICAgdHlwZUNvbmRpdGlvbjogKHRoaXMuZXhwZWN0S2V5d29yZCgnb24nKSwgdGhpcy5wYXJzZU5hbWVkVHlwZSgpKSxcbiAgICAgIGRpcmVjdGl2ZXM6IHRoaXMucGFyc2VEaXJlY3RpdmVzKGZhbHNlKSxcbiAgICAgIHNlbGVjdGlvblNldDogdGhpcy5wYXJzZVNlbGVjdGlvblNldCgpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBGcmFnbWVudE5hbWUgOiBOYW1lIGJ1dCBub3QgYG9uYFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUZyYWdtZW50TmFtZSA9IGZ1bmN0aW9uIHBhcnNlRnJhZ21lbnROYW1lKCkge1xuICAgIGlmICh0aGlzLl9sZXhlci50b2tlbi52YWx1ZSA9PT0gJ29uJykge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VOYW1lKCk7XG4gIH0gLy8gSW1wbGVtZW50cyB0aGUgcGFyc2luZyBydWxlcyBpbiB0aGUgVmFsdWVzIHNlY3Rpb24uXG5cbiAgLyoqXG4gICAqIFZhbHVlW0NvbnN0XSA6XG4gICAqICAgLSBbfkNvbnN0XSBWYXJpYWJsZVxuICAgKiAgIC0gSW50VmFsdWVcbiAgICogICAtIEZsb2F0VmFsdWVcbiAgICogICAtIFN0cmluZ1ZhbHVlXG4gICAqICAgLSBCb29sZWFuVmFsdWVcbiAgICogICAtIE51bGxWYWx1ZVxuICAgKiAgIC0gRW51bVZhbHVlXG4gICAqICAgLSBMaXN0VmFsdWVbP0NvbnN0XVxuICAgKiAgIC0gT2JqZWN0VmFsdWVbP0NvbnN0XVxuICAgKlxuICAgKiBCb29sZWFuVmFsdWUgOiBvbmUgb2YgYHRydWVgIGBmYWxzZWBcbiAgICpcbiAgICogTnVsbFZhbHVlIDogYG51bGxgXG4gICAqXG4gICAqIEVudW1WYWx1ZSA6IE5hbWUgYnV0IG5vdCBgdHJ1ZWAsIGBmYWxzZWAgb3IgYG51bGxgXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlVmFsdWVMaXRlcmFsID0gZnVuY3Rpb24gcGFyc2VWYWx1ZUxpdGVyYWwoaXNDb25zdCkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgc3dpdGNoICh0b2tlbi5raW5kKSB7XG4gICAgICBjYXNlIFRva2VuS2luZC5CUkFDS0VUX0w6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdChpc0NvbnN0KTtcblxuICAgICAgY2FzZSBUb2tlbktpbmQuQlJBQ0VfTDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3QoaXNDb25zdCk7XG5cbiAgICAgIGNhc2UgVG9rZW5LaW5kLklOVDpcbiAgICAgICAgdGhpcy5fbGV4ZXIuYWR2YW5jZSgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2luZDogS2luZC5JTlQsXG4gICAgICAgICAgdmFsdWU6IHRva2VuLnZhbHVlLFxuICAgICAgICAgIGxvYzogdGhpcy5sb2ModG9rZW4pXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgVG9rZW5LaW5kLkZMT0FUOlxuICAgICAgICB0aGlzLl9sZXhlci5hZHZhbmNlKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBraW5kOiBLaW5kLkZMT0FULFxuICAgICAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgICBsb2M6IHRoaXMubG9jKHRva2VuKVxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIFRva2VuS2luZC5TVFJJTkc6XG4gICAgICBjYXNlIFRva2VuS2luZC5CTE9DS19TVFJJTkc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCgpO1xuXG4gICAgICBjYXNlIFRva2VuS2luZC5OQU1FOlxuICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICd0cnVlJyB8fCB0b2tlbi52YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgIHRoaXMuX2xleGVyLmFkdmFuY2UoKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiBLaW5kLkJPT0xFQU4sXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWUgPT09ICd0cnVlJyxcbiAgICAgICAgICAgIGxvYzogdGhpcy5sb2ModG9rZW4pXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgdGhpcy5fbGV4ZXIuYWR2YW5jZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6IEtpbmQuTlVMTCxcbiAgICAgICAgICAgIGxvYzogdGhpcy5sb2ModG9rZW4pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xleGVyLmFkdmFuY2UoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuRU5VTSxcbiAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWUsXG4gICAgICAgICAgbG9jOiB0aGlzLmxvYyh0b2tlbilcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBUb2tlbktpbmQuRE9MTEFSOlxuICAgICAgICBpZiAoIWlzQ29uc3QpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhcmlhYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VTdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24gcGFyc2VTdHJpbmdMaXRlcmFsKCkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgdGhpcy5fbGV4ZXIuYWR2YW5jZSgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IEtpbmQuU1RSSU5HLFxuICAgICAgdmFsdWU6IHRva2VuLnZhbHVlLFxuICAgICAgYmxvY2s6IHRva2VuLmtpbmQgPT09IFRva2VuS2luZC5CTE9DS19TVFJJTkcsXG4gICAgICBsb2M6IHRoaXMubG9jKHRva2VuKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIExpc3RWYWx1ZVtDb25zdF0gOlxuICAgKiAgIC0gWyBdXG4gICAqICAgLSBbIFZhbHVlWz9Db25zdF0rIF1cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VMaXN0ID0gZnVuY3Rpb24gcGFyc2VMaXN0KGlzQ29uc3QpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG5cbiAgICB2YXIgaXRlbSA9IGZ1bmN0aW9uIGl0ZW0oKSB7XG4gICAgICByZXR1cm4gX3RoaXMucGFyc2VWYWx1ZUxpdGVyYWwoaXNDb25zdCk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLkxJU1QsXG4gICAgICB2YWx1ZXM6IHRoaXMuYW55KFRva2VuS2luZC5CUkFDS0VUX0wsIGl0ZW0sIFRva2VuS2luZC5CUkFDS0VUX1IpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPYmplY3RWYWx1ZVtDb25zdF0gOlxuICAgKiAgIC0geyB9XG4gICAqICAgLSB7IE9iamVjdEZpZWxkWz9Db25zdF0rIH1cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VPYmplY3QgPSBmdW5jdGlvbiBwYXJzZU9iamVjdChpc0NvbnN0KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcblxuICAgIHZhciBpdGVtID0gZnVuY3Rpb24gaXRlbSgpIHtcbiAgICAgIHJldHVybiBfdGhpczIucGFyc2VPYmplY3RGaWVsZChpc0NvbnN0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IEtpbmQuT0JKRUNULFxuICAgICAgZmllbGRzOiB0aGlzLmFueShUb2tlbktpbmQuQlJBQ0VfTCwgaXRlbSwgVG9rZW5LaW5kLkJSQUNFX1IpLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPYmplY3RGaWVsZFtDb25zdF0gOiBOYW1lIDogVmFsdWVbP0NvbnN0XVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZU9iamVjdEZpZWxkID0gZnVuY3Rpb24gcGFyc2VPYmplY3RGaWVsZChpc0NvbnN0KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkNPTE9OKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5PQkpFQ1RfRklFTEQsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwoaXNDb25zdCksXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH0gLy8gSW1wbGVtZW50cyB0aGUgcGFyc2luZyBydWxlcyBpbiB0aGUgRGlyZWN0aXZlcyBzZWN0aW9uLlxuXG4gIC8qKlxuICAgKiBEaXJlY3RpdmVzW0NvbnN0XSA6IERpcmVjdGl2ZVs/Q29uc3RdK1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZURpcmVjdGl2ZXMgPSBmdW5jdGlvbiBwYXJzZURpcmVjdGl2ZXMoaXNDb25zdCkge1xuICAgIHZhciBkaXJlY3RpdmVzID0gW107XG5cbiAgICB3aGlsZSAodGhpcy5wZWVrKFRva2VuS2luZC5BVCkpIHtcbiAgICAgIGRpcmVjdGl2ZXMucHVzaCh0aGlzLnBhcnNlRGlyZWN0aXZlKGlzQ29uc3QpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0aXZlcztcbiAgfVxuICAvKipcbiAgICogRGlyZWN0aXZlW0NvbnN0XSA6IEAgTmFtZSBBcmd1bWVudHNbP0NvbnN0XT9cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VEaXJlY3RpdmUgPSBmdW5jdGlvbiBwYXJzZURpcmVjdGl2ZShpc0NvbnN0KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQVQpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLkRJUkVDVElWRSxcbiAgICAgIG5hbWU6IHRoaXMucGFyc2VOYW1lKCksXG4gICAgICBhcmd1bWVudHM6IHRoaXMucGFyc2VBcmd1bWVudHMoaXNDb25zdCksXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH0gLy8gSW1wbGVtZW50cyB0aGUgcGFyc2luZyBydWxlcyBpbiB0aGUgVHlwZXMgc2VjdGlvbi5cblxuICAvKipcbiAgICogVHlwZSA6XG4gICAqICAgLSBOYW1lZFR5cGVcbiAgICogICAtIExpc3RUeXBlXG4gICAqICAgLSBOb25OdWxsVHlwZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZVR5cGVSZWZlcmVuY2UgPSBmdW5jdGlvbiBwYXJzZVR5cGVSZWZlcmVuY2UoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdmFyIHR5cGU7XG5cbiAgICBpZiAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKFRva2VuS2luZC5CUkFDS0VUX0wpKSB7XG4gICAgICB0eXBlID0gdGhpcy5wYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkJSQUNLRVRfUik7XG4gICAgICB0eXBlID0ge1xuICAgICAgICBraW5kOiBLaW5kLkxJU1RfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSB0aGlzLnBhcnNlTmFtZWRUeXBlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuQkFORykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IEtpbmQuTk9OX05VTExfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgLyoqXG4gICAqIE5hbWVkVHlwZSA6IE5hbWVcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VOYW1lZFR5cGUgPSBmdW5jdGlvbiBwYXJzZU5hbWVkVHlwZSgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5OQU1FRF9UWVBFLFxuICAgICAgbmFtZTogdGhpcy5wYXJzZU5hbWUoKSxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfSAvLyBJbXBsZW1lbnRzIHRoZSBwYXJzaW5nIHJ1bGVzIGluIHRoZSBUeXBlIERlZmluaXRpb24gc2VjdGlvbi5cblxuICAvKipcbiAgICogVHlwZVN5c3RlbURlZmluaXRpb24gOlxuICAgKiAgIC0gU2NoZW1hRGVmaW5pdGlvblxuICAgKiAgIC0gVHlwZURlZmluaXRpb25cbiAgICogICAtIERpcmVjdGl2ZURlZmluaXRpb25cbiAgICpcbiAgICogVHlwZURlZmluaXRpb24gOlxuICAgKiAgIC0gU2NhbGFyVHlwZURlZmluaXRpb25cbiAgICogICAtIE9iamVjdFR5cGVEZWZpbml0aW9uXG4gICAqICAgLSBJbnRlcmZhY2VUeXBlRGVmaW5pdGlvblxuICAgKiAgIC0gVW5pb25UeXBlRGVmaW5pdGlvblxuICAgKiAgIC0gRW51bVR5cGVEZWZpbml0aW9uXG4gICAqICAgLSBJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlVHlwZVN5c3RlbURlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZVR5cGVTeXN0ZW1EZWZpbml0aW9uKCkge1xuICAgIC8vIE1hbnkgZGVmaW5pdGlvbnMgYmVnaW4gd2l0aCBhIGRlc2NyaXB0aW9uIGFuZCByZXF1aXJlIGEgbG9va2FoZWFkLlxuICAgIHZhciBrZXl3b3JkVG9rZW4gPSB0aGlzLnBlZWtEZXNjcmlwdGlvbigpID8gdGhpcy5fbGV4ZXIubG9va2FoZWFkKCkgOiB0aGlzLl9sZXhlci50b2tlbjtcblxuICAgIGlmIChrZXl3b3JkVG9rZW4ua2luZCA9PT0gVG9rZW5LaW5kLk5BTUUpIHtcbiAgICAgIHN3aXRjaCAoa2V5d29yZFRva2VuLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3NjaGVtYSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTY2hlbWFEZWZpbml0aW9uKCk7XG5cbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjYWxhclR5cGVEZWZpbml0aW9uKCk7XG5cbiAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3RUeXBlRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVuaW9uVHlwZURlZmluaXRpb24oKTtcblxuICAgICAgICBjYXNlICdlbnVtJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVudW1UeXBlRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUlucHV0T2JqZWN0VHlwZURlZmluaXRpb24oKTtcblxuICAgICAgICBjYXNlICdkaXJlY3RpdmUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGlyZWN0aXZlRGVmaW5pdGlvbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZChrZXl3b3JkVG9rZW4pO1xuICB9O1xuXG4gIF9wcm90by5wZWVrRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBwZWVrRGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGVlayhUb2tlbktpbmQuU1RSSU5HKSB8fCB0aGlzLnBlZWsoVG9rZW5LaW5kLkJMT0NLX1NUUklORyk7XG4gIH1cbiAgLyoqXG4gICAqIERlc2NyaXB0aW9uIDogU3RyaW5nVmFsdWVcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHBhcnNlRGVzY3JpcHRpb24oKSB7XG4gICAgaWYgKHRoaXMucGVla0Rlc2NyaXB0aW9uKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2NoZW1hRGVmaW5pdGlvbiA6IHNjaGVtYSBEaXJlY3RpdmVzW0NvbnN0XT8geyBPcGVyYXRpb25UeXBlRGVmaW5pdGlvbisgfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZVNjaGVtYURlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZVNjaGVtYURlZmluaXRpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdzY2hlbWEnKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHZhciBvcGVyYXRpb25UeXBlcyA9IHRoaXMubWFueShUb2tlbktpbmQuQlJBQ0VfTCwgdGhpcy5wYXJzZU9wZXJhdGlvblR5cGVEZWZpbml0aW9uLCBUb2tlbktpbmQuQlJBQ0VfUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IEtpbmQuU0NIRU1BX0RFRklOSVRJT04sXG4gICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgICAgb3BlcmF0aW9uVHlwZXM6IG9wZXJhdGlvblR5cGVzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPcGVyYXRpb25UeXBlRGVmaW5pdGlvbiA6IE9wZXJhdGlvblR5cGUgOiBOYW1lZFR5cGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VPcGVyYXRpb25UeXBlRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHBhcnNlT3BlcmF0aW9uVHlwZURlZmluaXRpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMucGFyc2VPcGVyYXRpb25UeXBlKCk7XG4gICAgdGhpcy5leHBlY3RUb2tlbihUb2tlbktpbmQuQ09MT04pO1xuICAgIHZhciB0eXBlID0gdGhpcy5wYXJzZU5hbWVkVHlwZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLk9QRVJBVElPTl9UWVBFX0RFRklOSVRJT04sXG4gICAgICBvcGVyYXRpb246IG9wZXJhdGlvbixcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNjYWxhclR5cGVEZWZpbml0aW9uIDogRGVzY3JpcHRpb24/IHNjYWxhciBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdP1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZVNjYWxhclR5cGVEZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VTY2FsYXJUeXBlRGVmaW5pdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3NjYWxhcicpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLlNDQUxBUl9UWVBFX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT2JqZWN0VHlwZURlZmluaXRpb24gOlxuICAgKiAgIERlc2NyaXB0aW9uP1xuICAgKiAgIHR5cGUgTmFtZSBJbXBsZW1lbnRzSW50ZXJmYWNlcz8gRGlyZWN0aXZlc1tDb25zdF0/IEZpZWxkc0RlZmluaXRpb24/XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlT2JqZWN0VHlwZURlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZU9iamVjdFR5cGVEZWZpbml0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndHlwZScpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgaW50ZXJmYWNlcyA9IHRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IEtpbmQuT0JKRUNUX1RZUEVfREVGSU5JVElPTixcbiAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbnRlcmZhY2VzOiBpbnRlcmZhY2VzLFxuICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzSW50ZXJmYWNlcyA6XG4gICAqICAgLSBpbXBsZW1lbnRzIGAmYD8gTmFtZWRUeXBlXG4gICAqICAgLSBJbXBsZW1lbnRzSW50ZXJmYWNlcyAmIE5hbWVkVHlwZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzID0gZnVuY3Rpb24gcGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpIHtcbiAgICB2YXIgdHlwZXMgPSBbXTtcblxuICAgIGlmICh0aGlzLmV4cGVjdE9wdGlvbmFsS2V5d29yZCgnaW1wbGVtZW50cycpKSB7XG4gICAgICAvLyBPcHRpb25hbCBsZWFkaW5nIGFtcGVyc2FuZFxuICAgICAgdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKFRva2VuS2luZC5BTVApO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHR5cGVzLnB1c2godGhpcy5wYXJzZU5hbWVkVHlwZSgpKTtcbiAgICAgIH0gd2hpbGUgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuQU1QKSB8fCAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdGhlIFNETD9cbiAgICAgIHRoaXMuX29wdGlvbnMuYWxsb3dMZWdhY3lTRExJbXBsZW1lbnRzSW50ZXJmYWNlcyAmJiB0aGlzLnBlZWsoVG9rZW5LaW5kLk5BTUUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZXM7XG4gIH1cbiAgLyoqXG4gICAqIEZpZWxkc0RlZmluaXRpb24gOiB7IEZpZWxkRGVmaW5pdGlvbisgfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUZpZWxkc0RlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZUZpZWxkc0RlZmluaXRpb24oKSB7XG4gICAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHRoZSBTREw/XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuYWxsb3dMZWdhY3lTRExFbXB0eUZpZWxkcyAmJiB0aGlzLnBlZWsoVG9rZW5LaW5kLkJSQUNFX0wpICYmIHRoaXMuX2xleGVyLmxvb2thaGVhZCgpLmtpbmQgPT09IFRva2VuS2luZC5CUkFDRV9SKSB7XG4gICAgICB0aGlzLl9sZXhlci5hZHZhbmNlKCk7XG5cbiAgICAgIHRoaXMuX2xleGVyLmFkdmFuY2UoKTtcblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsTWFueShUb2tlbktpbmQuQlJBQ0VfTCwgdGhpcy5wYXJzZUZpZWxkRGVmaW5pdGlvbiwgVG9rZW5LaW5kLkJSQUNFX1IpO1xuICB9XG4gIC8qKlxuICAgKiBGaWVsZERlZmluaXRpb24gOlxuICAgKiAgIC0gRGVzY3JpcHRpb24/IE5hbWUgQXJndW1lbnRzRGVmaW5pdGlvbj8gOiBUeXBlIERpcmVjdGl2ZXNbQ29uc3RdP1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUZpZWxkRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHBhcnNlRmllbGREZWZpbml0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VBcmd1bWVudERlZnMoKTtcbiAgICB0aGlzLmV4cGVjdFRva2VuKFRva2VuS2luZC5DT0xPTik7XG4gICAgdmFyIHR5cGUgPSB0aGlzLnBhcnNlVHlwZVJlZmVyZW5jZSgpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IEtpbmQuRklFTERfREVGSU5JVElPTixcbiAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQXJndW1lbnRzRGVmaW5pdGlvbiA6ICggSW5wdXRWYWx1ZURlZmluaXRpb24rIClcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VBcmd1bWVudERlZnMgPSBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50RGVmcygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkoVG9rZW5LaW5kLlBBUkVOX0wsIHRoaXMucGFyc2VJbnB1dFZhbHVlRGVmLCBUb2tlbktpbmQuUEFSRU5fUik7XG4gIH1cbiAgLyoqXG4gICAqIElucHV0VmFsdWVEZWZpbml0aW9uIDpcbiAgICogICAtIERlc2NyaXB0aW9uPyBOYW1lIDogVHlwZSBEZWZhdWx0VmFsdWU/IERpcmVjdGl2ZXNbQ29uc3RdP1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUlucHV0VmFsdWVEZWYgPSBmdW5jdGlvbiBwYXJzZUlucHV0VmFsdWVEZWYoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkNPTE9OKTtcbiAgICB2YXIgdHlwZSA9IHRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCk7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZTtcblxuICAgIGlmICh0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oVG9rZW5LaW5kLkVRVUFMUykpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwodHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlRGlyZWN0aXZlcyh0cnVlKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5JTlBVVF9WQUxVRV9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEludGVyZmFjZVR5cGVEZWZpbml0aW9uIDpcbiAgICogICAtIERlc2NyaXB0aW9uPyBpbnRlcmZhY2UgTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gRmllbGRzRGVmaW5pdGlvbj9cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHBhcnNlSW50ZXJmYWNlVHlwZURlZmluaXRpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gdGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdpbnRlcmZhY2UnKTtcbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgdmFyIGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlRGlyZWN0aXZlcyh0cnVlKTtcbiAgICB2YXIgZmllbGRzID0gdGhpcy5wYXJzZUZpZWxkc0RlZmluaXRpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5JTlRFUkZBQ0VfVFlQRV9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICBmaWVsZHM6IGZpZWxkcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVW5pb25UeXBlRGVmaW5pdGlvbiA6XG4gICAqICAgLSBEZXNjcmlwdGlvbj8gdW5pb24gTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gVW5pb25NZW1iZXJUeXBlcz9cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VVbmlvblR5cGVEZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VVbmlvblR5cGVEZWZpbml0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndW5pb24nKTtcbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgdmFyIGRpcmVjdGl2ZXMgPSB0aGlzLnBhcnNlRGlyZWN0aXZlcyh0cnVlKTtcbiAgICB2YXIgdHlwZXMgPSB0aGlzLnBhcnNlVW5pb25NZW1iZXJUeXBlcygpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLlVOSU9OX1RZUEVfREVGSU5JVElPTixcbiAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgICAgdHlwZXM6IHR5cGVzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVbmlvbk1lbWJlclR5cGVzIDpcbiAgICogICAtID0gYHxgPyBOYW1lZFR5cGVcbiAgICogICAtIFVuaW9uTWVtYmVyVHlwZXMgfCBOYW1lZFR5cGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VVbmlvbk1lbWJlclR5cGVzID0gZnVuY3Rpb24gcGFyc2VVbmlvbk1lbWJlclR5cGVzKCkge1xuICAgIHZhciB0eXBlcyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuRVFVQUxTKSkge1xuICAgICAgLy8gT3B0aW9uYWwgbGVhZGluZyBwaXBlXG4gICAgICB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oVG9rZW5LaW5kLlBJUEUpO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHR5cGVzLnB1c2godGhpcy5wYXJzZU5hbWVkVHlwZSgpKTtcbiAgICAgIH0gd2hpbGUgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihUb2tlbktpbmQuUElQRSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlcztcbiAgfVxuICAvKipcbiAgICogRW51bVR5cGVEZWZpbml0aW9uIDpcbiAgICogICAtIERlc2NyaXB0aW9uPyBlbnVtIE5hbWUgRGlyZWN0aXZlc1tDb25zdF0/IEVudW1WYWx1ZXNEZWZpbml0aW9uP1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUVudW1UeXBlRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHBhcnNlRW51bVR5cGVEZWZpbml0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZW51bScpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5FTlVNX1RZUEVfREVGSU5JVElPTixcbiAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEVudW1WYWx1ZXNEZWZpbml0aW9uIDogeyBFbnVtVmFsdWVEZWZpbml0aW9uKyB9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24gPSBmdW5jdGlvbiBwYXJzZUVudW1WYWx1ZXNEZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsTWFueShUb2tlbktpbmQuQlJBQ0VfTCwgdGhpcy5wYXJzZUVudW1WYWx1ZURlZmluaXRpb24sIFRva2VuS2luZC5CUkFDRV9SKTtcbiAgfVxuICAvKipcbiAgICogRW51bVZhbHVlRGVmaW5pdGlvbiA6IERlc2NyaXB0aW9uPyBFbnVtVmFsdWUgRGlyZWN0aXZlc1tDb25zdF0/XG4gICAqXG4gICAqIEVudW1WYWx1ZSA6IE5hbWVcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VFbnVtVmFsdWVEZWZpbml0aW9uID0gZnVuY3Rpb24gcGFyc2VFbnVtVmFsdWVEZWZpbml0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHRoaXMucGFyc2VEZXNjcmlwdGlvbigpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLkVOVU1fVkFMVUVfREVGSU5JVElPTixcbiAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uIDpcbiAgICogICAtIERlc2NyaXB0aW9uPyBpbnB1dCBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdPyBJbnB1dEZpZWxkc0RlZmluaXRpb24/XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHBhcnNlSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2lucHV0Jyk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMucGFyc2VJbnB1dEZpZWxkc0RlZmluaXRpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5JTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICBmaWVsZHM6IGZpZWxkcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSW5wdXRGaWVsZHNEZWZpbml0aW9uIDogeyBJbnB1dFZhbHVlRGVmaW5pdGlvbisgfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUlucHV0RmllbGRzRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHBhcnNlSW5wdXRGaWVsZHNEZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsTWFueShUb2tlbktpbmQuQlJBQ0VfTCwgdGhpcy5wYXJzZUlucHV0VmFsdWVEZWYsIFRva2VuS2luZC5CUkFDRV9SKTtcbiAgfVxuICAvKipcbiAgICogVHlwZVN5c3RlbUV4dGVuc2lvbiA6XG4gICAqICAgLSBTY2hlbWFFeHRlbnNpb25cbiAgICogICAtIFR5cGVFeHRlbnNpb25cbiAgICpcbiAgICogVHlwZUV4dGVuc2lvbiA6XG4gICAqICAgLSBTY2FsYXJUeXBlRXh0ZW5zaW9uXG4gICAqICAgLSBPYmplY3RUeXBlRXh0ZW5zaW9uXG4gICAqICAgLSBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uXG4gICAqICAgLSBVbmlvblR5cGVFeHRlbnNpb25cbiAgICogICAtIEVudW1UeXBlRXh0ZW5zaW9uXG4gICAqICAgLSBJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlVHlwZVN5c3RlbUV4dGVuc2lvbiA9IGZ1bmN0aW9uIHBhcnNlVHlwZVN5c3RlbUV4dGVuc2lvbigpIHtcbiAgICB2YXIga2V5d29yZFRva2VuID0gdGhpcy5fbGV4ZXIubG9va2FoZWFkKCk7XG5cbiAgICBpZiAoa2V5d29yZFRva2VuLmtpbmQgPT09IFRva2VuS2luZC5OQU1FKSB7XG4gICAgICBzd2l0Y2ggKGtleXdvcmRUb2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICdzY2hlbWEnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NoZW1hRXh0ZW5zaW9uKCk7XG5cbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjYWxhclR5cGVFeHRlbnNpb24oKTtcblxuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdFR5cGVFeHRlbnNpb24oKTtcblxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW50ZXJmYWNlVHlwZUV4dGVuc2lvbigpO1xuXG4gICAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVuaW9uVHlwZUV4dGVuc2lvbigpO1xuXG4gICAgICAgIGNhc2UgJ2VudW0nOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRW51bVR5cGVFeHRlbnNpb24oKTtcblxuICAgICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbnB1dE9iamVjdFR5cGVFeHRlbnNpb24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoa2V5d29yZFRva2VuKTtcbiAgfVxuICAvKipcbiAgICogU2NoZW1hRXh0ZW5zaW9uIDpcbiAgICogIC0gZXh0ZW5kIHNjaGVtYSBEaXJlY3RpdmVzW0NvbnN0XT8geyBPcGVyYXRpb25UeXBlRGVmaW5pdGlvbisgfVxuICAgKiAgLSBleHRlbmQgc2NoZW1hIERpcmVjdGl2ZXNbQ29uc3RdXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlU2NoZW1hRXh0ZW5zaW9uID0gZnVuY3Rpb24gcGFyc2VTY2hlbWFFeHRlbnNpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHRlbmQnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3NjaGVtYScpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgdmFyIG9wZXJhdGlvblR5cGVzID0gdGhpcy5vcHRpb25hbE1hbnkoVG9rZW5LaW5kLkJSQUNFX0wsIHRoaXMucGFyc2VPcGVyYXRpb25UeXBlRGVmaW5pdGlvbiwgVG9rZW5LaW5kLkJSQUNFX1IpO1xuXG4gICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoID09PSAwICYmIG9wZXJhdGlvblR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IEtpbmQuU0NIRU1BX0VYVEVOU0lPTixcbiAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICBvcGVyYXRpb25UeXBlczogb3BlcmF0aW9uVHlwZXMsXG4gICAgICBsb2M6IHRoaXMubG9jKHN0YXJ0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNjYWxhclR5cGVFeHRlbnNpb24gOlxuICAgKiAgIC0gZXh0ZW5kIHNjYWxhciBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlU2NhbGFyVHlwZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIHBhcnNlU2NhbGFyVHlwZUV4dGVuc2lvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2V4dGVuZCcpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc2NhbGFyJyk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG5cbiAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLlNDQUxBUl9UWVBFX0VYVEVOU0lPTixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPYmplY3RUeXBlRXh0ZW5zaW9uIDpcbiAgICogIC0gZXh0ZW5kIHR5cGUgTmFtZSBJbXBsZW1lbnRzSW50ZXJmYWNlcz8gRGlyZWN0aXZlc1tDb25zdF0/IEZpZWxkc0RlZmluaXRpb25cbiAgICogIC0gZXh0ZW5kIHR5cGUgTmFtZSBJbXBsZW1lbnRzSW50ZXJmYWNlcz8gRGlyZWN0aXZlc1tDb25zdF1cbiAgICogIC0gZXh0ZW5kIHR5cGUgTmFtZSBJbXBsZW1lbnRzSW50ZXJmYWNlc1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZU9iamVjdFR5cGVFeHRlbnNpb24gPSBmdW5jdGlvbiBwYXJzZU9iamVjdFR5cGVFeHRlbnNpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHRlbmQnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3R5cGUnKTtcbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgdmFyIGludGVyZmFjZXMgPSB0aGlzLnBhcnNlSW1wbGVtZW50c0ludGVyZmFjZXMoKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHZhciBmaWVsZHMgPSB0aGlzLnBhcnNlRmllbGRzRGVmaW5pdGlvbigpO1xuXG4gICAgaWYgKGludGVyZmFjZXMubGVuZ3RoID09PSAwICYmIGRpcmVjdGl2ZXMubGVuZ3RoID09PSAwICYmIGZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLk9CSkVDVF9UWVBFX0VYVEVOU0lPTixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbnRlcmZhY2VzOiBpbnRlcmZhY2VzLFxuICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uIDpcbiAgICogICAtIGV4dGVuZCBpbnRlcmZhY2UgTmFtZSBEaXJlY3RpdmVzW0NvbnN0XT8gRmllbGRzRGVmaW5pdGlvblxuICAgKiAgIC0gZXh0ZW5kIGludGVyZmFjZSBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlSW50ZXJmYWNlVHlwZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIHBhcnNlSW50ZXJmYWNlVHlwZUV4dGVuc2lvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2V4dGVuZCcpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnaW50ZXJmYWNlJyk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiYgZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IEtpbmQuSU5URVJGQUNFX1RZUEVfRVhURU5TSU9OLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICBmaWVsZHM6IGZpZWxkcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVW5pb25UeXBlRXh0ZW5zaW9uIDpcbiAgICogICAtIGV4dGVuZCB1bmlvbiBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdPyBVbmlvbk1lbWJlclR5cGVzXG4gICAqICAgLSBleHRlbmQgdW5pb24gTmFtZSBEaXJlY3RpdmVzW0NvbnN0XVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZVVuaW9uVHlwZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIHBhcnNlVW5pb25UeXBlRXh0ZW5zaW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZXh0ZW5kJyk7XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCd1bmlvbicpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHZhciB0eXBlcyA9IHRoaXMucGFyc2VVbmlvbk1lbWJlclR5cGVzKCk7XG5cbiAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPT09IDAgJiYgdHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5VTklPTl9UWVBFX0VYVEVOU0lPTixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLFxuICAgICAgdHlwZXM6IHR5cGVzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFbnVtVHlwZUV4dGVuc2lvbiA6XG4gICAqICAgLSBleHRlbmQgZW51bSBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdPyBFbnVtVmFsdWVzRGVmaW5pdGlvblxuICAgKiAgIC0gZXh0ZW5kIGVudW0gTmFtZSBEaXJlY3RpdmVzW0NvbnN0XVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUVudW1UeXBlRXh0ZW5zaW9uID0gZnVuY3Rpb24gcGFyc2VFbnVtVHlwZUV4dGVuc2lvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2V4dGVuZCcpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZW51bScpO1xuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZU5hbWUoKTtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IHRoaXMucGFyc2VEaXJlY3RpdmVzKHRydWUpO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24oKTtcblxuICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCAmJiB2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5FTlVNX1RZUEVfRVhURU5TSU9OLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uIDpcbiAgICogICAtIGV4dGVuZCBpbnB1dCBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdPyBJbnB1dEZpZWxkc0RlZmluaXRpb25cbiAgICogICAtIGV4dGVuZCBpbnB1dCBOYW1lIERpcmVjdGl2ZXNbQ29uc3RdXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uID0gZnVuY3Rpb24gcGFyc2VJbnB1dE9iamVjdFR5cGVFeHRlbnNpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fbGV4ZXIudG9rZW47XG4gICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHRlbmQnKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2lucHV0Jyk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlTmFtZSgpO1xuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5wYXJzZURpcmVjdGl2ZXModHJ1ZSk7XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMucGFyc2VJbnB1dEZpZWxkc0RlZmluaXRpb24oKTtcblxuICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCAmJiBmaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5JTlBVVF9PQkpFQ1RfVFlQRV9FWFRFTlNJT04sXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgbG9jOiB0aGlzLmxvYyhzdGFydClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEaXJlY3RpdmVEZWZpbml0aW9uIDpcbiAgICogICAtIERlc2NyaXB0aW9uPyBkaXJlY3RpdmUgQCBOYW1lIEFyZ3VtZW50c0RlZmluaXRpb24/IGByZXBlYXRhYmxlYD8gb24gRGlyZWN0aXZlTG9jYXRpb25zXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlRGlyZWN0aXZlRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHBhcnNlRGlyZWN0aXZlRGVmaW5pdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSB0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTtcbiAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2RpcmVjdGl2ZScpO1xuICAgIHRoaXMuZXhwZWN0VG9rZW4oVG9rZW5LaW5kLkFUKTtcbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG4gICAgdmFyIGFyZ3MgPSB0aGlzLnBhcnNlQXJndW1lbnREZWZzKCk7XG4gICAgdmFyIHJlcGVhdGFibGUgPSB0aGlzLmV4cGVjdE9wdGlvbmFsS2V5d29yZCgncmVwZWF0YWJsZScpO1xuICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnb24nKTtcbiAgICB2YXIgbG9jYXRpb25zID0gdGhpcy5wYXJzZURpcmVjdGl2ZUxvY2F0aW9ucygpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBLaW5kLkRJUkVDVElWRV9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGFyZ3VtZW50czogYXJncyxcbiAgICAgIHJlcGVhdGFibGU6IHJlcGVhdGFibGUsXG4gICAgICBsb2NhdGlvbnM6IGxvY2F0aW9ucyxcbiAgICAgIGxvYzogdGhpcy5sb2Moc3RhcnQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGlyZWN0aXZlTG9jYXRpb25zIDpcbiAgICogICAtIGB8YD8gRGlyZWN0aXZlTG9jYXRpb25cbiAgICogICAtIERpcmVjdGl2ZUxvY2F0aW9ucyB8IERpcmVjdGl2ZUxvY2F0aW9uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlRGlyZWN0aXZlTG9jYXRpb25zID0gZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmVMb2NhdGlvbnMoKSB7XG4gICAgLy8gT3B0aW9uYWwgbGVhZGluZyBwaXBlXG4gICAgdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKFRva2VuS2luZC5QSVBFKTtcbiAgICB2YXIgbG9jYXRpb25zID0gW107XG5cbiAgICBkbyB7XG4gICAgICBsb2NhdGlvbnMucHVzaCh0aGlzLnBhcnNlRGlyZWN0aXZlTG9jYXRpb24oKSk7XG4gICAgfSB3aGlsZSAodGhpcy5leHBlY3RPcHRpb25hbFRva2VuKFRva2VuS2luZC5QSVBFKSk7XG5cbiAgICByZXR1cm4gbG9jYXRpb25zO1xuICB9XG4gIC8qXG4gICAqIERpcmVjdGl2ZUxvY2F0aW9uIDpcbiAgICogICAtIEV4ZWN1dGFibGVEaXJlY3RpdmVMb2NhdGlvblxuICAgKiAgIC0gVHlwZVN5c3RlbURpcmVjdGl2ZUxvY2F0aW9uXG4gICAqXG4gICAqIEV4ZWN1dGFibGVEaXJlY3RpdmVMb2NhdGlvbiA6IG9uZSBvZlxuICAgKiAgIGBRVUVSWWBcbiAgICogICBgTVVUQVRJT05gXG4gICAqICAgYFNVQlNDUklQVElPTmBcbiAgICogICBgRklFTERgXG4gICAqICAgYEZSQUdNRU5UX0RFRklOSVRJT05gXG4gICAqICAgYEZSQUdNRU5UX1NQUkVBRGBcbiAgICogICBgSU5MSU5FX0ZSQUdNRU5UYFxuICAgKlxuICAgKiBUeXBlU3lzdGVtRGlyZWN0aXZlTG9jYXRpb24gOiBvbmUgb2ZcbiAgICogICBgU0NIRU1BYFxuICAgKiAgIGBTQ0FMQVJgXG4gICAqICAgYE9CSkVDVGBcbiAgICogICBgRklFTERfREVGSU5JVElPTmBcbiAgICogICBgQVJHVU1FTlRfREVGSU5JVElPTmBcbiAgICogICBgSU5URVJGQUNFYFxuICAgKiAgIGBVTklPTmBcbiAgICogICBgRU5VTWBcbiAgICogICBgRU5VTV9WQUxVRWBcbiAgICogICBgSU5QVVRfT0JKRUNUYFxuICAgKiAgIGBJTlBVVF9GSUVMRF9ERUZJTklUSU9OYFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZURpcmVjdGl2ZUxvY2F0aW9uID0gZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmVMb2NhdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9sZXhlci50b2tlbjtcbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VOYW1lKCk7XG5cbiAgICBpZiAoRGlyZWN0aXZlTG9jYXRpb25bbmFtZS52YWx1ZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKHN0YXJ0KTtcbiAgfSAvLyBDb3JlIHBhcnNpbmcgdXRpbGl0eSBmdW5jdGlvbnNcblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2F0aW9uIG9iamVjdCwgdXNlZCB0byBpZGVudGlmeSB0aGUgcGxhY2UgaW5cbiAgICogdGhlIHNvdXJjZSB0aGF0IGNyZWF0ZWQgYSBnaXZlbiBwYXJzZWQgb2JqZWN0LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5sb2MgPSBmdW5jdGlvbiBsb2Moc3RhcnRUb2tlbikge1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5ub0xvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gbmV3IExvYyhzdGFydFRva2VuLCB0aGlzLl9sZXhlci5sYXN0VG9rZW4sIHRoaXMuX2xleGVyLnNvdXJjZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBuZXh0IHRva2VuIGlzIG9mIGEgZ2l2ZW4ga2luZFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wZWVrID0gZnVuY3Rpb24gcGVlayhraW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xleGVyLnRva2VuLmtpbmQgPT09IGtpbmQ7XG4gIH1cbiAgLyoqXG4gICAqIElmIHRoZSBuZXh0IHRva2VuIGlzIG9mIHRoZSBnaXZlbiBraW5kLCByZXR1cm4gdGhhdCB0b2tlbiBhZnRlciBhZHZhbmNpbmdcbiAgICogdGhlIGxleGVyLiBPdGhlcndpc2UsIGRvIG5vdCBjaGFuZ2UgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3cgYW4gZXJyb3IuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmV4cGVjdFRva2VuID0gZnVuY3Rpb24gZXhwZWN0VG9rZW4oa2luZCkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgaWYgKHRva2VuLmtpbmQgPT09IGtpbmQpIHtcbiAgICAgIHRoaXMuX2xleGVyLmFkdmFuY2UoKTtcblxuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIHRocm93IHN5bnRheEVycm9yKHRoaXMuX2xleGVyLnNvdXJjZSwgdG9rZW4uc3RhcnQsIFwiRXhwZWN0ZWQgXCIuY29uY2F0KGtpbmQsIFwiLCBmb3VuZCBcIikuY29uY2F0KGdldFRva2VuRGVzYyh0b2tlbikpKTtcbiAgfVxuICAvKipcbiAgICogSWYgdGhlIG5leHQgdG9rZW4gaXMgb2YgdGhlIGdpdmVuIGtpbmQsIHJldHVybiB0aGF0IHRva2VuIGFmdGVyIGFkdmFuY2luZ1xuICAgKiB0aGUgbGV4ZXIuIE90aGVyd2lzZSwgZG8gbm90IGNoYW5nZSB0aGUgcGFyc2VyIHN0YXRlIGFuZCByZXR1cm4gdW5kZWZpbmVkLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5leHBlY3RPcHRpb25hbFRva2VuID0gZnVuY3Rpb24gZXhwZWN0T3B0aW9uYWxUb2tlbihraW5kKSB7XG4gICAgdmFyIHRva2VuID0gdGhpcy5fbGV4ZXIudG9rZW47XG5cbiAgICBpZiAodG9rZW4ua2luZCA9PT0ga2luZCkge1xuICAgICAgdGhpcy5fbGV4ZXIuYWR2YW5jZSgpO1xuXG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogSWYgdGhlIG5leHQgdG9rZW4gaXMgYSBnaXZlbiBrZXl3b3JkLCBhZHZhbmNlIHRoZSBsZXhlci5cbiAgICogT3RoZXJ3aXNlLCBkbyBub3QgY2hhbmdlIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93IGFuIGVycm9yLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5leHBlY3RLZXl3b3JkID0gZnVuY3Rpb24gZXhwZWN0S2V5d29yZCh2YWx1ZSkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMuX2xleGVyLnRva2VuO1xuXG4gICAgaWYgKHRva2VuLmtpbmQgPT09IFRva2VuS2luZC5OQU1FICYmIHRva2VuLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fbGV4ZXIuYWR2YW5jZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBzeW50YXhFcnJvcih0aGlzLl9sZXhlci5zb3VyY2UsIHRva2VuLnN0YXJ0LCBcIkV4cGVjdGVkIFxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIiwgZm91bmQgXCIpLmNvbmNhdChnZXRUb2tlbkRlc2ModG9rZW4pKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJZiB0aGUgbmV4dCB0b2tlbiBpcyBhIGdpdmVuIGtleXdvcmQsIHJldHVybiBcInRydWVcIiBhZnRlciBhZHZhbmNpbmdcbiAgICogdGhlIGxleGVyLiBPdGhlcndpc2UsIGRvIG5vdCBjaGFuZ2UgdGhlIHBhcnNlciBzdGF0ZSBhbmQgcmV0dXJuIFwiZmFsc2VcIi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZXhwZWN0T3B0aW9uYWxLZXl3b3JkID0gZnVuY3Rpb24gZXhwZWN0T3B0aW9uYWxLZXl3b3JkKHZhbHVlKSB7XG4gICAgdmFyIHRva2VuID0gdGhpcy5fbGV4ZXIudG9rZW47XG5cbiAgICBpZiAodG9rZW4ua2luZCA9PT0gVG9rZW5LaW5kLk5BTUUgJiYgdG9rZW4udmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9sZXhlci5hZHZhbmNlKCk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhbiBlcnJvciB3aGVuIGFuIHVuZXhwZWN0ZWQgbGV4ZWQgdG9rZW5cbiAgICogaXMgZW5jb3VudGVyZWQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVuZXhwZWN0ZWQgPSBmdW5jdGlvbiB1bmV4cGVjdGVkKGF0VG9rZW4pIHtcbiAgICB2YXIgdG9rZW4gPSBhdFRva2VuIHx8IHRoaXMuX2xleGVyLnRva2VuO1xuICAgIHJldHVybiBzeW50YXhFcnJvcih0aGlzLl9sZXhlci5zb3VyY2UsIHRva2VuLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgXCIuY29uY2F0KGdldFRva2VuRGVzYyh0b2tlbikpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHBvc3NpYmx5IGVtcHR5IGxpc3Qgb2YgcGFyc2Ugbm9kZXMsIGRldGVybWluZWQgYnlcbiAgICogdGhlIHBhcnNlRm4uIFRoaXMgbGlzdCBiZWdpbnMgd2l0aCBhIGxleCB0b2tlbiBvZiBvcGVuS2luZFxuICAgKiBhbmQgZW5kcyB3aXRoIGEgbGV4IHRva2VuIG9mIGNsb3NlS2luZC4gQWR2YW5jZXMgdGhlIHBhcnNlclxuICAgKiB0byB0aGUgbmV4dCBsZXggdG9rZW4gYWZ0ZXIgdGhlIGNsb3NpbmcgdG9rZW4uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFueSA9IGZ1bmN0aW9uIGFueShvcGVuS2luZCwgcGFyc2VGbiwgY2xvc2VLaW5kKSB7XG4gICAgdGhpcy5leHBlY3RUb2tlbihvcGVuS2luZCk7XG4gICAgdmFyIG5vZGVzID0gW107XG5cbiAgICB3aGlsZSAoIXRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihjbG9zZUtpbmQpKSB7XG4gICAgICBub2Rlcy5wdXNoKHBhcnNlRm4uY2FsbCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBwYXJzZSBub2RlcywgZGV0ZXJtaW5lZCBieSB0aGUgcGFyc2VGbi5cbiAgICogSXQgY2FuIGJlIGVtcHR5IG9ubHkgaWYgb3BlbiB0b2tlbiBpcyBtaXNzaW5nIG90aGVyd2lzZSBpdCB3aWxsIGFsd2F5c1xuICAgKiByZXR1cm4gbm9uLWVtcHR5IGxpc3QgdGhhdCBiZWdpbnMgd2l0aCBhIGxleCB0b2tlbiBvZiBvcGVuS2luZCBhbmQgZW5kc1xuICAgKiB3aXRoIGEgbGV4IHRva2VuIG9mIGNsb3NlS2luZC4gQWR2YW5jZXMgdGhlIHBhcnNlciB0byB0aGUgbmV4dCBsZXggdG9rZW5cbiAgICogYWZ0ZXIgdGhlIGNsb3NpbmcgdG9rZW4uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9wdGlvbmFsTWFueSA9IGZ1bmN0aW9uIG9wdGlvbmFsTWFueShvcGVuS2luZCwgcGFyc2VGbiwgY2xvc2VLaW5kKSB7XG4gICAgaWYgKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihvcGVuS2luZCkpIHtcbiAgICAgIHZhciBub2RlcyA9IFtdO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG5vZGVzLnB1c2gocGFyc2VGbi5jYWxsKHRoaXMpKTtcbiAgICAgIH0gd2hpbGUgKCF0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oY2xvc2VLaW5kKSk7XG5cbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBub24tZW1wdHkgbGlzdCBvZiBwYXJzZSBub2RlcywgZGV0ZXJtaW5lZCBieVxuICAgKiB0aGUgcGFyc2VGbi4gVGhpcyBsaXN0IGJlZ2lucyB3aXRoIGEgbGV4IHRva2VuIG9mIG9wZW5LaW5kXG4gICAqIGFuZCBlbmRzIHdpdGggYSBsZXggdG9rZW4gb2YgY2xvc2VLaW5kLiBBZHZhbmNlcyB0aGUgcGFyc2VyXG4gICAqIHRvIHRoZSBuZXh0IGxleCB0b2tlbiBhZnRlciB0aGUgY2xvc2luZyB0b2tlbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ubWFueSA9IGZ1bmN0aW9uIG1hbnkob3BlbktpbmQsIHBhcnNlRm4sIGNsb3NlS2luZCkge1xuICAgIHRoaXMuZXhwZWN0VG9rZW4ob3BlbktpbmQpO1xuICAgIHZhciBub2RlcyA9IFtdO1xuXG4gICAgZG8ge1xuICAgICAgbm9kZXMucHVzaChwYXJzZUZuLmNhbGwodGhpcykpO1xuICAgIH0gd2hpbGUgKCF0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4oY2xvc2VLaW5kKSk7XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH07XG5cbiAgcmV0dXJuIFBhcnNlcjtcbn0oKTtcblxuZnVuY3Rpb24gTG9jKHN0YXJ0VG9rZW4sIGVuZFRva2VuLCBzb3VyY2UpIHtcbiAgdGhpcy5zdGFydCA9IHN0YXJ0VG9rZW4uc3RhcnQ7XG4gIHRoaXMuZW5kID0gZW5kVG9rZW4uZW5kO1xuICB0aGlzLnN0YXJ0VG9rZW4gPSBzdGFydFRva2VuO1xuICB0aGlzLmVuZFRva2VuID0gZW5kVG9rZW47XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xufSAvLyBQcmludCBhIHNpbXBsaWZpZWQgZm9ybSB3aGVuIGFwcGVhcmluZyBpbiBKU09OL3V0aWwuaW5zcGVjdC5cblxuXG5kZWZpbmVUb0pTT04oTG9jLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgZW5kOiB0aGlzLmVuZFxuICB9O1xufSk7XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGRlc2NyaWJlIGEgdG9rZW4gYXMgYSBzdHJpbmcgZm9yIGRlYnVnZ2luZ1xuICovXG5cbmZ1bmN0aW9uIGdldFRva2VuRGVzYyh0b2tlbikge1xuICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgcmV0dXJuIHZhbHVlID8gXCJcIi5jb25jYXQodG9rZW4ua2luZCwgXCIgXFxcIlwiKS5jb25jYXQodmFsdWUsIFwiXFxcIlwiKSA6IHRva2VuLmtpbmQ7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44\n")}]);